<?xml version="1.0"?>
<doc>
<assembly>
<name>
Microsoft.VisualBasic.DataMining.BinaryTreeClustering
</name>
</assembly>
<members>
<member name="T:Microsoft.VisualBasic.DataMining.BinaryTree.AffinityPropagation.AffinityPropagation">
 <summary>
 ### Affinity propagation
 
 In statistics and data mining, affinity propagation (AP) is a clustering
 algorithm based on the concept of "message passing" between data points.
 Unlike clustering algorithms such as k-means or k-medoids, affinity 
 propagation does not require the number of clusters to be determined or 
 estimated before running the algorithm. Similar to k-medoids, affinity 
 propagation finds "exemplars," members of the input set that are representative 
 of clusters.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.DataMining.BinaryTree.AffinityPropagation.AffinityPropagation.#ctor(System.Collections.Generic.IEnumerable{Microsoft.VisualBasic.DataMining.KMeans.ClusterEntity},System.Single,System.Int32,System.Int32)">
 <summary>
 
 </summary>
 <param name="ds"></param>
 <param name="damping">[0.5,1]</param>
 <param name="max_iteration"></param>
 <param name="convergence"></param>
</member>
<member name="M:Microsoft.VisualBasic.DataMining.BinaryTree.AffinityPropagation.AffinityPropagation.UpdateResponsabilities">
 <summary>
 The "responsibility" matrix R has values r(i, k) that quantify how well
 -suited xk is to serve as the exemplar for xi, relative to other 
 candidate exemplars for xi.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.DataMining.BinaryTree.AffinityPropagation.AffinityPropagation.UpdateAvailabilities">
 <summary>
 The "availability" matrix A contains values a(i, k) that represent how 
 "appropriate" it would be for xi to pick xk as its exemplar, taking into
 account other points' preference for xk as an exemplar.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.DataMining.BinaryTree.AffinityPropagation.AffinityPropagation.UpdateExamplars(System.Int32[])">
 <summary>
 The diagonal of s (i.e.{\displaystyle s(i,i)}) Is particularly important, 
 as it represents the instance preference, meaning how likely a particular 
 instance Is to become an exemplar. When it Is set to the same value for 
 all inputs, it controls how many classes the algorithm produces. A value 
 close to the minimum possible similarity produces fewer classes, while a
 value close to Or larger than the maximum possible similarity produces 
 many classes. It Is typically initialized to the median similarity of all
 pairs of inputs.
 </summary>
 <param name="examplar"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.DataMining.BinaryTree.AffinityPropagation.QuickSelect.k2thSmallest(Microsoft.VisualBasic.DataMining.BinaryTree.AffinityPropagation.Edge[]@,System.Int32,System.Int32,System.Int32)">
 <summary>
 Implementation of QuickSelect
 </summary>
 <param name="a"></param>
 <param name="left"></param>
 <param name="right"></param>
 <param name="k"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.DataMining.BinaryTree.AffinityPropagation.SimilarityMatrix.SparseSimilarityMatrix(Microsoft.VisualBasic.DataMining.KMeans.ClusterEntity[],Microsoft.VisualBasic.DataMining.Evaluation.IMetric)">
 <summary>
 Create the similarity matrix with a user defined distance measure
 </summary>
 <param name="ptr"></param>
 <param name="distance"></param>
 <returns></returns>
 
</member>
<member name="T:Microsoft.VisualBasic.DataMining.BinaryTree.BTreeCluster">
 <summary>
 Clustering data via binary tree
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.DataMining.BinaryTree.BTreeCluster.members">
 <summary>
 这个列表之中已经保存有<see cref="P:Microsoft.VisualBasic.DataMining.BinaryTree.BTreeCluster.uuid"/>了
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.DataMining.BinaryTree.BTreeCluster.PullAllClusterNodes(Microsoft.VisualBasic.DataMining.BinaryTree.BTreeCluster,System.Collections.Generic.List{Microsoft.VisualBasic.DataMining.BinaryTree.BTreeCluster}@)">
 <summary>
 
 </summary>
 <param name="btree"></param>
 <param name="pull"></param>
 <remarks>
 this function will missing the current cluster node itself,
 you should add current node after call this function
 </remarks>
</member>
<member name="T:Microsoft.VisualBasic.DataMining.BinaryTree.ClusterTree">
 <summary>
 A simple cluster tree builder
 
 just provides the reference id of the target object for make the 
 alignment or comparision.
 
 the comparision for build the tree is under the given <see cref="T:Microsoft.VisualBasic.DataMining.BinaryTree.ClusterTree.Argument"/>.
 </summary>
 <remarks>
 implements the Molecule Networking via the tree clustering operation in mzkit
 this model is a kind of tree with multiple branches, each branches standards for
 different similarity SCORE LEVELs.
 </remarks>
</member>
<member name="P:Microsoft.VisualBasic.DataMining.BinaryTree.ClusterTree.Members">
 <summary>
 This property includes all data in current cluster tree node, 
 also includes the <see cref="P:Microsoft.VisualBasic.Data.GraphTheory.Tree`1.Data"/> member.
 </summary>
 <returns></returns>
</member>
<member name="F:Microsoft.VisualBasic.DataMining.BinaryTree.ClusterTree.Argument.alignment">
 <summary>
 evaluate score by compare two dataset which are related 
 to the input key name as reference id.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.DataMining.BinaryTree.ClusterTree.Argument.threshold">
 <summary>
 the cutoff value for set current element 
 <see cref="F:Microsoft.VisualBasic.DataMining.BinaryTree.ClusterTree.Argument.target"/> as the member of
 current node <see cref="T:Microsoft.VisualBasic.DataMining.BinaryTree.ClusterTree"/>.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.DataMining.BinaryTree.ClusterTree.Argument.diff">
 <summary>
 default interval score value is 0.05
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.DataMining.BinaryTree.ClusterTree.Add(Microsoft.VisualBasic.DataMining.BinaryTree.ClusterTree,Microsoft.VisualBasic.DataMining.BinaryTree.ClusterTree.Argument,Microsoft.VisualBasic.DataMining.BinaryTree.ClusterTree@)">
 <summary>
 build tree
 </summary>
 <param name="tree"></param>
 <remarks>
 the <see cref="F:Microsoft.VisualBasic.DataMining.BinaryTree.ClusterTree.Argument.target"/> object will be added into <see cref="P:Microsoft.VisualBasic.DataMining.BinaryTree.ClusterTree.Members"/> 
 if a node is asserts that the similarity score between <see cref="F:Microsoft.VisualBasic.DataMining.BinaryTree.ClusterTree.Argument.target"/> and
 <see cref="P:Microsoft.VisualBasic.Data.GraphTheory.Tree`1.Data"/> is greater than <see cref="F:Microsoft.VisualBasic.DataMining.BinaryTree.ClusterTree.Argument.threshold"/>.
 
 or create a new node if no hits: the new node its <see cref="P:Microsoft.VisualBasic.Data.GraphTheory.Tree`1.Data"/> is the
 <see cref="F:Microsoft.VisualBasic.DataMining.BinaryTree.ClusterTree.Argument.target"/>.
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.DataMining.BinaryTree.ClusterTree.Add(System.String)">
 <summary>
 add a new child node
 </summary>
 <param name="label"></param>
 
</member>
<member name="T:Microsoft.VisualBasic.DataMining.BinaryTree.Comparison">
 <summary>
 Data adapter for get comparision score from a pre-computed <see cref="T:Microsoft.VisualBasic.Math.Matrix.DistanceMatrix"/>.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.DataMining.BinaryTree.ComparisonProvider.#ctor(System.Double,System.Double)">
 <summary>
 create a new score generator
 </summary>
 <param name="equals">score level for construct a binary tree cluster</param>
 <param name="gt">score level for create a binary tree branch</param>
</member>
<member name="M:Microsoft.VisualBasic.DataMining.BinaryTree.ComparisonProvider.Compares(System.String,System.String)">
 <summary>
 binary tree generator
 </summary>
 <param name="x"></param>
 <param name="y"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.DataMining.BinaryTree.DiffusionMap">
 <summary>
 Generate a diffusion map embedding
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.DataMining.BinaryTree.DiffusionMap.compute_diffusion_map(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix,System.Double,System.Nullable{System.Int32},System.Double,System.Boolean,System.Boolean,System.Boolean)">
 <summary>
 Compute the diffusion maps of a symmetric similarity matrix
 </summary>
 <param name="L">matrix N x N
 L is symmetric and L(x, y) >= 0
 </param>
 <param name="alpha">float [0, 1]
 Setting alpha=1 and the diffusion operator approximates the
 Laplace-Beltrami operator. We then recover the Riemannian geometry
 of the data set regardless of the distribution of the points. To
 describe the Long-term behavior Of the point distribution Of a
 system of stochastic differential equations, we can use alpha=0.5
 And the resulting Markov chain approximates the Fokker-Planck
 diffusion. With alpha=0, it reduces to the classical graph Laplacian
 normalization.
 </param>
 <param name="n_components">
 The number of diffusion map components to return. Due to the
 spectrum decay Of the eigenvalues, only a few terms are necessary To
 achieve a given relative accuracy In the sum M^t.
 </param>
 <param name="diffusion_time">float >= 0
 use the diffusion_time (t) step transition matrix M^t
 
 t Not only serves as a time parameter, but also has the dual role of
 scale parameter. One Of the main ideas Of diffusion framework Is
 that running the chain forward In time (taking larger And larger
 powers of M) reveals the geometric structure of X at larger And
 larger scales(the diffusion process).

 t = 0 empirically provides a reasonable balance from a clustering
 perspective. Specifically, the notion of a cluster in the data set
 Is quantified as a region in which the probability of escaping this
 region Is low (within a certain time t).
 </param>
 <param name="skip_checks">Avoid expensive pre-checks on input data. The caller has to make
 sure that input data Is valid Or results will be undefined.</param>
 <param name="overwrite">Optimize memory usage by re-using input matrix L as scratch space.</param>
 <param name="return_result"></param>
 <returns></returns>
 <remarks>
 References
 ----------

 [1] https//en.wikipedia.org/wiki/Diffusion_map
 [2] Coifman, R.R.; S. Lafon. (2006). "Diffusion maps". Applied And
     Computational Harmonic Analysis 21: 5-30. doi:10.1016/j.acha.2006.04.006
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.DataMining.BinaryTree.DiffusionMap.step_5(System.Double,Microsoft.VisualBasic.Math.LinearAlgebra.Vector,System.Int32,System.Int32,System.Double)">
 <summary>
 This is a helper function for diffusion map computation.
 
 The lambdas have been sorted in decreasing order.
 The vectors are ordered according To lambdas.
 </summary>
 <param name="lambdas"></param>
 <param name="vectors"></param>
 <param name="ndim"></param>
 <param name="n_components"></param>
 <param name="diffusion_time"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.DataMining.BinaryTree.KNNGraph.#ctor(System.Collections.Generic.IEnumerable{Microsoft.VisualBasic.DataMining.KMeans.ClusterEntity})">
 <summary>
 construct a kdtree for the given dataset points
 </summary>
 <param name="data">a collection of dataset points</param>
</member>
<member name="M:Microsoft.VisualBasic.DataMining.BinaryTree.KNNGraph.GetGraph(System.Int32,System.Double,System.Double)">
 <summary>
 Build a graph cluster result via KNN method
 </summary>
 <param name="k"></param>
 <returns></returns>
 <remarks>
 the algorithm implements:
 
 1. search KNN via KDtree, get connection id of each node
 2. build cluster tree
 3. metric via the jaccard index between the node via in tree construction.
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.DataMining.BinaryTree.KNNGraph.KNN(System.Int32)">
 <summary>
 search KNN via KDTree
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.DataMining.BinaryTree.KNNGraph.NodeVisits.#ctor(System.Collections.Generic.Dictionary{System.String,System.Int32})">
 <summary>
 construct a data accessor with the dimension mapping
 </summary>
 <param name="dims"></param>
 
</member>
<member name="T:Microsoft.VisualBasic.DataMining.BinaryTree.NewickParser">
 <summary>
 http://www.evolgenius.info/evolview/
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.DataMining.BinaryTree.NewickParser.TreeParser``1(System.String,System.Collections.Generic.Dictionary{System.String,System.String})">
 <summary>
 
 </summary>
 <typeparam name="T"></typeparam>
 <param name="input"></param>
 <param name="hashTranslate">可以通过这个对象将节点编号映射为名称</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.DataMining.BinaryTree.NewickParser.TreeParser``1(System.String,System.Collections.Generic.Dictionary{System.String,System.String},Microsoft.VisualBasic.ComponentModel.DataStructures.BinaryTree.TreeNode{``0}@)">
 <summary>
 created: Oct 20, 2013 : a better and easier to maintain parser for newick and nexus trees
 NOTE: this is a recursive function </summary>
 <param name="inputstr"> : input tree string </param>
 <param name="hashTranslate"> : aliases for lead nodes (for nexsus format) </param>
 <param name="iNode"> : current internal node; == rootNode the first time 'newickParser' is called  </param>
</member>
<member name="M:Microsoft.VisualBasic.DataMining.BinaryTree.NewickParser.__makeInternalNode``1(System.String,System.Boolean,Microsoft.VisualBasic.ComponentModel.DataStructures.BinaryTree.TreeNode{``0}@)">
 <summary>
 Dec 5, 2011; can be used to make rootnode
 </summary>
 <param name="id"></param>
 <param name="isroot"></param>
 <param name="parentnode"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.DataMining.BinaryTree.NewickParser.parseInforAndMakeNewLeafNode``1(System.String,System.Collections.Generic.Dictionary{System.String,System.String},Microsoft.VisualBasic.ComponentModel.DataStructures.BinaryTree.TreeNode{``0})">
 <summary>
 created on Oct 20, 2013 
 input: the leafstr to be parsed, the internal node the leaf node has to be added to 
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.DataMining.BinaryTree.Partitioning.CreateClusterPartitions(Microsoft.VisualBasic.DataMining.BinaryTree.BTreeCluster,System.Int32)">
 <summary>
 do tree cut
 </summary>
 <param name="btree"></param>
 <param name="depth"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.DataMining.BinaryTree.Partitioning.getAnyData(Microsoft.VisualBasic.DataMining.BinaryTree.BTreeCluster)">
 <summary>
 Just get data vector for generates the names
 </summary>
 <param name="btree"></param>
 <returns></returns>
</member>
</members>
</doc>
