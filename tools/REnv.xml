<?xml version="1.0"?>
<doc>
<assembly>
<name>
REnv
</name>
</assembly>
<members>
<member name="T:SMRUCC.Rsharp.My.Resources.Resources">
<summary>
  A strongly-typed resource class, for looking up localized strings, etc.
</summary>
</member>
<member name="P:SMRUCC.Rsharp.My.Resources.Resources.ResourceManager">
<summary>
  Returns the cached ResourceManager instance used by this class.
</summary>
</member>
<member name="P:SMRUCC.Rsharp.My.Resources.Resources.Culture">
<summary>
  Overrides the current thread's CurrentUICulture property for all
  resource lookups using this strongly typed resource class.
</summary>
</member>
<member name="P:SMRUCC.Rsharp.My.Resources.Resources.contributions">
<summary>
  Looks up a localized string similar to R# is a language and environment for GCModeller scripting 
and data science chart plot graphics. It is an Open source 
project which is similar to the R language and environment 
which was developed at R&amp;D laboratory from BioNovogene 
corporation by Xie.Guigang. The R# language its language 
syntax is derived from the R language, and R# can be considered 
as a part of implementation of R on Microsoft .NET Framework 
environment. Although there are too many important differences 
between R# and R, bu [rest of string was truncated]&quot;;.
</summary>
</member>
<member name="P:SMRUCC.Rsharp.My.Resources.Resources.gpl">
<summary>
  Looks up a localized string similar to                     GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. &lt;http://fsf.org/&gt;
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to [rest of string was truncated]&quot;;.
</summary>
</member>
<member name="M:SMRUCC.Rsharp.ApiArgumentHelpers.slot(System.String)">
 <summary>
 create a slot value reference inside a tuple <see cref="M:SMRUCC.Rsharp.ApiArgumentHelpers.list(Microsoft.VisualBasic.Language.ArgumentReference[])"/> for construct a new list data
 </summary>
 <param name="name"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.ApiArgumentHelpers.GetNamedValueTuple``1(System.Object,SMRUCC.Rsharp.Runtime.Environment,System.String)">
 <summary>
 create a name tagged value object from a 
 given data source value
 </summary>
 <typeparam name="T"></typeparam>
 <param name="value">
 any type of the .NET object
 </param>
 <param name="env"></param>
 <param name="api">
 the traceback tag
 </param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.ApiArgumentHelpers.FileStreamWriter(SMRUCC.Rsharp.Runtime.Environment,System.Object,System.Action{System.IO.Stream})">
 <summary>
 open stream for file write
 </summary>
 <param name="file"></param>
 <param name="write"></param>
 
</member>
<member name="F:SMRUCC.Rsharp.ApiArgumentHelpers.ReadOnlyRawByteStream">
 <summary>
 the memory stream object that construct via the given byte array works in readonly mode!
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.ApiArgumentHelpers.GetFileStream(System.Object,System.IO.FileAccess,SMRUCC.Rsharp.Runtime.Environment,System.Boolean,System.Boolean@,System.Boolean)">
 <summary>
 get a file stream object
 </summary>
 <param name="file">
 the file resource could be one of the:
 
 1. a valid file path to a filesystem location
 2. a stream object that can be read/write based on the <paramref name="mode"/> context
 3. a raw bytes array for construct a memory stream in this function(readonly)
 </param>
 <param name="mode"></param>
 <param name="env"></param>
 <param name="suppress"></param>
 <returns></returns>
 <remarks>
 base on the value of <paramref name="mode"/>, this function has different behaviour:
 
 1. <see cref="F:System.IO.FileAccess.Read"/> for a readonly stream
 2. <see cref="F:System.IO.FileAccess.ReadWrite"/> for create a stream could be used for write data
 3. <see cref="F:System.IO.FileAccess.Write"/> will truncate the stream at first!
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Extensions.GetObject``1(SMRUCC.Rsharp.Runtime.Internal.Object.list)">
 <summary>
 Create a specific .NET object from given data
 </summary>
 <typeparam name="T"></typeparam>
 <param name="list">the object property data value collection.</param>
 <returns></returns>
 
</member>
<member name="M:SMRUCC.Rsharp.Extensions.GetEncoding(System.Object)">
 <summary>
 Get text encoding value, returns <see cref="P:System.Text.Encoding.Default"/> by default if no matched.
 </summary>
 <param name="val">
 
 </param>
 <returns></returns>
 <remarks>
 utf8 encoding will be returned if the parameter 
 value is nothing orelse is unknown string value.
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Extensions.GetString(SMRUCC.Rsharp.Runtime.Internal.Object.list,System.String,System.String)">
 <summary>
 get target value as string
 </summary>
 <param name="list"></param>
 <param name="key$"></param>
 <param name="default$"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Extensions.evaluateList``2(SMRUCC.Rsharp.Runtime.Internal.Object.list,System.Func{``0,``1},System.Boolean,System.Boolean,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 
 </summary>
 <typeparam name="T"></typeparam>
 <typeparam name="TOut"></typeparam>
 <param name="x"></param>
 <param name="eval"></param>
 <param name="parallel"></param>
 <param name="env"></param>
 <returns>
 variant type of <typeparamref name="TOut"/> or a tuple list result
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Extensions.EvaluateFramework``2(SMRUCC.Rsharp.Runtime.Environment,System.Object,System.Func{``0,``1},System.Boolean,System.Boolean)">
 <summary>
 一个R对象通用的求值框架函数
 </summary>
 <typeparam name="T">输入的元素类型</typeparam>
 <typeparam name="TOut">输出的元素类型</typeparam>
 <param name="env"></param>
 <param name="x">the input object source, supports vector, list, and scalar data object.
 (输入的数据源)
 </param>
 <param name="eval">求值函数</param>
 <returns>this function returns value of:
 
 + nothing if the parameter input <paramref name="x"/> has no value, 
 + vector for input is a collection or array
 + list for input is a list
 + Tout value object if the given x is a <typeparamref name="T"/> scalar object
 + and also may returns an error <see cref="T:SMRUCC.Rsharp.Runtime.Components.Message"/> if error happends!
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Extensions.CastSequence``2(Microsoft.VisualBasic.Language.List{``0},System.Func{``0,``1},System.Boolean,System.Boolean)">
 <summary>
 the parallel will not break the input sequence order
 </summary>
 <typeparam name="T"></typeparam>
 <typeparam name="TOut"></typeparam>
 <param name="cast"></param>
 <param name="eval"></param>
 <param name="parallel"></param>
 <returns>
 variant of vector or <typeparamref name="TOut"/> value
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Extensions.Buffer(System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 try to convert any object as bytes byffer data
 </summary>
 <param name="stream"></param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Interpreter.DebugLevels">
 <summary>
 debug echo verbose level for the R# interpreter engine
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Interpreter.DebugLevels.None">
 <summary>
 no debug echo, normal mode(or production mode)
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Interpreter.DebugLevels.Memory">
 <summary>
 debug echo of the memory delta change after execute each expression
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Interpreter.DebugLevels.Stack">
 <summary>
 print the expression executation stack data
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Interpreter.DebugLevels.All">
 <summary>
 print all data on the console
 </summary>
</member>
<member name="T:SMRUCC.Rsharp.Interpreter.ExecutableLoop">
 <summary>
 使用for循环执行脚本语句
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecutableLoop.Execute(System.Collections.Generic.IEnumerable{SMRUCC.Rsharp.Interpreter.ExecuteEngine.Expression},SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 function/forloop/if/else/elseif/repeat/while, etc...
 </summary>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecutableLoop.ExecuteCodeLine(SMRUCC.Rsharp.Interpreter.ExecuteEngine.Expression,SMRUCC.Rsharp.Runtime.Environment,System.Boolean@,System.Boolean)">
 <summary>
 For execute lambda function
 </summary>
 <param name="expression"></param>
 <param name="envir"></param>
 <param name="breakLoop"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecutableLoop.isBreakSignal(System.Object)">
 <summary>
 break current loop via the R# language keyword
 </summary>
 <param name="last"></param>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExecuteBreaks">
 <summary>
 Enumerations of breaks the executation of the current code closure.
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExecuteBreaks.ReturnValue">
 <summary>
 returns value for function
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExecuteBreaks.ContinuteNext">
 <summary>
 continute to next for/while/loop
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExecuteBreaks.BreakLoop">
 <summary>
 break of while/loop
 </summary>
</member>
<member name="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.Expression">
 <summary>
 An expression object model in R# language interpreter
 </summary>
</member>
<member name="P:SMRUCC.Rsharp.Interpreter.ExecuteEngine.Expression.type">
 <summary>
 推断出的这个表达式可能产生的值的类型
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Interpreter.ExecuteEngine.Expression.expressionName">
 <summary>
 debug used...
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Interpreter.ExecuteEngine.Expression.isCallable">
 <summary>
 is a function?
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.Expression.Evaluate(SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 Evaluate the R# expression for get its runtime value result.
 </summary>
 <param name="envir"></param>
 <returns>
 this function should returns the value of the current expression 
 evaluation if the invoke has no error, or the <see cref="T:SMRUCC.Rsharp.Runtime.Components.Message"/>
 object value if some error happends.
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.Expression.CreateExpression(System.Collections.Generic.IEnumerable{SMRUCC.Rsharp.Language.TokenIcer.Token},SMRUCC.Rsharp.Language.Syntax.SyntaxParser.SyntaxBuilderOptions)">
 <summary>
 Create a new expression model from the given R# code token collection.
 </summary>
 <param name="code"></param>
 <param name="opts"></param>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Annotation.BreakPoint">
 <summary>
 ``@stop``
 </summary>
</member>
<member name="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Annotation.HomeSymbol">
 <summary>
 ``@HOME`` for just get the directory path of the R# program file where it is.
 </summary>
</member>
<member name="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Annotation.HostSymbol">
 <summary>
 ``@HOST``
 
 ``*.exe`` file path of the ``R#`` script host
 </summary>
</member>
<member name="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Annotation.Profiler">
 <summary>
 ``@profile``
 
 开始进行性能计数
 </summary>
 <remarks>It is not recommended that open the profiler 
 session in the production mode, due to the reason of
 profiler sampling will take too much time to generate 
 sample data.
 </remarks>
</member>
<member name="P:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Annotation.Profiler.target">
 <summary>
 target expression for run profiler
 </summary>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Annotation.ScriptFolder">
 <summary>
 ``@dir``
 </summary>
</member>
<member name="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Annotation.ScriptSymbol">
 <summary>
 ``@script``
 </summary>
</member>
<member name="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.ArgumentValue">
 <summary>
 Get commandline argument or safely get environment symbol value by name
 
 ```
 ?'name'
 ```
 </summary>
</member>
<member name="P:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.ArgumentValue.name">
 <summary>
 The argument name
 </summary>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.ExternalCommandLine">
 <summary>
 External commandline invoke
 
 ```
 @"cli"
 ```
 </summary>
 <remarks>
 Supports the commandline string input in multiple lines
 </remarks>
</member>
<member name="F:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.ExternalCommandLine.cli">
 <summary>
 expression object should generates the commandline string value
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.ExternalCommandLine.silent">
 <summary>
 do not should the std_out content of child process?
 </summary>
</member>
<member name="P:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.ExternalCommandLine.ShellRsharpCmd">
 <summary>
 A special path to indicate the R#.exe file path
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.ExternalCommandLine.ShellRscriptHost">
 <summary>
 A special path to indicate the Rscript.exe file path
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.ExternalCommandLine.possibleInterpolationFailure(System.String,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 create a warning message about the commandline 
 string in string interpolate syntax
 </summary>
 <param name="commandline"></param>
 <param name="envir"></param>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.DataSets.CreateObject">
 <summary>
 ``new xxx(...)``
 </summary>
</member>
<member name="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.DataSets.DotDotDotSymbol">
 <summary>
 ... symbol for the R function
 </summary>
</member>
<member name="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.DataSets.FormulaExpression">
 <summary>
 var ~ formula
 </summary>
</member>
<member name="P:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.DataSets.FormulaExpression.var">
 <summary>
 因变量
 </summary>
</member>
<member name="P:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.DataSets.FormulaExpression.formula">
 <summary>
 只能够是符号引用或者双目运算符表达式
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.DataSets.FormulaExpression.#ctor(System.String,SMRUCC.Rsharp.Interpreter.ExecuteEngine.Expression)">
 <summary>
 create a new formula expression, example like:
 
 ```
 y ~ x
 ```
 </summary>
 <param name="y"></param>
 <param name="formula">x factor variable in the formula expression</param>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.DataSets.FormulaExpression.GetSymbols(SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 get all symbol names from <see cref="P:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.DataSets.FormulaExpression.formula"/>
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.DataSets.FormulaExpression.GetResponseSymbol">
 <summary>
 A helper function for get symbol name from response <see cref="P:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.DataSets.FormulaExpression.var"/>.
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.DataSets.FormulaExpression.GetSymbols(SMRUCC.Rsharp.Interpreter.ExecuteEngine.Expression)">
 <summary>
 get symbol names from a binary expression or a single symbol reference
 </summary>
 <param name="formula"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.DataSets.FormulaExpression.Evaluate(SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 这个只是用来表述关系的，并不会产生内容
 </summary>
 <param name="envir"></param>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.DataSets.JSONLiteral">
 <summary>
 
 </summary>
 <remarks>
 这个数据对象模型只兼容json object的申明
 </remarks>
</member>
<member name="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.DataSets.Literal">
 <summary>
 the literal value expression in R# 
 </summary>
 <remarks>
 the number/boolean/character/integer/byte
 </remarks>
</member>
<member name="P:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.DataSets.Literal.isNull">
 <summary>
 Does current value is NULL literal?
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.DataSets.Literal.isNA">
 <summary>
 Does current value is NA literal?
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.DataSets.Literal.ValueStr">
 <summary>
 any.tostring of <see cref="F:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.DataSets.Literal.value"/>
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.DataSets.Literal.#ctor(SMRUCC.Rsharp.Language.TokenIcer.Token)">
 <summary>
 create literal from a language token
 </summary>
 <param name="token"></param>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.DataSets.Literal.#ctor(System.String)">
 <summary>
 create a string literal
 </summary>
 <param name="value"></param>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.DataSets.Literal.ToString">
 <summary>
 Get string representation of the literal object value
 </summary>
 <returns></returns>
 
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.DataSets.Literal.op_Equality(SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.DataSets.Literal,System.String)">
 <summary>
 string value equals?
 </summary>
 <param name="exp"></param>
 <param name="literal"></param>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.DataSets.SequenceLiteral">
 <summary>
 a syntax for generate a numeric sequence: ``from:to step diff``
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.DataSets.SequenceLiteral.steps">
 <summary>
 nothing means default steps
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.DataSets.SequenceLiteral.measureSequence(System.Object,System.Object,System.Object)">
 <summary>
 test the value mode of the target sequence literal
 </summary>
 <param name="init"></param>
 <param name="stops"></param>
 <param name="offset"></param>
 <returns>
 literal value mode could be:
 
 + num for float number
 + int for integer number
 + chr for characters
 + n/a for error message
 
 </returns>
</member>
<member name="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.DataSets.VectorLiteral">
 <summary>
 1. vector literal
 
 ```
 [x,y,z,...]
 ```
 
 2. vector append
 
 ```
 [x, ...y, ...z]
 ```
 </summary>
 <remarks>
 this object model implements the interface of a collection of the value <see cref="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.Expression"/>.
 </remarks>
</member>
<member name="P:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.DataSets.VectorLiteral.isLiteral">
 <summary>
 check all elements inside this vector is literal value or not?
 </summary>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.DataSets.NamespaceFunctionSymbolReference">
 <summary>
 ``namespace::function(xxx)``
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.DataSets.NamespaceFunctionSymbolReference.getFuncNameSymbolText(SMRUCC.Rsharp.Interpreter.ExecuteEngine.Expression,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 this function returns the name of target function symbol to invoke or an error 
 message if the expression type is invalid.
 </summary>
 <param name="funcNameSymbol"></param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.DataSets.NamespaceFunctionSymbolReference.getPackageApiImpl(SMRUCC.Rsharp.Runtime.Environment,System.String,SMRUCC.Rsharp.Interpreter.ExecuteEngine.Expression)">
 <summary>
 
 </summary>
 <param name="env"></param>
 <param name="namespace$"></param>
 <param name="funcNameSymbol"></param>
 <returns></returns>
 <remarks>
 find in runtime environment at first
 and then installed packages
 </remarks>
</member>
<member name="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.DataSets.ObjectWith">
 <summary>
 syntax implementation for ``with`` keyword
 </summary>
</member>
<member name="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.DataSets.Regexp">
 <summary>
 a regular expression literal syntax
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.DataSets.Regexp.Evaluate(SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 just create a new regexp object for run text match
 </summary>
 <param name="envir"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.DataSets.Regexp.Matches(System.Text.RegularExpressions.Regex,SMRUCC.Rsharp.Interpreter.ExecuteEngine.Expression,System.Boolean,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 do regular expression pattern matches
 </summary>
 <param name="r"></param>
 <param name="text"></param>
 <param name="drop">controls of the function evaluation result</param>
 <param name="env"></param>
 <returns>
 this function returns different result value based on the <paramref name="drop"/> option:
 
 1. drop = FALSE, for scalar string value, will returns a character vector that contains all matches result, 
                  for multiple string input, this function will returns a list that contains all regexp 
                  matches result for each elements string.
                  
 2. drop = TRUE, for scalar string value, will returns a scalar character string of the first regexp matches
                 result. for multiple string input, this function will returns a character vector which is 
                 consist with the every first matches result of the multiple string input, empty string will 
                 be placed in the result vector if the corresponding input string element has no matches 
                 result.
 </returns>
</member>
<member name="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.DataSets.StringInterpolation">
 <summary>
 A typescript liked string interpolation syntax
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.DataSets.StringInterpolation.stringParts">
 <summary>
 这些表达式产生的全部都是字符串结果值
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.DataSets.StringInterpolation.UnsafeStringConcatenate(System.Collections.Generic.IEnumerable{System.String[]},System.String)">
 <summary>
 
 </summary>
 <param name="strs">the string collection must be checked for the size before call this function</param>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.DataSets.SymbolIndexer">
 <summary>
 get/set elements by index 
 (X$name或者X[[name]])
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.DataSets.SymbolIndexer.index">
 <summary>
 index value for get subset from <see cref="F:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.DataSets.SymbolIndexer.symbol"/>. 
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.DataSets.SymbolIndexer.symbol">
 <summary>
 target symbol x
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.DataSets.SymbolIndexer.indexType">
 <summary>
 X[[name]]
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.DataSets.SymbolIndexer.#ctor(SMRUCC.Rsharp.Interpreter.ExecuteEngine.Expression,SMRUCC.Rsharp.Interpreter.ExecuteEngine.Expression)">
 <summary>
 symbol$byName
 </summary>
 <param name="symbol"></param>
 <param name="byName"></param>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.DataSets.SymbolIndexer.CheckRemoves">
 <summary>
 treat -xxx as removes xxx, 
 xxx as takes by name xxx
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.DataSets.SymbolIndexer.getDataframeRowRange(SMRUCC.Rsharp.Runtime.Internal.Object.dataframe,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 x[selector, ] get dataframe rows, make subset of the observation samples
 </summary>
 <param name="data"></param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.DataSets.SymbolIndexer.emptyIndexError(SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.DataSets.SymbolIndexer,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 generate the empty index error message for ``R#``
 </summary>
 <param name="symbol"></param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.DataSets.SymbolIndexer.getByIndex(System.Object,System.Array,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 vec[names/x] or list[names/index]
 </summary>
 <param name="obj"></param>
 <param name="indexer"></param>
 <param name="envir"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.DataSets.SymbolIndexer.listSubset(System.Collections.IDictionary,System.Array,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 make the tuple list subset
 </summary>
 <param name="list"></param>
 <param name="indexer"></param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.DataSets.SymbolIndexer.translateInteger2keys(System.Array,System.Object[])">
 <summary>
 translate the integer index to tuple list keys for make tuple list subset
 </summary>
 <param name="indexer">1-based integer index keys</param>
 <param name="allkeys"></param>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.DataSets.SymbolIndexers">
 <summary>
 enumerate all kinds of the symbol indexer syntax inside current R-sharp language
 </summary>
 <remarks><see cref="T:System.Byte"/></remarks>
</member>
<member name="F:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.DataSets.SymbolIndexers.vectorIndex">
 <summary>
 a[x]
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.DataSets.SymbolIndexers.nameIndex">
 <summary>
 a[[x]], a$x
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.DataSets.SymbolIndexers.dataframeColumns">
 <summary>
 a[, x]
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.DataSets.SymbolIndexers.dataframeRows">
 <summary>
 a[x, ]
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.DataSets.SymbolIndexers.dataframeRanges">
 <summary>
 a[x,y]
 </summary>
</member>
<member name="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.DataSets.VectorLoop">
 <summary>
 create a new vector data which is introduced via 
 the perl syntax:
 
 ``list@name`` means ``sapply(list, x -> x$name);``
 ``list@{name}`` means ``sapply(list, x -> x[[name]]);``
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.DataSets.VectorLoop.index">
 <summary>
 the target member name
 
 should be string literal or a symbol reference 
 expression produce the variable name
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.DataSets.VectorLoop.symbol">
 <summary>
 target list symbol that will extract vector data
 from it
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.DataSets.VectorLoop.getVectorList(System.Array,System.String,SMRUCC.Rsharp.Runtime.Components.TypeCodes,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 extract the specific element value from [list, list, list] vector data
 </summary>
 <param name="data"></param>
 <param name="memberName"></param>
 <param name="envir"></param>
 <returns>
 this function ensure that the generated vector keeps 
 the same size and the element order with the input 
 data vector.
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.DataSets.VectorLoop.__getVectorList(System.Object[],System.String,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 get by name
 </summary>
 <param name="source"></param>
 <param name="memberName"></param>
 <param name="envir"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.DataSets.VectorLoop.__getVectorList(System.Object[],System.Int32,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 get by index
 </summary>
 <param name="source"></param>
 <param name="index">this index value is 1-based</param>
 <param name="envir"></param>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.DataSets.SymbolReference">
 <summary>
 符号引用
 </summary>
</member>
<member name="P:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.DataSets.SymbolReference.symbol">
 <summary>
 目标变量名
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.DataSets.SymbolReference.GetReferenceObject(System.String,SMRUCC.Rsharp.Runtime.Environment,System.Boolean)">
 <summary>
 
 </summary>
 <param name="symbolName"></param>
 <param name="env"></param>
 <param name="[inherits]"></param>
 <returns>
 this function will returns an error message when the symbol reference
 could not be solved, otherwise returns the value of the symbol.
 </returns>
</member>
<member name="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.DataSets.ModeOf">
 <summary>
 get type/get class/get mode
 </summary>
</member>
<member name="P:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.DataSets.ModeOf.keyword">
 <summary>
 + ``modeof`` for get R# type code
 + ``typeof`` for get VB.NET type
 + ``valueof`` for get VB.NET type of the return value from a .NET api
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.DataSets.ModeOf.target">
 <summary>
 
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.DataSets.ModeOf.TypeOf(System.Object)">
 <summary>
 根据向量化的运算特性，在这里是否应该对于array以及vector，都只返回element type? 
 </summary>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.DataSets.TypeOfCheck">
 <summary>
 ``typeof x is "export_typename"``
 </summary>
</member>
<member name="P:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.DataSets.TypeOfCheck.typeName">
 <summary>
 value of this property is usually comes from <see cref="T:SMRUCC.Rsharp.Runtime.Interop.RTypeExportAttribute"/>
 </summary>
 <returns></returns>
 <remarks>
 binary right
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.DataSets.TypeOfCheck.#ctor(SMRUCC.Rsharp.Interpreter.ExecuteEngine.Expression,SMRUCC.Rsharp.Interpreter.ExecuteEngine.Expression)">
 <summary>
 typeof target == typeName?
 </summary>
 <param name="target"></param>
 <param name="typeName"></param>
 <remarks>
 关键词总是typeof
 </remarks>
</member>
<member name="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Closure.DeclareNewSymbol">
 <summary>
 An expressin for create a new symbol inside the runtime environment
 </summary>
</member>
<member name="P:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Closure.DeclareNewSymbol.names">
 <summary>
 tuple names.
 (对于tuple语法，会存在多个变量)
 </summary>
</member>
<member name="P:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Closure.DeclareNewSymbol.hasInitializeExpression">
 <summary>
 true for if the <see cref="P:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Closure.DeclareNewSymbol.value"/> expression is not nothing
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Closure.DeclareNewSymbol.getName(System.Int32)">
 <summary>
 get name by index
 </summary>
 <param name="i"></param>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Closure.DeclareNewSymbol.type">
 <summary>
 get object value type for current new symbol
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Closure.DeclareNewSymbol.symbolSize">
 <summary>
 the size of the symbol names
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Closure.DeclareNewSymbol.isTuple">
 <summary>
 does current symbol declaration contains multiple symbol targets?
 </summary>
 <returns>
 TRUE means contains multiple symbol target, it is a new tuple syntax;
 FALSE means just has one symbol target to create in the context.
 </returns>
</member>
<member name="P:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Closure.DeclareNewSymbol.value">
 <summary>
 The symbol initial value.(初始值)
 </summary>
</member>
<member name="P:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Closure.DeclareNewSymbol.unit">
 <summary>
 the unit name of the symbol value if it is a vector
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Closure.DeclareNewSymbol.#ctor(SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Operators.ValueAssignExpression,Microsoft.VisualBasic.ApplicationServices.Debugging.Diagnostics.StackFrame)">
 <summary>
 create new symbol with a specific initial value
 </summary>
 <param name="assign"></param>
 <param name="stack"></param>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Closure.DeclareNewSymbol.#ctor(SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.DataSets.SymbolReference,Microsoft.VisualBasic.ApplicationServices.Debugging.Diagnostics.StackFrame)">
 <summary>
 create new symbol without initial value
 </summary>
 <param name="symbol"></param>
 <param name="stack"></param>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Closure.DeclareNewSymbol.GetSymbolName">
 <summary>
 get symbol name string
 </summary>
 <returns>
 usually be the first element of the names array. For multiple names, 
 a string json array text will be generates from this function.
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Closure.DeclareNewSymbol.Evaluate(SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 Push current variable into the target environment ``<paramref name="envir"/>``.
 </summary>
 <param name="envir"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Closure.DeclareNewSymbol.PushNames(System.String[],System.Object,SMRUCC.Rsharp.Runtime.Components.TypeCodes,System.Boolean,SMRUCC.Rsharp.Runtime.Environment,SMRUCC.Rsharp.Runtime.Components.Message@)">
 <summary>
 
 </summary>
 <param name="names">The variable names</param>
 <param name="value">.NET runtime object value.</param>
 <param name="type"></param>
 <param name="envir"></param>
 <returns>
 用于初始化环境对象
 </returns>
</member>
<member name="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Closure.AcceptorClosure">
 <summary>
 ```
 func(yyy) {
     func2(xxx);
 }
 
 # will accept the closure as the first parameter
 # which is equals to the function invoke expression
 
 func({
     func2(xxx);
 }, yyy);
 ```
 </summary>
</member>
<member name="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Closure.ByRefFunctionCall">
 <summary>
 ``func(a) &lt;- value``
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Closure.ByRefFunctionCall.GetUnionParameters">
 <summary>
 get target symbol union with addtional byref function parameters
 </summary>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Closure.ClosureExpression">
 <summary>
 Is a kind of expression collection which consist with multiple 
 expression lines.
 (其实就是一段拥有自己的<see cref="T:SMRUCC.Rsharp.Runtime.Environment"/>的没有名称的匿名函数)
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Closure.ClosureExpression.#ctor(SMRUCC.Rsharp.Interpreter.ExecuteEngine.Expression[])">
 <summary>
 construct closure from a collection of the multiple expression
 </summary>
 <param name="code"></param>
</member>
<member name="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Closure.DeclareLambdaFunction">
 <summary>
 只允许简单的表达式出现在这里
 并且参数也只允许出现一个
 </summary>
 <remarks>
 a subclass of <see cref="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.SymbolExpression"/>
 
 (lambda函数与普通函数相比，lambda函数是没有environment的
 所以lambda函数会更加的轻量化)
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Closure.DeclareLambdaFunction.getArguments">
 <summary>
 lambda函数是不存在可选默认参数值的
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Closure.DeclareLambdaFunction.Evaluate(SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 返回的是一个<see cref="T:SMRUCC.Rsharp.Runtime.Components.Interface.RFunction"/>
 </summary>
 <param name="envir"></param>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Closure.DeclareNewFunction">
 <summary>
 ## Function Definition
 
 An R function object. These functions provide the base mechanisms 
 for defining new functions in the R language.
 
 The names in an argument list can be back-quoted non-standard names 
 (see ‘backquote’).
 If value is missing, NULL is returned. If it is a single expression,
 the value of the evaluated expression is returned. (The expression 
 is evaluated as soon as return is called, in the evaluation frame 
 of the function and before any on.exit expression is evaluated.)
 If the end of a function is reached without calling return, the value
 of the last evaluated expression is returned.
 
 (普通的函数定义模型: 
 
 普通的函数与lambda函数<see cref="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Closure.DeclareLambdaFunction"/>在结构上是一致的，
 但是有一个区别就是lambda函数<see cref="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Closure.DeclareLambdaFunction"/>是没有<see cref="T:SMRUCC.Rsharp.Runtime.Environment"/>的，
 所以lambda函数会更加的轻量化，不容易产生内存溢出的问题)
 </summary>
 <remarks>
 This type of function is not the only type in R: they are called 
 closures (a name with origins in LISP) to distinguish them from 
 primitive functions.
 A closure has three components, its formals (its argument list), 
 its body (expr in the ‘Usage’ section) and its environment which 
 provides the enclosure of the evaluation frame when the closure is 
 used.
 There is an optional further component if the closure has been 
 byte-compiled. This is not normally user-visible, but it indicated 
 when functions are printed.
 
 > Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988) The New S Language.
 Wadsworth &amp; Brooks/Cole.
 
 A subclass of <see cref="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.SymbolExpression"/>
 </remarks>
</member>
<member name="P:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Closure.DeclareNewFunction.Namespace">
 <summary>
 这个是当前的这个函数的程序包来源名称，在运行时创建的函数的命令空间为``SMRUCC/R#_runtime``
 </summary>
 <returns></returns>
</member>
<member name="F:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Closure.DeclareNewFunction.envir">
 <summary>
 The environment of current function closure, this environment
 context is comes from the environment where this function 
 symbol is created.
 
 this environment context holder make the closure it works for 
 holding the executation context
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Closure.DeclareNewFunction.hasObjectList">
 <summary>
 does the parameter set of this function contains a ``...`` 
 object list parameter?
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Closure.DeclareNewFunction.SetSymbol(System.String)">
 <summary>
 renames current function object its symbol name
 </summary>
 <param name="newName"></param>
 
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Closure.DeclareNewFunction.getArguments">
 <summary>
 get the parameter arguments of current function object
 </summary>
 <returns>
 this function will nenver returns nothing
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Closure.DeclareNewFunction.InitializeEnvironment(SMRUCC.Rsharp.Runtime.Environment,SMRUCC.Rsharp.Runtime.Components.InvokeParameter[],System.Boolean@)">
 <summary>
 set parameters
 </summary>
 <param name="caller_context">
 The environment context from the caller stack
 </param>
 <param name="params"></param>
 <param name="runDispose">
 A byref parameter to indicated that the resulted <see cref="T:SMRUCC.Rsharp.Runtime.Environment"/> should 
 be release after this function has been successfully executated? 
 </param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Closure.DeclareNewFunction.Invoke(System.Object[],SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 direct invoke of this R# function
 </summary>
 <param name="arguments"></param>
 <param name="caller"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Closure.DeclareNewFunction.Evaluate(SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 just create a new function object in the environment context
 </summary>
 <param name="envir"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Closure.DeclareNewFunction.ToString">
 <summary>
 Inspect of the function declaration content of current function closure object.
 </summary>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Closure.FunctionInvoke">
 <summary>
 Invoke a function symbol
 
 ```
 call xxx(...)
 ```
 </summary>
</member>
<member name="P:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Closure.FunctionInvoke.namespace">
 <summary>
 The namespace reference of the target <see cref="P:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Closure.FunctionInvoke.funcName"/>.
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Closure.FunctionInvoke.parameters">
 <summary>
 The parameters expression that passing to the target invoked function.
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Closure.FunctionInvoke.#ctor(System.String,Microsoft.VisualBasic.ApplicationServices.Debugging.Diagnostics.StackFrame,SMRUCC.Rsharp.Interpreter.ExecuteEngine.Expression[])">
 <summary>
 Use for create pipeline calls from identifier target
 </summary>
 <param name="funcName"></param>
 <param name="parameters"></param>
 
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Closure.FunctionInvoke.#ctor(SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Closure.FunctionInvoke)">
 <summary>
 make a data copy of the function invoke expression itself
 </summary>
 <param name="copy"></param>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Closure.FunctionInvoke.#ctor(SMRUCC.Rsharp.Interpreter.ExecuteEngine.Expression,Microsoft.VisualBasic.ApplicationServices.Debugging.Diagnostics.StackFrame,SMRUCC.Rsharp.Interpreter.ExecuteEngine.Expression[])">
 <summary>
 Use for create pipeline calls from identifier target
 </summary>
 <param name="funcVar"></param>
 <param name="parameters"></param>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Closure.FunctionInvoke.EnumerateInvokedParameters">
 <summary>
 Populate all function invoke parameter values
 </summary>
 <returns></returns>
</member>
<member name="F:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Closure.FunctionInvoke.runtimeFuncs">
 <summary>
 These function create from script text in runtime
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Closure.FunctionInvoke.Evaluate(SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 call R#/python/julia function
 </summary>
 <param name="envir"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Closure.FunctionInvoke.CheckInvoke(SMRUCC.Rsharp.Runtime.Environment,System.Boolean@)">
 <summary>
 Check and get the object reference to the target invoke function
 </summary>
 <param name="envir"></param>
 <param name="passed"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Closure.FunctionInvoke.HandleResult(System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 check the function invoke returns values for:

 1. error message
 2. invisible
 3. returns expression, break expression
 
 </summary>
 <param name="result"></param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Closure.FunctionInvoke.getFuncVar(SMRUCC.Rsharp.Interpreter.ExecuteEngine.Expression,System.String,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 This function maybe returns <see cref="T:SMRUCC.Rsharp.Runtime.Components.Interface.RFunction"/>, nothing or exception <see cref="T:SMRUCC.Rsharp.Runtime.Components.Message"/> 
 if the namespace reference function is not found or unable to load library module.
 </summary>
 <param name="funcName"></param>
 <param name="namespace"></param>
 <param name="envir"></param>
 <returns>
 This function returns a R api function or regex object for do string matches
 
 + 1. <see cref="T:SMRUCC.Rsharp.Runtime.Components.Interface.RFunction"/>
 + 2. <see cref="T:System.Text.RegularExpressions.Regex"/>
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Closure.FunctionInvoke.GetFunctionVar(SMRUCC.Rsharp.Interpreter.ExecuteEngine.Expression,SMRUCC.Rsharp.Runtime.Environment,System.String)">
 <summary>
 get internal function symbol object or runtime function 
 from the given runtime <see cref="T:SMRUCC.Rsharp.Runtime.Environment"/>.
 </summary>
 <param name="env"></param>
 <param name="funcName">
 这个参数不会处理ns::func的引用情况，请在调用这个函数之前完成解析
 </param>
 <returns>
 an error message will be return if the 
 target function symbol is not found in 
 the given runtime <paramref name="env"/>.
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Closure.FunctionInvoke.GetFunctionVar(SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 get internal function symbol object or runtime function 
 from the given runtime <see cref="T:SMRUCC.Rsharp.Runtime.Environment"/>.
 </summary>
 <param name="env"></param>
 <returns></returns>
 
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Closure.FunctionInvoke.doInvokeFuncVar(SMRUCC.Rsharp.Runtime.Components.Interface.RFunction,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 invoke runtime function or .NET methodinfo
 </summary>
 <param name="funcVar"></param>
 <param name="envir"></param>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Closure.TryCatchExpression">
 <summary>
 try ... catch block in R# language
 </summary>
 <remarks>
 this closure will convert the error message as warning message
 </remarks>
</member>
<member name="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Closure.UsingClosure">
 <summary>
 ```R
 using xxx as creator() {
 
 }
 ```
 </summary>
 <remarks>
 a subclass of <see cref="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.SymbolExpression"/>
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Closure.UsingClosure.#ctor(SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Closure.DeclareNewSymbol,SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Closure.ClosureExpression,Microsoft.VisualBasic.ApplicationServices.Debugging.Diagnostics.StackFrame)">
 <summary>
 using params do closure
 </summary>
 <param name="params">using x as value</param>
 <param name="closure"></param>
 <param name="stackframe"></param>
</member>
<member name="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Operators.AppendOperator">
 <summary>
 append, not modify the source vector
 
 ```
 a &lt;&lt; b
 ```
 </summary>
</member>
<member name="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Operators.BinaryBetweenExpression">
 <summary>
 x between inside a range?
 
 ```
 x between [min, max]
 ```
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Operators.BinaryBetweenExpression.collectionSet">
 <summary>
 left
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Operators.BinaryBetweenExpression.range">
 <summary>
 right
 </summary>
</member>
<member name="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Operators.IBinaryExpression">
 <summary>
 the abstract model of expression:
 
 ```
 left op right
 ```
 </summary>
</member>
<member name="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Operators.BinaryInExpression">
 <summary>
 operator for test of left in right?
 </summary>
 <remarks>
 + 如果右边参数为序列，则是进行对值的indexOf操作
 + 如果右边参数为列表，则是对key进行查找操作
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Operators.BinaryInExpression.#ctor(SMRUCC.Rsharp.Interpreter.ExecuteEngine.Expression,SMRUCC.Rsharp.Interpreter.ExecuteEngine.Expression)">
 <summary>
 construct a expression for determine that does <paramref name="a"/> in <paramref name="b"/>?
 </summary>
 <param name="a">left</param>
 <param name="b">right</param>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Operators.BinaryInExpression.testListIndex(SMRUCC.Rsharp.Runtime.Components.Interface.RNames,System.String[])">
 <summary>
 check keys in left is exists in the namelist of right?
 </summary>
 <param name="sequence"></param>
 <param name="testLeft"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Operators.BinaryInExpression.getIndex(System.Object)">
 <summary>
 
 </summary>
 <param name="src"></param>
 <returns>
 array data or error message
 </returns>
</member>
<member name="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Operators.NullishCoalescing">
 <summary>
 The nullish coalescing (??) operator is a logical operator that returns
 its right-hand side operand when its left-hand side operand is null 
 or undefined, and otherwise returns its left-hand side operand.
 
 ```
 x ?? default
 ```
 </summary>
 <remarks>
 The nullish coalescing operator can be seen as a special case of the logical OR (||) 
 operator. The latter returns the right-hand side operand if the left operand is any 
 falsy value, not only null or undefined. In other words, if you use || to provide 
 some default value to another variable foo, you may encounter unexpected behaviors 
 if you consider some falsy values as usable (e.g., '' or 0). 
 
 The nullish coalescing Operator has the fifth-lowest Operator precedence, directly lower 
 than || And directly higher than the conditional (ternary) Operator.
 
 It Is Not possible to combine both the And (&amp;&amp;) And Or operators (||) directly 
 with ??. A syntax error will be thrown in such cases.
 </remarks>
</member>
<member name="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Operators.DataFrameProjection">
 <summary>
 get value of ``data[, selector]``
 </summary>
</member>
<member name="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Operators.DataFrameSlice">
 <summary>
 get value of ``data[selector, ]``
 </summary>
</member>
<member name="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Operators.DotNetObject">
 <summary>
 [x]::property, this syntax only works for the class property
 </summary>
</member>
<member name="P:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Operators.DotNetObject.member">
 <summary>
 the vector shadow reader
 </summary>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Operators.ReturnValue">
 <summary>
 returns the value from the function stack and break the executation loop of the function
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Operators.ReturnValue.#ctor(SMRUCC.Rsharp.Interpreter.ExecuteEngine.Expression)">
 <summary>
 create a new function return expression
 </summary>
 <param name="value"></param>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Operators.StringBinaryExpression.DoStringBinary``1(System.Object,System.Object,SMRUCC.Rsharp.Runtime.Vectorization.op_evaluator,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 string binary operator
 </summary>
 <typeparam name="Out"></typeparam>
 <param name="a"></param>
 <param name="b"></param>
 <param name="op"></param>
 <param name="env">
 helper for throw error message if the length of <paramref name="a"/> 
 and <paramref name="b"/> is not equals to each other.
 </param>
 <returns>
 this function returns a string array or error message
 </returns>
 <remarks>
 the <see cref="M:SMRUCC.Rsharp.Runtime.Vectorization.CLRVector.asCharacter(System.Object)"/> function will be
 called in this function automatic for processing the parameter
 <paramref name="a"/> and <paramref name="b"/> to string vector.
 </remarks>
</member>
<member name="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Operators.UnaryNot">
 <summary>
 
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Operators.UnaryNumeric.operator">
 <summary>
 +-!
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Operators.UnaryNumeric.numeric">
 <summary>
 可能是一个符号，也可以能是一个对象引用
 </summary>
</member>
<member name="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Operators.MemberValueAssign">
 <summary>
 a[xxx] = value
 </summary>
</member>
<member name="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Operators.ValueAssignExpression">
 <summary>
 Set variable or tuple
 </summary>
 <remarks>
 supports tuple disconstruct syntax for assign value to multiuple symbols.
 </remarks>
</member>
<member name="P:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Operators.ValueAssignExpression.targetSymbols">
 <summary>
 可能是对tuple做赋值
 所以应该是多个变量名称
 </summary>
</member>
<member name="P:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Operators.ValueAssignExpression.value">
 <summary>
 the value data expression for assigned to the <see cref="P:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Operators.ValueAssignExpression.targetSymbols"/>
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Operators.ValueAssignExpression.EvaluateValue(SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 evaluate the <see cref="P:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Operators.ValueAssignExpression.value"/> expression as the clr runtime value.
 </summary>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Operators.ValueAssignExpression.DoValueAssign(SMRUCC.Rsharp.Runtime.Environment,System.Object)">
 <summary>
 set the given <paramref name="value"/> to <see cref="P:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Operators.ValueAssignExpression.targetSymbols"/>.
 </summary>
 <param name="envir"></param>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Operators.ValueAssignExpression.setFromObjectList(SMRUCC.Rsharp.Runtime.Environment,SMRUCC.Rsharp.Interpreter.ExecuteEngine.Expression[],System.Boolean,System.Object)">
 <summary>
 使用左边的变量符号的名称从右边的列表之中按名称取出值，不存在的名字则赋值为空值
 </summary>
 <param name="envir"></param>
 <param name="targetSymbols"></param>
 <param name="isByRef"></param>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Operators.ValueAssignExpression.GetSymbol(SMRUCC.Rsharp.Interpreter.ExecuteEngine.Expression)">
 <summary>
 handling get symbol from the given expression types:
 
 1. <see cref="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.DataSets.Literal"/>: get string literal value as symbol text
 2. <see cref="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.DataSets.SymbolReference"/>: get symbol name as the symbol text
 
 </summary>
 <param name="symbolName"></param>
 <returns>
 this function returns nothing if the given expression type 
 is not implements for get symbol text
 </returns>
</member>
<member name="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Imports">
 <summary>
 A syntax from imports new package namespace from the external module assembly. 
 
 ```
 imports [namespace] from [module.dll]
 imports "script.R"
 ```
 
 if the module file is missing file extension name, then the file extension name 
 ``dll`` will be used as default. 
 </summary>
 <remarks>
 ``imports``关键词的功能除了可以导入dll模块之中的包模块以外，也可以导入R脚本。
 导入R脚本的功能和``source``函数保持一致，但是存在一些行为上的区别：
 
 + ``source``函数要求脚本文件必须是一个正确的绝对路径或者相对路径
 + ``imports``关键词则无此要求，因为imports关键词会自动进行脚本文件的搜索操作
 
 为了兼容javascript的调用，在导入模块成功的时候还会在全局环境中生成模块的变量
 </remarks>
</member>
<member name="P:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Imports.library">
 <summary>
 ``*.dll/*.R`` file name
 </summary>
 <returns></returns>
 <remarks>
 dll file path may be affected by the ``attach_lib_dir`` in options,
 ``attach_lib_dir`` is defined based on the ``--attach`` argument value
 from the commandline.
 </remarks>
</member>
<member name="P:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Imports.isImportsScript">
 <summary>
 当前的语句是否是用于导入其他的脚本文件模块？
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Imports.#ctor(SMRUCC.Rsharp.Interpreter.ExecuteEngine.Expression,SMRUCC.Rsharp.Interpreter.ExecuteEngine.Expression,System.String)">
 <summary>
 imports package from library
 </summary>
 <param name="packages"></param>
 <param name="library"></param>
 <param name="source">The file path of the source R# script file</param>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Imports.#ctor(System.String,System.String)">
 <summary>
 imports package from library
 </summary>
 <param name="package"></param>
 <param name="library"></param>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Imports.importsLibrary(SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ```js
 import "library-name"
 ```
 </summary>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Imports.importsPackages(SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ```js
 import packages from "dll-file"
 ```
 </summary>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Imports.GetExternalScriptFile(System.String,System.String,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 
 </summary>
 <param name="libFile"></param>
 <param name="source">
 + 如果源文件存在值，则会在source脚本所处的文件夹，其中的R文件夹，当前文件夹进行搜索
 + 如果源文件是空值，则会在当前文件夹以及当前文件夹中的R文件夹进行搜索
 </param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Imports.GetDllFile(System.String,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 the clr dll assembly file name(full name)
 </summary>
 <param name="libDll">the file name of the dll file, example like: ``file.dll``</param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Imports.LoadLibrary(System.String,SMRUCC.Rsharp.Runtime.Environment,Microsoft.VisualBasic.ComponentModel.Collection.Index{System.String})">
 <summary>
 Load packages from a given dll module file
 </summary>
 <param name="libDll">A given dll module file its file path</param>
 <param name="envir"></param>
 <param name="names">a list of package module in target assembly file <paramref name="libDll"/></param>
 <returns></returns>
 
</member>
<member name="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Require">
 <summary>
 ## Loading/Attaching and Listing of Packages
 
 library and require load and attach add-on packages.
 
 library and require can only load/attach an installed package, 
 and this is detected by having a ‘DESCRIPTION’ file containing
 a Built: field.
 Under Unix-alikes, the code checks that the package was 
 installed under a similar operating system As given by
 R.version$platform (the canonical name Of the platform under 
 which R was compiled), provided it contains compiled code. 
 Packages which Do Not contain compiled code can be Shared 
 between Unix-alikes, but Not To other OSes because Of potential 
 problems With line endings And OS-specific help files. If 
 Sub-architectures are used, the OS similarity Is Not checked 
 since the OS used To build may differ (e.g. i386-pc-linux-gnu
 code can be built On an x86_64-unknown-linux-gnu OS).
 The package name given To library And require must match the 
 name given In the package's ‘DESCRIPTION’ file exactly, even on 
 case-insensitive file systems such as are common on Windows 
 and macOS.
 </summary>
 <remarks>
 ``require`` returns a logical vector for indicates the package loading result.
 </remarks>
</member>
<member name="P:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Require.packages">
 <summary>
 the name of a package, given as a name or 
 literal character string, or a character 
 string, depending on whether ``character.only``
 is FALSE (default) or TRUE.
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Require.#ctor(System.Collections.Generic.IEnumerable{SMRUCC.Rsharp.Interpreter.ExecuteEngine.Expression})">
 <summary>
 Loading/Attaching and Listing of Packages
 </summary>
 <param name="names"></param>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Require.#ctor(System.String)">
 <summary>
 Loading/Attaching and Listing of Packages
 </summary>
 <param name="packageName"></param>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Require.#ctor(System.Collections.Generic.IEnumerable{System.String})">
 <summary>
 Loading/Attaching and Listing of Packages
 </summary>
 <param name="names"></param>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Require.Evaluate(SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 require returns (invisibly) a logical indicating whether the 
 required package is available.
 
 library(package) and require(package) both load the namespace
 of the package with name package and attach it on the search
 list. require is designed for use inside other functions; it 
 returns FALSE and gives a warning (rather than an error as
 ``library()`` does by default) if the package does not exist. 
 Both functions check and update the list of currently attached 
 packages and do not reload a namespace which is already loaded. 
 (If you want to reload such a package, call detach(unload = TRUE)
 or unloadNamespace first.) If you want to load a package 
 without attaching it on the search list, see requireNamespace.
 To suppress messages during the loading of packages use 
 suppressPackageStartupMessages: this will suppress all messages 
 from R itself but Not necessarily all those from package authors.
 If library Is called With no package Or help argument, it lists 
 all available packages In the libraries specified by Lib.loc,
 And returns the corresponding information In an Object Of Class
 "libraryIQR". (The Structure Of this Class may change In future
 versions.) Use .packages(all = True) To obtain just the names 
 Of all available packages, And installed.packages() For more 
 information.
 library(help = somename) computes basic information about the package 
 somename, And returns this in an object of class "packageInfo". 
 (The structure of this class may change in future versions.) When 
 used with the default value (NULL) for lib.loc, the attached 
 packages are searched before the libraries.
 </summary>
 <param name="envir"></param>
 <returns>
 Normally library returns (invisibly) the list of attached packages,
 but TRUE or FALSE if logical.return is TRUE. When called as library() 
 it returns an object of class "libraryIQR", and for library(help=),
 one of class "packageInfo".
 require returns(invisibly) a logical indicating whether the required 
 package Is available.
 </returns>
 <remarks>
 ### Conflicts
 
 Handling of conflicts depends on the setting of the conflicts.policy 
 option. If this option Is Not set, then conflicts result in warning 
 messages if the argument warn.conflicts Is TRUE. If the option Is set
 to the character string "strict", then all unresolved conflicts signal
 errors. Conflicts can be resolved using the mask.ok, exclude, And
 include.only arguments to library And require. Defaults for mask.ok 
 And exclude can be specified using conflictRules.
 If the conflicts.policy Option Is Set To the String "depends.ok" Then
 conflicts resulting from attaching declared dependencies will Not
 produce errors, but other conflicts will. This Is likely To be the
 best setting For most users wanting some additional protection against
 unexpected conflicts.
 The policy can be tuned further by specifying the conflicts.policy Option 
 As a named list With the following fields
 
 + error: logical; if TRUE treat unresolved conflicts as errors.
 + warn: logical; unless FALSE issue a warning message when conflicts are found.
 + generics.ok: logical; if TRUE ignore conflicts created by defining S4 
                generics for functions on the search path.
 + depends.ok: logical; if TRUE do Not treat conflicts with required 
               packages as errors.
 + can.mask: character vector Of names Of packages that are allowed To be
             masked. These would typically be base packages attached by
             Default.
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Require.ToString">
 <summary>
 Loading/Attaching and Listing of Packages
 </summary>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Blocks.ContinuteFor">
 <summary>
 next
 </summary>
</member>
<member name="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Blocks.ForLoop">
 <summary>
 在R语言之中，只有for each循环
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Blocks.ForLoop.variables">
 <summary>
 单个变量或者tuple的时候为多个变量
 </summary>
</member>
<member name="P:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Blocks.ForLoop.body">
 <summary>
 为了兼容tuple的赋值，在这里这个函数体就没有参数了
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Blocks.ForLoop.parallel">
 <summary>
 ``%dopar%``
 </summary>
</member>
<member name="P:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Blocks.ForLoop.type">
 <summary>
 循环体的返回值类型就是for循环的返回值类型
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Blocks.ForLoop.Evaluate(SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 run for loop at here
 </summary>
 <param name="envir"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Blocks.ForLoop.RunLoop(System.Object,Microsoft.VisualBasic.ApplicationServices.Debugging.Diagnostics.StackFrame,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 run a single loop
 </summary>
 <param name="value"></param>
 <param name="stackframe"></param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Blocks.ForLoop.getSequence(SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 this function will cast dataframe to rows if
 the variables is a multiple symbol tuple 
 vector. 
 </summary>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Blocks.IfPromise.DoValueAssign(SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 the value assign will be skip to evaluate 
 if the target <see cref="P:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Blocks.IfPromise.assignTo"/> is 
 nothing.
 </summary>
 <param name="envir"></param>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Blocks.IIfExpression">
 <summary>
 ifelse expression
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Blocks.IIfExpression.Evaluate(SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 if test true, then returns true part else returns false part
 </summary>
 <param name="envir"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Blocks.IIfExpression.ToString">
 <summary>
 javascript ifelse syntax
 </summary>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.LINQ.DataFrameDataSet">
 <summary>
 populate by rows
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.LINQ.DataFrameDataSet.PopulatesData">
 <summary>
 populate a list of javascript object
 </summary>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.LINQ.DataSet">
 <summary>
 the linq dataset object, a helper module for 
 iterates through the data sequence that produced
 by the <see cref="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.LINQ.QueryExpression"/>
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.LINQ.ErrorDataSet.PopulatesData">
 <summary>
 populate nothing
 </summary>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.LINQ.JointDataSet">
 <summary>
 data set result of left join
 </summary>
</member>
<member name="P:SMRUCC.Rsharp.Interpreter.ExecuteEngine.LINQ.QuerySource.symbolName">
 <summary>
 symbol name of the data source sequence
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.LINQ.ExecutableContext.SetSymbol(System.String,System.Object)">
 <summary>
 set <paramref name="value"/> to target symbol <paramref name="name"/>.
 </summary>
 <param name="name"></param>
 <param name="value"></param>
 
</member>
<member name="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.LINQ.Expression">
 <summary>
 the Linq expression
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.LINQ.Expression.Exec(SMRUCC.Rsharp.Interpreter.ExecuteEngine.LINQ.ExecutableContext)">
 <summary>
 Evaluate the expression
 </summary>
 <param name="context"></param>
 <returns></returns>
</member>
<member name="F:SMRUCC.Rsharp.Interpreter.ExecuteEngine.LINQ.DataLeftJoin.anotherData">
 <summary>
 join xxx in xxx
 </summary>
</member>
<member name="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.LINQ.BinaryExpression">
 <summary>
 the linq binary expression
 </summary>
</member>
<member name="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.LINQ.RunTimeValueExpression">
 <summary>
 这个是为了解决R#脚本中的表达式对象与Linq脚本中的表达式对象的不兼容问题创建的
 </summary>
</member>
<member name="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.LINQ.SymbolDeclare">
 <summary>
 declare a new temp symbol: ``LET x = ...``
 </summary>
</member>
<member name="P:SMRUCC.Rsharp.Interpreter.ExecuteEngine.LINQ.SymbolDeclare.symbol">
 <summary>
 is a <see cref="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.LINQ.Literal"/> or <see cref="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.LINQ.VectorLiteral"/>
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.LINQ.SymbolDeclare.Exec(SMRUCC.Rsharp.Interpreter.ExecuteEngine.LINQ.ExecutableContext)">
 <summary>
 just create new symbol in the target environment
 </summary>
 <param name="context"></param>
 <returns>returns nothing</returns>
</member>
<member name="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.LINQ.LinqKeywordExpression">
 <summary>
 the linq expression of a specific keyword 
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.LINQ.PipelineKeyword.FixLiteral(SMRUCC.Rsharp.Interpreter.ExecuteEngine.LINQ.Expression)">
 <summary>
 将字符串常量表示转换为变量引用
 </summary>
 <param name="expr"></param>
 <returns></returns>
 <remarks>
 这个是因为list或者dataframe之中的对象名称可能含有非法字符
 需要使用字符串常量来表示，这个函数将字符串常量表示转换为变量
 对象引用
 </remarks>
</member>
<member name="F:SMRUCC.Rsharp.Interpreter.ExecuteEngine.LINQ.SkipItems.n">
 <summary>
 this expression should produce an integer value
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Interpreter.ExecuteEngine.LINQ.TakeItems.n">
 <summary>
 this expression should produce an integer value
 </summary>
</member>
<member name="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.LINQ.OutputProjection">
 <summary>
 data projection: ``SELECT &lt;fields>``
 </summary>
</member>
<member name="P:SMRUCC.Rsharp.Interpreter.ExecuteEngine.LINQ.OutputProjection.fields">
 <summary>
 produce a javascript object or dataframe row
 </summary>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.LINQ.WhereFilter">
 <summary>
 data filter: ``WHERE &lt;condition>``
 </summary>
</member>
<member name="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.LINQ.NamespaceDoc">
 <summary>
 LINQ language query sub-system in R# interpreter
 </summary>
</member>
<member name="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.LINQ.AggregateExpression">
 <summary>
 aggregate ... into ...
 </summary>
</member>
<member name="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.LINQ.ProjectionExpression">
 <summary>
 from ... select ...
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.LINQ.ProjectionExpression.Exec(SMRUCC.Rsharp.Interpreter.ExecuteEngine.LINQ.ExecutableContext)">
 <summary>
 
 </summary>
 <param name="context"></param>
 <returns>
 array of <see cref="T:Microsoft.VisualBasic.My.JavaScript.JavaScriptObject"/>
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.LINQ.QueryExpression.GetSeqValue(SMRUCC.Rsharp.Interpreter.ExecuteEngine.LINQ.ExecutableContext)">
 <summary>
 get sequence value
 
 evaluate expression for get ``IN ...`` data source
 </summary>
 <param name="context"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.LINQ.QueryExpression.GetDataSet(SMRUCC.Rsharp.Interpreter.ExecuteEngine.LINQ.ExecutableContext)">
 <summary>
 get data source iterator for query
 </summary>
 <param name="context"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.LINQ.QueryExpression.Compile">
 <summary>
 do optimization of the current query expression.
 </summary>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.LINQ.Syntax.StackParser">
 <summary>
 Stack parser of the Linq query expression
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.LINQ.Syntax.StackParser.DoSplitByTopLevelStack(System.Collections.Generic.IEnumerable{SMRUCC.Rsharp.Language.TokenIcer.Token},System.Func{SMRUCC.Rsharp.Language.TokenIcer.Token,System.Boolean},System.Boolean,System.Boolean,System.Boolean)">
 <summary>
 根据最顶端的关键词以及括号进行栈片段的分割
 </summary>
 <param name="tokenList"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.LINQ.Syntax.SyntaxImplements.IsNumeric(SMRUCC.Rsharp.Language.TokenIcer.Token)">
 <summary>
 target token is a number literal value? 
 </summary>
 <param name="t"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.LINQ.Syntax.SyntaxImplements.PopulateQueryExpression(System.Collections.Generic.IEnumerable{SMRUCC.Rsharp.Language.TokenIcer.Token},SMRUCC.Rsharp.Language.Syntax.SyntaxParser.SyntaxBuilderOptions)">
 <summary>
 the main entry of parse linq expression
 </summary>
 <param name="tokenList"></param>
 <returns>
 <see cref="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.LINQ.QueryExpression"/> or an error <see cref="T:System.Exception"/>
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.LINQ.Syntax.SyntaxImplements.CreateProjectionQuery(SMRUCC.Rsharp.Language.TokenIcer.Token[],SMRUCC.Rsharp.Language.TokenIcer.Token[][],SMRUCC.Rsharp.Language.Syntax.SyntaxParser.SyntaxBuilderOptions)">
 <summary>
 <see cref="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.LINQ.ProjectionExpression"/>
 </summary>
 <param name="symbol"></param>
 <param name="blocks"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.LINQ.Syntax.SyntaxImplements.CreateAggregateQuery(SMRUCC.Rsharp.Language.TokenIcer.Token[],SMRUCC.Rsharp.Language.TokenIcer.Token[][],SMRUCC.Rsharp.Language.Syntax.SyntaxParser.SyntaxBuilderOptions)">
 <summary>
 <see cref="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.LINQ.AggregateExpression"/>
 </summary>
 <param name="symbol"></param>
 <param name="blocks"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.LINQ.Syntax.SyntaxImplements.ParseToken(SMRUCC.Rsharp.Language.TokenIcer.Token,SMRUCC.Rsharp.Language.Syntax.SyntaxParser.SyntaxBuilderOptions)">
 <summary>
 
 </summary>
 <param name="t"></param>
 <param name="opts"></param>
 <returns></returns>
 <remarks>
 发生错误的时候，已经在函数内部自动使用<paramref name="t"/>参数的未知信息来创建语法错误消息
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.LINQ.Syntax.SyntaxImplements.IsClosure(SMRUCC.Rsharp.Language.TokenIcer.Token[])">
 <summary>
 (...) or {...}
 </summary>
 <param name="tokenList"></param>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.SymbolExpression">
 <summary>
 An expression that will create a new symbol in R# environment
 </summary>
 <remarks>
 the base type of 
 
 1. <see cref="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Closure.DeclareNewSymbol"/>
 2. <see cref="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Closure.DeclareLambdaFunction"/>
 3. <see cref="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Closure.DeclareNewFunction"/>
 4. <see cref="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Closure.UsingClosure"/>
 </remarks>
</member>
<member name="F:SMRUCC.Rsharp.Interpreter.ExecuteEngine.SymbolExpression.attributes">
 <summary>
 the annotation data from the attribute annotation, example as:
 
 ```R
 [@name "value"]
 [@name1 "value2"]
 const symbol = ...
 ```
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.SymbolExpression.GetSymbolName">
 <summary>
 The symbol name of current symbol object
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.SymbolExpression.hasAttribute(System.String)">
 <summary>
 does a specific attribute exists in current symbol?
 </summary>
 <param name="name"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.SymbolExpression.GetAttributeNames">
 <summary>
 Get all attribute name that tagged with current symbol object.
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.SymbolExpression.GetAttributeValue(System.String)">
 <summary>
 Get values that associated with the current symbol object
 </summary>
 <param name="name">the attribute name string for get the value</param>
 <returns>returns empty string collection if the attribute name is not exists</returns>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.SymbolExpression.AddCustomAttributes(System.Collections.Generic.IEnumerable{Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedValue{System.String[]}})">
 <summary>
 Add custom attribute data into current symbol object
 </summary>
 <param name="attrs"></param>
 <remarks>
 Call this method at script parser or expression parser code
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.SymbolExpression.SetAttributes(System.Collections.Generic.Dictionary{System.String,System.String[]})">
 <summary>
 Just set value, this function use for the package parser
 </summary>
 <param name="attrs"></param>
 <remarks>
 use the <see cref="M:SMRUCC.Rsharp.Interpreter.ExecuteEngine.SymbolExpression.AddCustomAttribute(System.String,System.String[])"/> if want to 
 add a specific single attribute data
 </remarks>
</member>
<member name="T:SMRUCC.Rsharp.Interpreter.Program">
 <summary>
 is a collection of the expresion object, represents the parser result of a R script file
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Interpreter.Program.Rscript">
 <summary>
 the raw Rscript data
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.Program.CreateProgram(SMRUCC.Rsharp.Runtime.Components.Rscript,System.Boolean,System.String@)">
 <summary>
 
 </summary>
 <param name="Rscript"></param>
 <param name="debug"></param>
 <param name="error"></param>
 <returns>
 this function returns nothing if syntax error
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.Program.isException(System.Object@,SMRUCC.Rsharp.Runtime.Environment,System.Boolean@)">
 <summary>
 is error <see cref="T:SMRUCC.Rsharp.Runtime.Components.Message"/> andalso which is in <see cref="F:Microsoft.VisualBasic.ApplicationServices.Debugging.Logging.MSG_TYPES.ERR"/> level? or any
 kind of .NET <see cref="T:System.Exception"/> value?
 </summary>
 <param name="result"></param>
 <param name="envir"></param>
 <param name="isDotNETException"></param>
 <returns>
 false for input <paramref name="result"/> is nothing, true if the <paramref name="result"/> value is message or clr exception.
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.Program.BuildProgram(System.String,System.Boolean,System.String@)">
 <summary>
 
 </summary>
 <param name="scriptText"></param>
 <param name="debug"></param>
 <param name="error"></param>
 <returns>
 this function returns nothing if syntax error
 </returns>
</member>
<member name="P:SMRUCC.Rsharp.Interpreter.RInterpreter.globalEnvir">
 <summary>
 Global runtime environment.
 </summary>
 <remarks>
 (全局环境)
 </remarks>
</member>
<member name="P:SMRUCC.Rsharp.Interpreter.RInterpreter.debug">
 <summary>
 R# running in debug mode.
 </summary>
 <returns></returns>
 <remarks>
 调试模式下，除了输出表达式的字符串信息之外
 还会改变stop的行为，在非调试模式下，stop函数只会丢出错误消息并且终止脚本的运行
 但是在调试模式下面，stop函数则会令程序抛出异常方便开发人员进行错误的定位
 </remarks>
</member>
<member name="P:SMRUCC.Rsharp.Interpreter.RInterpreter.redirectError2stdout">
 <summary>
 是否重定向错误消息输出至<see cref="M:SMRUCC.Rsharp.Interpreter.RInterpreter.RedirectOutput(System.IO.StreamWriter,SMRUCC.Rsharp.Runtime.OutputEnvironments)"/>函数所定义的输出设备之中
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Interpreter.RInterpreter.strict">
 <summary>
 是否在严格模式下运行R#脚本？默认为严格模式，即：
 
 1. 所有的变量必须使用``let``关键词进行申明
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Interpreter.RInterpreter.GetValue(System.String)">
 <summary>
 Get value of a <see cref="T:SMRUCC.Rsharp.Runtime.Components.Symbol"/>
 </summary>
 <param name="name"></param>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Interpreter.RInterpreter.globalSymbols">
 <summary>
 get all symbols inside the global environment
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.RInterpreter.#ctor(SMRUCC.Rsharp.Development.Configuration.Options,System.String)">
 <summary>
 直接无参数调用这个构造函数，则会使用默认的配置文件创建R#脚本解释器引擎实例
 </summary>
 <param name="envirConf"></param>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.RInterpreter.getDataStream(System.String,System.String)">
 <summary>
 open the data file as stream from a given 
 package with a specific resource reference 
 name.
 </summary>
 <param name="dataName"></param>
 <param name="package"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.RInterpreter.Print(System.String,System.Boolean)">
 <summary>
 A shortcut of ``print(expr)``
 </summary>
 <param name="expr"></param>
 <param name="auto">
 在自动条件下，会忽略掉<paramref name="expr"/>为<see cref="T:SMRUCC.Rsharp.Runtime.Internal.Object.invisible"/>
 的结果打印
 </param>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.RInterpreter.Inspect(System.Object)">
 <summary>
 do call ``str`` function for inspect the structure of the given <paramref name="obj"/>
 </summary>
 <param name="obj"></param>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.RInterpreter.Imports(System.String[],System.String)">
 <summary>
 imports {<paramref name="pkgs"/>} from "<paramref name="baseDll"/>";
 </summary>
 <param name="pkgs"></param>
 <param name="baseDll"></param>
 <returns></returns>
 <remarks>
 attach_lib_dir
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.RInterpreter.LoadLibrary(System.String,System.Boolean,System.Boolean)">
 <summary>
 Load packages from package name or dll module file
 </summary>
 <param name="packageName">
 package namespace or dll module file path
 </param>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.RInterpreter.LoadLibrary(System.Type)">
 <summary>
 Imports static api function from given package module
 </summary>
 <param name="package"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.RInterpreter.Add(System.String,System.Object,SMRUCC.Rsharp.Runtime.Components.TypeCodes)">
 <summary>
 Create a new symbol inside the R# runtime environment
 </summary>
 <param name="name$"></param>
 <param name="value"></param>
 <param name="type"></param>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.RInterpreter.Invoke(System.String,System.Object[])">
 <summary>
 direct invoke
 </summary>
 <param name="funcName">
 the function name, can be prefixed with the package namespace
 </param>
 <param name="args">
 the argument without names, this function will pass the
 argument value to target R# function directly with aligned 
 with the function argument list.
 </param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.RInterpreter.Invoke(System.String,Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedValue{System.Object}[])">
 <summary>
 invoke a R function by name
 </summary>
 <param name="funcName">the R function name</param>
 <param name="args">the named parameter list</param>
 <returns></returns>
 <remarks>
 the named parameter list will be aligned with the function 
 argument list and then do function invoke.
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.RInterpreter.Evaluate(System.String)">
 <summary>
 Run R# script program from text data.
 </summary>
 <param name="script">The script text</param>
 <returns></returns>
 
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.RInterpreter.InitializeEnvironment(System.String,Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedValue{System.Object}[])">
 <summary>
 
 </summary>
 <param name="source">The script file name</param>
 <param name="arguments"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.RInterpreter.RunInternal(SMRUCC.Rsharp.Runtime.Components.Rscript,Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedValue{System.Object}[],SMRUCC.Rsharp.Runtime.Environment@)">
 <summary>
 
 </summary>
 <param name="Rscript"></param>
 <param name="arguments">
 symbol values that will be pushed into the runtime environment context
 </param>
 <param name="globalEnvir"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.RInterpreter.Source(System.String,Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedValue{System.Object}[],SMRUCC.Rsharp.Runtime.Environment@)">
 <summary>
 Run R# script program from a given script file.
 (运行脚本的时候调用的是<see cref="P:SMRUCC.Rsharp.Interpreter.RInterpreter.globalEnvir"/>全局环境)
 </summary>
 <param name="filepath">The script file path.</param>
 <param name="arguments"></param>
 <returns></returns>
 
</member>
<member name="P:SMRUCC.Rsharp.Interpreter.RInterpreter.Rsharp">
 <summary>
 Default R# script interpreter which is created on the default environment.
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Interpreter.RInterpreter.FromEnvironmentConfiguration(System.String)">
 <summary>
 
 </summary>
 <param name="configs">
 the filepath of the configuration file
 </param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Language.Code.GetCodeSpan(System.Collections.Generic.IEnumerable{SMRUCC.Rsharp.Language.TokenIcer.Token})">
 <summary>
 For parse the raw script text
 </summary>
 <param name="code"></param>
 <returns></returns>
</member>
<member name="F:SMRUCC.Rsharp.Language.Syntax.Extensions.ignores">
 <summary>
 
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Language.Syntax.Extensions.GetExpressions(SMRUCC.Rsharp.Runtime.Components.Rscript,SMRUCC.Rsharp.Language.Syntax.SyntaxParser.SyntaxBuilderOptions)">
 <summary>
 从所输入的R脚本文本之中解析出语句表达式列表
 </summary>
 <param name="Rscript"></param>
 <param name="opts"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Language.Syntax.Extensions.GetExpressions(SMRUCC.Rsharp.Language.TokenIcer.Token[],System.Action{SMRUCC.Rsharp.Language.Syntax.SyntaxParser.SyntaxResult},SMRUCC.Rsharp.Language.Syntax.SyntaxParser.SyntaxBuilderOptions)">
 <summary>
 将单词化的R脚本文件解析为语句表达式列表
 </summary>
 <param name="tokens">R脚本单词</param>
 <param name="errHandler"></param>
 <param name="opts"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Language.Syntax.Helper.IsStringOpen(System.String,System.String@)">
 <summary>
 check current line input is string stack open?
 </summary>
 <param name="line"></param>
 <param name="string">get last open string part value</param>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Language.Syntax.IncompleteExpression">
 <summary>
 Helper for R shell terminal multiple line editing
 </summary>
</member>
<member name="P:SMRUCC.Rsharp.Language.Syntax.IncompleteExpression.Check">
 <summary>
 
 </summary>
 <returns>
 true means the script expression is in-complete
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Language.Syntax.IncompleteExpression.CheckTokenSequence(SMRUCC.Rsharp.Language.TokenIcer.Token[])">
 <summary>
 test the given line tokens is in-complete expression or not?
 </summary>
 <param name="tokens"></param>
 <returns></returns>
 <remarks>
 in-complete expression:
 
 1. ends with operator token
 2. bracket stack not closed
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Language.Syntax.IncompleteExpression.scanStackOpen(SMRUCC.Rsharp.Language.TokenIcer.Token[])">
 <summary>
 
 </summary>
 <param name="tokens"></param>
 <returns>
 returns true means the stack is opened
 </returns>
</member>
<member name="T:SMRUCC.Rsharp.Language.Syntax.SyntaxParser.SyntaxBuilderOptions">
 <summary>
 Syntax tree parser configuration
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Language.Syntax.SyntaxParser.SyntaxBuilderOptions.source">
 <summary>
 the source script text
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Language.Syntax.SyntaxParser.SyntaxBuilderOptions.keepsCommentLines">
 <summary>
 是否保留下来所有的单行注释信息
 </summary>
</member>
<member name="P:SMRUCC.Rsharp.Language.Syntax.SyntaxParser.SyntaxBuilderOptions.haveSyntaxErr">
 <summary>
 this property will returns true if the error message string is not empty
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Language.Syntax.SyntaxParser.SyntaxBuilderOptions.isPythonPipelineSymbol">
 <summary>
 operator of <see cref="F:SMRUCC.Rsharp.Language.Syntax.SyntaxParser.SyntaxBuilderOptions.pipelineSymbols"/> is ``.``?
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Language.Syntax.SyntaxParser.SyntaxImplements.ClosureExpressionSyntax.ClosureExpression(System.Collections.Generic.IEnumerable{SMRUCC.Rsharp.Language.TokenIcer.Token},SMRUCC.Rsharp.Language.Syntax.SyntaxParser.SyntaxBuilderOptions)">
 <summary>
 
 </summary>
 <param name="tokens">
 应该是去掉了最外层的``{}``的
 </param>
 <param name="opts"></param>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Language.Syntax.SyntaxParser.SyntaxImplements.CommandLineSyntax">
 <summary>
 Commandline shell syntax tree parser
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Language.Syntax.SyntaxParser.SyntaxImplements.CommandLineSyntax.isInterpolation(System.String)">
 <summary>
 Does the given text string contains the syntax of string interpolation?
 </summary>
 <param name="text"></param>
 <returns></returns>
 
</member>
<member name="F:SMRUCC.Rsharp.Language.Syntax.SyntaxParser.SyntaxImplements.ArgumentGetters.GetArgument">
 <summary>
 ?"--arg"
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Language.Syntax.SyntaxParser.SyntaxImplements.ArgumentGetters.GetArgumentWithDefault">
 <summary>
 ?"--arg" || default
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Language.Syntax.SyntaxParser.SyntaxImplements.ArgumentGetters.GetArgumentWithRequired">
 <summary>
 ?"--arg" || stop(xxx)
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Language.Syntax.SyntaxParser.SyntaxImplements.DeclareLambdaFunctionSyntax.DeclareLambdaFunction(SMRUCC.Rsharp.Interpreter.ExecuteEngine.Expression,SMRUCC.Rsharp.Interpreter.ExecuteEngine.Expression,System.Int32,SMRUCC.Rsharp.Language.Syntax.SyntaxParser.SyntaxBuilderOptions)">
 <summary>
 只允许拥有一个参数，并且只允许出现一行代码
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Language.Syntax.SyntaxParser.SyntaxImplements.DeclareLambdaFunctionSyntax.DeclareLambdaFunction(Microsoft.VisualBasic.Language.List{SMRUCC.Rsharp.Language.TokenIcer.Token[]},SMRUCC.Rsharp.Language.Syntax.SyntaxParser.SyntaxBuilderOptions)">
 <summary>
 只允许拥有一个参数，并且只允许出现一行代码
 </summary>
 <param name="tokens"></param>
</member>
<member name="M:SMRUCC.Rsharp.Language.Syntax.SyntaxParser.SyntaxImplements.DeclareNewFunctionSyntax.DeclareAnonymousFunction(Microsoft.VisualBasic.Language.List{SMRUCC.Rsharp.Language.TokenIcer.Token[]},SMRUCC.Rsharp.Language.Syntax.SyntaxParser.SyntaxBuilderOptions)">
 <summary>
 
 </summary>
 <param name="code">
 这个数组应该是有两个元素组成：
 
 1. function
 2. (...){...}
 </param>
 <param name="opts"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Language.Syntax.SyntaxParser.SyntaxImplements.DeclareNewSymbolSyntax.DeclareNewSymbol(Microsoft.VisualBasic.Language.List{SMRUCC.Rsharp.Language.TokenIcer.Token[]},System.Boolean,SMRUCC.Rsharp.Language.Syntax.SyntaxParser.SyntaxBuilderOptions)">
 <summary>
 const x as type = xxx
 </summary>
 <param name="code"></param>
 <param name="[readonly]"></param>
 <param name="opts"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Language.Syntax.SyntaxParser.SyntaxImplements.DeclareNewSymbolSyntax.DeclareNewSymbol(SMRUCC.Rsharp.Language.TokenIcer.Token[],SMRUCC.Rsharp.Language.Syntax.SyntaxParser.SyntaxBuilderOptions)">
 <summary>
 declare a parameter symbol
 </summary>
 <param name="singleToken"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Language.Syntax.SyntaxParser.SyntaxImplements.DeclareNewSymbolSyntax.DeclareNewSymbol(SMRUCC.Rsharp.Language.TokenIcer.Token[],SMRUCC.Rsharp.Language.TokenIcer.Token[],SMRUCC.Rsharp.Language.Syntax.SyntaxParser.SyntaxBuilderOptions,System.Boolean)">
 <summary>
 declare a new parameter with optional default value
 </summary>
 <param name="symbol"></param>
 <param name="value"></param>
 <param name="opts"></param>
 <param name="funcParameter"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Language.Syntax.SyntaxParser.SyntaxImplements.DeclareNewSymbolSyntax.getNames(SMRUCC.Rsharp.Language.TokenIcer.Token[],SMRUCC.Rsharp.Language.Syntax.SyntaxParser.SyntaxBuilderOptions)">
 <summary>
 get tuple names or a single symbol name
 </summary>
 <param name="code"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Language.Syntax.SyntaxParser.SyntaxImplements.FunctionInvokeSyntax.FunctionInvoke(SMRUCC.Rsharp.Language.TokenIcer.Token[],SMRUCC.Rsharp.Language.Syntax.SyntaxParser.SyntaxBuilderOptions)">
 <summary>
 
 </summary>
 <param name="tokens">scan0 is the name target</param>
 <param name="opts"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Language.Syntax.SyntaxParser.SyntaxImplements.IfBranchSyntax.ElseClosure(SMRUCC.Rsharp.Language.TokenIcer.Token[],SMRUCC.Rsharp.Language.Syntax.SyntaxParser.SyntaxBuilderOptions)">
 <summary>
 + else ...
 + else {...}
 + else if () ...
 </summary>
 <param name="code"></param>
 <param name="opts"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Language.Syntax.SyntaxParser.SyntaxImplements.LinqExpressionSyntax.LinqExpression(Microsoft.VisualBasic.Language.List{SMRUCC.Rsharp.Language.TokenIcer.Token[]},SMRUCC.Rsharp.Language.Syntax.SyntaxParser.SyntaxBuilderOptions)">
 <summary>
 produce a <see cref="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.DataSets.LinqQuery"/>
 </summary>
 <param name="tokens"></param>
 <param name="opts"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Language.Syntax.SyntaxParser.SyntaxImplements.SymbolIndexerSyntax.SymbolIndexer(SMRUCC.Rsharp.Interpreter.ExecuteEngine.Expression,SMRUCC.Rsharp.Language.TokenIcer.Token[],SMRUCC.Rsharp.Language.Syntax.SyntaxParser.SyntaxBuilderOptions)">
 <summary>
 Simple indexer
 </summary>
 <param name="tokens">
 ``a[x]``
 </param>
 
</member>
<member name="M:SMRUCC.Rsharp.Language.Syntax.SyntaxParser.SyntaxImplements.SymbolIndexerSyntax.SymbolIndexer(SMRUCC.Rsharp.Language.TokenIcer.Token[],SMRUCC.Rsharp.Language.Syntax.SyntaxParser.SyntaxBuilderOptions)">
 <summary>
 Simple indexer
 </summary>
 <param name="tokens">
 ``a[x]``
 </param>
</member>
<member name="M:SMRUCC.Rsharp.Language.Syntax.SyntaxParser.SyntaxImplements.SymbolIndexerSyntax.SymbolIndexer(SMRUCC.Rsharp.Language.TokenIcer.Token[],SMRUCC.Rsharp.Language.TokenIcer.Token[],SMRUCC.Rsharp.Language.Syntax.SyntaxParser.SyntaxBuilderOptions)">
 <summary>
 Complex indexer
 
 ```
 func(...)[x]
 func(...)[[x]]
 ```
 </summary>
 <param name="ref"></param>
 <param name="indexer"></param>
</member>
<member name="M:SMRUCC.Rsharp.Language.Syntax.SyntaxParser.SyntaxImplements.SymbolIndexerSyntax.parseDataframeIndex(Microsoft.VisualBasic.Language.List{SMRUCC.Rsharp.Language.TokenIcer.Token[]},SMRUCC.Rsharp.Language.Syntax.SyntaxParser.SyntaxResult@,SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.DataSets.SymbolIndexers@,SMRUCC.Rsharp.Language.Syntax.SyntaxParser.SyntaxBuilderOptions)">
 <summary>
 dataframe indexer
 </summary>
 <param name="blocks"></param>
 <param name="index"></param>
 <param name="indexType"></param>
</member>
<member name="M:SMRUCC.Rsharp.Language.Syntax.SyntaxParser.SyntaxImplements.VectorLiteralSyntax.TypeCodeOf(System.Collections.Generic.IEnumerable{SMRUCC.Rsharp.Interpreter.ExecuteEngine.Expression})">
 <summary>
 get type code value of the vector literal 
 </summary>
 <param name="values"></param>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Language.Syntax.SyntaxParser.SyntaxResult">
 <summary>
 The R# expression syntax build result, the result of this 
 model could be an error or resulted expression model 
 object. 
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Language.Syntax.SyntaxParser.SyntaxResult.expression">
 <summary>
 the successful parsed expression model.
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Language.Syntax.SyntaxParser.SyntaxResult.stackTrace">
 <summary>
 the .NET stacktrace in R# interpreter
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Language.Syntax.SyntaxParser.SyntaxResult.CreateError(System.String,SMRUCC.Rsharp.Language.Syntax.SyntaxParser.SyntaxBuilderOptions)">
 <summary>
 Create syntax error on current script file code span
 </summary>
 <param name="err"></param>
 <param name="opts"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Language.Syntax.SyntaxParser.SyntaxResult.CreateError(SMRUCC.Rsharp.Language.Syntax.SyntaxParser.SyntaxBuilderOptions,System.Exception,Microsoft.VisualBasic.Scripting.TokenIcer.CodeSpan,Microsoft.VisualBasic.Scripting.TokenIcer.CodeSpan)">
 <summary>
 create a syntax error
 </summary>
 <param name="opts"></param>
 <param name="err"></param>
 <param name="from">The code span of line start where the syntax error occurs</param>
 <param name="to">the code span of line ends where the syntax error occurs</param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Language.Syntax.SyntaxParser.SyntaxResult.op_Like(SMRUCC.Rsharp.Language.Syntax.SyntaxParser.SyntaxResult,System.Type)">
 <summary>
 check of the <see cref="F:SMRUCC.Rsharp.Language.Syntax.SyntaxParser.SyntaxResult.expression"/> type
 </summary>
 <param name="syntax"></param>
 <param name="type"></param>
 <returns></returns>
</member>
<member name="F:SMRUCC.Rsharp.Language.Syntax.SyntaxParser.BinaryExpressionTree.operatorPriority">
 <summary>
 the math operators
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Language.Syntax.SyntaxParser.BinaryExpressionTree.joinNegatives(Microsoft.VisualBasic.Language.List{SMRUCC.Rsharp.Language.TokenIcer.Token[]},Microsoft.VisualBasic.Language.List{Microsoft.VisualBasic.Language.Variant{SMRUCC.Rsharp.Language.Syntax.SyntaxParser.SyntaxResult,System.String}}@,Microsoft.VisualBasic.Language.List{System.String}@,SMRUCC.Rsharp.Language.Syntax.SyntaxParser.SyntaxBuilderOptions)">
 <summary>
 
 </summary>
 <param name="tokenBlocks"></param>
 <param name="buf"></param>
 <param name="oplist"></param>
 <param name="opts"></param>
 <returns>
 returns error message
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Language.Syntax.SyntaxParser.BinaryExpressionTree.ParseInvokeInternal(SMRUCC.Rsharp.Language.TokenIcer.Token[],Microsoft.VisualBasic.Language.List{Microsoft.VisualBasic.Language.Variant{SMRUCC.Rsharp.Language.Syntax.SyntaxParser.SyntaxResult,System.String}}@,SMRUCC.Rsharp.Language.Syntax.SyntaxParser.SyntaxBuilderOptions@)">
 <summary>
 
 </summary>
 <param name="list">always wrap with brackets ()</param>
 <param name="buf"></param>
 <param name="opts"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Language.Syntax.SyntaxParser.BinaryExpressionTree.ProcessOperators(Microsoft.VisualBasic.Language.List{Microsoft.VisualBasic.Language.Variant{SMRUCC.Rsharp.Language.Syntax.SyntaxParser.SyntaxResult,System.String}},Microsoft.VisualBasic.Language.List{System.String},System.String[],System.Func{System.String,System.String,System.Boolean},SMRUCC.Rsharp.Language.Syntax.SyntaxParser.SyntaxBuilderOptions)">
 <summary>
 
 </summary>
 <param name="buf">
 a token list for process the operators, this list input value
 may be changed after the operator scanning in this function
 </param>
 <param name="oplist"></param>
 <param name="operators">A set of the operators</param>
 <param name="test">test(op, o)</param>
 <returns>
 this function returns the syntax error if some syntax error has been found,
 otherwise returns nothing if has no error!
 </returns>
 <remarks>
 the expression change is generated via the <paramref name="buf"/> parameter
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Language.Syntax.SyntaxParser.BinaryExpressionTree.CreateBinary(SMRUCC.Rsharp.Interpreter.ExecuteEngine.Expression,SMRUCC.Rsharp.Interpreter.ExecuteEngine.Expression,System.String,SMRUCC.Rsharp.Language.Syntax.SyntaxParser.SyntaxBuilderOptions)">
 <summary>
 
 </summary>
 <param name="a">the left</param>
 <param name="b">the right</param>
 <param name="opToken">the operator</param>
 <param name="opts"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Language.Syntax.SyntaxParser.ExpressionBuilder.parseInvoke(Microsoft.VisualBasic.Language.List{SMRUCC.Rsharp.Language.TokenIcer.Token[]},SMRUCC.Rsharp.Language.Syntax.SyntaxParser.SyntaxBuilderOptions)">
 <summary>
 a(...)
 </summary>
 <param name="code">code block with 2 elements</param>
 <param name="opts"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Language.Syntax.SyntaxParser.ExpressionBuilder.parseSymbolIndex(Microsoft.VisualBasic.Language.List{SMRUCC.Rsharp.Language.TokenIcer.Token[]},SMRUCC.Rsharp.Language.Syntax.SyntaxParser.SyntaxBuilderOptions)">
 <summary>
 a[...]
 </summary>
 <param name="code"></param>
 <param name="opts"></param>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Language.Syntax.SyntaxParser.ExpressionSignature">
 <summary>
 The signature determination of the given expression tokens 
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Language.Syntax.SyntaxParser.ExpressionSignature.lambdaOperator">
 <summary>
 -> orelse =>
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Language.Syntax.SyntaxParser.ExpressionSignature.isLambdaFunction(Microsoft.VisualBasic.Language.List{SMRUCC.Rsharp.Language.TokenIcer.Token[]})">
 <summary>
 The given code tokens is a lambda function?
 
 x -> ...
 </summary>
 <param name="code"></param>
 <returns></returns>
 
</member>
<member name="M:SMRUCC.Rsharp.Language.Syntax.SyntaxParser.ExpressionSignature.isLambdaFunction(Microsoft.VisualBasic.Language.Variant{SMRUCC.Rsharp.Interpreter.ExecuteEngine.Expression,System.String}[])">
 <summary>
 The given code tokens is a lambda function?
 
 x -> ...
 </summary>
 <param name="code"></param>
 <returns></returns>
 
</member>
<member name="M:SMRUCC.Rsharp.Language.Syntax.SyntaxParser.ExpressionSignature.isFunctionInvoke(SMRUCC.Rsharp.Language.TokenIcer.Token[])">
 <summary>
 XXX(YYY)
 </summary>
 <param name="tokens"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Language.Syntax.SyntaxParser.ExpressionSignature.isTuple(SMRUCC.Rsharp.Language.TokenIcer.Token[])">
 <summary>
 [x,y,z]
 </summary>
 <param name="tokens"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Language.Syntax.SyntaxParser.ExpressionSignature.isComma(SMRUCC.Rsharp.Language.TokenIcer.Token[])">
 <summary>
 length is 1 and also the token is comma
 </summary>
 <param name="tokens"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Language.Syntax.SyntaxParser.ExpressionSignature.isLiteral(SMRUCC.Rsharp.Language.TokenIcer.Token[],SMRUCC.Rsharp.Language.TokenType)">
 <summary>
 XXX
 </summary>
 <param name="tokens"></param>
 <param name="type"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Language.Syntax.SyntaxParser.ExpressionSignature.isIdentifier(SMRUCC.Rsharp.Language.TokenIcer.Token[])">
 <summary>
 XXX
 </summary>
 <param name="tokens"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Language.Syntax.SyntaxParser.ExpressionSignature.isKeyword(SMRUCC.Rsharp.Language.TokenIcer.Token,System.String)">
 <summary>
 XXX
 </summary>
 <param name="token"></param>
 <param name="keyword"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Language.Syntax.SyntaxParser.ExpressionSignature.isKeyword(SMRUCC.Rsharp.Language.TokenIcer.Token[],System.String)">
 <summary>
 XXX
 </summary>
 <param name="tokens"></param>
 <param name="keyword$"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Language.Syntax.SyntaxParser.ExpressionSignature.isOneOfKeywords(SMRUCC.Rsharp.Language.TokenIcer.Token[],System.String[])">
 <summary>
 XXX
 </summary>
 <param name="tokens"></param>
 <param name="keywords"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Language.Syntax.SyntaxParser.ExpressionSignature.isOperator(SMRUCC.Rsharp.Language.TokenIcer.Token[],System.String[])">
 <summary>
 *
 </summary>
 <param name="tokens"></param>
 <param name="operators"></param>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Language.TokenIcer.Escapes">
 <summary>
 common language escape model between multiple language syntax parser
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Language.TokenIcer.Escapes.isBlockComment">
 <summary>
 apply for the block comment in other language parser, example as:
 
 1. javascript/typescript 
 
 /**
  *
  *
 */
 
 2. matlab/octave language
 
 %{
 ...
 %}
 </summary>
</member>
<member name="T:SMRUCC.Rsharp.Language.TokenIcer.IScanner">
 <summary>
 An abstract script text tokenlicer
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Language.TokenIcer.IScanner.GetTokens">
 <summary>
 parse the given script text as language tokens
 </summary>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Language.TokenIcer.Scanner">
 <summary>
 The token scanner
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Language.TokenIcer.Scanner.lineNumber">
 <summary>
 当前的代码行号
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Language.TokenIcer.Scanner.keepsDelimiter">
 <summary>
 keeps the blankspace, cr, lf, tab as the delimiter/expression terminator
 could be used for parse the typescript,javascript,python
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Language.TokenIcer.Scanner.dollarAsSymbol">
 <summary>
 use the dollar symbol $ as symbol name?
 
 set false for R# language by default, and should turn on this option for 
 javascript/typescript language parser.
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Language.TokenIcer.Scanner.#ctor(Microsoft.VisualBasic.Language.Variant{System.String,Microsoft.VisualBasic.Text.Parser.CharPtr},System.Boolean,System.Boolean)">
 <summary>
 construct a r language token scanner
 </summary>
 <param name="source"></param>
 <param name="tokenStringMode"></param>
 <param name="keepsDelimiter"></param>
</member>
<member name="M:SMRUCC.Rsharp.Language.TokenIcer.Scanner.finalizeToken(SMRUCC.Rsharp.Language.TokenIcer.Token,System.Int32@)">
 <summary>
 Add stack trace and then try to reset the escape status
 </summary>
 <param name="token"></param>
 <param name="start%"></param>
 <returns></returns>
</member>
<member name="F:SMRUCC.Rsharp.Language.TokenIcer.Scanner.longOperatorParts">
 <summary>
 这里的操作符都是需要多个字符构成的，例如
 
 + &lt;- 
 + &lt;=
 + &lt;&lt;
 + :>
 + =>
 + &amp;&amp;
 + ||
 + ==
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Language.TokenIcer.Scanner.RSymbol">
 <summary>
 .128MB
 _
 .
 ...
 _128MB
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Language.TokenIcer.Scanner.populateToken(System.Nullable{System.Char})">
 <summary>
 这个函数的调用会将<see cref="F:SMRUCC.Rsharp.Language.TokenIcer.Scanner.buffer"/>清空
 </summary>
 <param name="bufferNext">
 这个参数是为了诸如 || 或者 &lt;- 此类需要两个字符构成的操作符的解析而设定的
 当这个参数不是空的时候，会在清空buffer之后将这个字符添加进入buffer，解决双字符的操作符的解析的问题
 </param>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Language.TokenIcer.StringInterpolation">
 <summary>
 The string interpolation expression token parser
 </summary>
</member>
<member name="T:SMRUCC.Rsharp.Language.TokenIcer.Token">
 <summary>
 the R# language token word
 </summary>
</member>
<member name="P:SMRUCC.Rsharp.Language.TokenIcer.Token.literal">
 <summary>
 get the literal value of current token text represented.
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Language.TokenIcer.Token.isLiteral">
 <summary>
 is value literal of current token type?
 </summary>
 <returns>
 this property returns true, if the token type <see cref="P:Microsoft.VisualBasic.Scripting.TokenIcer.CodeToken`1.name"/> is one of the value:
 
 + <see cref="F:SMRUCC.Rsharp.Language.TokenType.booleanLiteral"/>
 + <see cref="F:SMRUCC.Rsharp.Language.TokenType.integerLiteral"/>
 + <see cref="F:SMRUCC.Rsharp.Language.TokenType.missingLiteral"/>
 + <see cref="F:SMRUCC.Rsharp.Language.TokenType.numberLiteral"/>
 + <see cref="F:SMRUCC.Rsharp.Language.TokenType.stringLiteral"/>
 </returns>
</member>
<member name="P:SMRUCC.Rsharp.Language.TokenLine.length">
 <summary>
 the size of the <see cref="P:SMRUCC.Rsharp.Language.TokenLine.tokens"/> array
 </summary>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Language.TokenType">
 <summary>
 Language syntax token types
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Language.TokenType.invalid">
 <summary>
 Syntax error
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Language.TokenType.newLine">
 <summary>
 cr/lf
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Language.TokenType.delimiter">
 <summary>
 &lt;whitespace> and &lt;TAB> as delimiter
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Language.TokenType.annotation">
 <summary>
 类似于在VisualBasic中的自定义属性的注解语法
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Language.TokenType.terminator">
 <summary>
 必须要使用``;``作为表达式的结束分隔符
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Language.TokenType.sequence">
 <summary>
 :
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Language.TokenType.iif">
 <summary>
 ?
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Language.TokenType.stringInterpolation">
 <summary>
 字符串插值语法，与javascript脚本之中的字符串插值保持一致
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Language.TokenType.cliShellInvoke">
 <summary>
 命令行调用语法
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Language.TokenType.missingLiteral">
 <summary>
 NULL, NA, Inf
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Language.TokenType.open">
 <summary>
 左边的括号与大括号
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Language.TokenType.close">
 <summary>
 右边的括号与大括号
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Language.TokenType.lineContinue">
 <summary>
 ... line continue token for matlab/octave language
 </summary>
</member>
<member name="T:SMRUCC.Rsharp.LICENSE">
 <summary>
 Information about the ``R#`` interpreter code module.
 </summary>
</member>
<member name="P:SMRUCC.Rsharp.LICENSE.GPL3">
<summary>
  Looks up a localized string similar to                     GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. &lt;http://fsf.org/&gt;
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away yo [rest of string was truncated]&quot;;.
</summary>
</member>
<member name="M:SMRUCC.Rsharp.LICENSE.GithubRepository">
 <summary>
 https://github.com/SMRUCC/R-sharp
 </summary>
 
</member>
<member name="T:SMRUCC.Rsharp.Runtime.ClosureEnvironment">
 <summary>
 A local environment of the function closure
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.ClosureEnvironment.FindSymbol(System.String,System.Boolean)">
 <summary>
 find in closure internal context at first 
 and then find on the parent context
 </summary>
 <param name="name"></param>
 <param name="[inherits]"></param>
 <returns>
 this function returns nothing if the target symbol 
 is not found in the environment context
 </returns>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.OutputEnvironments">
 <summary>
 A enum flag value for indicates the console output device: standard output or html display
 </summary>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.RContentOutput">
 <summary>
 R# I/O redirect and interface for Rserve http server
 </summary>
 <remarks>
 a <see cref="T:System.IO.TextWriter"/> sub class object.
 </remarks>
</member>
<member name="F:SMRUCC.Rsharp.Runtime.RContentOutput.stdout">
 <summary>
 usually be the console standard output 
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Runtime.RContentOutput.logfile">
 <summary>
 save the print content to the *.log local file
 </summary>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.RContentOutput.isLogOpen">
 <summary>
 check of the <see cref="F:SMRUCC.Rsharp.Runtime.RContentOutput.logfile"/> which is opened by <see cref="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.base.sink(System.String,System.Boolean,System.Boolean,System.Boolean,SMRUCC.Rsharp.Runtime.Environment)"/> function is existed or not?
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.RContentOutput.openSink(System.String,System.Boolean,System.Boolean)">
 <summary>
 open a new log file session
 </summary>
 <param name="logfile"></param>
 <param name="split"></param>
 <param name="append"></param>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.RContentOutput.LoggingDriver(System.String,System.String,Microsoft.VisualBasic.ApplicationServices.Debugging.Logging.MSG_TYPES)">
 <summary>
 just write the message text data
 </summary>
 <param name="header$"></param>
 <param name="message$"></param>
 <param name="level"></param>
 <remarks>
 use <see cref="F:Microsoft.VisualBasic.Constants.vbBack"/> for indicates that use the write function instead of writeline.
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.RContentOutput.WriteLine(System.String)">
 <summary>
 Writes a string followed by a line terminator to the text string or stream.
 </summary>
 <param name="message">
 The string to write. If value is null, only the line terminator is written.
 </param>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.RContentOutput.Write(System.String,System.String)">
 <summary>
 xml/json/csv, etc...
 </summary>
 <param name="message"></param>
 <param name="content_type$"></param>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Environment">
 <summary>
 A ``R#`` scripting runtime context.
 </summary>
 <remarks>
 (在一个环境对象容器之中，所有的对象都是以变量来表示的)
 </remarks>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Environment.parent">
 <summary>
 最顶层的closure环境的parent是空值来的
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Environment.stackFrame">
 <summary>
 The name of this current stack closure.(R function name, closure id, etc)
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Environment.stackTrace">
 <summary>
 <see cref="M:SMRUCC.Rsharp.Runtime.Internal.debug.getEnvironmentStack(SMRUCC.Rsharp.Runtime.Environment)"/>
 </summary>
 <returns>
 from current stack to top stack
 </returns>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Environment.funcSymbols">
 <summary>
 导入的函数列表
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Environment.messages">
 <summary>
 主要是存储警告消息
 </summary>
 <returns></returns>
 <remarks>
 A collection of the warning message
 </remarks>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Environment.globalEnvironment">
 <summary>
 the global environment
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Environment.last">
 <summary>
 get value of the special last variable in R# <see cref="T:SMRUCC.Rsharp.Runtime.Environment"/>
 </summary>
 <returns></returns>
</member>
<member name="F:SMRUCC.Rsharp.Runtime.Environment.global">
 <summary>
 In the constructor function of <see cref="T:SMRUCC.Rsharp.Runtime.GlobalEnvironment"/>, 
 require attach itself to this parent field
 So this parent field should not be readonly
 </summary>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Environment.isGlobal">
 <summary>
 It is the top level global environment?
 </summary>
 <returns></returns>
 <remarks>
 (当前的环境是否为最顶层的全局环境？)
 </remarks>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Environment.value(System.String)">
 <summary>
 Get/set variable value
 </summary>
 <param name="name"></param>
 <returns>
 getter of this property is a wrapper of function <see cref="M:SMRUCC.Rsharp.Runtime.Environment.FindSymbol(System.String,System.Boolean)"/>,
 and the setter of this property is a wrapper of visit data table <see cref="F:SMRUCC.Rsharp.Runtime.Environment.symbols"/>.
 </returns>
 <remarks>
 If the current stack does not contains the target variable, then the program will try 
 to find the variable in his parent.
 
 if variable in format like [var], then it means a global or parent environment variable
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Environment.#ctor">
 <summary>
 run environment initialize:
 
 1. <see cref="F:SMRUCC.Rsharp.Runtime.Environment.symbols"/>
 2. <see cref="F:SMRUCC.Rsharp.Runtime.Environment.hiddenFunctions"/>
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Environment.#ctor(SMRUCC.Rsharp.Runtime.Environment,System.String,System.Collections.Generic.IEnumerable{SMRUCC.Rsharp.Runtime.Components.Symbol},System.Collections.Generic.IEnumerable{SMRUCC.Rsharp.Runtime.Components.Symbol})">
 <summary>
 context constructor for parallel task
 </summary>
 <param name="parent"></param>
 <param name="stackName"></param>
 <param name="symbols"></param>
 <param name="funcs"></param>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Environment.#ctor(SMRUCC.Rsharp.Runtime.Environment,System.String,System.Boolean)">
 <param name="isInherits">
 If is inherits mode, then all of the modification in sub-environment will affects the <paramref name="parent"/> environment.
 Otherwise, the modification in sub-environment will do nothing to the <paramref name="parent"/> environment.
 </param>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Environment.#ctor(SMRUCC.Rsharp.Runtime.Environment,Microsoft.VisualBasic.ApplicationServices.Debugging.Diagnostics.StackFrame,System.Boolean,System.Boolean)">
 <summary>
 Create a new runtime environment context
 </summary>
 <param name="parent"></param>
 <param name="stackFrame"></param>
 <param name="isInherits">
 If is inherits mode, then all of the modification in sub-environment will affects the <paramref name="parent"/> environment.
 Otherwise, the modification in sub-environment will do nothing to the <paramref name="parent"/> environment.
 </param>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Environment.GetSymbolsNames">
 <summary>
 get all variable symbol names(function symbol is not included)
 </summary>
 <returns></returns>
 
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Environment.GetValue(System.String,System.Object)">
 <summary>
 Try to get value of the specific symbol
 </summary>
 <param name="name"></param>
 <returns>
 this function returns nothing by default if the symbol is missing in the environment context
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Environment.WriteLineHandler">
 <summary>
 a shortcut wrapper function pointer for 
 <see cref="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.base.print(System.Object,SMRUCC.Rsharp.Runtime.Internal.Object.list,SMRUCC.Rsharp.Runtime.Environment)"/> 
 </summary>
 <returns></returns>
 
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Environment.AddMessage(System.Object,Microsoft.VisualBasic.ApplicationServices.Debugging.Logging.MSG_TYPES)">
 <summary>
 add error/warning message
 </summary>
 <param name="message"></param>
 <param name="level"></param>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Environment.AddMessage(SMRUCC.Rsharp.Runtime.Components.Message)">
 <summary>
 add error/warning message
 </summary>
 <param name="msg"></param>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Environment.setStackInfo(Microsoft.VisualBasic.ApplicationServices.Debugging.Diagnostics.StackFrame)">
 <summary>
 replace current stackframe information
 </summary>
 <param name="stackframe"></param>
 <remarks>
 this method used for the internal R# loop, example like for loop/apply loop, etc
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Environment.FindSymbol(System.String,System.Boolean)">
 <summary>
 这个函数查找失败的时候只会返回空值
 </summary>
 <param name="name"></param>
 <param name="inherits">
 andalso look into the parent environment for the target symbol by <paramref name="name"/>?
 </param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Environment.FindFunction(System.String,System.Boolean)">
 <summary>
 会首先在当前环境中的符号列表查找函数，如果不是函数则会在当前环境的函数列表中查找
 如果当前环境中不存在，则会在父环境中查找符号
 </summary>
 <param name="name"></param>
 <param name="[inherits]"></param>
 <returns>
 returns nothing if symbol not found
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Environment.Delete(System.String,System.Boolean)">
 <summary>
 just removes the symbol reference in the runtime environment
 </summary>
 <param name="name">
 target symbol name that will be removes 
 from the current environment context.
 </param>
 <param name="seekParent">
 andalso removes the symbol with the same name in any parent environment context?
 (是否将任意环境路径中的目标符号引用进行删除？)
 </param>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Environment.AssignSymbol(System.String,System.Object,System.Boolean)">
 <summary>
 do value assign
 </summary>
 <param name="name"></param>
 <param name="value"></param>
 <param name="strict">
 create a new symbol automatically if target symbol <paramref name="name"/> 
 is not exists in current environment context? otherwise this function will 
 populate an error message if this parameter value is config as false by 
 default.
 </param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Environment.Push(System.String,System.Object,System.Boolean,SMRUCC.Rsharp.Runtime.Components.TypeCodes,System.Boolean)">
 <summary>
 Variable declare, just add a new symbol in current environment context.
 </summary>
 <param name="name"></param>
 <param name="value"></param>
 <param name="mode"></param>
 <param name="overrides">
 enable overrides the constant symbol which is in status of lock binding? 
 </param>
 <returns>返回错误消息或者对象值</returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Environment.asRVector(SMRUCC.Rsharp.Runtime.Components.TypeCodes,System.Object)">
 <summary>
 
 </summary>
 <param name="type"></param>
 <param name="value">
 应该是确保这个变量值是非空的
 </param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Environment.EnumerateAllFunctions(System.Boolean)">
 <summary>
 get all function symbols based on the environment context lineage to the root environment
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Environment.EnumerateAllSymbols(System.Boolean)">
 <summary>
 get all symbols based on the environment context lineage to the root environment
 </summary>
 <returns>
 not includes the function symbols
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Environment.GetEnumerator">
 <summary>
 get all symbols in current environment context 
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Environment.PushEnvironmentContext(SMRUCC.Rsharp.Runtime.Environment,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 add all of the data symbols from <paramref name="parent"/> to <paramref name="join"/>.
 </summary>
 <param name="join"></param>
 <param name="parent"></param>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Environment.op_Concatenate(SMRUCC.Rsharp.Runtime.Environment,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 join two runtime environment, this function works for
 the function closure environment setup initialization.
 </summary>
 <param name="closure"></param>
 <param name="parent"></param>
 <returns></returns>
 <remarks>
 this operator procedure calls may lock all of the parent 
 environment context chain in parallel context
 </remarks>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.GlobalEnvironment">
 <summary>
 the global environment of the R# interpreter runtime. 
 </summary>
 <remarks>
 R#之中的全局环境对象
 </remarks>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.GlobalEnvironment.polyglot">
 <summary>
 Enable programming in multiple kind of programming language
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.GlobalEnvironment.Rscript">
 <summary>
 the R# script host object
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.GlobalEnvironment.stdout">
 <summary>
 a <see cref="T:System.IO.TextWriter"/> wrapper object
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.GlobalEnvironment.debugMode">
 <summary>
 <see cref="P:SMRUCC.Rsharp.Interpreter.RInterpreter.debug"/>
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.GlobalEnvironment.lastException">
 <summary>
 用于traceback进行脚本函数调试使用
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.GlobalEnvironment.scriptDir">
 <summary>
 if current executation is comes from the R script executation
 then this property will returns the directory path in the ``!script``
 magic symbol object, otherwise will returns nothing
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.GlobalEnvironment.#ctor(SMRUCC.Rsharp.Runtime.GlobalEnvironment,SMRUCC.Rsharp.Interpreter.RInterpreter)">
 <summary>
 copy environment
 </summary>
 <param name="globalEnv"></param>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.GlobalEnvironment.GetResourceFile(System.String,System.String)">
 <summary>
 ``system.file`` export to clr function for get the package data file
 </summary>
 <param name="resource"></param>
 <param name="package"></param>
 <returns>
 the full file path of the package internal resource data file
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.GlobalEnvironment.doCall(System.String,Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedValue{System.Object}[])">
 <summary>
 invoke a R function by name
 </summary>
 <param name="func">the R function name</param>
 <param name="args">the named parameter list</param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.GlobalEnvironment.GetType(System.Object)">
 <summary>
 get type definition from a given type object or type name
 </summary>
 <param name="typeof">
 the object type value, and it should be one of the:
 
 1. class name from the <see cref="T:SMRUCC.Rsharp.Runtime.Interop.RTypeExportAttribute"/>
 2. .NET CLR <see cref="T:System.Type"/> value
 3. R-sharp <see cref="T:SMRUCC.Rsharp.Runtime.Interop.RType"/> value
 4. R-sharp primitive <see cref="T:SMRUCC.Rsharp.Runtime.Components.TypeCodes"/> value
 5. <see cref="T:Microsoft.VisualBasic.Scripting.MetaData.TypeInfo"/> metadata
 </param>
 <returns>
 this function returns nothing if the given
 <paramref name="typeof"/> type information is nothing 
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.GlobalEnvironment.LoadLibrary(System.String,System.Boolean,System.Boolean)">
 <summary>
 load library module
 </summary>
 <param name="packageName">the library package name</param>
 <param name="silent">quietly option, suppress of print message?</param>
 <param name="ignoreMissingStartupPackages">debug used only</param>
 <returns>
 this function returns an error message object instance if
 load package error, otherwise returns nothing means load 
 the required package correctly.
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.GlobalEnvironment.LoadLibrary(System.Type,System.String,System.Boolean)">
 <summary>
 Imports static api function from given package module
 </summary>
 <param name="package"></param>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.ObjectEnvironment">
 <summary>
 helper for object with syntax implements
 </summary>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.ObjectEnvironment.value(System.String)">
 <summary>
 
 </summary>
 <param name="name"></param>
 <returns></returns>
 <remarks>
 优先应用对象的成员
 </remarks>
</member>
<member name="F:SMRUCC.Rsharp.Runtime.ObjectEnvironment.target">
 <summary>
 target object
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.ObjectEnvironment.FindSymbol(System.String,System.Boolean)">
 <summary>
 
 </summary>
 <param name="name"></param>
 <param name="[inherits]"></param>
 <returns></returns>
 <remarks>
 优先应用对象的成员
 </remarks>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.PackageEnvironment">
 <summary>
 The package namespace
 </summary>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.PackageEnvironment.libpath">
 <summary>
 the package directory path that would be used for:
 
 1. config for load .NET assembly module files
 2. get resource files inside the package
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.PackageEnvironment.AddSymbols(System.Collections.Generic.IEnumerable{SMRUCC.Rsharp.Runtime.Components.Interface.RFunction})">
 <summary>
 handling of the function overloads between difference package namespace.
 </summary>
 <param name="symbols"></param>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.PolyglotInteropEnvironment">
 <summary>
 symbols solver for javascript/python reference to R# object
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.PolyglotInteropEnvironment.hook_jsEnv(System.Type[])">
 <summary>
 construct the interop object for javascript/python
 </summary>
 <param name="libs"></param>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.SymbolNamespaceSolver">
 <summary>
 Package namespace environment
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Runtime.SymbolNamespaceSolver.funcOverloads">
 <summary>
 an overrloads of [func_name => [namespace => func]]
 </summary>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.SymbolNamespaceSolver.GetNamespace(System.String)">
 <summary>
 get namespace by a given package name
 </summary>
 <param name="ref"></param>
 <returns>returns nothing if the given package name is not existed in current environment</returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.SymbolNamespaceSolver.FindNamespace(System.String)">
 <summary>
 find all namespace that contains the given symbol
 </summary>
 <param name="name"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.SymbolNamespaceSolver.hasNamespace(System.String)">
 <summary>
 check of the given package <paramref name="pkgName"/> has already
 been attached into the global environment or not?
 </summary>
 <param name="pkgName"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.SymbolNamespaceSolver.Add(SMRUCC.Rsharp.Development.Package.File.PackageNamespace)">
 <summary>
 attach a R# zip/project folder source package
 </summary>
 <param name="[namespace]"></param>
 <returns></returns>
 <remarks>
 20221126 due to the reason of zip/source folder package 
 its directory path is required for loading the internal 
 .NET assembly file, so we needs to overrides the old
 package module at here?
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.SymbolNamespaceSolver.Add(System.String,System.String)">
 <summary>
 add a package module from a given .NET assembly file
 </summary>
 <param name="pkgName">
 the name of the package module inside a .NET dll file
 </param>
 <param name="libdll">
 the file path of the target .NET dll file
 </param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.SymbolNamespaceSolver.FindSymbol(System.String,System.String)">
 <summary>
 find a symbol by its name and under the specific namespace
 </summary>
 <param name="namespace">the package namespace</param>
 <param name="symbolName">the target symbol its name</param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.SymbolNamespaceSolver.FindPackageSymbol(System.String,System.String,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 load symbol via search of the manifest in package 
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.SymbolNamespaceSolver.ToString">
 <summary>
 gets all attached namespace list in json string array format.
 </summary>
 <returns></returns>
 
</member>
<member name="M:SMRUCC.Rsharp.Runtime.SymbolNamespaceSolver.GetEnumerator">
 <summary>
 enumerates the <see cref="T:SMRUCC.Rsharp.Runtime.PackageEnvironment"/> inside the current <see cref="P:SMRUCC.Rsharp.Runtime.SymbolNamespaceSolver.attachedNamespace"/>
 </summary>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.SymbolSet">
 <summary>
 A pool set of the R# runtime symbols
 </summary>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.SymbolSet.SymbolNames">
 <summary>
 get all variable symbol names inside current symbol list
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.SymbolSet.#ctor(SMRUCC.Rsharp.Runtime.SymbolSet)">
 <summary>
 make symbol list copy
 </summary>
 <param name="copy"></param>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.SymbolSet.CheckSymbolExists(System.String)">
 <summary>
 Check of the given symbol name is existsed inside current symbols collection
 </summary>
 <param name="name"></param>
 <returns></returns>
 
</member>
<member name="M:SMRUCC.Rsharp.Runtime.SymbolSet.Add(SMRUCC.Rsharp.Runtime.Components.Symbol)">
 <summary>
 Add a new symbol into current symbol list
 </summary>
 <param name="symbol"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.SymbolSet.Add(System.String,SMRUCC.Rsharp.Runtime.Components.Symbol)">
 <summary>
 
 </summary>
 <param name="name"></param>
 <param name="symbol"></param>
 <returns></returns>
 <remarks>
 this add function may cause the in-consist name mapping problem. due to the 
 reason of key name parameter value maybe different with the 
 <see cref="P:SMRUCC.Rsharp.Runtime.Components.Symbol.name"/> value.
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.SymbolSet.FindSymbol(System.String)">
 <summary>
 try get value from the symbol set dictionary object
 </summary>
 <param name="name">a given symbol name to find associated symbol value</param>
 <returns>
 this function returns nothing if the given symbol name is not found insdie this collection
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Extensions.TryCatch(System.Func{System.Object},System.Boolean)">
 <summary>
 If exception happens, then this function will catch 
 the exceptin object and then returns the error.
 </summary>
 <param name="runScript"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Extensions.MeasureArrayElementType(System.Array)">
 <summary>
 这个函数只会尝试第一个不为空的元素的类型
 </summary>
 <param name="array"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Extensions.MeasureRealElementType(System.Array,System.Type)">
 <summary>
 这个会遵循类型缩放的原则返回最大的类型
 </summary>
 <param name="array"></param>
 <returns>
 if all of the element in the given <paramref name="array"/> is nothing
 then function returns the <paramref name="defaultType"/> value
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Extensions.isCallable(System.Object)">
 <summary>
 test target object is a <see cref="T:SMRUCC.Rsharp.Runtime.Components.Interface.RFunction"/> or not
 </summary>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Extensions.Push(SMRUCC.Rsharp.Runtime.Environment,System.Collections.Generic.IEnumerable{SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Closure.DeclareNewSymbol})">
 <summary>
 push runtime function parameters
 </summary>
 <param name="env"></param>
 <param name="parameters"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Extensions.strictOption(SMRUCC.Rsharp.Runtime.Environment,System.Nullable{System.Boolean})">
 <summary>
 get strict options value
 </summary>
 <param name="env">The runtime context</param>
 <param name="opt"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Extensions.verboseOption(SMRUCC.Rsharp.Runtime.Environment,System.Nullable{System.Boolean})">
 <summary>
 get verbose options value
 </summary>
 <param name="env">
 The runtime context
 </param>
 <param name="opt"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.graphicsPipeline.GetRawColor(System.Object,System.String)">
 <summary>
 因为html颜色不支持透明度，所以这个函数是为了解决透明度丢失的问题而编写的
 </summary>
 <param name="color"></param>
 <param name="default$"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.graphicsPipeline.getSize(System.Collections.Generic.Dictionary{System.String,System.Object},SMRUCC.Rsharp.Runtime.Environment,System.Drawing.SizeF)">
 <summary>
 get size value from the arguments list
 </summary>
 <param name="args"></param>
 <param name="env"></param>
 <param name="default">the default size value is the parameter is not found</param>
 <returns>
 size is get via the parameter names:
 
 1. size: should be an integer vector of [width,height]
 2. w and h
 3. width and height
 </returns>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Internal.debug.verbose">
 <summary>
 啰嗦模式下会输出一些调试信息
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.debug.write(System.String,System.ConsoleColor)">
 <summary>
 只在<see cref="P:SMRUCC.Rsharp.Runtime.Internal.debug.verbose"/>啰嗦模式下才会工作
 </summary>
 <param name="message$"></param>
 <param name="color"></param>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.debug.stop(System.Object,SMRUCC.Rsharp.Runtime.Environment,System.Boolean,System.Nullable{System.Boolean})">
 <summary>
 Create an error message to populate to the upper environment.
 </summary>
 <param name="message">the message content, value of this 
 parameter could be a string character data, a string vector 
 or a .NET exception object.
 </param>
 <param name="envir">
 the environment source stack of the current exception happended.
 </param>
 <param name="suppress">
 this parameter indicated that the R environment should not 
 throw the exception when running in debug mode. 
 </param>
 <param name="suppress_log">
 suppress write the internal error log file? this parameter is 
 useful when the error stop happends inside a loop. if not suppress
 write the error log, then a log file in huge size may produced!
 </param>
 <returns>
 a generated error message
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.debug.getEnvironmentStack(SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 get a stackframe list of current environment traceback
 </summary>
 <param name="parent">
 the parent enviroment traceback
 </param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.debug.CreateMessageInternal(System.Object,SMRUCC.Rsharp.Runtime.Environment,Microsoft.VisualBasic.ApplicationServices.Debugging.Logging.MSG_TYPES)">
 <summary>
 Create R# internal message
 </summary>
 <param name="messages"></param>
 <param name="envir"></param>
 <param name="level">The message level</param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.debug.CastCLRExceptionMessage(System.Exception,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 convert the .NET exception as the ``R#`` runtime error message.
 </summary>
 <param name="ex"></param>
 <param name="envir"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.debug.PrintRExceptionStackTrace(Microsoft.VisualBasic.ApplicationServices.Debugging.Diagnostics.ExceptionData)">
 <summary>
 print the stacktrace as string for a given .NET exception object
 </summary>
 <param name="err"></param>
 <returns></returns>
 
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.debug.PrintRStackTrace(Microsoft.VisualBasic.ApplicationServices.Debugging.Diagnostics.StackFrame[])">
 <summary>
 print the stacktrace as string for a given ``R#`` 
 exception message object.
 </summary>
 <param name="stacktrace"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.debug.PrintWarningMessages(System.Collections.Generic.IEnumerable{SMRUCC.Rsharp.Runtime.Components.Message},SMRUCC.Rsharp.Runtime.GlobalEnvironment,System.Boolean)">
 <summary>
 print the given warning message
 </summary>
 <param name="warnings">
 a list of warning message
 </param>
 <param name="globalEnv"></param>
 <param name="all"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.debug.PrintMessageInternal(SMRUCC.Rsharp.Runtime.Components.Message,SMRUCC.Rsharp.Runtime.GlobalEnvironment)">
 <summary>
 return 500 error code
 </summary>
 <param name="message"></param>
 <param name="globalEnv">这个参数可以为空，空值的时候会默认将消息打印在标准输出</param>
 <returns>
 this function will returns 500 error code
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.debug.writeErrMessage(SMRUCC.Rsharp.Runtime.Components.Message,System.IO.TextWriter,System.Boolean)">
 <summary>
 write error message to the output printer device
 </summary>
 <param name="message"></param>
 <param name="stdout">the output printer device</param>
 <param name="redirectError2stdout">
 message data will be print to the <see cref="P:Microsoft.VisualBasic.App.StdErr"/> autoamtically
 if this parameter value is set to FALSE by default, otherwise the error
 message will be print to <paramref name="stdout"/> if set this parameter
 value TRUE.
 </param>
 <remarks>
 parameter <paramref name="redirectError2stdout"/> only works when the parameter
 <paramref name="stdout"/> is not nothing
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.debug.getMessagePrefix(SMRUCC.Rsharp.Runtime.Components.Message)">
 <summary>
 get message prefix based on the <see cref="P:SMRUCC.Rsharp.Runtime.Components.Message.level"/>
 </summary>
 <param name="message"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.debug.getMessageColor(SMRUCC.Rsharp.Runtime.Components.Message)">
 <summary>
 get message color based on the <see cref="P:SMRUCC.Rsharp.Runtime.Components.Message.level"/>
 </summary>
 <param name="message"></param>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Internal.GenericFunction">
 <summary>
 类型通用函数重载申明
 fun(x, ...)
 </summary>
 <param name="x">脚本引擎会根据这个参数的类型进行通用函数的调用</param>
 <param name="args"></param>
 <returns></returns>
 <remarks>
 可以将这个机制看作为函数重载
 </remarks>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Internal.generic">
 <summary>
 Typped generic function invoke. the generic function is overloads by the parameter type
 </summary>
 <remarks>
 supports call primitive functions:
 
 1. plot(...)
 2. as.list(...)
 3. summary(...)
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.generic.get(System.String,System.Type)">
 <summary>
 
 </summary>
 <param name="name"></param>
 <param name="type"></param>
 <returns>
 this function returns nothing if the target function symbol/type 
 is not exists in the generic function pool.
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.generic.add(System.String,System.Type,SMRUCC.Rsharp.Runtime.Internal.GenericFunction)">
 <summary>
 overloads <paramref name="name"/> = (
    x As <see cref="T:System.Object"/>, 
    args As <see cref="M:SMRUCC.Rsharp.ApiArgumentHelpers.list(Microsoft.VisualBasic.Language.ArgumentReference[])"/>, 
    env As <see cref="T:SMRUCC.Rsharp.Runtime.Environment"/>
 ) As <see cref="T:System.Object"/>
 </summary>
 <param name="name"></param>
 <param name="x"></param>
 <param name="[overloads]"></param>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.generic.exists(System.Object@,System.String,System.Type,SMRUCC.Rsharp.Runtime.Environment,SMRUCC.Rsharp.Runtime.Internal.GenericFunction@)">
 <summary>
 check target generic function is exists in the runtime index or not
 </summary>
 <param name="x"></param>
 <param name="funcName"></param>
 <param name="type"></param>
 <param name="env"></param>
 <param name="callable"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.generic.parseGeneric(System.String,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ``genericName.&lt;type>``
 </summary>
 <param name="funcName"></param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.generic.invokeGeneric(SMRUCC.Rsharp.Runtime.Internal.Object.list,System.Object,SMRUCC.Rsharp.Runtime.Environment,System.String)">
 <summary>
 invoke a generic R# function
 
 The function name is comes from the compiler 
 options <see cref="T:System.Runtime.CompilerServices.CallerMemberNameAttribute"/>
 </summary>
 <param name="args"></param>
 <param name="x"></param>
 <param name="env"></param>
 <param name="funcName"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.generic.getGenericCallable(System.Object@,System.Type,System.String,SMRUCC.Rsharp.Runtime.Environment,System.Boolean)">
 <summary>
 
 </summary>
 <param name="x">this function will auto cast the data type of this input parameter x</param>
 <param name="type"></param>
 <param name="funcName"></param>
 <param name="env"></param>
 <param name="suppress">
 this function may be call by the function for check function existsed or not, no needs to throw
 the error, so set suppress to TRUE could avoid generates the error message and stop the program.
 </param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.applys.apply(System.Object,SMRUCC.Rsharp.Runtime.Internal.Object.margins,System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ### Apply Functions Over Array Margins
 
 Returns a vector or array or list of values obtained by applying 
 a function to margins of an array or matrix.
 </summary>
 <param name="x">an array, including a matrix.</param>
 <param name="margin">a vector giving the subscripts which the 
 function will be applied over. E.g., for a matrix 1 indicates rows, 
 2 indicates columns, c(1, 2) indicates rows and columns. Where X has 
 named dimnames, it can be a character vector selecting dimension 
 names.</param>
 <param name="FUN">
 the function to be applied: see ‘Details’. In the case of functions 
 like +, %*%, etc., the function name must be backquoted or quoted.
 </param>
 <param name="env"></param>
 <returns>If each call to FUN returns a vector of length n, then apply 
 returns an array of dimension c(n, dim(X)[MARGIN]) if ``n &gt; 1``. 
 If n equals 1, apply returns a vector if MARGIN has length 1 and an array 
 of dimension dim(X)[MARGIN] otherwise. If n is 0, the result has length 
 0 but not necessarily the ‘correct’ dimension.

 If the calls To FUN Return vectors Of different lengths, apply returns 
 a list Of length prod(Dim(X)[MARGIN]) With Dim Set To MARGIN If this has 
 length greater than one.

 In all cases the result Is coerced by as.vector to one of the basic 
 vector types before the dimensions are set, so that (for example) factor 
 results will be coerced to a character array.</returns>
 <remarks>
 If X is not an array but an object of a class with a non-null dim value 
 (such as a data frame), apply attempts to coerce it to an array via 
 ``as.matrix`` if it is two-dimensional (e.g., a data frame) or via 
 ``as.array``.

 FUN Is found by a call to match.fun And typically Is either a function 
 Or a symbol (e.g., a backquoted name) Or a character string specifying 
 a function to be searched for from the environment of the call to apply.

 Arguments in ``...`` cannot have the same name as any of the other 
 arguments, And care may be needed to avoid partial matching to MARGIN Or 
 FUN. In general-purpose code it Is good practice to name the first three 
 arguments if ... Is passed through: this both avoids Partial matching To 
 MARGIN Or FUN And ensures that a sensible Error message Is given If 
 arguments named X, MARGIN Or FUN are passed through ``...``.
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.applys.parLapply(SMRUCC.Rsharp.Runtime.Internal.Object.list,System.Object,System.Int32,System.Int32,System.Nullable{System.Boolean},System.String[],SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 Parallel version of ``lapply``.
 </summary>
 <param name="x"></param>
 <param name="FUN"></param>
 <param name="group"></param>
 <param name="n_threads"></param>
 <param name="verbose"></param>
 <param name="names">
 Set new names to the result list, the size of this parameter
 should be equals to the size of the original input sequence 
 size.
 </param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.applys.parSapply(System.Object,System.Object,System.Int32,System.Int32,System.Nullable{System.Boolean},SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 parallel sapply
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.applys.checkInternal(System.Object,System.Object@,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 check for the argument error
 </summary>
 <param name="X">check for the input argument, should be nothing if no needed</param>
 <param name="FUN">should be implements a R# function interface.</param>
 <param name="env"></param>
 <returns>
 this function returns nothing if no errors, otherwise a
 error message will be generated if:
 
 1. the input <paramref name="X"/> may be a error message, or
 2. the given <paramref name="FUN"/> is not implements the <see cref="T:SMRUCC.Rsharp.Runtime.Components.Interface.RFunction"/> interface.
 </returns>
 <remarks>this function will convert the <paramref name="FUN"/> 
 from a clr <see cref="T:System.Reflection.MethodInfo"/> pointer to <see cref="T:SMRUCC.Rsharp.Runtime.Interop.RMethodInfo"/> 
 automatically.</remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.applys.sapply(System.Object,System.Object,System.Boolean,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 # Apply a Function over a List or Vector
 
 sapply is a user-friendly version and wrapper of lapply by default 
 returning a vector, matrix or, if simplify = "array", an array 
 if appropriate, by applying simplify2array(). sapply(x, f, simplify 
 = FALSE, USE.NAMES = FALSE) is the same as lapply(x, f).
 </summary>
 <param name="X">
 a vector (atomic or list) or an expression object. Other objects 
 (including classed objects) will be coerced by ``base::as.list``.
 </param>
 <param name="FUN">
 the Function to be applied To Each element Of X: see 'Details’. 
 In the case of functions like +, %*%, the function name must be 
 backquoted or quoted.
 </param>
 <param name="stream">
 run in lazy stream mode? default is not.
 </param>
 <param name="envir"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.applys.lapply(System.Object,System.Object,System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 # Apply a Function over a List or Vector
 
 lapply returns a list of the same length as X, each element of 
 which is the result of applying FUN to the corresponding 
 element of X.
 </summary>
 <param name="X">
 a vector (atomic or list) or an expression object. Other objects 
 (including classed objects) will be coerced by ``base::as.list``.
 </param>
 <param name="FUN">
 the Function to be applied To Each element Of X: see 'Details’. 
 In the case of functions like +, %*%, the function name must be 
 backquoted or quoted. and optional index of function secondary 
 parameter, start from base 1.
 </param>
 <param name="envir"></param>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Internal.Invokes.base">
 <summary>
 在这个模块之中仅包含有最基本的数据操作函数
 </summary>
 
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.base.isTRUE(System.Object)">
 <summary>
 ### Logical Operators
 
 isTRUE(x) is the same as { is.logical(x) &amp;&amp; length(x) == 1 &amp;&amp; !is.na(x) &amp;&amp; x }; 
 isFALSE() is defined analogously. Consequently, if(isTRUE(cond)) may be preferable to if(cond) because 
 of NAs.
 
 In earlier R versions, isTRUE &lt;- function(x) identical(x, TRUE), had the drawback to be false e.g., 
 for x &lt;- c(val = TRUE).
 </summary>
 <param name="x"></param>
 <returns></returns>
 <example>
 # TRUE
 isTRUE(TRUE);
 
 # FALSE
 isTRUE("TRUE");
 
 # FALSE
 isTRUE(FALSE);
 
 # FALSE
 isTRUE([TRUE TRUE]);
 </example>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.base.isFALSE(System.Object)">
 <summary>
 ### Logical Operators
 
 isTRUE(x) is the same as { is.logical(x) &amp;&amp; length(x) == 1 &amp;&amp; !is.na(x) &amp;&amp; x }; 
 isFALSE() is defined analogously. Consequently, if(isTRUE(cond)) may be preferable to if(cond) because 
 of NAs.
 
 In earlier R versions, isTRUE &lt;- function(x) identical(x, TRUE), had the drawback to be false e.g., 
 for x &lt;- c(val = TRUE).
 </summary>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.base.numeric(System.Int32,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ### Numeric Vectors
 
 Creates or coerces objects of type "numeric". is.numeric 
 is a more general test of an object being interpretable 
 as numbers.
 </summary>
 <param name="length">A non-negative integer specifying 
 the desired length. Double values will be coerced to integer: 
 supplying an argument of length other than one is an error.
 </param>
 <param name="env"></param>
 <returns></returns>
 <remarks>
 numeric is identical to double. It creates a double-precision 
 vector of the specified length with each element equal to 0.
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.base.raws(System.Int32,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 Create the raw bytes vector
 </summary>
 <param name="length"></param>
 <param name="env"></param>
 <returns>
 A vector of the raw bytes data if the given <paramref name="length"/>
 greater than zero or a .net clr <see cref="T:System.IO.MemoryStream"/> object that 
 could be used for the file write connection if used the default <paramref name="length"/>
 value: zero.
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.base.argumentList(System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ### Argument List of a Function
 
 Displays the argument names and corresponding default values of a 
 (non-primitive or primitive) function.
 </summary>
 <param name="name">
 a function (a primitive or a closure, i.e., “non-primitive”). If name 
 is a character string then the function with that name is found and 
 used.
 </param>
 <returns>
 + For a closure, a closure with identical formal argument list but an empty (NULL) body.
 + For a primitive (function), a closure with the documented usage And NULL body. 
    Note that some primitives do Not make use of named arguments And match by position 
    rather than name.
 + NULL in case of a non-function.
 </returns>
 <remarks>
 This function is mainly used interactively to print the argument list 
 of a function. For programming, consider using formals instead.
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.base.commandArgs(System.Boolean,System.Boolean)">
 <summary>
 ##### commandArgs: Extract Command Line Arguments
 
 Provides access to a copy of the command line arguments supplied when this R session was invoked.
 </summary>
 <param name="trailingOnly">
 logical. Should only arguments after --args be returned?
 </param>
 <returns>
 A character vector containing the name of the executable and the user-supplied command 
 line arguments. The first element is the name of the executable by which R was invoked. 
 The exact form of this element is platform dependent: it may be the fully qualified name,
 or simply the last component (or basename) of the application, or for an embedded R it 
 can be anything the programmer supplied.
 
 if ``trailingOnly = TRUE``, a character vector Of those arguments (If any) supplied 
 after ``--args``.
 </returns>
 <remarks>
 These arguments are captured before the standard R command line processing takes place. 
 This means that they are the unmodified values. This is especially useful with the --args 
 command-line flag to R, as all of the command line after that flag is skipped.
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.base.range(System.Object,System.Object,System.Boolean,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ## Range of Values
 
 range returns a vector containing the minimum and maximum 
 of all the given arguments.
 </summary>
 <param name="x">
 any numeric or character objects.
 </param>
 <param name="na_rm">
 logical, indicating if NA's should be omitted.
 </param>
 <param name="finite">
 logical, indicating if all non-finite elements should be 
 omitted.
 </param>
 <returns></returns>
 <remarks>
 range is a generic function: methods can be defined for it 
 directly or via the Summary group generic. For this to work 
 properly, the arguments ... should be unnamed, and dispatch 
 is on the first argument.
 
 If na.rm Is False, NA And NaN values In any Of the arguments 
 will cause NA values To be returned, otherwise NA values are 
 ignored.
 If finite Is True, the minimum And maximum Of all finite 
 values Is computed, i.e., finite = True includes na.rm = True.
 
 A special situation occurs When there Is no (after omission 
 Of NAs) nonempty argument left, see min.
 </remarks>
 <example>
 # [2] 1 6
 range(1:6);
 </example>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.base.seq(System.Object,System.Object,System.Double,System.Int32,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ### Sequence Generation
 
 Generate regular sequences. seq is a standard generic with a default method. 
 seq.int is a primitive which can be much faster but has a few restrictions. 
 seq_along and seq_len are very fast primitives for two common cases.
 </summary>
 <param name="from">the starting And (maximal) End values Of the sequence. 
 Of length 1 unless just from Is supplied As an unnamed argument.</param>
 <param name="[to]">the starting And (maximal) End values Of the sequence. 
 Of length 1 unless just from Is supplied As an unnamed argument.</param>
 <param name="by">number: increment of the sequence.</param>
 <returns></returns>
 <remarks>
 Numerical inputs should all be finite (that is, not infinite, NaN or NA).
 The interpretation Of the unnamed arguments Of seq And seq.int Is Not standard, 
 And it Is recommended always To name the arguments When programming.
 
 seq Is generic, And only the default method Is described here. Note that it 
 dispatches on the class of the first argument irrespective of argument names. 
 This can have unintended consequences if it Is called with just one argument 
 intending this to be taken as along.with it Is much better to use seq_along 
 in that case.
 
 seq.int Is an internal generic which dispatches on methods for "seq" based on 
 the class of the first supplied argument (before argument matching).
 
 Typical usages are
 
 + seq(from, to)
 + seq(from, to, by= )
 + seq(from, to, length.out= )
 + seq(along.with= )
 + seq(from)
 + seq(length.out= )
 
 The first form generates the sequence from, from+/-1, ..., To (identical To 
 from:to).

 The second form generates from, from+by, ..., up To the sequence value less 
 than Or equal To To. Specifying To - from And by Of opposite signs Is an Error. 
 Note that the computed final value can go just beyond To To allow For rounding 
 Error, but Is truncated To To. ('Just beyond’ is by up to 1e-10 times
 abs(from - to).)

 The third generates a sequence Of length.out equally spaced values from from To 
 To. (length.out Is usually abbreviated To length Or len, And seq_len Is much 
 faster.)

 The fourth form generates the Integer sequence 1, 2, ..., length(along.With). 
 (along.With Is usually abbreviated To along, And seq_along Is much faster.)

 The fifth form generates the sequence 1, 2, ..., length(from) (As If argument 
 along.With had been specified), unless the argument Is numeric Of length 1 When 
 it Is interpreted As 1:from (even for seq(0) for compatibility with S). Using 
 either seq_along Or seq_len Is much preferred (unless strict S compatibility 
 Is essential).

 The final form generates the Integer sequence 1, 2, ..., length.out unless 
 length.out = 0, When it generates Integer(0).

 Very small sequences (With from - To Of the order Of 10^{-14} times the larger 
 Of the ends) will Return from.

 For seq(only), up To two Of from, To And by can be supplied As complex values 
 provided length.out Or along.With Is specified. More generally, the Default 
 method Of seq will handle classed objects With methods For the Math, Ops 
 And Summary group generics.

 seq.int, seq_along And seq_len are primitive.
 </remarks>
 <example>
 seq(1, 5);
 # is equals to
 1:5;
 
 seq(1, 5, by = 0.1);
 # is equals to
 1:5 step 0.1;
 </example>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.base.date(System.String[],System.String,System.Boolean)">
 <summary>
 ### System Date and Time
 </summary>
 <param name="str">
 this parameter also can accept the unix timestamp.
 </param>
 <param name="format">
 specific the date string parser format, example as ``yyyyMMdd`` will be 
 used for parse the given string ``20220101`` as ``#2022-01-01#``.
 </param>
 <returns>
 Returns a character string of the current system date and time.
 </returns>
 <remarks>
 the given number string will not be treated as unix timestamp
 if the format string has been specific.
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.base.c(System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ### Combine Values into a Vector or List
 
 This is a generic function which combines its arguments.
 The Default method combines its arguments To form a vector. 
 All arguments are coerced To a common type which Is the 
 type Of the returned value, And all attributes except 
 names are removed.
 </summary>
 <param name="values">objects to be concatenated.</param>
 <param name="env"></param>
 <returns>
 NULL or an expression or a vector of an appropriate mode. 
 (With no arguments the value is NULL.)
 </returns>
 <example>
 # for the vector literal, use the syntax of [] literal is better:
 
 # use c() function
 c(1,2,3,4,5,6);
 # is equals to the vector literal syntax
 [1 2 3 4 5 6];
 
 # create string vector
 c("a","b","c","d");
 
 # create logical vector
 c(TRUE, TRUE, FALSE);
 </example>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.base.ifelse(System.Object,System.Object,System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ### Conditional Element Selection
 
 ifelse returns a value with the same shape as test which is filled with 
 elements selected from either yes or no depending on whether the 
 element of test is ``TRUE`` or ``FALSE``.
 </summary>
 <param name="test">an object which can be coerced to logical mode.</param>
 <param name="yes">return values for true elements of test.</param>
 <param name="no">return values for false elements of test.</param>
 <returns>
 A vector of the same length and attributes (including dimensions and "class") 
 as test and data values from the values of yes or no. The mode of the answer 
 will be coerced from logical to accommodate first any values taken from yes 
 and then any values taken from no.
 </returns>
 <remarks>
 If yes or no are too short, their elements are recycled. yes will 
 be evaluated if and only if any element of test is true, and 
 analogously for no.
 
 Missing values In test give missing values In the result.
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.base.Robj_dimension(System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ### Dimensions of an Object
 
 Retrieve or set the dimension of an object.
 </summary>
 <param name="x">an R Object, For example a matrix, array Or data frame.</param>
 <returns>
 For the default method, either NULL or a numeric vector, which is 
 coerced to integer (by truncation).
 
 For an array (and hence in particular, for a matrix) dim retrieves 
 the dim attribute of the object. It is ``NULL`` or a vector of mode 
 integer.
 
 The replacement method changes the "dim" attribute (provided the New 
 value Is compatible) And removes any "dimnames" And "names" 
 attributes.
 </returns>
 <remarks>
 The functions dim and ``dim&lt;-`` are internal generic primitive functions.
 Dim has a method For ``data.frames``, which returns the lengths Of the 
 ``row.names`` attribute Of x And Of x (As the numbers Of rows And columns 
 respectively).
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.base.rep(System.Object,System.Nullable{System.Int32},System.Nullable{System.Int32},SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ### Replicate Elements of Vectors and Lists
 
 rep replicates the values in x. It is a generic function, 
 and the (internal) default method is described here.
 </summary>
 <param name="x">
 a vector (of any mode including a list) or a factor or (for rep only) 
 a POSIXct or POSIXlt or Date object; or an S4 object containing such 
 an object.
 </param>
 <param name="each">
 non-negative integer. Each element of x is repeated each times. Other 
 inputs will be coerced to an integer or double vector and the first 
 element taken. Treated as 1 if NA or invalid.
 </param>
 <param name="times">an integer-valued vector giving the (non-negative) 
 number of times to repeat each element if of length length(x), or to 
 repeat the whole vector if of length 1. Negative or NA values are an 
 error. A double vector is accepted, other inputs being coerced to an 
 integer or double vector.</param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.base.rep_int(System.Object,System.Int32,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 
 </summary>
 <param name="x"></param>
 <param name="times">an integer-valued vector giving the (non-negative) 
 number of times to repeat each element if of length length(x), or to
 repeat the whole vector if of length 1. Negative or NA values are an 
 error. A double vector is accepted, other inputs being coerced to an
 integer or double vector.</param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.base.rep_len(System.Object,System.Int32,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 
 </summary>
 <param name="x"></param>
 <param name="length_out">non-negative integer. The desired 
 length of the output vector. Other inputs will be coerced to 
 a double vector and the first element taken. Ignored if NA 
 or invalid.</param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.base.rbind(SMRUCC.Rsharp.Runtime.Internal.Object.dataframe,System.Object,System.Boolean,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ### Combine R Objects by Rows or Columns
 
 Take a sequence of vector, matrix or data-frame arguments and combine 
 by columns or rows, respectively. These are generic functions with 
 methods for other R classes.
 </summary>
 <param name="d">should be a dataframe object</param>
 <param name="row">should be another dataframe object, or a vector 
 for combine a row or a tuple list for combine as a row.</param>
 <param name="env"></param>
 <param name="safe">
 Merge the dataframe safely?
 </param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.base.cbind(SMRUCC.Rsharp.Runtime.Internal.Object.list,System.Boolean,System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ### Combine R Objects by Rows or Columns
 
 Take a sequence of vector, matrix or data-frame arguments 
 and combine by columns or rows, respectively. These are 
 generic functions with methods for other R classes.
 </summary>
 <param name="x">
 (generalized) vectors Or matrices. These can be given as 
 named arguments. Other R objects may be coerced as appropriate, 
 Or S4 methods may be used: see sections 'Details’ and 
 ‘Value’. (For the "data.frame" method of cbind these can 
 be further arguments to data.frame such as stringsAsFactors.)
 </param>
 <param name="strict">
 this option affects the column merge speed. When this option is 
 set to TRUE, then cbind function will check the row order at first
 and then do row re-ordering for column appends.
 When this option is set to FALSE, then the cbind function will
 merge the dataframe directly without any row order checking. So
 you must ensure that the row order is keeps the same when doing
 non-strict cbind invoke.
 </param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.base.rowwise(SMRUCC.Rsharp.Runtime.Internal.Object.dataframe,System.Boolean,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 dataframe to rows
 </summary>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.base.t(SMRUCC.Rsharp.Runtime.Internal.Object.dataframe,System.Boolean,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ### matrix transpose
 
 Given a matrix or data.frame x, t returns the transpose of x.
 </summary>
 <param name="x">a matrix Or data frame, typically.</param>
 <returns>
 A matrix, with dim and dimnames constructed appropriately from 
 those of x, and other attributes except names copied across.
 </returns>
 <remarks>
 This is a generic function for which methods can be written. 
 The description here applies to the default and "data.frame" 
 methods.
 
 A data frame Is first coerced To a matrix: see as.matrix. 
 When x Is a vector, it Is treated as a column, i.e., the 
 result Is a 1-row matrix.
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.base.allocate(System.Int32)">
 <summary>
 create an empty vector with specific count of null value filled
 </summary>
 <param name="size"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.base.unitOfT(System.Object,System.Object,System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ### Function to Create a Unit Object
 
 get or set unit to a given vector. This function creates a unit object — a vector of unit values. 
 A unit value is typically just a single numeric value with an associated unit.
 </summary>
 <param name="x">A numeric vector. For is.unit, any R object.</param>
 <param name="units">A character vector specifying the units for the corresponding numeric values.</param>
 <param name="data">
 This argument is used to supply extra information for special unit types.
 </param>
 <returns>
 a numeric vector data that tagged with the given specific unit value, or returns the 
 units name of the given vector data if the <paramref name="units"/> parameter has 
 not been assigned.
 </returns>
 <remarks>
 Unit objects allow the user to specify locations and dimensions in a large number of different
 coordinate systems. All drawing occurs relative to a viewport and the units specifies what
 coordinate system to use within that viewport.
 
 Possible units (coordinate systems) are:
 
 "npc"
 Normalised Parent Coordinates (the default). The origin of the viewport is (0, 0) and the 
 viewport has a width and height of 1 unit. For example, (0.5, 0.5) is the centre of the 
 viewport.
 
 "cm"
 Centimetres.
 
 "inches"
 Inches. 1 in = 2.54 cm.
 
 "mm"
 Millimetres. 10 mm = 1 cm.
 
 "points"
 Points. 72.27 pt = 1 in.
 
 "picas"
 Picas. 1 pc = 12 pt.
 
 "bigpts"
 Big Points. 72 bp = 1 in.
 
 "dida"
 Dida. 1157 dd = 1238 pt.
 
 "cicero"
 Cicero. 1 cc = 12 dd.
 
 "scaledpts"
 Scaled Points. 65536 sp = 1 pt.
 
 "lines"
 Lines of text. Locations and dimensions are in terms of multiples of the default text size of the
 viewport (as specified by the viewport's fontsize and lineheight).
 
 "char"
 Multiples of nominal font height of the viewport (as specified by the viewport's fontsize).
 
 "native"
 Locations and dimensions are relative to the viewport's xscale and yscale.
 
 "snpc"
 Square Normalised Parent Coordinates. Same as Normalised Parent Coordinates, except gives the same
 answer for horizontal and vertical locations/dimensions. It uses the lesser of npc-width and npc-height. 
 This is useful for making things which are a proportion of the viewport, but have to be square 
 (or have a fixed aspect ratio).
 
 "strwidth"
 Multiples of the width of the string specified in the data argument. The font size is determined by
 the pointsize of the viewport.
 
 "strheight"
 Multiples of the height of the string specified in the data argument. The font size is determined by 
 the pointsize of the viewport.
 
 "grobwidth"
 Multiples of the width of the grob specified in the data argument.
 
 "grobheight"
 Multiples of the height of the grob specified in the data argument.
 
 A number of variations are also allowed for the most common units. For example, it is possible to 
 use "in" or "inch" instead of "inches" and "centimetre" or "centimeter" instead of "cm".
 
 A special units value of "null" is also allowed, but only makes sense when used in specifying widths of
 columns or heights of rows in grid layouts (see grid.layout).
 
 The data argument must be a list when the unit.length() is greater than 1. For example,
 
 ```r
 unit(rep(1, 3), c("npc", "strwidth", "inches"),
 data = list(NULL, "my string", NULL))
 ```
 
 It is possible to subset unit objects in the normal way and to perform subassignment (see the examples),
 but a special function unit.c is provided for combining unit objects.
 
 Certain arithmetic and summary operations are defined for unit objects. In particular, it is possible 
 to add and subtract unit objects (e.g., unit(1, "npc") - unit(1, "inches")), and to specify the minimum 
 or maximum of a list of unit objects (e.g., min(unit(0.5, "npc"), unit(1, "inches"))).
 
 There is a format method for units, which should respond to the arguments for the default format method, 
 e.g., digits to control the number of significant digits printed for numeric values.
 
 The is.unit() function is a convenience for checking whether x inherits from the "unit" class.
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.base.__invisible(System.Object)">
 <summary>
 # Change the Print Mode to Invisible
 
 Return a (temporarily) invisible copy of an object.
 </summary>
 <param name="x">an arbitrary R object.</param>
 <returns>
 This function can be useful when it is desired to have functions 
 return values which can be assigned, but which do not print when 
 they are not assigned.
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.base.neg(System.Object)">
 <summary>
 A function to make the numeric value negative
 </summary>
 <param name="o"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.base.append(System.Object,System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ### Vector Merging
 
 Add elements to a vector.
 </summary>
 <param name="x">the vector the values are to be appended to.</param>
 <param name="values">to be included in the modified vector.</param>
 <param name="env"></param>
 <returns>
 A vector containing the values in x with the elements of values 
 appended after the specified element of x.
 </returns>
 <remarks>
 for append one tuple list into another tuple list, element value may be overrides 
 if there is duplicated name between the two list. ``join`` function could be used 
 for union the element value.
 
 </remarks>
 <example>
 let a = list(a = 1, b = 2);
 let b = list(a = 333, c = 5);
 
 str(append(a,b));
 # tuple key ``a`` in list a has been overrided by the 
 # tuple key ``a`` from the list b
 
 # List of 3
 #  $ a : int 333
 #  $ b : int 2
 #  $ c : int 5
 
 str(join(a, b));
 # tuple value of ``a`` will be union in join function
 
 # List of 3
 #  $ a : int [1:2] 1 333
 #  $ b : int 2
 #  $ c : int 5
 
 </example>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.base.objectAddInvoke(SMRUCC.Rsharp.Runtime.Environment,System.Object,System.Object)">
 <summary>
 implements ``append`` via the add method
 </summary>
 <param name="env"></param>
 <param name="x"></param>
 <param name="values"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.base.Rdataframe(System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 #### Data Frames
 
 The function ``data.frame()`` creates data frames, tightly coupled collections 
 of variables which share many of the properties of matrices and of lists, 
 used as the fundamental data structure by most of R's modeling software.
 </summary>
 <param name="columns">
 these arguments are of either the form value or ``tag = value``. Component names 
 are created based on the tag (if present) or the deparsed argument itself.
 </param>
 <param name="env"></param>
 <returns>
 A data frame, a matrix-like structure whose columns may be of differing types 
 (``numeric``, ``logical``, ``factor`` and ``character`` and so on).

 How the names Of the data frame are created Is complex, And the rest Of this 
 paragraph Is only the basic story. If the arguments are all named And simple 
 objects (Not lists, matrices Of data frames) Then the argument names give the 
 column names. For an unnamed simple argument, a deparsed version Of the 
 argument Is used As the name (With an enclosing ``I(...)`` removed). For a named 
 ``matrix``/``list``/``dataframe`` argument With more than one named column, the names Of 
 the columns are the name Of the argument followed by a dot And the column name 
 inside the argument: If the argument Is unnamed, the argument's column names 
 are used. For a named or unnamed matrix/list/data frame argument that contains 
 a single column, the column name in the result is the column name in the 
 argument. 
 Finally, the names are adjusted to be unique and syntactically valid unless 
 ``check.names = FALSE``.
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.base.checkDimensionsAgree(System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 Utils function for check for dataframe object construction
 </summary>
 <param name="columns"></param>
 <param name="env"></param>
 <returns>
 false means the data has some column fields that do not matched 
 with others to create a valid dataframe object
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.base.nrow(System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 The Number of Rows/Columns of an Array
 
 nrow and ncol return the number of rows or columns present in x.
 </summary>
 <param name="x">a vector, array, data frame, or NULL.</param>
 <param name="env"></param>
 <returns>an integer of length 1 or NULL, the latter only for ncol and nrow.</returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.base.ncol(System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 The Number of Rows/Columns of an Array
 
 nrow and ncol return the number of rows or columns present in x.
 </summary>
 <param name="x">a vector, array, data frame, or NULL.</param>
 <param name="env"></param>
 <returns>an integer of length 1 or NULL, the latter only for ncol and nrow.</returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.base.Rlist(System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 # Lists – Generic and Dotted Pairs
 
 Functions to construct, coerce and check for both kinds of ``R#`` lists.
 </summary>
 <param name="slots">objects, possibly named.
 ``.symbol_names`` options could be used in this parameter list for indicated
 that the list function should use the symbol name as the tuple slot name if
 the given slot value is not a value assigned expression but it is a symbol
 reference expression.
 </param>
 <param name="envir"></param>
 <returns>
 
 </returns>
 <remarks>
 Almost all lists in R internally are Generic Vectors, whereas traditional dotted pair lists (as in LISP)
 remain available but rarely seen by users (except as formals of functions).
 
 The arguments to list or pairlist are of the form value or tag = value. The functions return a list or 
 dotted pair list composed of its arguments with each value either tagged or untagged, depending on how 
 the argument was specified.
 
 alist handles its arguments as if they described function arguments. So the values are not evaluated, 
 and tagged arguments with no value are allowed whereas list simply ignores them. alist is most often 
 used in conjunction with formals.
 
 as.list attempts to coerce its argument to a list. For functions, this returns the concatenation of the 
 list of formal arguments and the function body. For expressions, the list of constituent elements is 
 returned. as.list is generic, and as the default method calls as.vector(mode = "list") for a non-list, 
 methods for as.vector may be invoked. as.list turns a factor into a list of one-element factors, keeping
 names. Other attributes may be dropped unless the argument already is a list or expression. (This is 
 inconsistent with functions such as as.character which always drop attributes, and is for efficiency since
 lists can be expensive to copy.)
 
 is.list returns TRUE if and only if its argument is a list or a pairlist of length > 0. is.pairlist returns
 TRUE if and only if the argument is a pairlist (or NULL which is a pairlist, see below).
 
 The "environment" method for as.list copies the name-value pairs (for names not beginning with a dot) from
 an environment to a named list. The user can request that all named objects are copied. Unless sorted = TRUE,
 the list is in no particular order (the order depends on the order of creation of objects and whether the 
 environment is hashed). No enclosing environments are searched. (Objects copied are duplicated so this 
 can be an expensive operation.) Note that there is an inverse operation, the as.environment() method for 
 list objects.
 
 An empty pairlist, pairlist() is the same as NULL. This is different from list(): some but not all operations 
 will promote an empty pairlist to an empty list.
 
 as.pairlist is implemented as as.vector(x, "pairlist"), and hence will dispatch methods for the generic 
 function as.vector. Lists are copied element-by-element into a pairlist and the names of the list used as 
 tags for the pairlist: the return value for other types of argument is undocumented.
 
 list, is.list and is.pairlist are primitive functions.
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.base.summary(System.Object,System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 # Object Summaries
 
 summary is a generic function used to produce result summaries of 
 the results of various model fitting functions. The function 
 invokes particular methods which depend on the class of the first 
 argument.
 </summary>
 <param name="object">
 an object for which a summary is desired.
 </param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.base.isEmpty(System.Object)">
 <summary>
 This function returns a logical value to determine that the given object is empty or not?
 </summary>
 <param name="x">an object for which test for empty is desired.</param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.base.isNull(System.Object,System.Boolean,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 # The Null Object
 
 ``NULL`` represents the null object in R: it is a reserved word. 
 ``NULL`` is often returned by expressions and functions whose 
 value is undefined.
 
 ``is.null`` is a primitive function.
 </summary>
 <param name="x">an object to be tested or coerced.</param>
 <param name="els">
 does function test for the elements inside x, not the given object x?
 </param>
 <returns>is.null returns TRUE if its argument's value is NULL and FALSE otherwise.</returns>
 <remarks>
 ``NULL`` can be indexed (see Extract) in just about any syntactically 
 legal way: whether it makes sense or not, the result is always ``NULL``. 
 Objects with value ``NULL`` can be changed by replacement operators 
 and will be coerced to the type of the right-hand side.
 
 ``NULL`` Is also used as the empty pairlist: see the examples. Because 
 pairlists are often promoted To lists, you may encounter ``NULL`` being 
 promoted To an empty list.
 
 Objects with value ``NULL`` cannot have attributes as there Is only 
 one null object attempts to assign them are either an error (attr) 
 Or promote the object to an empty list with attribute(s) (attributes 
 And structure).
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.base.isDataframe(System.Object)">
 <summary>
 ### Coerce to a Data Frame
 
 Functions to check if an object is a data frame, or coerce it 
 if possible.
 </summary>
 <param name="x">any R object.</param>
 <returns>
 is.data.frame returns TRUE if its argument is a data frame 
 (that is, has "data.frame" amongst its classes) and FALSE 
 otherwise.
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.base.isList(System.Object)">
 <summary>
 ### Lists – Generic and Dotted Pairs
 
 Functions to construct, coerce and check for both kinds of R lists.
 </summary>
 <param name="x">
 object to be coerced or tested.
 </param>
 <returns>
 is.list returns TRUE if and only if its argument is a list or 
 a pairlist of length > 0. is.pairlist returns TRUE if and only 
 if the argument is a pairlist or NULL (see below).
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.base.isFunction(System.Object)">
 <summary>
 ### Is an Object of Type (Primitive) Function?
 
 Checks whether its argument is a (primitive) function.
 </summary>
 <param name="x">an R object.</param>
 <returns>
 TRUE if x is a (primitive) function, and FALSE otherwise.
 </returns>
 <remarks>
 is.primitive(x) tests if x is a primitive function, i.e, if typeof(x) is either "builtin" or "special".
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.base.isRVector(System.Object,System.Object)">
 <summary>
 ‘is.vector’ returns ‘TRUE’ if ‘x’ is a vector of the specified
 mode having no attributes _other than names_.  It returns 'FALSE’
 otherwise.
 </summary>
 <param name="x">an R object.</param>
 <param name="mode">
 character string naming an atomic mode or ‘"list"’ or
 '"expression"’ or (except for ‘vector’) ‘"any"’.  Currently,
 'is.vector()’ allows any type (see ‘typeof’) for ‘mode’, and
 when mode Is Not '"any"’, ‘is.vector(x, mode)’ is almost the
 same as 'typeof(x) == mode’.
 </param>
 <returns></returns>
 <remarks>
 The atomic modes are ‘"logical"’, ‘"integer"’, ‘"numeric"’
 (synonym '"double"’), ‘"complex"’, ‘"character"’ and ‘"raw"’.

 If 'mode = "any"’, ‘is.vector’ may return ‘TRUE’ for the atomic
 modes, 'list’ and ‘expression’.  For any ‘mode’, it will return
 'FALSE’ if ‘x’ has any attributes except names.  (This is
 incompatible with S.)  On the other hand, 'as.vector’ removes
 _all_ attributes including names For results Of atomic mode (but
 Not those of mode '"list"’ nor ‘"expression"’).

 Note that factors are _not_ vectors; 'is.vector’ returns ‘FALSE’
 And 'as.vector’ converts a factor to a character vector for ‘mode
 = "any"'.
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.base.is_array(System.Object)">
 <summary>
 Check of the given object is clr array or not
 </summary>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.base.as_array(System.Object)">
 <summary>
 cast any R object collection as a generic type clr array
 </summary>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.base.isNA(System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ### ‘Not Available’ / Missing Values
 
 NA is a logical constant of length 1 which contains a missing value indicator. 
 NA can be coerced to any other vector type except raw. There are also constants 
 NA_integer_, NA_real_, NA_complex_ and NA_character_ of the other atomic vector 
 types which support missing values: all of these are reserved words in the R 
 language.
 
 The generic Function Is.na indicates which elements are missing.
 The generic Function Is.na&lt;- sets elements To NA.
 </summary>
 <param name="x">an R object to be tested: the default method for is.na and anyNA 
 handle atomic vectors, lists, pairlists, and NULL.</param>
 <param name="env"></param>
 <returns>
 The default method for is.na applied to an atomic vector returns a logical vector 
 of the same length as its argument x, containing TRUE for those elements marked NA 
 or, for numeric or complex vectors, NaN, and FALSE otherwise. (A complex value is 
 regarded as NA if either its real or imaginary part is NA or NaN.) dim, dimnames 
 and names attributes are copied to the result.

 The Default methods also work For lists And pairlists
 
 For Is.na, elementwise the result Is false unless that element Is a length-one atomic 
 vector And the single element of that vector Is regarded as NA Or NaN (note that any 
 Is.na method for the class of the element Is ignored).
 
 anyNA(recursive = FALSE) works the same way as Is.na; anyNA(recursive = TRUE) applies 
 anyNA (with method dispatch) to each element.

 The data frame method For Is.na returns a logical matrix With the same dimensions As 
 the data frame, And With dimnames taken from the row And column names Of the data 
 frame.

 anyNA(NULL) Is false; Is.na(NULL) Is logical(0) (no longer warning since R version 
 3.5.0).
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.base.sink(System.String,System.Boolean,System.Boolean,System.Boolean,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 Send R Output to a File
 
 ``sink`` diverts R output to a connection (and stops such diversions).
 </summary>
 <param name="file">
 a writable connection Or a character String naming 
 the file To write To, Or NULL To Stop sink-ing.
 </param>
 <param name="append">
 logical. If TRUE, output will be appended to file; 
 otherwise, it will overwrite the contents of file.
 </param>
 <param name="split">
 logical: if TRUE, output will be sent to the new sink 
 and to the current output stream, like the Unix 
 program ``tee``.
 </param>
 <returns>sink returns NULL.</returns>
 <remarks>
 sink diverts R output to a connection (and must be used 
 again to finish such a diversion, see below!). If file 
 is a character string, a file connection with that name 
 will be established for the duration of the diversion.

 Normal R output (To connection stdout) Is diverted by the 
 Default type = "output". Only prompts And (most) messages 
 Continue To appear On the console. Messages sent To 
 stderr() (including those from message, warning And Stop) 
 can be diverted by sink(type = "message") (see below).

 sink() Or sink(file = NULL) ends the last diversion (of 
 the specified type). There Is a stack of diversions for 
 normal output, so output reverts to the previous diversion 
 (if there was one). The stack Is of up to 21 connections 
 (20 diversions).

 If file Is a connection it will be opened If necessary 
 (In "wt" mode) And closed once it Is removed from the 
 stack Of diversions.

 split = TRUE only splits R output (via Rvprintf) And the 
 default output from writeLines: it does Not split all 
 output that might be sent To stdout().

 Sink-ing the messages stream should be done only with 
 great care. For that stream file must be an already open 
 connection, And there Is no stack of connections.

 If file Is a character String, the file will be opened 
 Using the current encoding. If you want a different 
 encoding (e.g., To represent strings which have been 
 stored In UTF-8), use a file connection — but some 
 ways To produce R output will already have converted 
 such strings To the current encoding.
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.base.sink_number(System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ``sink.number()`` reports how many diversions are in use.
 </summary>
 <param name="type"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.base.length(System.Object,System.Int32)">
 <summary>
 # Length of an Object
 
 Get or set the length of vectors (including lists) and factors, 
 and of any other R object for which a method has been defined.
 </summary>
 <param name="x">an R object. For replacement, a vector or factor.</param>
 <param name="newSize">
 a non-negative integer or double (which will be rounded down).
 </param>
 <returns>
 The default method for length currently returns a non-negative 
 integer of length 1, except for vectors of more than 2^31 - 1 
 elements, when it returns a double.

 For vectors(including lists) And factors the length Is the 
 number of elements. For an environment it Is the number of 
 objects in the environment, And NULL has length 0. For expressions 
 And pairlists (including language objects And dotlists) it Is the 
 length of the pairlist chain. All other objects (including 
 functions) have length one: note that For functions this differs 
 from S.

 The replacement form removes all the attributes Of x except its 
 names, which are adjusted (And If necessary extended by "").
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.base.source(System.String,System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ## Run the external R# script. Read R Code from a File, a Connection or Expressions
 
 causes R to accept its input from the named file or URL or connection or expressions directly. 
 Input is read and parsed from that file until the end of the file is reached, then the parsed 
 expressions are evaluated sequentially in the chosen environment.
 </summary>
 <param name="path">
 a connection Or a character String giving the pathname Of the file Or URL To read from. 
 "" indicates the connection ``stdin()``.</param>
 <param name="envir"></param>
 <returns>
 The value of special ``last variable`` or the value returns by the ``return`` keyword. 
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.base.getOption(System.String,System.String,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 # Options Settings
 
 Allow the user to set and examine a variety of global options which affect the way in 
 which R computes and displays its results.
 </summary>
 <param name="x">a character string holding an option name.</param>
 <param name="default">if the specified option is not set in the options list, this 
 value is returned. This facilitates retrieving an option and checking whether it is 
 set and setting it separately if not.</param>
 <param name="envir"></param>
 <returns>For getOption, the current value set for option x, or default (which defaults 
 to NULL) if the option is unset.</returns>
 <remarks>
 Invoking options() with no arguments returns a list with the current values of the options. 
 Note that not all options listed below are set initially. To access the value of a single 
 option, one should use, e.g., getOption("width") rather than options("width") which is a 
 list of length one.
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.base.options(System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ###### Options Settings
 
 Allow the user to set and examine a variety of global options which 
 affect the way in which R computes and displays its results.
 </summary>
 <param name="opts">
 any options can be defined, using name = value. However, only the 
 ones below are used in base R.
 
 Options can also be passed by giving a Single unnamed argument which 
 Is a named list.
 </param>
 <param name="envir"></param>
 <returns>
 For options(), a list of all set options sorted by name. For options(name), a list of 
 length one containing the set value, or NULL if it is unset. For uses setting one or more 
 options, a list with the previous values of the options changed (returned invisibly).
 </returns>
 <remarks>
 Options used in base R
 
 + add.smooth: typically logical, defaulting to TRUE. Could also be set to an 
 integer for specifying how many (simulated) smooths should be added. This 
 is currently only used by plot.lm.
 + askYesNo: a function (typically set by a front-end) to ask the user binary 
 response functions in a consistent way, or a vector of strings used by 
 askYesNo to use as default responses for such questions.

 browserNLdisabled:
 logical: whether newline is disabled as a synonym for "n" in the browser.

 checkPackageLicense:
 logical, not set by default. If true, loadNamespace asks a user to accept any 
 non-standard license at first load of the package.

 check.bounds:
 logical, defaulting to FALSE. If true, a warning is produced whenever a vector 
 (atomic or list) is extended, by something like x &lt;- 1:3; x[5] &lt;- 6.

 CBoundsCheck:
 logical, controlling whether .C and .Fortran make copies to check for array 
 over-runs on the atomic vector arguments.

 Initially set from value of the environment variable R_C_BOUNDS_CHECK (set to 
 yes to enable).

 conflicts.policy:
 character string or list controlling handling of conflicts found in calls to 
 library or require. See library for details.

 continue:
 a non-empty string setting the prompt used for lines which continue over one 
 line.

 defaultPackages:
 the packages that are attached by default when R starts up. Initially set from 
 value of the environment variable R_DEFAULT_PACKAGES, or if that is unset 
 to c("datasets", "utils", "grDevices", "graphics", "stats", "methods"). (Set 
 R_DEFAULT_PACKAGES to NULL or a comma-separated list of package names.) It 
 will not work to set this in a ‘.Rprofile’ file, as its value is consulted 
 before that file is read.

 deparse.cutoff:
 integer value controlling the printing of language constructs which are deparsed. 
 Default 60.

 deparse.max.lines:
 controls the number of lines used when deparsing in traceback, browser, and 
 upon entry to a function whose debugging flag is set. Initially unset, and 
 only used if set to a positive integer.

 digits:
 controls the number of significant (see signif) digits to print when printing 
 numeric values. It is a suggestion only. Valid values are 1...22 with default 
 7. See the note in print.default about values greater than 15.

 digits.secs:
 controls the maximum number of digits to print when formatting time values 
 in seconds. Valid values are 0...6 with default 0. See strftime.

 download.file.extra:
 Extra command-line argument(s) for non-default methods: see download.file.

 download.file.method:
 Method to be used for download.file. Currently download methods "internal",
 "wininet" (Windows only), "libcurl", "wget" and "curl" are available. If 
 not set, method = "auto" is chosen: see download.file.

 echo:
 logical. Only used in non-interactive mode, when it controls whether input 
 is echoed. Command-line option --slave sets this to FALSE, but otherwise 
 it starts the session as TRUE.

 encoding:
 The name of an encoding, default "native.enc". See connections.

 error:
 either a function or an expression governing the handling of non-catastrophic 
 errors such as those generated by stop as well as by signals and internally 
 detected errors. If the option is a function, a call to that function, with
 no arguments, is generated as the expression. By default the option is not
 set: see stop for the behaviour in that case. The functions dump.frames 
 and recover provide alternatives that allow post-mortem debugging. Note that 
 these need to specified as e.g. options(error = utils::recover) in startup
 files such as ‘.Rprofile’.

 expressions:
 sets a limit on the number of nested expressions that will be evaluated. Valid 
 values are 25...500000 with default 5000. If you increase it, you may also 
 want to start R with a larger protection stack; see --max-ppsize in Memory. 
 Note too that you may cause a segfault from overflow of the C stack, and on 
 OSes where it is possible you may want to increase that. Once the limit is 
 reached an error is thrown. The current number under evaluation can be found 
 by calling Cstack_info.

 interrupt:
 a function taking no arguments to be called on a user interrupt if the interrupt 
 condition is not otherwise handled.

 keep.parse.data:
 When internally storing source code (keep.source is TRUE), also store parse data. 
 Parse data can then be retrieved with getParseData() and used e.g. for spell
 checking of string constants or syntax highlighting. The value has effect only
 when internally storing source code (see keep.source). The default is TRUE.

 keep.parse.data.pkgs:
 As for keep.parse.data, used only when packages are installed. Defaults to FALSE 
 unless the environment variable R_KEEP_PKG_PARSE_DATA is set to yes. The space 
 overhead of parse data can be substantial even after compression and it causes 
 performance overhead when loading packages.

 keep.source:
 When TRUE, the source code for functions (newly defined or loaded) is stored 
 internally allowing comments to be kept in the right places. Retrieve the source 
 by printing or using deparse(fn, control = "useSource").

 The default is interactive(), i.e., TRUE for interactive use.

 keep.source.pkgs:
 As for keep.source, used only when packages are installed. Defaults to FALSE 
 unless the environment variable R_KEEP_PKG_SOURCE is set to yes.

 matprod:
 a string selecting the implementation of the matrix products %*%, crossprod, 
 and tcrossprod for double and complex vectors:

 "internal"
 uses an unoptimized 3-loop algorithm which correctly propagates NaN and Inf
 values and is consistent in precision with other summation algorithms inside
 R like sum or colSums (which now means that it uses a long double accumulator
 for summation if available and enabled, see capabilities).

 "default"
 uses BLAS to speed up computation, but to ensure correct propagation of NaN 
 and Inf values it uses an unoptimized 3-loop algorithm for inputs that may 
 contain NaN or Inf values. When deemed beneficial for performance, "default"
 may call the 3-loop algorithm unconditionally, i.e., without checking the 
 input for NaN/Inf values. The 3-loop algorithm uses (only) a double accumulator
 for summation, which is consistent with the reference BLAS implementation.

 "blas"
 uses BLAS unconditionally without any checks and should be used with extreme 
 caution. BLAS libraries do not propagate NaN or Inf values correctly and 
 for inputs with NaN/Inf values the results may be undefined.

 "default.simd"
 is experimental and will likely be removed in future versions of R. It 
 provides the same behavior as "default", but the check whether the input 
 contains NaN/Inf values is faster on some SIMD hardware. On older systems
 it will run correctly, but may be much slower than "default".

 max.print:
 integer, defaulting to 99999. print or show methods can make use of this option, 
 to limit the amount of information that is printed, to something in the order 
 of (and typically slightly less than) max.print entries.

 OutDec:
 character string containing a single character. The preferred character to be 
 used as the decimal point in output conversions, that is in printing, 
 plotting, format and as.character but not when deparsing nor by sprintf nor
 formatC (which are sometimes used prior to printing.)

 pager:
 the command used for displaying text files by file.show, details depending on
 the platform:

 On a unix-alike
 defaults to ‘R_HOME/bin/pager’, which is a shell script running the command-line
 specified by the environment variable PAGER whose default is set at 
 configuration, usually to less.

 On Windows
 defaults to "internal", which uses a pager similar to the GUI console. 
 Another possibility is "console" to use the console itself.

 Can be a character string or an R function, in which case it needs to accept
 the arguments (files, header, title, delete.file) corresponding to the 
 first four arguments of file.show.

 papersize:
 the default paper format used by postscript; set by environment variable
 R_PAPERSIZE when R is started: if that is unset or invalid it defaults 
 platform dependently

 on a unix-alike
 to a value derived from the locale category LC_PAPER, or if that is unavailable 
 to a default set when R was built.

 on Windows
 to "a4", or "letter" in US and Canadian locales.

 PCRE_limit_recursion:
 Logical: should grep(perl = TRUE) and similar limit the maximal recursion
 allowed when matching? PCRE can be built not to use a recursion stack (see
 pcre_config, but it is by default with a recursion limit of 10000000 which 
 potentially needs a very large C stack: see the discussion at 
 http://www.pcre.org/original/doc/html/pcrestack.html. If true, the limit is 
 reduced using R's estimate of the C stack size available (if known), 
 otherwise 10000. If NA, the limit is imposed only if any input string has 
 1000 or more bytes.

 PCRE_study:
 Logical or integer: should grep(perl = TRUE) and similar ‘study’ the patterns? 
 Either logical or a numerical threshold for the minimum number of strings 
 to be matched for the pattern to be studied (the default is 10)). Missing 
 values and negative numbers are treated as false.

 PCRE_use_JIT:
 Logical: should grep(perl = TRUE), strsplit(perl = TRUE) and similar make use
 of PCRE's Just-In-Time compiler for studied patterns, if available? Missing 
 values are treated as false.

 pdfviewer:
 default PDF viewer. The default is set from the environment variable
 R_PDFVIEWER, the default value of which

 on a unix-alike
 is set when R is configured, and

 on Windows
 is the full path to open.exe, a utility supplied with R.

 printcmd:
 the command used by postscript for printing; set by environment variable 
 R_PRINTCMD when R is started. This should be a command that expects either 
 input to be piped to ‘stdin’ or to be given a single filename argument. 
 Usually set to "lpr" on a Unix-alike.

 prompt:
 a non-empty string to be used for R's prompt; should usually end in a 
 blank (" ").

 rl_word_breaks:
 (Unix only:) Used for the readline-based terminal interface. Default 
 value " \t\n\"\\'`>&lt;=%;,|&amp;{()}".

 This is the set of characters use to break the input line into tokens for
 object- and file-name completion. Those who do not use spaces around 
 operators may prefer
 ``" \t\n\"\\'`>&lt;=+-*%;,|&amp;{()}"``

 save.defaults, save.image.defaults:
 see save.

 scipen:
 integer. A penalty to be applied when deciding to print numeric values in 
 fixed or exponential notation. Positive values bias towards fixed and
 negative towards scientific notation: fixed notation will be preferred
 unless it is more than scipen digits wider.

 setWidthOnResize:
 a logical. If set and TRUE, R run in a terminal using a recent readline
 library will set the width option when the terminal is resized.

 showWarnCalls, showErrorCalls:
 a logical. Should warning and error messages show a summary of the call
 stack? By default error calls are shown in non-interactive sessions.

 showNCalls:
 integer. Controls how long the sequence of calls must be (in bytes) before 
 ellipses are used. Defaults to 40 and should be at least 30 and no more 
 than 500.

 show.error.locations:
 Should source locations of errors be printed? If set to TRUE or "top", the
 source location that is highest on the stack (the most recent call) will
 be printed. "bottom" will print the location of the earliest call found 
 on the stack.

 Integer values can select other entries. The value 0 corresponds to "top"
 and positive values count down the stack from there. The value -1 corresponds
 to "bottom" and negative values count up from there.

 show.error.messages:
 a logical. Should error messages be printed? Intended for use with try or a 
 user-installed error handler.

 stringsAsFactors:
 The default setting for arguments of data.frame and read.table.

 texi2dvi:
 used by functions texi2dvi and texi2pdf in package tools.

 unix-alike only:
 Set at startup from the environment variable R_TEXI2DVICMD, which defaults 
 first to the value of environment variable TEXI2DVI, and then to a value 
 set when R was installed (the full path to a texi2dvi script if one was 
 found). If necessary, that environment variable can be set to "emulation".

 timeout:
 integer. The timeout for some Internet operations, in seconds. Default 60 
 seconds. See download.file and connections.

 topLevelEnvironment:
 see topenv and sys.source.

 url.method:
 character string: the default method for url. Normally unset, which is 
 equivalent to "default", which is "internal" except on Windows.

 useFancyQuotes:
 controls the use of directional quotes in sQuote, dQuote and in rendering 
 text help (see Rd2txt in package tools). Can be TRUE, FALSE, "TeX" or 
 "UTF-8".

 verbose:
 logical. Should R report extra information on progress? Set to TRUE by the
 command-line option --verbose.

 warn:
 sets the handling of warning messages. If warn is negative all warnings are 
 ignored. If warn is zero (the default) warnings are stored until the 
 top–level function returns. If 10 or fewer warnings were signalled they 
 will be printed otherwise a message saying how many were signalled. An object 
 called last.warning is created and can be printed through the function
 warnings. If warn is one, warnings are printed as they occur. If warn is
 two (or larger, coercible to integer), all warnings are turned into errors.

 warnPartialMatchArgs:
 logical. If true, warns if partial matching is used in argument matching.

 warnPartialMatchAttr:
 logical. If true, warns if partial matching is used in extracting attributes
 via attr.

 warnPartialMatchDollar:
 logical. If true, warns if partial matching is used for extraction by $.

 warning.expression:
 an R code expression to be called if a warning is generated, replacing the 
 standard message. If non-null it is called irrespective of the value of 
 option warn.

 warning.length:
 sets the truncation limit for error and warning messages. A non-negative 
 integer, with allowed values 100...8170, default 1000.

 nwarnings:
 the limit for the number of warnings kept when warn = 0, default 50. This 
 will discard messages if called whilst they are being collected. If 
 you increase this limit, be aware that the current implementation pre-allocates 
 the equivalent of a named list for them, i.e., do not increase it to more 
 than say a million.

 width:
 controls the maximum number of columns on a line used in printing vectors,
 matrices and arrays, and when filling by cat.

 Columns are normally the same as characters except in East Asian languages.

 You may want to change this if you re-size the window that R is running in. 
 Valid values are 10...10000 with default normally 80. (The limits on valid
 values are in file ‘Print.h’ and can be changed by re-compiling R.) Some 
 R consoles automatically change the value when they are resized.

 See the examples on Startup for one way to set this automatically from the 
 terminal width when R is started.

 The ‘factory-fresh’ default settings of some of these options are

 add.smooth	TRUE
 check.bounds	FALSE
 continue	"+ "
 digits	7
 echo	TRUE
 encoding	"native.enc"
 error	NULL
 expressions	5000
 keep.source	interactive()
 keep.source.pkgs	FALSE
 max.print	99999
 OutDec	"."
 prompt	"> "
 scipen	0
 show.error.messages	TRUE
 timeout	60
 verbose	FALSE
 warn	0
 warning.length	1000
 width	80
 Others are set from environment variables or are platform-dependent.
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.base.options_flush(SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 save the options configuration data to file
 </summary>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.base.names(System.Object,System.Array,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 # The Names of an Object
 
 Functions to get or set the names of an object.
 </summary>
 <param name="object">an R object.</param>
 <param name="namelist">
 a character vector of up to the same length as ``x``, or ``NULL``.
 </param>
 <param name="envir"></param>
 <returns>
 For ``names``, ``NULL`` or a character vector of the same length as x. 
 (NULL is given if the object has no names, including for objects of 
 types which cannot have names.) For an environment, the length is the 
 number of objects in the environment but the order of the names is 
 arbitrary.
 
 For ``names&lt;-``, the updated object. (Note that the value of 
 ``names(x) &lt;- value`` Is that of the assignment, value, Not the 
 return value from the left-hand side.)
 </returns>
 <example>
 x = list(1,2,3,4,5,6)
 print(names(x));
 # NULL
 names(x) = ["a", "b", "c", "d", "e", "f"];
 print(names(x));
 # [1] "a" "b" "c" "d" "e" "f"
 </example>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.base.makeNames(System.Object,System.Boolean,System.Boolean)">
 <summary>
 ### Make Syntactically Valid Names
 
 Make syntactically valid names out of character vectors.
 
 
 </summary>
 <param name="names">
 character vector To be coerced To syntactically valid names. 
 This Is coerced To character If necessary.
 </param>
 <param name="unique">
 logical; if TRUE, the resulting elements are unique. This may 
 be desired for, e.g., column names.
 </param>
 <param name="allow_">
 logical. For compatibility with R prior to 1.9.0.
 </param>
 <remarks>
 A syntactically valid name consists of letters, numbers and 
 the dot or underline characters and starts with a letter or 
 the dot not followed by a number. Names such as ".2way" are 
 not valid, and neither are the reserved words.

 The definition Of a letter depends On the current locale, but 
 only ASCII digits are considered To be digits.

 The character "X" Is prepended If necessary. All invalid 
 characters are translated To ".". A missing value Is translated 
 To "NA". Names which match R keywords have a dot appended To 
 them. Duplicated values are altered by make.unique.
 </remarks>
 <returns>A character vector of same length as names with each 
 changed to a syntactically valid name, in the current locale's 
 encoding.</returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.base.uniqueNames(System.Object)">
 <summary>
 make the given name string be unique
 </summary>
 <param name="names"></param>
 <returns>this function by extends the numeric suffix to the duplictaed name for make the name string be uniqued!</returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.base.rownames(System.Object,System.Array,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 # Row and Column Names
 
 Retrieve or set the row or column names of a matrix-like object.
 </summary>
 <param name="[object]">a matrix-like R object, with at least two dimensions for colnames.</param>
 <param name="namelist">a valid value for that component of ``dimnames(x)``. 
 For a matrix or array this is either NULL or a character vector of non-zero 
 length equal to the appropriate dimension.</param>
 <param name="envir"></param>
 <returns></returns>
 <remarks>
 The extractor functions try to do something sensible for any matrix-like object x. 
 If the object has dimnames the first component is used as the row names, and the 
 second component (if any) is used for the column names. For a data frame, rownames 
 and colnames eventually call row.names and names respectively, but the latter are 
 preferred.
 
 If do.NULL Is FALSE, a character vector (of length NROW(x) Or NCOL(x)) Is returned 
 in any case, prepending prefix to simple numbers, if there are no dimnames Or the 
 corresponding component of the dimnames Is NULL.
 
 The replacement methods For arrays/matrices coerce vector And factor values Of value 
 To character, but Do Not dispatch methods For As.character.
 
 For a data frame, value for rownames should be a character vector of non-duplicated 
 And non-missing names (this Is enforced), And for colnames a character vector of 
 (preferably) unique syntactically-valid names. In both cases, value will be coerced 
 by as.character, And setting colnames will convert the row names To character.
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.base.colnames(System.Object,System.Array,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 # Row and Column Names
 
 Retrieve or set the row or column names of a matrix-like object.
 </summary>
 <param name="x">a matrix-like R object, with at least two dimensions for colnames.</param>
 <param name="namelist">a valid value for that component of ``dimnames(x)``. 
 For a matrix or array this is either NULL or a character vector of non-zero 
 length equal to the appropriate dimension.</param>
 <param name="envir"></param>
 <returns></returns>
 <remarks>
 The extractor functions try to do something sensible for any matrix-like object x. 
 If the object has dimnames the first component is used as the row names, and the 
 second component (if any) is used for the column names. For a data frame, rownames 
 and colnames eventually call row.names and names respectively, but the latter are 
 preferred.
 
 If do.NULL Is FALSE, a character vector (of length NROW(x) Or NCOL(x)) Is returned 
 in any case, prepending prefix to simple numbers, if there are no dimnames Or the 
 corresponding component of the dimnames Is NULL.
 
 The replacement methods For arrays/matrices coerce vector And factor values Of value 
 To character, but Do Not dispatch methods For As.character.
 
 For a data frame, value for rownames should be a character vector of non-duplicated 
 And non-missing names (this Is enforced), And for colnames a character vector of 
 (preferably) unique syntactically-valid names. In both cases, value will be coerced 
 by as.character, And setting colnames will convert the row names To character.
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.base.stop(System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ### Stop Function Execution
 
 ``stop`` stops execution of the current expression and executes an error action.
 </summary>
 <param name="message">
 <see cref="T:System.String"/> array or <see cref="T:System.Exception"/>, zero Or more objects which 
 can be coerced to character (And which are pasted together with no separator) Or 
 a single condition object.
 </param>
 <param name="envir"></param>
 <returns></returns>
 <remarks>
 The error action is controlled by error handlers established within the executing 
 code and by the current default error handler set by options(error=). The error 
 is first signaled as if using signalCondition(). If there are no handlers or if 
 all handlers return, then the error message is printed (if options("show.error.messages") 
 is true) and the default error handler is used. The default behaviour (the NULL 
 error-handler) in interactive use is to return to the top level prompt or the top 
 level browser, and in non-interactive use to (effectively) call q("no", status = 1, 
 runLast = FALSE). The default handler stores the error message in a buffer; it can 
 be retrieved by geterrmessage(). It also stores a trace of the call stack that can 
 be retrieved by traceback().
 
 Errors will be truncated To getOption("warning.length") characters, Default 1000.
 
 If a condition Object Is supplied it should be the only argument, And further arguments 
 will be ignored, With a warning.
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.base.warning(System.Object,System.Boolean,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ### Warning Messages
 
 Generates a warning message that corresponds to 
 its argument(s) and (optionally) the expression 
 or function from which it was called.
 </summary>
 <param name="message">
 zero Or more objects which can be coerced to 
 character (And which are pasted together with 
 no separator) Or a single condition object.
 </param>
 <param name="immediate_">
 logical, indicating if the warning should be output immediately, 
 even if getOption("warn") &lt;= 0. NB: this is not respected for condition objects.
 </param>
 <param name="envir"></param>
 <returns>
 The warning message as character string, invisibly.
 </returns>
 <remarks>
 Create a new wraning message in current environment frame
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.base.warnings(System.Boolean,SMRUCC.Rsharp.Runtime.GlobalEnvironment)">
 <summary>
 ### Print Warning Messages
 
 warnings and its print method print the variable last.warning in a pleasing form.
 </summary>
 <param name="all"></param>
 <param name="env"></param>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.base.sQuote(System.String,System.Object)">
 <summary>
 ### Quote Text
 
 Single or double quote text by combining with appropriate 
 single or double left and right quotation marks.
 </summary>
 <param name="x">an R object, to be coerced to a character vector.</param>
 <param name="q">the kind of quotes to be used, see ‘Details’.</param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.base.dQuote(System.String,System.Object)">
 <summary>
 ### Quote Text
 
 Single or double quote text by combining with appropriate 
 single or double left and right quotation marks.
 </summary>
 <param name="x">an R object, to be coerced to a character vector.</param>
 <param name="q">the kind of quotes to be used, see ‘Details’.</param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.base.println_message(SMRUCC.Rsharp.Runtime.Internal.Object.list,System.Object,System.Boolean,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ### Diagnostic Messages
 
 Generate a diagnostic message from its arguments.
 </summary>
 <param name="x">zero or more objects which can be coerced 
 to character (and which are pasted together with no separator) 
 or (for message only) a single condition object.</param>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.base.cat(System.Object,System.String,System.String,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 # Concatenate and Print
 
 Outputs the objects, concatenating the representations. 
 ``cat`` performs much less conversion than ``print``.
 </summary>
 <param name="values">R objects (see ‘Details’ for the types of objects allowed).</param>
 <param name="file">A connection, or a character string naming the file to print to. 
 If "" (the default), cat prints to the standard output connection, the console 
 unless redirected by ``sink``.</param>
 <param name="sep">a character vector of strings to append after each element.</param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.base.str(System.Object,System.Int32,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ### Compactly Display the Structure of an Arbitrary ``R#`` Object
 
 Compactly display the internal structure of an R object, a diagnostic function 
 and an alternative to summary (and to some extent, dput). Ideally, only one 
 line for each ‘basic’ structure is displayed. It is especially well suited to 
 compactly display the (abbreviated) contents of (possibly nested) lists. The 
 idea is to give reasonable output for any R object. It calls args for 
 (non-primitive) function objects.
 
 ``strOptions()`` Is a convenience function for setting ``options(str = .)``, 
 see the examples.
 </summary>
 <param name="object">any R object about which you want to have some information.</param>
 <param name="list_len">
 numeric; maximum number of list elements to display within a level.
 </param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.base.print(System.Object,SMRUCC.Rsharp.Runtime.Internal.Object.list,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 # Print Values
 
 print prints its argument and returns it invisibly (via invisible(x)). 
 It is a generic function which means that new printing methods can be 
 easily added for new classes.
 </summary>
 <param name="x">an object used to select a method.</param>
 <param name="args">
 #### quote
 logical, indicating whether Or Not strings (characters) should be 
 printed with surrounding quotes.
 
 #### color
 character, set the color of this message to print on the console by using the 
 asni escape sequence. this option only supports on the string vector message
 
 #### max.print
 integer, the max number of elements to print. this parameter value
 will overrides the max.print options from the options function.
 
 #### syntax.highlight
 logical, indicates that show the R# runtime expression object code
 with syntax highlights? default is TRUE.
 
 #### max.width
 integer, the max character number for display in a cell when apply for 
 print of the dataframe contents. default config is max 200 character
 in a cell. if the cell string char length is greater then this threshold
 then the display string will be truncated.
 
 #### select
 character, a character vector for select the columns for display when 
 do print of a dataframe object.
 </param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Internal.Invokes.base.PrinterOptions.quot">
 <summary>
 quot string with symbol `"`?
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Internal.Invokes.base.PrinterOptions.maxWidth">
 <summary>
 apply for table cell text truncated
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Internal.Invokes.base.PrinterOptions.fields">
 <summary>
 fields for select data from the dataframe 
 to print contents, nothing means print all
 fields
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.base.factors(System.String[],System.Object,System.Object,System.Object,System.Boolean,System.Nullable{System.Int32})">
 <summary>
 The function factor is used to encode a vector as a factor (the terms ‘category’ and ‘enumerated type’
 are also used for factors). If argument ordered is TRUE, the factor levels are assumed to be ordered. 
 For compatibility with S there is also a function ordered.
 </summary>
 <param name="x">a vector of data, usually taking a small number of distinct values.</param>
 <param name="levels">an optional vector of the unique values (as character strings) that x might have taken. 
 The default is the unique set of values taken by as.character(x), sorted into increasing order of x.
 Note that this set can be specified as smaller than sort(unique(x)).</param>
 <param name="labels">either an optional character vector of labels for the levels (in the same order
 as levels after removing those in exclude), or a character string of length 1. Duplicated values in 
 labels can be used to map different values of x to the same factor level.</param>
 <param name="exclude">a vector Of values To be excluded When forming the Set Of levels. This may be 
 factor With the same level Set As x Or should be a character.</param>
 <param name="ordered">logical flag To determine If the levels should be regarded As ordered 
 (In the order given).</param>
 <param name="nmax">an upper bound on the number of levels; see ‘Details’.</param>
 <returns>a vector with elements data encoded as factor. factor returns an object of class "factor" which 
 has a set of integer codes the length of x with a "levels" attribute of mode character and unique (!anyDuplicated(.)) 
 entries. If argument ordered is true (or ordered() is used) the result has class c("ordered", "factor"). 
 Undocumentedly for a long time, factor(x) loses all attributes(x) but "names", and resets "levels" 
 and "class".
 
 Applying factor to an ordered or unordered factor returns a factor (of the same type) with just the 
 levels which occur: see also [.factor for a more transparent way to achieve this.</returns>
 <remarks>
 The type of the vector x is not restricted; it only must have an as.character method and be sortable (by order).
 Ordered factors differ from factors only In their Class, but methods And the model-fitting functions 
 treat the two classes quite differently.
 The encoding Of the vector happens As follows. First all the values In exclude are removed from levels. 
 If x[i] equals levels[j], Then the i-th element Of the result Is j. If no match Is found For x[i] In 
 levels (which will happen For excluded values) Then the i-th element Of the result Is Set To NA.
 Normally the 'levels’ used as an attribute of the result are the reduced set of levels after removing 
 those in exclude, but this can be altered by supplying labels. This should either be a set of new 
 labels for the levels, or a character string, in which case the levels are that character string with 
 a sequence number appended.
 factor(x, exclude = NULL) applied to a factor without NAs Is a no-operation unless there are unused 
 levels in that case, a factor with the reduced level set Is returned. If exclude Is used, since R 
 version 3.4.0, excluding non-existing character levels Is equivalent to excluding nothing, And when 
 exclude Is a character vector, that Is applied to the levels of x. Alternatively, exclude can be factor 
 with the same level set as x And will exclude the levels present in exclude.
 The codes Of a factor may contain NA. For a numeric x, Set exclude = NULL To make NA an extra level 
 (prints As &lt;NA>); by Default, this Is the last level.
 If NA Is a level, the way To Set a code To be missing (As opposed To the code Of the missing level) 
 Is To use Is.na On the left-hand-side Of an assignment (As In Is.na(f)[i] &lt;- True; indexing inside 
 Is.na does Not work). Under those circumstances missing values are currently printed As &lt;NA>, i.e.,
 identical To entries Of level NA.
 Is.factor Is generic: you can write methods To handle specific classes Of objects, see InternalMethods.
 Where levels Is Not supplied, unique Is called. Since factors typically have quite a small number Of 
 levels, For large vectors x it Is helpful To supply nmax As an upper bound On the number Of unique 
 values.
 When using c to combine a (possibly ordered) factor with other objects, if all objects are (possibly 
 ordered) factors, the result will be a factor with levels the union of the level sets of the elements, 
 in the order the levels occur in the level sets of the elements (which means that if all the elements 
 have the same level set, that Is the level set of the result), equivalent to how unlist operates on a 
 list of factor objects.
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.base.autoDispose(System.Object,System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 
 </summary>
 <param name="x"><see cref="T:Microsoft.VisualBasic.ComponentModel.ISaveHandle"/> object or any other object.</param>
 <param name="dispose">
 the dispose handler, for type of parameter x is <see cref="T:Microsoft.VisualBasic.ComponentModel.ISaveHandle"/>,
 this parameter value should be a file path. for other type, this parameter
 value should be a function object.
 </param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.base.library(System.String,System.Boolean,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 # Loading/Attaching and Listing of Packages
 
 library and require load and attach add-on packages.
 </summary>
 <param name="package">the name Of a package, given As a name Or 
 literal character String, Or a character String, depending On 
 whether character.only Is False (Default) Or True.</param>
 <param name="env"></param>
 <returns>Normally library returns (invisibly) the list of attached 
 packages, but TRUE or FALSE if logical.return is TRUE. When 
 called as library() it returns an object of class "libraryIQR", 
 and for library(help=), one of class "packageInfo".
 
 require returns(invisibly) a logical indicating whether the required 
 package Is available.</returns>
 <remarks>
 library(package) and require(package) both load the namespace of 
 the package with name package and attach it on the search list. 
 require is designed for use inside other functions; it returns 
 FALSE and gives a warning (rather than an error as library() does 
 by default) if the package does not exist. Both functions check 
 and update the list of currently attached packages and do not 
 reload a namespace which is already loaded. (If you want to 
 reload such a package, call detach(unload = TRUE) or unloadNamespace 
 first.) If you want to load a package without attaching it on 
 the search list, see requireNamespace.
 
 To suppress messages during the loading of packages use 
 suppressPackageStartupMessages: this will suppress all messages from 
 R itself but Not necessarily all those from package authors.
 
 If library Is called With no package Or help argument, it lists all 
 available packages In the libraries specified by Lib.loc, And returns 
 the corresponding information In an Object Of Class "libraryIQR". 
 (The Structure Of this Class may change In future versions.) Use 
 .packages(all = True) To obtain just the names Of all available packages, 
 And installed.packages() For even more information.
 
 library(help = somename) computes basic information about the package 
 somename, And returns this in an object of class "packageInfo". 
 (The structure of this class may change in future versions.) When 
 used with the default value (NULL) for lib.loc, the attached packages 
 are searched before the libraries.
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.base.attachPackageFile(SMRUCC.Rsharp.Interpreter.RInterpreter,System.String,System.Boolean)">
 <summary>
 attact a given zip archive file as package
 </summary>
 <param name="R"></param>
 <param name="zip">the file path to the zip package</param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.base.on_exit(SMRUCC.Rsharp.Interpreter.ExecuteEngine.Expression,System.Boolean,System.Boolean,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ### Function Exit Code
 
 ``on.exit`` records the expression given as its argument as needing to be executed when the 
 current function exits (either naturally or as the result of an error). This is useful for 
 resetting graphical parameters or performing other cleanup actions.
 
 If no expression Is provided, i.e., the Call Is on.exit(), Then the current on.exit code Is 
 removed.
 </summary>
 <param name="expr">an expression to be executed.</param>
 <param name="add">if TRUE, add expr to be executed after any previously set expressions 
 (or before if after is FALSE); otherwise (the default) expr will overwrite any previously 
 set expressions.</param>
 <param name="after">if add is TRUE and after is FALSE, then expr will be added on top of 
 the expressions that were already registered. The resulting last in first out order is 
 useful for freeing or closing resources in reverse order.</param>
 <returns>Invisible NULL.</returns>
 <remarks>
 The expr argument passed to on.exit is recorded without evaluation. If it is not subsequently 
 removed/replaced by another on.exit call in the same function, it is evaluated in the evaluation 
 frame of the function when it exits (including during standard error handling). Thus any 
 functions or variables in the expression will be looked for in the function and its environment 
 at the time of exit: to capture the current value in expr use substitute or similar.

 If multiple On.Exit expressions are Set Using add = True Then all expressions will be run 
 even If one signals an Error.

 This Is a 'special’ primitive function: it only evaluates the arguments add and after.
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.base.load(System.String,SMRUCC.Rsharp.Runtime.GlobalEnvironment,System.Boolean)">
 <summary>
 ### Reload Saved Datasets
 
 Reload datasets written with the function ``save``.
 </summary>
 <param name="file">a (readable binary-mode) connection or a character 
 string giving the name of the file to load (when tilde expansion is 
 done).</param>
 <param name="envir">the environment where the data should be loaded.</param>
 <param name="verbose">
 should item names be printed during loading?
 </param>
 <returns>
 A character vector of the names of objects created, invisibly.
 </returns>
 <remarks>
 load can load R objects saved in the current or any earlier format. 
 It can read a compressed file (see save) directly from a file or from 
 a suitable connection (including a call to url).

 A Not-open connection will be opened in mode "rb" And closed after 
 use. Any connection other than a gzfile Or gzcon connection will be 
 wrapped in gzcon to allow compressed saves to be handled: note that 
 this leaves the connection In an altered state (In particular, 
 binary-only), And that it needs To be closed explicitly (it will 
 Not be garbage-collected).

 Only R objects saved In the current format (used since R 1.4.0) can 
 be read from a connection. If no input Is available On a connection 
 a warning will be given, but any input Not In the current format 
 will result In a Error.

 Loading from an earlier version will give a warning about the 'magic number’: 
 magic numbers 1971:1977 are from R &lt; 0.99.0, and RD[ABX]1 from 
 R 0.99.0 to R 1.3.1. These are all obsolete, and you are strongly 
 recommended to re-save such files in a current format.

 The verbose argument Is mainly intended For debugging. If it Is True, 
 Then As objects from the file are loaded, their names will be printed 
 To the console. If verbose Is Set To an Integer value greater than 
 one, additional names corresponding To attributes And other parts Of 
 individual objects will also be printed. Larger values will print names 
 To a greater depth.

 Objects can be saved With references To namespaces, usually As part Of 
 the environment Of a Function Or formula. Such objects can be loaded 
 even If the Namespace Is Not available: it Is replaced by a reference 
 to the global environment with a warning. The warning identifies the 
 first object with such a reference (but there may be more than one).
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.base.save(System.Object,System.String,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ### Save R Objects
 
 writes an external representation of R objects to the specified file. 
 The objects can be read back from the file at a later date by using 
 the function load or attach (or data in some cases).
 </summary>
 <param name="objects">the names of the objects to be saved (as symbols or character strings).</param>
 <param name="file">
 a (writable binary-mode) connection or the name of the file where 
 the data will be saved (when tilde expansion is done). Must be a 
 file name for save.image or version = 1.
 </param>
 <param name="env">environment to search for objects to be saved.</param>
 <returns></returns>
 
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.base.saveRDS(System.Object,System.String,System.Boolean,System.String,System.Boolean,System.String,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 Serialization Interface for Single Objects
 
 Functions to write a single R object to a file, and to restore it.
 </summary>
 <param name="object">R object to serialize.</param>
 <param name="file">
 a connection Or the name Of the file where the R Object 
 Is saved To Or read from.</param>
 <param name="ascii"></param>
 <param name="version"></param>
 <param name="compress"></param>
 <param name="refhook">
 a hook function for handling reference objects.
 </param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.base.readRDS(System.String,System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 Serialization Interface for Single Objects
 
 Functions to write a single R object to a file, and to restore it.
 </summary>
 <param name="file">
 a connection Or the name Of the file where the R Object 
 Is saved To Or read from.</param>
 <param name="refhook">
 a hook function for handling reference objects.
 </param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.base.saveImage(System.String,System.String,System.Boolean,System.Object,System.Boolean,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ### Save R Objects
 
 ``save.image()`` is just a short-cut for ‘save my current workspace’, 
 i.e., save(list = ls(all.names = TRUE), file = ".RData", envir = .GlobalEnv). 
 It is also what happens with q("yes").
 </summary>
 <param name="file">a (writable binary-mode) connection or the name of the file 
 where the data will be saved (when tilde expansion is done). Must be a file 
 name for save.image or version = 1.</param>
 <param name="version">the workspace format version to use. NULL specifies the 
 current default format (2). Version 1 was the default from R 0.99.0 to R 1.3.1 
 and version 2 from R 1.4.0. Version 3 is supported from R 3.5.0.</param>
 <param name="ascii">if TRUE, an ASCII representation of the data is written. 
 The default value of ascii is FALSE which leads to a binary file being written. 
 If NA and version >= 2, a different ASCII representation is used which writes 
 double/complex numbers as binary fractions.</param>
 <param name="compress">logical Or character string specifying whether saving to 
 a named file Is to use compression. TRUE corresponds to gzip compression, And 
 character strings "gzip", "bzip2" Or "xz" specify the type of compression. Ignored 
 when file Is a connection And for workspace format version 1.</param>
 <param name="safe">logical. If TRUE, a temporary file is used for creating the 
 saved workspace. The temporary file is renamed to file if the save succeeds. This 
 preserves an existing workspace file if the save fails, but at the cost of using 
 extra disk space during the save.</param>
 <param name="envir">environment to search for objects to be saved.</param>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.bitView.magicNumber(System.Object,System.Int32,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 try to get the magic number of the given binary file
 </summary>
 <param name="file"></param>
 <param name="max_offset"></param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.devtools.translate_to_rlang(SMRUCC.Rsharp.Interpreter.ExecuteEngine.Expression,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 
 </summary>
 <param name="code">
 the expression code that will be run inside R language, the expression type could be:
 
 1. <see cref="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Closure.ClosureExpression"/>
 2. <see cref="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Closure.DeclareNewFunction"/>
 </param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.devtools.FNV1aHash(System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 #### FNV-1a non-cryptographic hash function
 
 FNV hashes are designed to be fast while maintaining a low collision rate.
 The FNV speed allows one to quickly hash lots of data while maintaining a
 reasonable collision rate. The high dispersion of the FNV hashes makes 
 them well suited for hashing nearly identical strings such as URLs, hostnames,
 filenames, text, IP addresses, etc.
 </summary>
 <param name="[set]"></param>
 <param name="env"></param>
 <returns>Returns the hash as a positive integer</returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.devtools.flash_load(System.String,System.Boolean,SMRUCC.Rsharp.Runtime.GlobalEnvironment)">
 <summary>
 Load R script in directory
 
 Load all of the R script in a given working directory,
 by default is load all script in current directory.
 </summary>
 <param name="dir">The script source directory, by default is current workspace.</param>
 <param name="quietly">
 silent mode? default is verbose mode(show the package loading banner information)
 </param>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.devtools.fetchProfileData(SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 get performance profile data
 </summary>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.devtools.gc">
 <summary>
 ## Garbage Collection
 
 A call of gc causes a garbage collection to take place. 
 gcinfo sets a flag so that automatic collection is 
 either silent (verbose = FALSE) or prints memory usage 
 statistics (verbose = TRUE).
 </summary>
 <remarks>
 A call of gc causes a garbage collection to take place. 
 This will also take place automatically without user 
 intervention, and the primary purpose of calling gc is 
 for the report on memory usage. For an accurate report 
 full = TRUE should be used.
 It can be useful To Call gc after a large Object has 
 been removed, As this may prompt R To Return memory To 
 the operating system.
 R allocates space For vectors In multiples Of 8 bytes: 
 hence the report Of "Vcells", a relic Of an earlier 
 allocator (that used a vector heap).
 When gcinfo(TRUE) Is in force, messages are sent to the 
 message connection at each garbage collection of the 
 form:
 
 ```
     Garbage collection 12 = 10+0+2 (level 0) ...
     6.4 Mbytes of cons cells used (58%)
     2.0 Mbytes of vectors used (32%)
 ```
 
 Here the last two lines give the current memory usage 
 rounded up To the Next 0.1Mb And As a percentage Of the 
 current trigger value. The first line gives a breakdown 
 Of the number Of garbage collections at various levels 
 (For an explanation see the 'R Internals’ manual).
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.devtools.getDllPath(System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 get library dll file path
 </summary>
 <param name="files"></param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.devtools.raiseException(System.String)">
 <summary>
 this function will throw a .NET exception for run exception handler demo test
 </summary>
 <param name="message"></param>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.devtools.raiseThreadException(System.String)">
 <summary>
 this function will throw a .NET exception on another thread for run exception handler demo test
 </summary>
 <param name="message"></param>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Internal.Invokes.RPInvoke">
 <summary>
 helper class for create runtime delegate type in dynamics
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.RCurl.guessMIMEType(System.Object,System.String,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ### Infer the MIME type from a file name
 
 This function returns the MIME type, i.e. part of the value 
 used in the Content-Type for an HTTP request/response or in
 email to identify the nature of the content. This is a string
 such as "text/plain" or "text/xml" or "image/png".
 
 The Function consults an R Object constructed by reading a 
 Web site Of known MIME types (Not necessarily all) And 
 matching the extension Of the file name To the names Of that 
 table.
 </summary>
 <param name="name">character vector of file names</param>
 <param name="default">
 the value to use if no MIME type is found in the table for 
 the given file name/extension.
 </param>
 <returns></returns>
 <example>
 guessMIMEType(["file.json" "data.dat" "image.png" "page.html"])
 </example>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Internal.Invokes.rust">
 <summary>
 the rust language helper
 </summary>
 
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.rust.dynLoad(System.String,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ### Foreign Function Interface
 
 Load or unload DLLs (also known as shared objects), and test whether a 
 C function or Fortran subroutine is available.
 </summary>
 <returns></returns>
 <param name="x">
 a character string giving the pathname to a DLL, also known as a dynamic 
 shared object. (See ‘Details’ for what these terms mean.)
 </param>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.rust.Rcall(System.String,System.String,SMRUCC.Rsharp.Runtime.Internal.Object.list,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 Modern Interfaces to VisualBasic.NET code
 
 Functions to pass R# objects to compiled VisualBasic.NET code that has been loaded into R#.
 </summary>
 <param name="NAME">
 a character string giving the name of a C function, or an object 
 of class "NativeSymbolInfo", "RegisteredNativeSymbol" or 
 "NativeSymbol" referring to such a name.</param>
 <param name="PACKAGE">
 If supplied, confine the search For a character String .NAME To 
 the DLL given by this argument (plus the conventional extension, 
 '.so’, ‘.dll’, ...).
 This argument follows ... And so its name cannot be abbreviated.
 This Is intended to add safety for packages, which can ensure by 
 using this argument that no other package can override their 
 external symbols, And also speeds up the search (see 'Note’).
 </param>
 <param name="args">
 arguments to be passed to the compiled code. Up to 65 for .Call.
 </param>
 <param name="env"></param>
 <returns>An R object constructed in the compiled code.</returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.rust.i32(System.Object)">
 <summary>
 create an integer scalar value
 </summary>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Internal.Invokes.env">
 <summary>
 The r-sharp script runtime environment functions
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.env.exit(System.Int32)">
 <summary>
 break and force quit of current R# session without confirm
 </summary>
 <param name="status"></param>
 
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.env.exists(System.String,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ## Is an Object Defined?
 
 Look for an R object of the given name and possibly return it
 </summary>
 <param name="name">
 a variable name (given As a character String Or a symbol).
 </param>
 <param name="envir">where to look for the object (see the details section);
 if omitted, the function will search as if the name of the object 
 appeared unquoted in an expression. an alternative way To specify an 
 environment To look In, but it Is usually simpler To just use the 
 where argument.
 </param>
 <returns>Logical, true if and only if an object of the correct name and mode is found.</returns>
 <example>
 const myEnvir = globalenv();
 
 if (exists(myVarName, envir = myEnvir)) {
    r &lt;- get(myVarName, envir = myEnvir)
    ## ... deal with r ...
 }
 </example>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.env.set(SMRUCC.Rsharp.Runtime.Environment,System.String,System.Object)">
 <summary>
 ### Assign a Value to a Name
 
 Assign a value to a name in an environment.
 </summary>
 <param name="env">the environment To use. See 'Details’.</param>
 <param name="name">
 a variable name, given as a character string. No coercion is done, 
 and the first element of a character vector of length greater than 
 one will be used, with a warning.</param>
 <param name="value">a value To be assigned To x.</param>
 <returns>
 This function is invoked for its side effect, which is assigning 
 value to the variable x. If no envir is specified, then the assignment 
 takes place in the currently active environment.
 If inherits Is TRUE, enclosing environments of the supplied environment 
 are searched until the variable x Is encountered. The value Is Then 
 assigned In the environment In which the variable Is encountered 
 (provided that the binding Is Not locked: see lockBinding : If it Is, 
 an error Is signaled). If the symbol Is Not encountered Then assignment 
 takes place In the user's workspace (the global environment).
 If inherits Is FALSE, assignment takes place in the initial frame of 
 envir, unless an existing binding Is locked Or there Is no existing 
 binding And the environment Is locked (when an error Is signaled).
 </returns>
 <remarks>
 There are no restrictions on the name given as x: it can be a 
 non-syntactic name (see make.names).
 The pos argument can specify the environment In which To assign 
 the Object In any Of several ways: as -1 (the default), as a 
 positive integer (the position in the search list); as the 
 character string name of an element in the search list; Or as 
 an environment (including using sys.frame to access the currently 
 active function calls). The envir argument Is an alternative way 
 to specify an environment, but Is primarily for back compatibility.
 assign does Not dispatch assignment methods, so it cannot be used 
 To Set elements Of vectors, names, attributes, etc.
 Note that assignment To an attached list Or data frame changes the 
 attached copy And Not the original Object: see attach And With.
 </remarks>
 <example>
 set(globalenv(), "symbol_name") &lt;- value;
 </example>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.env.get(System.Object,SMRUCC.Rsharp.Runtime.Environment,System.Boolean)">
 <summary>
 # Return the Value of a Named Object
 
 Search by name for an object (get) or zero or more objects (mget).
 </summary>
 <param name="x">For get, an object name (given as a character string).
 For mget, a character vector of object names.</param>
 <param name="envir">where to look for the object (see ‘Details’); if omitted search as if the name of the object appeared unquoted in an expression.</param>
 <param name="inherits">
 should the enclosing frames of the environment be searched?
 </param>
 <returns></returns>
 <example>
 get(myVarName, envir = myEnvir)
 </example>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.env.globalenv(SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 Get global environment
 </summary>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.env.environment(SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Closure.DeclareNewFunction,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 Get current environment or envirnment of target function closure
 </summary>
 <param name="env"></param>
 <param name="fun">
 a Function, a formula, Or NULL, which Is the default.
 </param>
 <returns>
 If fun is a function or a formula then environment(fun) returns 
 the environment associated with that function or formula. If fun 
 is NULL then the current evaluation environment is returned.
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.env.getOutputDevice(SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 Get the standard output device name string
 </summary>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.env.docs(System.Object)">
 <summary>
 Get the help document of the target runtime function
 </summary>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.env.ls(System.String,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 # List Objects
 
 ``ls`` and ``objects`` return a vector of character strings giving 
 the names of the objects in the specified environment. When invoked 
 with no argument at the top level prompt, ls shows what data sets 
 and functions a user has defined. When invoked with no argument inside 
 a function, ls returns the names of the function's local variables: 
 this is useful in conjunction with ``browser``.
 </summary>
 <param name="name">The package name, which environment to use in 
 listing the available objects. Defaults to the current environment. 
 Although called name for back compatibility, in fact this argument 
 can specify the environment in any form.</param>
 <param name="envir">
 an alternative argument to name for specifying the environment. 
 Mostly there for back compatibility.
 </param>
 <returns></returns>
 <remarks>
 ``name`` input of the ls function:
 
 + pattern like ``package:xxx`` means get all symbols inside the specific R# package
 + ``REnv`` means get all symbols inside the R# internal runtime
 + ``Activator`` means get all attached clr types full name
 + ``/xxx/xxx`` a directory path on the file system, will list all files inside the specific directory
 + ``Function`` means get all attached function objects from the runtime
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.env.objects(SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 list all object symbols inside current environment frame
 </summary>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.env.objectSize(System.Object)">
 <summary>
 # Report the Space Allocated for an Object
 
 Provides an estimate of the memory that is being used to store 
 an R# object.
 
 Exactly which parts of the memory allocation should be attributed 
 to which object is not clear-cut. This function merely provides 
 a rough indication: it should be reasonably accurate for atomic 
 vectors, but does not detect if elements of a list are shared, for 
 example. (Sharing amongst elements of a character vector is taken 
 into account, but not that between character vectors in a single 
 object.)

 The calculation Is Of the size Of the Object, And excludes the 
 space needed To store its name In the symbol table.

 Associated space(e.g., the environment of a function And what the 
 pointer in a EXTPTRSXP points to) Is Not included in the 
 calculation.

 Object sizes are larger On 64-bit builds than 32-bit ones, but will 
 very likely be the same On different platforms With the same word 
 length And pointer size.
 </summary>
 <param name="x">an R# object.</param>
 <returns>
 An object of class "object_size" with a length-one double value, 
 an estimate of the memory allocation attributable to the object 
 in bytes.
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.env.doCall(System.Object,System.String,System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 # Execute a Function Call
 
 ``do.call`` constructs and executes a function call from a name or 
 a function and a list of arguments to be passed to it.
 </summary>
 <param name="what"></param>
 <param name="calls">
 either a function or a non-empty character string naming the function 
 to be called.
 </param>
 <param name="args">
 a list of arguments to the function call. The names attribute of 
 args gives the argument names.
 </param>
 <param name="envir">
 an environment within which to evaluate the call. This will be most 
 useful if what is a character string and the arguments are symbols 
 or quoted expressions.
 </param>
 <returns>The result of the (evaluated) function call.</returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.env.traceback(System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ### Get and Print Call Stacks
 
 By default traceback() prints the call stack of the last uncaught 
 error, i.e., the sequence of calls that lead to the error. This 
 is useful when an error occurs with an unidentifiable error message. 
 It can also be used to print the current stack or arbitrary lists 
 of deparsed calls.
 </summary>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.env.lockBinding(System.String[],SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 Binding and Environment Locking, Active Bindings
 </summary>
 <param name="sym">a name object or character string.</param>
 <param name="env">an environment.</param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.env.typeof(System.String)">
 <summary>
 get a .NET type model from a given VB.NET type full name
 </summary>
 <param name="fullName">.NET type name</param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.env.gettype(System.String,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 get exported type by name
 </summary>
 <param name="name">export type name</param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.env.rm(SMRUCC.Rsharp.Runtime.Internal.Object.list,System.Object,System.Boolean,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ## Remove Objects from a Specified Environment
 
 remove and rm can be used to remove objects. These can be specified 
 successively as character strings, or in the character vector list, 
 or through a combination of both. All objects thus specified will be 
 removed.

 + If envir Is NULL Then the currently active environment Is searched first.
 + If inherits Is TRUE Then parents Of the supplied directory are 
   searched until a variable With the given name Is encountered. A warning 
   Is printed For Each variable that Is Not found.

 </summary>
 <param name="x">the objects to be removed, as names (unquoted) or character strings (quoted).</param>
 <param name="list">a character vector naming objects to be removed.</param>
 <param name="inherits">should the enclosing frames of the environment be inspected?</param>
 <param name="envir">the environment to use. See ‘details’.</param>
 <returns></returns>
 <remarks>
 The pos argument can specify the environment from which to remove the 
 objects in any of several ways: as an integer (the position in the search
 list); as the character string name of an element in the search list; 
 or as an environment (including using sys.frame to access the currently
 active function calls). The envir argument is an alternative way to specify
 an environment, but is primarily there for back compatibility.

 It Is Not allowed to remove variables from the base environment And base 
 namespace, nor from any environment which Is locked (see lockEnvironment).

 Earlier versions Of R incorrectly claimed that supplying a character 
 vector In ... removed the objects named In the character vector, but it
 removed the character vector. Use the list argument To specify objects 
 via a character vector.
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.env.relative_work(System.String,System.Nullable{System.Boolean},SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 get the absolute file path that relative to the current script folder
 </summary>
 <param name="file">
 this function will returns current script folder if this parameter is missing
 </param>
 <param name="env"></param>
 <returns>
 returns the given <paramref name="file"/> its full path which is 
 relative to the folder of current running script file.
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.etc.license(SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 # The R# License Terms
 
 The license terms under which R# is distributed.
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.etc.contributors(SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 # ``R#`` Project Contributors
 
 The R# Who-is-who, describing who made significant contributions to the development of R#.
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.etc.Sys_info">
 <summary>
 ### Extract System and User Information
 
 Reports system and user information.
 </summary>
 <returns>
 A character vector with fields

 + ``sysname`` The operating system name.
 + ``release`` The OS release.
 + ``version`` The OS version.
 + ``nodename`` A name by which the machine Is known On 
     the network (If any).
 + ``machine`` A concise description Of the hardware, 
     often the CPU type.
 + ``login`` The user 's login name, or "unknown" if it 
     cannot be ascertained.
 + ``user`` The name Of the real user ID, Or "unknown" If 
     it cannot be ascertained.
 + ``effective_user`` The name Of the effective user ID, Or 
     "unknown" If it cannot be ascertained. This may differ 
     from the real user In 'set-user-ID’ processes.

 The last three fields give the same value On Windows.
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.etc.unixtimestamp">
 <summary>
 Get current time in ``xxxxx.xxxx`` unix time stamp format.
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.etc.Sys_getenv(System.String)">
 <summary>
 ### Get Environment Variables
 
 ``Sys.getenv`` obtains the values of the environment variables.
 </summary>
 <param name="x">
 a character vector, or NULL.
 </param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.etc.Sys_getlocale">
 <summary>
 Provides information about a specific culture (called a locale for unmanaged
 code development). The information includes the names for the culture, the writing
 system, the calendar used, the sort order of strings, and formatting for dates
 and numbers.
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.etc.sessionInfo(SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ### Collect Information About the Current R Session
 
 Print version information about R, the OS and attached or 
 loaded packages.
 </summary>
 <returns>
 sessionInfo() returns an object of class "sessionInfo" which has 
 print and toLatex methods. This is a list with components
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.etc.platformID">
 <summary>
 Gets a System.Version object that identifies the operating system.
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.etc.RVer(SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ### Version Information
 
 R.Version() provides detailed information about the version of R running.
 </summary>
 <param name="env"></param>
 <returns>
 R.Version returns a list with character-string components

 + ``platform`` the platform For which R was built. A triplet Of the form 
    CPU-VENDOR-OS, As determined by the configure script. E.g, 
    "i686-unknown-linux-gnu" Or "i386-pc-mingw32".
 + ``arch`` the architecture(CPU) R was built On/For.
 + ``os`` the underlying operating system.
 + ``system`` CPU And OS, separated by a comma.
 + ``status`` the status Of the version (e.g., "alpha")
 + ``major`` the major version number
 + ``minor`` the minor version number, including the patchlevel
 + ``year`` the year the version was released
 + ``month`` the month the version was released
 + ``day`` the day the version was released
 + ``svn rev`` the Subversion revision number, which should be either "unknown" 
    Or a Single number. (A range Of numbers Or a number With M Or S appended 
    indicates inconsistencies In the sources used To build this version Of R.)
 + ``language`` always "R".
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.etc.CultureInfo(System.String)">
 <summary>
 Initializes a new instance of the System.Globalization.CultureInfo class based
 on the culture specified by name.
 </summary>
 <param name="cultureName">A predefined System.Globalization.CultureInfo name,
 System.Globalization.CultureInfo.Name of an existing System.Globalization.CultureInfo, 
 Or Windows-only culture name. name Is Not case-sensitive.</param>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Internal.Invokes.file">
 <summary>
 #### File Manipulation
 
 These functions provide a low-level interface to the computer's file system.
 </summary>
 
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.file.GetSha1Hash(System.String)">
 <summary>
 # Generate SHA1 checksum of a file
 </summary>
 <param name="filePath"></param>
 <returns></returns>
 
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.file.getRelativePath(System.String[],System.Object)">
 <summary>
 Gets the relative pathname relative to a directory.
 </summary>
 <param name="pathname">A character String Of the pathname To be converted into an relative pathname.</param>
 <param name="relativeTo">A character string of the reference pathname.</param>
 <returns>Returns a character string of the relative pathname.</returns>
 <remarks>
 In case the two paths are on different file systems, 
 for instance, C:/foo/bar/ and D:/foo/, the method 
 returns pathname as is.
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.file.filesize(System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ## Extract File Information
 
 Utility function to extract information about files on the user's file systems.
 </summary>
 <param name="x">
 character vectors containing file paths. Tilde-expansion is done: see path.expand.
 </param>
 <returns>Double: File size In bytes. For missing file, this function will 
 returns a negative number -1; and the file is exists on the filesystem, this 
 function returns ZERO(empty file) or a positive number.</returns>
 <remarks>
 What constitutes a ‘file’ is OS-dependent but includes directories. (However, 
 directory names must not include a trailing backslash or slash on Windows.) 
 See also the section in the help for file.exists on case-insensitive file 
 systems.
 
 The file 'mode’ follows POSIX conventions, giving three octal digits summarizing 
 the permissions for the file owner, the owner's group and for anyone respectively. 
 Each digit is the logical or of read (4), write (2) and execute/search (1) 
 permissions.
 
 See files For how file paths With marked encodings are interpreted.
 
 File modes are probably only useful On NTFS file systems, And it seems all three 
 digits refer To the file's owner. The execute/search bits are set for directories, 
 and for files based on their extensions (e.g., ‘.exe’, ‘.com’, ‘.cmd’ and ‘.bat’ 
 files). file.access will give a more reliable view of read/write access 
 availability to the R process.
 
 UTF-8-encoded file names Not valid in the current locale can be used.
 
 Junction points And symbolic links are followed, so information Is given about 
 the file/directory To which the link points rather than about the link.
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.file.filepath(System.Object,System.String,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 Construct Path to File
 
 Construct the path to a file from components in a
 platform-independent way.
 </summary>
 <param name="x">character vectors.  Long vectors are not supported.</param>
 <param name="fsep">the path separator to use (assumed to be ASCII).
 The components are by default separated by ‘/’ (not ‘\’) on
 Windows.
 </param>
 <returns>
 A character vector of the arguments concatenated term-by-term and
 separated by 'fsep’ if all arguments have positive length;
 otherwise, an empty character vector (unlike 'paste’).

 An element Of the result will be marked (see 'Encoding’ as UTF-8
 If run In a UTF-8 locale (When marked inputs are converted To
 UTF-8) Or if an component of the result Is marked as UTF-8, Or as
 Latin-1 in a non-Latin-1 locale.
 </returns>
 <remarks>
 The implementation is designed to be fast (faster than ‘paste’) as
 this Function is() used extensively In R itself.
 It can also be used for environment paths such as 'PATH’ and
 'R_LIBS’ with ‘fsep = .Platform$path.sep’.
 Trailing Path separators are invalid For Windows file paths apart
 from '/’ and ‘d:/’ (although some functions/utilities do accept
 them), so a trailing '/’ or ‘\’ is removed there.
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.file.fileinfo(System.Object,System.Boolean,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 Extract File Information
 
 Utility function to extract information about files on the user's file systems.
 </summary>
 <param name="files">
 The fully qualified name of the new file, or the relative file name. Do not end
 the path with the directory separator character.
 </param>
 <param name="env"></param>
 <returns>
 a object list with slots:
 
 + DirectoryName: Gets a string representing the directory's full path.
 + Length: Gets the size, in bytes, of the current file.
 + Name: Gets the name of the file.
 + IsReadOnly: Gets or sets a value that determines if the current file is read only.
 + Exists: Gets a value indicating whether a file exists.
 
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.file.filecopy(System.String[],System.String[],System.Boolean,System.Boolean,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ``file.copy`` works in a similar way to ``file.append`` but with the arguments 
 in the natural order for copying. Copying to existing destination files is 
 skipped unless overwrite = TRUE. The to argument can specify a single existing 
 directory. If copy.mode = TRUE file read/write/execute permissions are copied 
 where possible, restricted by ‘umask’. (On Windows this applies only to files.
 ) Other security attributes such as ACLs are not copied. On a POSIX filesystem 
 the targets of symbolic links will be copied rather than the links themselves, 
 and hard links are copied separately. Using copy.date = TRUE may or may not 
 copy the timestamp exactly (for example, fractional seconds may be omitted), 
 but is more likely to do so as from R 3.4.0.
 </summary>
 <param name="from"></param>
 <param name="To"></param>
 <returns>
 These functions return a logical vector indicating which operation succeeded 
 for each of the files attempted. Using a missing value for a file or path 
 name will always be regarded as a failure.
 </returns>
 
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.file.fileExt(System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 Get file extension name
 </summary>
 <param name="path">the file path string</param>
 <returns>
 returns a file extension suffix name in lower case, if there is 
 no extension name or path string is empty, then empty string 
 value will be returned.
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.file.dirCopy(System.String,System.String,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 copy file contents in one dir to another dir
 </summary>
 <param name="from"></param>
 <param name="To"></param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.file.openDir(System.String,Microsoft.VisualBasic.ApplicationServices.IFileSystemEnvironment,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 Open an interface to a specific local filesystem location
 </summary>
 <param name="dir"></param>
 <param name="fs">
 the logical filesystem view
 </param>
 <param name="env"></param>
 <returns>a directory model</returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.file.normalizePath(System.String[],SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 Express File Paths in Canonical Form
 
 Convert file paths to canonical form for the platform, to display them in a 
 user-understandable form and so that relative and absolute paths can be 
 compared.
 </summary>
 <param name="fileNames">character vector of file paths.</param>
 <param name="envir"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.file.Rhome">
 <summary>
 Return the R Home Directory
 
 Return the R home directory, or the full path to a 
 component of the R installation.
 
 The R home directory is the top-level directory of the R installation being run.

 The R home directory Is often referred To As R_HOME, And Is the value Of an 
 environment variable Of that name In an R session. It can be found outside 
 an R session by R RHOME.
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.file.dirname(System.Object,System.Boolean,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ``dirname`` returns the part of the ``path`` up to but excluding the last path separator, 
 or "." if there is no path separator.
 </summary>
 <param name="fileNames">character vector, containing path names.</param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.file.listFiles(System.Object,System.String[],System.Boolean,System.Boolean,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 List the Files in a Directory/Folder
 </summary>
 <param name="dir">
 a character vector of full path names; the default corresponds to the 
 working directory, ``getwd()``. 
 Tilde expansion (see path.expand) is performed. Missing values will be 
 ignored.
 
 or zip folder object if this parameter is a file stream r zip file path.
 </param>
 <param name="pattern">
 an optional regular expression/wildcard expression. Only file names which 
 match the regular expression will be returned.
 </param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.file.listDirs(System.String,System.Boolean,System.Boolean,Microsoft.VisualBasic.ApplicationServices.IFileSystemEnvironment)">
 <summary>
 List the Files in a Directory/Folder
 </summary>
 <param name="dir">
 a character vector of full path names; the default corresponds to the working directory, ``getwd()``. 
 Tilde expansion (see path.expand) is performed. Missing values will be ignored.
 </param>
 <param name="fullNames"></param>
 <param name="recursive"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.file.file_ext(System.String[])">
 <summary>
 ## File Utilities
 
 </summary>
 <param name="filenames">character vector giving file paths.</param>
 <returns>
 ``file_ext`` returns the file (name) extensions (excluding the leading dot). 
 (Only purely alphanumeric extensions are recognized.)
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.file.basename(System.String[],System.Boolean,System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 removes all of the path up to and including the last path separator (if any).
 </summary>
 <param name="fileNames">character vector, containing path names.</param>
 <param name="withExtensionName">
 option for config keeps the extension suffix in the name or not, 
 removes the file suffix name by default.
 </param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.file.normalizeFileName(System.Object,System.Boolean,System.String,System.Boolean,System.Int32,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 removes all of the invalid character for the windows file name
 </summary>
 <param name="strings"></param>
 <param name="alphabetOnly"></param>
 <param name="replacement">
 all of the invalid character for the windows file name 
 will be replaced as this placeholder character
 </param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.file.exists(System.Object,System.Boolean,Microsoft.VisualBasic.ApplicationServices.IFileSystemEnvironment,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ``file.exists`` returns a logical vector indicating whether the files named by its 
 argument exist. (Here ‘exists’ is in the sense of the system's stat call: a file 
 will be reported as existing only if you have the permissions needed by stat. 
 Existence can also be checked by file.access, which might use different permissions 
 and so obtain a different result. Note that the existence of a file does not 
 imply that it is readable: for that use file.access.) What constitutes a ‘file’ 
 is system-dependent, but should include directories. (However, directory names 
 must not include a trailing backslash or slash on Windows.) Note that if the file 
 is a symbolic link on a Unix-alike, the result indicates if the link points to 
 an actual file, not just if the link exists. Lastly, note the different function 
 exists which checks for existence of R objects.
 </summary>
 <param name="files">
 character vectors, containing file names or paths.
 </param>
 <param name="fs">
 a virtual filesystem object
 </param>
 <returns>
 this function returns FALSE if the given files value is NULL
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.file.dirCreate(System.String,System.Boolean,System.Boolean,System.String)">
 <summary>
 dir.create creates the last element of the path, unless recursive = TRUE. 
 Trailing path separators are discarded. On Windows drives are allowed in 
 the path specification and unless the path is rooted, it will be interpreted 
 relative to the current directory on that drive. mode is ignored on Windows.
 
 One of the idiosyncrasies of Windows Is that directory creation may report 
 success but create a directory with a different name, for example dir.create("G.S.") 
 creates '"G.S"’. This is undocumented, and what are the precise circumstances 
 is unknown (and might depend on the version of Windows). Also avoid directory 
 names with a trailing space.
 </summary>
 <param name="path">a character vector containing a single path name.</param>
 <param name="showWarnings">logical; should the warnings on failure be shown?</param>
 <param name="recursive">logical. Should elements of the path other than the last be created? 
 If true, Like the Unix command mkdir -p.</param>
 <param name="mode">the mode To be used On Unix-alikes: it will be coerced by as.octmode. 
 For Sys.chmod it Is recycled along paths.</param>
 <returns>
 dir.create and Sys.chmod return invisibly a logical vector indicating if 
 the operation succeeded for each of the files attempted. Using a missing 
 value for a path name will always be regarded as a failure. dir.create 
 indicates failure if the directory already exists. If showWarnings = TRUE, 
 dir.create will give a warning for an unexpected failure (e.g., not for a 
 missing value nor for an already existing component for recursive = TRUE).
 </returns>
 <remarks>
 There is no guarantee that these functions will handle Windows relative paths 
 of the form ‘d:path’: try ‘d:./path’ instead. In particular, ‘d:’ is 
 not recognized as a directory. Nor are \\?\ prefixes (and similar) supported.
 
 UTF-8-encoded dirnames Not valid in the current locale can be used.
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.file.dir_exists(System.String[])">
 <summary>
 dir.exists returns a logical vector of TRUE or FALSE values (without names).
 </summary>
 <param name="paths">
 character vectors containing file or directory paths. 
 Tilde expansion (see path.expand) is done.
 </param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.file.readLines(System.Object,System.Int32,Microsoft.VisualBasic.Text.Encodings,System.Boolean,System.Nullable{System.Boolean},SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ### Read Text Lines from a Connection
 
 Read some or all text lines from a connection.
 </summary>
 <param name="con">a connection object or a character string.</param>
 <param name="stream">
 if this options is config as TRUE, means this function will returns 
 a lazy load data pipeline. default value of this option is FALSE, which
 means this function will returns a character vector which contains all 
 data content lines directly.
 </param>
 <param name="strict">
 this function will returns an empty string vector if not in strict mode
 </param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.file.readText(System.Object,Microsoft.VisualBasic.Text.Encodings,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 Reads all characters from the current position to the end of the given stream.
 </summary>
 <param name="con"></param>
 <param name="encoding"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.file.writeLines(System.Object,System.Object,System.String,Microsoft.VisualBasic.ApplicationServices.IFileSystemEnvironment,Microsoft.VisualBasic.Text.Encodings,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ### Write Lines to a Connection
 
 Write text lines to a connection.
 </summary>
 <param name="text">A character vector, or a serials of compatible interface for get text contents.</param>
 <param name="con">A connection Object Or a character String.</param>
 <param name="sep">
 character string. A string to be written to the connection after each line of text.
 </param>
 <returns></returns>
 <remarks>
 If the con is a character string, the function calls file to obtain a file connection
 which is opened for the duration of the function call.

 If the connection Is open it Is written from its current position. If it Is Not open, 
 it Is opened For the duration Of the Call In "wt" mode And Then closed again.

 Normally writeLines Is used With a text-mode connection, And the Default separator Is 
 converted To the normal separator For that platform (LF On Unix/Linux, CRLF On Windows). 
 For more control, open a binary connection And specify the precise value you want 
 written To the file In sep. For even more control, use writeChar On a binary connection.

 useBytes Is for expert use. Normally (when false) character strings with marked 
 encodings are converted to the current encoding before being passed to the connection 
 (which might do further re-encoding). useBytes = TRUE suppresses the re-encoding of 
 marked strings so they are passed byte-by-byte to the connection: this can be useful 
 When strings have already been re-encoded by e.g. iconv. (It Is invoked automatically 
 For strings With marked encoding "bytes".)
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.file.getwd">
 <summary>
 getwd returns an absolute filepath representing the current working directory of the R process;
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.file.setwd(System.String[],SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 setwd(dir) is used to set the working directory to dir.
 </summary>
 <param name="dir">A character String: tilde expansion will be done.</param>
 <param name="envir"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.file.saveList(System.Object,System.String,Microsoft.VisualBasic.Text.Encodings,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 Save a R# object list in json file format
 </summary>
 <param name="list"></param>
 <param name="file$"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.file.readList(System.String,System.String,System.Boolean,Microsoft.VisualBasic.Text.Encodings,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 read list from a given json file
 </summary>
 <param name="file">A json file path</param>
 <param name="mode">The value mode of the loaded list object in ``R#``</param>
 <param name="ofVector">
 Is a list of vector?
 </param>
 <param name="envir"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.file.gzfile(System.String,System.IO.FileMode,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 open a *.gz file for make file data read/write
 </summary>
 <param name="description"></param>
 <returns>stream object for read/write data</returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.file.gzcheck(System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 check of the target gz file data is corrupted or not
 </summary>
 <param name="file"></param>
 <param name="env"></param>
 <returns>
 true for no error in gzfile, false means the given gz file is corrupted
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.file.stdin_dev">
 <summary>
 
 </summary>
 <returns>
 stdin(), stdout() and stderr() return connection objects.
 </returns>
 <remarks>
 stdin(), stdout() and stderr() are standard connections corresponding to input, output and error on the console 
 respectively (and not necessarily to file streams). They are text-mode connections of class "terminal" which 
 cannot be opened or closed, and are read-only, write-only and write-only respectively. The stdout() and stderr() 
 connections can be re-directed by sink (and in some circumstances the output from stdout() can be split: see the 
 help page).
 
 The encoding For stdin() When redirected can be Set by the command-line flag --encoding.
 
 nullfile() returns filename of the null device ("/dev/null" on Unix, "nul:" on Windows).
 
 showConnections returns a matrix Of information. If a connection Object has been lost Or forgotten, getConnection 
 will take a row number from the table And Return a connection Object For that connection, which can be used To 
 close the connection, For example. However, If there Is no R level Object referring To the connection it will be 
 closed automatically at the Next garbage collection (except For gzcon connections).
 
 closeAllConnections closes(And destroys) all user connections, restoring all sink diversions As it does so.
 
 isatty returns True If the connection Is one Of the Class "terminal" connections And it Is apparently connected To 
 a terminal, otherwise False. This may Not be reliable In embedded applications, including GUI consoles.
 
 getAllConnections returns a sequence Of Integer connection descriptors For use With getConnection, corresponding 
 To the row names Of the table returned by showConnections(all = True).
 
 stdin() refers to the ‘console’ and not to the C-level ‘stdin’ of the process. The distinction matters in GUI 
 consoles (which may not have an active ‘stdin’, and if they do it may not be connected to console input), and also 
 in embedded applications. If you want access to the C-level file stream ‘stdin’, use file("stdin").
 
 When R Is reading a script from a file, the file Is the 'console’: this is traditional usage to allow in-line 
 data (see ‘An Introduction to R’ for an example).
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.file.file(System.String,Microsoft.VisualBasic.FileIO.FileModeDescriptor,System.Boolean,Microsoft.VisualBasic.ApplicationServices.IFileSystemEnvironment)">
 <summary>
 Functions to create, open and close connections, i.e., 
 "generalized files", such as possibly compressed files, 
 URLs, pipes, etc.
 </summary>
 <param name="description">character string. A description of the connection: see ‘Details’.</param>
 <param name="open">
 character string. A description of how to open the connection (if it should be opened initially). 
 See section ‘Modes’ for possible values.
 </param>
 <param name="repo">
 this function will open an internal block stream if this repository reference has been specificed.
 </param>
 <returns></returns>
 <remarks>
 + ``stdin``  for stdinput stream, and
 + ``stdout`` for stdoutput stream.
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.file.readBin(System.Object,System.Object,System.Int32,System.Int32,System.Boolean,SMRUCC.Rsharp.Runtime.Internal.Invokes.endianness,SMRUCC.Rsharp.Runtime.Internal.Object.list,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ### ransfer Binary Data To and From Connections
 
 Read binary data from or write binary data to a connection
 or raw vector.
 </summary>
 <param name="con">A connection Object Or a character 
 String naming a file Or a raw vector.</param>
 <param name="n">
 numeric. The (maximal) number of records to be read. 
 You can use an over-estimate here, but not too large 
 as storage is reserved for n items.
 </param>
 <param name="size">
 Integer.The number Of bytes per element In the Byte 
 stream. The Default, NA_integer_, uses the natural 
 size. Size changing Is Not supported For raw And 
 complex vectors.
 </param>
 <param name="signed">
 logical. Only used for integers of sizes 1 and 2, when 
 it determines if the quantity on file should be regarded
 as a signed or unsigned integer.
 </param>
 <param name="endian">The endian-ness ("big" Or "little") 
 Of the target system For the file. Using "swap" will force 
 swapping endian-ness.
 </param>
 <param name="what">
 Either an object whose mode will give the mode of the 
 vector to be read, or a character vector of length one 
 describing the mode: one of "numeric", "double", 
 "integer", "int", "logical", "complex", "character", 
 "raw".
 </param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.file.writeBin(System.Object,System.Object,System.Int32,SMRUCC.Rsharp.Runtime.Internal.Invokes.endianness,System.Boolean,SMRUCC.Rsharp.Runtime.Internal.Object.list,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 
 </summary>
 <param name="[object]"></param>
 <param name="con"></param>
 <param name="size"></param>
 <param name="endian"></param>
 <param name="useBytes"></param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.file.close(System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 close connections, i.e., “generalized files”, such as possibly compressed files, URLs, pipes, etc.
 </summary>
 <param name="con">a connection.</param>
 <returns></returns>
 
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.file.openZip(System.String,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 open a zip file
 </summary>
 <param name="file"></param>
 <param name="env"></param>
 <returns>
 a folder liked list object
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.file.openGzip(System.Object,System.String,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 decompression of a gzip file and get the deflate file data stream.
 </summary>
 <param name="file">
 the file path or file stream data.
 </param>
 <param name="tmpfileWorker">
 using tempfile for process the large data file which its file length 
 is greater then the memorystream its upbound capacity.
 </param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.file.buffer(SMRUCC.Rsharp.Runtime.Serialize.BufferObjects,System.String,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 create a new buffer object
 </summary>
 <param name="type">the r-sharp internal buffer data type</param>
 <param name="mime">the data mime-type for http response, some buffer 
 object type may required of this parameter for specific the correct 
 mine content type.</param>
 <returns></returns>
 <remarks>
 this function usually works for the http web services.
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.file.tempfile(System.Object,System.String,System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ### Create Names for Temporary Files
 
 ``tempfile`` returns a vector of character strings 
 which can be used as names for temporary files.
 </summary>
 <param name="pattern">a non-empty character vector giving the initial part of the name.</param>
 <param name="tmpdir">a non-empty character vector giving the directory name</param>
 <param name="fileext">a non-empty character vector giving the file extension</param>
 <returns>
 a character vector giving the names of possible (temporary) files. 
 Note that no files are generated by tempfile.
 </returns>
 <remarks>
 The length of the result is the maximum of the lengths of the three arguments; 
 values of shorter arguments are recycled.

 The names are very likely To be unique among calls To tempfile In an R session 
 And across simultaneous R sessions (unless tmpdir Is specified). The filenames 
 are guaranteed Not To be currently In use.

 The file name Is made by concatenating the path given by tmpdir, the pattern 
 String, a random String In hex And a suffix Of fileext.

 By Default, tmpdir will be the directory given by tempdir(). This will be a 
 subdirectory of the per-session temporary directory found by the following 
 rule when the R session Is started. The environment variables TMPDIR, TMP And TEMP 
 are checked in turn And the first found which points to a writable directory Is 
 used: If none succeeds the value Of R_USER (see Rconsole) Is used. If the path 
 To the directory contains a space In any Of the components, the path returned will 
 use the shortnames version Of the path. Note that setting any Of these environment 
 variables In the R session has no effect On tempdir(): the per-session temporary 
 directory Is created before the interpreter Is started.
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.file.tempdir(System.Boolean)">
 <summary>
 ### Create Names For Temporary Files
 </summary>
 <param name="check">
 logical indicating if ``tmpdir()`` should be checked and recreated if no longer valid.
 </param>
 <returns>the path of the per-session temporary directory.</returns>
 <remarks>
 + On Windows, both will use a backslash as the path separator.
 + On a Unix-alike, the value will be an absolute path (unless tmpdir Is set to a relative path), 
   but it need Not be canonical (see normalizePath) And on macOS it often Is Not.
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.file.fileRename(System.String,System.String,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 File renames
 </summary>
 <param name="from">character vectors, containing file names Or paths.</param>
 <param name="to">character vectors, containing file names Or paths.</param>
 <param name="env"></param>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.file.fileRemove(System.String[],System.Nullable{System.Boolean},SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ## Delete files or directories
 
 ``file.remove`` attempts to remove the files named 
 in its argument. On most Unix platforms ‘file’ 
 includes empty directories, symbolic links, fifos 
 and sockets. On Windows, ‘file’ means a regular file 
 and not, say, an empty directory.
 </summary>
 <param name="x">
 character vectors, containing file names or paths.
 </param>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.file.unlinks(System.String[],SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 Delete files or directories
 </summary>
 <remarks>
 this function is the alias name of the function
 ``file.remove``.
 </remarks>
 <param name="x"></param>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.file.erase(System.String,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 delete all contents in target directory
 </summary>
 <param name="dir"></param>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.file.isSystemDir(System.String)">
 <summary>
 Check of the given directory path is a system internal directory
 or not.
 
 The system directories are:
 + Windows: c:\, c:/, c:, c:\program files, c:\program files (x86), c:\windows, c:\windows\system32, c:\windows\syswow64
 + Linux: /bin, /boot, /dev, /etc, /home, /lib, /lib64, /media, /mnt, /opt, /root, /run, /sbin, /srv, /sys, /usr, /var
 </summary>
 <param name="dir"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.file.dataUri(System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 read file as data URI string
 </summary>
 <param name="file">the file path</param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.file.bytes(System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 create a in-memory byte stream object
 </summary>
 <param name="byts"></param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Internal.Invokes.LinqPipeline.dataframe_methods">
 <summary>
 some common dataframe operations
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.LinqPipeline.dataframe_methods.aggregate_eval(System.Object,System.Object,System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ### Compute Summary Statistics of Data Subsets
 
 Splits the data into subsets, computes summary statistics for each, 
 and returns the result in a convenient form.
 </summary>
 <param name="x">an R object. For the formula method a formula, such as y ~ x or cbind(y1, y2) ~ x1 + x2,
 where the y variables are numeric data to be split into groups according to the grouping 
 x variables (usually factors).</param>
 <param name="by">
 a list of grouping elements, each as long as the variables in the data frame x. 
 The elements are coerced to factors before use.
 </param>
 <param name="FUN">
 a function to compute the summary statistics which can be applied to 
 all data subsets.
 </param>
 <param name="env"></param>
 <returns></returns>
 <example>
 # create data frame
 df &lt;- data.frame(team     = c('A', 'A', 'A', 'B', 'B', 'B'),
                     position = c('G', 'G', 'F', 'G', 'F', 'F'),
                     points   = c(99, 90, 86, 88, 95, 99),
                     assists  = c(33, 28, 31, 39, 34, 23),
                     rebounds = c(30, 28, 24, 24, 28, 33));
 
 # view data frame
 print(df);
 
 #            team position    points   assists  rebounds
 # -------------------------------------------------------
 # &lt;mode> &lt;string> &lt;string> &lt;integer> &lt;integer> &lt;integer>
 # [1, ]       "A"      "G"        99        33        30
 # [2, ]       "A"      "G"        90        28        28
 # [3, ]       "A"      "F"        86        31        24
 # [4, ]       "B"      "G"        88        39        24
 # [5, ]       "B"      "F"        95        34        28
 # [6, ]       "B"      "F"        99        23        33
 
 # find mean points by team
 aggregate(df$points, by=list(df$team), FUN=mean);
 
 #           Group        x
 # ------------------------
 # &lt;mode> &lt;string> &lt;double>
 # A           "A"  91.6667
 # B           "B"       94
 
 # or 
 aggregate(df, by = points ~ team, FUN = mean);
 
 #           Group        x
 # ------------------------
 # &lt;mode> &lt;string> &lt;double>
 # A           "A"  91.6667
 # B           "B"       94
 
 # get aggregate function demo
 #
 let f = aggregate(FUN = "mean");
 
 # is equalient as the expression mean
 f([1,2,3,4,5]);
 mean([1,2,3,4,5]);
 </example>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.LinqPipeline.dataframe_methods.colSums(SMRUCC.Rsharp.Runtime.Internal.Object.dataframe,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 colSums: Form Row and Column Sums and Means
 
 Form row and column sums and means for numeric arrays (or data frames).
 </summary>
 <param name="x">
 an array of two or more dimensions, containing numeric, 
 complex, integer or logical values, or a numeric data 
 frame. For .colSums() etc, a numeric, integer or logical 
 matrix (or vector of length m * n).
 </param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.LinqPipeline.dataframe_methods.rename(SMRUCC.Rsharp.Runtime.Internal.Object.dataframe,SMRUCC.Rsharp.Runtime.Internal.Object.list,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 renames the dataframe object its specific column fields
 </summary>
 <param name="x"></param>
 <param name="renames">
 a collection of name mapping lambda, liked: ``a -> b``
 </param>
 <param name="env"></param>
 <returns>
 this function will returns nothing if the given dataframe object is nothing
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.LinqPipeline.dataframe_methods.rank_unique(SMRUCC.Rsharp.Runtime.Internal.Object.dataframe,System.String,System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 make rank unique of the element rows inside a dataframe
 </summary>
 <param name="x"></param>
 <param name="duplicates">
 the column field name which contains the duplictaed keys for the element rows.
 </param>
 <param name="ranking">the column field name for the ranking score or 
 a numeric vector of the ranking scores for each corresponding element
 rows.</param>
 <param name="env"></param>
 <returns>a new dataframe object with duplicated rows removed</returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.LinqPipeline.dataframe_methods.merge(SMRUCC.Rsharp.Runtime.Internal.Object.dataframe,SMRUCC.Rsharp.Runtime.Internal.Object.dataframe,System.Object,System.Object,System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ### Merge Two Data Frames
 
 Merge two data frames by common columns or row names, or do other versions of database join operations.
 </summary>
 <param name="x">data frames, or objects To be coerced To one.</param>
 <param name="y">data frames, or objects To be coerced To one.</param>
 <param name="by">specifications of the columns used for merging.</param>
 <param name="env"></param>
 <returns>
 A data frame. The rows are by default lexicographically sorted on the common columns, but for 
 sort = FALSE are in an unspecified order. The columns are the common columns followed by the 
 remaining columns in x and then those in y. If the matching involved row names, an extra character 
 column called Row.names is added at the left, and in all cases the result has ‘automatic’ row 
 names.
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.LinqPipeline.dplyr.bind_rows(SMRUCC.Rsharp.Runtime.Internal.Object.list,System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 Bind multiple data frames by row
 
 Bind any number of data frames by row, making a longer result. 
 This is similar to do.call(rbind, dfs), but the output will 
 contain all columns that appear in any of the inputs.
 </summary>
 <param name="x">
 Data frames To combine. Each argument can either be a data frame, 
 a list that could be a data frame, Or a list Of data frames.
 Columns are matched by name, And any missing columns will be
 filled With NA.
 </param>
 <param name="_id">
 The name Of an Optional identifier column. Provide a String To 
 create an output column that identifies Each input. The column 
 will use names If available, otherwise it will use positions.
 </param>
 <param name="env"></param>
 <returns>
 A data frame the same type as the first element of ....
 </returns>
 <example>
 df1 &lt;- tibble(x = 1:2, y = letters[1:2])
 df2 &lt;- tibble(x = 4:5, z = 1:2)
 
 # You can supply individual data frames as arguments:
 bind_rows(df1, df2)
 
 # Or a list of data frames:
 bind_rows(list(df1, df2))
 
 # When you supply a column name with the `.id` argument, a new
 # column is created to link each row to its original data frame
 bind_rows(list(df1, df2), .id = "id")
 bind_rows(list(a = df1, b = df2), .id = "id")
 </example>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Internal.Invokes.LinqPipeline.Group">
 <summary>
 Elements in <see cref="F:SMRUCC.Rsharp.Runtime.Internal.Invokes.LinqPipeline.Group.group"/> have a common <see cref="F:SMRUCC.Rsharp.Runtime.Internal.Invokes.LinqPipeline.Group.key"/>
 </summary>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Internal.Invokes.LinqPipeline.Group.Item(System.Int32)">
 <summary>
 get by 0 based index
 </summary>
 <param name="i"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.LinqPipeline.Group.getByName(System.String)">
 <summary>
 just supports get data via 'key' or 'group'
 </summary>
 <param name="name"></param>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Internal.Invokes.LinqPipeline.keyIndex">
 <summary>
 get key name index for the lapply/parLapply
 </summary>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Internal.Invokes.LinqPipeline.linq">
 <summary>
 Provides a set of static (Shared in Visual Basic) methods for querying objects
 that implement System.Collections.Generic.IEnumerable`1.
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.LinqPipeline.linq.left_join(SMRUCC.Rsharp.Runtime.Internal.Object.dataframe,SMRUCC.Rsharp.Runtime.Internal.Object.dataframe,System.Object,System.Object,System.Object,System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 A left join is a type of relational join operation that combines 
 two datasets based on a common column or variable. The result of 
 a left join includes all the rows from the left dataset and any 
 matching rows from the right dataset.
 </summary>
 <param name="left"></param>
 <param name="right"></param>
 <param name="by">the field name that used for join two data table, if the field name that 
 specific by this parameter is existsed in both <paramref name="left"/> and 
 <paramref name="right"/>.
 
 this parameter option also could be an integer value 1-based.
 </param>
 <param name="grep">
 text grep expression for the index key string value, see ``text_grep``.
 </param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.LinqPipeline.linq.progress(System.Object,System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 apply for the pipeline progress report
 </summary>
 <param name="x">
 the pipeline object or a progress number if 
 current function invoke is occurs in a parallel 
 task.
 </param>
 <param name="msgFunc">a text message to display or function for show message</param>
 <param name="env"></param>
 <returns></returns>
 <remarks>
 value range of parameter <paramref name="x"/> should be in numeric 
 range ``[0,100]`` if the progress function is invoked in a parallel 
 stack environment.
 </remarks>
 <example>
 # just used for display the progress
 progress(20);
 # [SET_PROGRESS] 20% Pipeline progress report
 
 x 
 |> progress("display progress info")
 |> blablabla()
 ;
 </example>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.LinqPipeline.linq.fastIndexing(System.Array,System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 create data index for the given input data sequence
 </summary>
 <param name="x">a data array as sequence</param>
 <param name="mode">the element mode of the data input seuqnce <paramref name="x"/></param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.LinqPipeline.linq.take(System.Object,System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 take the first n items from the given input sequence data 
 </summary>
 <param name="sequence">the input sequence data</param>
 <param name="n">the number of first n element</param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.LinqPipeline.linq.match(System.Array,System.Array,System.Int32,System.Int32)">
 <summary>
 ### Value Matching
 
 match returns a vector of the positions of 
 (first) matches of its first argument in 
 its second.
 
 find the index of the elements in input sequence
 <paramref name="x"/> in the source target sequence
 <paramref name="table"/>
 
 find the index of (where x in table)
 </summary>
 <param name="x">
 vector or NULL: the values to be matched. Long 
 vectors are supported.
 </param>
 <param name="table">
 vector or NULL: the values to be matched against. 
 Long vectors are not supported. (using as index 
 object.)
 </param>
 <param name="nomatch">
 the value to be returned in the case when no 
 match is found. Note that it is coerced to 
 integer.
 </param>
 <param name="incomparables">
 a vector of values that cannot be matched. 
 Any value in x matching a value in this vector 
 is assigned the nomatch value. For historical 
 reasons, FALSE is equivalent to NULL.
 </param>
 <returns>
 A vector of the same length as x.
 An integer vector giving the position in table of 
 the first match if there Is a match, otherwise 
 nomatch.
 If x[i] Is found To equal table[j] Then the value 
 returned In the i-th position Of the Return value 
 Is j, For the smallest possible j. If no match Is 
 found, the value Is nomatch.
 </returns>
 <remarks>
 https://stackoverflow.com/questions/7530765/get-the-index-of-the-values-of-one-vector-in-another
 
 ```r
 first  = c("a", "c", "b");
 second = c("c", "b", "a");
 match(second, first);
 
 #   c b a  &lt;-second 
 [1] 2 3 1
 ```
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.LinqPipeline.linq.skip(System.Object,System.Int32,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 Bypasses a specified number of elements in a sequence and then 
 returns the remaining elements.
 </summary>
 <param name="sequence">An System.Collections.Generic.IEnumerable`1 to return elements from.</param>
 <param name="n">The number of elements to skip before returning the remaining elements.</param>
 <returns>An System.Collections.Generic.IEnumerable`1 that contains the elements that occur
 after the specified index in the input sequence.</returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.LinqPipeline.linq.unique(System.Object,SMRUCC.Rsharp.Runtime.Components.Interface.RFunction,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 Returns distinct elements from a sequence by using a specified 
 IEqualityComparer to compare values.
 </summary>
 <param name="items">The sequence to remove duplicate elements from.</param>
 <param name="getKey">An IEqualityComparer to compare values.</param>
 <param name="envir"></param>
 <returns>An IEnumerable that contains distinct elements from
 the source sequence.</returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.LinqPipeline.linq.projectAs(System.Object,SMRUCC.Rsharp.Runtime.Components.Interface.RFunction,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 A lapply/sapply liked mapping function
 </summary>
 <param name="sequence"></param>
 <param name="project"></param>
 <param name="envir"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.LinqPipeline.linq.where(System.Object,System.Object,System.Boolean,System.Boolean,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ### Which indices are TRUE?
 
 The which test filter, Give the TRUE indices of a logical 
 object, allowing for array indices.
 </summary>
 <param name="env"></param>
 <param name="x">
 a logical vector or array. NAs are allowed and omitted
 (treated as if FALSE).
 </param>
 <param name="first">
 get the first index element where the assert is TRUE, this parameter
 works for test expression is nothing
 </param>
 <returns>
 an integer vector with length equal to sum(x), i.e., to 
 the number of TRUEs in x; Basically, the result is 
 ``(1:length(x))[x]``.
 </returns>
 <remarks>
 Unlike most other base R functions this does not coerce to 
 x to logical: only arguments with typeof logical are 
 accepted and others give an error.
 </remarks>
 <example>
 x = [TRUE FALSE FALSE TRUE];
 
 print(which(x));
 # [1] 1 4
 
 # just returns the first element index which is assert as TRUE
 print(which(x, first = TRUE));
 # [1] 1
 </example>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.LinqPipeline.linq.whichMax(System.Object,System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 Where is the Min() or Max() or first TRUE or FALSE ?
 
 Determines the location, i.e., index of the (first) minimum or maximum of a 
 numeric (or logical) vector.
 </summary>
 <param name="x">
 numeric (logical, integer or double) vector or an R object for which the internal 
 coercion to double works whose min or max is searched for.
 </param>
 <param name="eval"></param>
 <param name="env"></param>
 <returns>
 Missing and NaN values are discarded.
 
 an integer Or on 64-bit platforms, if length(x) = n>= 2^31 an integer valued 
 double of length 1 Or 0 (iff x has no non-NAs), giving the index of the first 
 minimum Or maximum respectively of x.
 
 If this extremum Is unique (Or empty), the results are the same As (but more 
 efficient than) ``which(x == min(x, na.rm = True))`` Or 
 ``which(x == max(x, na.rm = True))`` respectively.
 
 Logical x – First True Or False
 
 For a logical vector x with both FALSE And TRUE values, which.min(x) And 
 which.max(x) return the index of the first FALSE Or TRUE, respectively, as 
 FALSE &lt; TRUE. However, match(FALSE, x) Or match(TRUE, x) are typically 
 preferred, as they do indicate mismatches.
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.LinqPipeline.linq.whichMin(System.Object,System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 Where is the Min() or Max() or first TRUE or FALSE ?
 
 Determines the location, i.e., index of the (first) minimum or maximum of a 
 numeric (or logical) vector.
 </summary>
 <param name="x">
 numeric (logical, integer or double) vector or an R object for which the internal 
 coercion to double works whose min or max is searched for.
 </param>
 <param name="eval"></param>
 <param name="env"></param>
 <returns>
 Missing and NaN values are discarded.
 
 an integer Or on 64-bit platforms, if length(x) = n>= 2^31 an integer valued 
 double of length 1 Or 0 (iff x has no non-NAs), giving the index of the first 
 minimum Or maximum respectively of x.
 
 If this extremum Is unique (Or empty), the results are the same As (but more 
 efficient than) which(x == min(x, na.rm = True)) Or which(x == max(x, na.rm = True)) 
 respectively.
 
 Logical x – First True Or False
 
 For a logical vector x with both FALSE And TRUE values, which.min(x) And 
 which.max(x) return the index of the first FALSE Or TRUE, respectively, as 
 FALSE &lt; TRUE. However, match(FALSE, x) Or match(TRUE, x) are typically 
 preferred, as they do indicate mismatches.
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.LinqPipeline.linq.first(System.Object,SMRUCC.Rsharp.Runtime.Components.Interface.RFunction,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 Returns the first element of a sequence.
 </summary>
 <param name="sequence">
 The System.Collections.Generic.IEnumerable`1 to return 
 the first element of.
 </param>
 <param name="test">An element test assert lambda function
 for find the first element which matched with this test 
 condition</param>
 <param name="envir"></param>
 <returns>The first element in the specified sequence. NULL
 value will be returned if there is no element could be found
 in the given seuqnece or under the given <paramref name="test"/>
 condition.</returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.LinqPipeline.linq.last(System.Object,SMRUCC.Rsharp.Runtime.Components.Interface.RFunction,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 get the last element in the sequence
 </summary>
 <param name="sequence">a general data sequence</param>
 <param name="test">
 if this test function is nothing, then means get the last element in 
 the sequence. else if the function is not nothing, then means get the
 last element that which meet this test condition in the sequence
 data input.
 </param>
 <param name="envir"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.LinqPipeline.linq.groupBy(System.Object,System.Object,System.Boolean,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 group vector/list by a given evaluator or group a dataframe rows
 by the cell values of a specific column.
 </summary>
 <param name="sequence"></param>
 <param name="getKey"></param>
 <param name="env"></param>
 <returns></returns>
 <remarks>
 this function could also accept a numeric tolerance error as the
 <paramref name="getKey"/> for do numeric bin grouping
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.LinqPipeline.linq.produceKeyedSequence(System.Func{System.Object,System.Object},System.Object,SMRUCC.Rsharp.Runtime.Environment,SMRUCC.Rsharp.Runtime.Components.Message@)">
 <summary>
 get key value from the input data sequence and 
 then populate the key with the original value 
 elements.
 </summary>
 <param name="keyBy"></param>
 <param name="sequence"></param>
 <param name="env"></param>
 <param name="err"></param>
 <returns>
 ***** element names will be returns as object reference 
 if the given <paramref name="sequence"/> is a 
 list. *****
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.LinqPipeline.linq.sort(System.Object,System.Boolean,System.Boolean)">
 <summary>
 ### Sorting or Ordering Vectors
 
 Sort (or order) a vector or factor (partially) into ascending 
 or descending order. For ordering along more than one variable, 
 e.g., for sorting data frames, see order.
 </summary>
 <param name="x">
 For sort an R object with a class Or a numeric, complex, 
 character Or logical vector. For sort.int, a numeric, complex, 
 character Or logical vector, Or a factor.
 </param>
 <param name="decreasing">
 logical. Should the sort be increasing or decreasing? For the 
 "radix" method, this can be a vector of length equal to the 
 number of arguments in .... For the other methods, it must be 
 length one. Not available for partial sorting.
 </param>
 <param name="na_last">
 for controlling the treatment of NAs. If TRUE, missing values 
 in the data are put last; if FALSE, they are put first; if NA, 
 they are removed.
 </param>
 <remarks>
 sort is a generic function for which methods can be written, and 
 sort.int is the internal method which is compatible with S if 
 only the first three arguments are used.
 The Default sort method makes use Of order For classed objects, 
 which In turn makes use Of the generic Function xtfrm (And can be 
 slow unless a xtfrm method has been defined Or Is.numeric(x) Is 
 True).
 Complex values are sorted first by the real part, Then the imaginary 
 part.
 The "auto" method selects "radix" for short (less than 2^31 elements) 
 numeric vectors, integer vectors, logical vectors And factors; 
 otherwise, "shell".
 Except for method "radix", the sort order for character vectors will 
 depend on the collating sequence of the locale in use: see Comparison. 
 The sort order For factors Is the order Of their levels (which Is 
 particularly appropriate For ordered factors).
 If partial Is Not NULL, it Is taken to contain indices of elements of 
 the result which are to be placed in their correct positions in the 
 sorted array by partial sorting. For each of the result values in 
 a specified position, any values smaller than that one are guaranteed 
 to have a smaller index in the sorted array And any values which 
 are greater are guaranteed to have a bigger index in the sorted array. 
 (This Is included for efficiency, And many of the options are Not 
 available for partial sorting. It Is only substantially more efficient 
 if partial has a handful of elements, And a full sort Is done (a 
 Quicksort if possible) if there are more than 10.) Names are discarded 
 for partial sorting.
 Method "shell" uses Shellsort (an O(n^{4/3}) variant from Sedgewick 
 (1986)). If x has names a stable modification Is used, so ties are Not 
 reordered. (This only matters if names are present.)
 Method "quick" uses Singleton (1969)'s implementation of Hoare's 
 Quicksort method and is only available when x is numeric (double or 
 integer) and partial is NULL. (For other types of x Shellsort is used, 
 silently.) It is normally somewhat faster than Shellsort (perhaps 50% 
 faster on vectors of length a million and twice as fast at a billion)
 but has poor performance in the rare worst case. (Peto's modification 
 using a pseudo-random midpoint is used to make the worst case rarer.) 
 This is not a stable sort, and ties may be reordered.
 Method "radix" relies on simple hashing to scale time linearly with 
 the input size, i.e., its asymptotic time complexity Is O(n). The specific 
 variant And its implementation originated from the data.table package 
 And are due to Matt Dowle And Arun Srinivasan. For small inputs (&lt; 200), 
 the implementation uses an insertion sort (O(n^2)) that operates in-place 
 to avoid the allocation overhead of the radix sort. For integer vectors 
 of range less than 100,000, it switches to a simpler And faster linear 
 time counting sort. In all cases, the sort Is stable; the order of ties 
 Is preserved. It Is the default method for integer vectors And factors.
 The "radix" method generally outperforms the other methods, especially 
 for character vectors And small integers. Compared to quick sort, it Is 
 slightly faster for vectors with large integer Or real values (but unlike 
 quick sort, radix Is stable And supports all na.last options). The 
 implementation Is orders of magnitude faster than shell sort for character 
 vectors, in part thanks to clever use of the internal CHARSXP table.
 However, there are some caveats with the radix sort
 If x Is a character vector, all elements must share the same encoding. 
 Only UTF-8 (including ASCII) And Latin-1 encodings are supported. Collation 
 always follows the "C" locale.
 Long vectors(with more than 2^32 elements) And complex vectors are Not 
 supported yet.
 </remarks>
 <returns>
 For sort, the result depends on the S3 method which is dispatched. If 
 x does not have a class sort.int is used and it description applies. 
 For classed objects which do not have a specific method the default method 
 will be used and is equivalent to x[order(x, ...)]: this depends on the 
 class having a suitable method for [ (and also that order will work, 
 which requires a xtfrm method).
 For sort.int the value Is the sorted vector unless index.return Is true, 
 when the result Is a list with components named x And ix containing the 
 sorted numbers And the ordering index vector. In the latter case, if 
 method == "quick" ties may be reversed in the ordering (unlike sort.list) 
 as quicksort Is Not stable. For method == "radix", index.return Is 
 supported for all na.last modes. The other methods only support index.return 
 when na.last Is NA. The index vector refers To element numbers after removal 
 Of NAs: see order If you want the original element numbers.
 All attributes are removed from the Return value (see Becker et al, 1988, 
 p.146) except names, which are sorted. (If Partial Is specified even the 
 names are removed.) Note that this means that the returned value has no 
 Class, except For factors And ordered factors (which are treated specially 
 And whose result Is transformed back To the original Class).
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.LinqPipeline.linq.orderBy(System.Object,System.Object,System.Boolean,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 Sorts the elements of a sequence in ascending order according to a key.
 </summary>
 <param name="sequence">A sequence of values to order.</param>
 <param name="getKey">
 A function to extract a key from an element. and this parameter value 
 can also be the field name or column name to sort.
 </param>
 <param name="envir"></param>
 <returns>
 An System.Linq.IOrderedEnumerable`1 whose elements are sorted according 
 to a key. The sort result could be situations:
 
 1. a vector which is sort by the element evaluated value
 2. a list which is sort by the specific element value
 3. a dataframe which is sort its rows by a specific column value
 
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.LinqPipeline.linq.reverse(System.Object)">
 <summary>
 reverse a given sequence
 </summary>
 <param name="sequence"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.LinqPipeline.linq.any(System.Object,System.Boolean)">
 <summary>
 # Are Some Values True?
 
 Given a set of logical vectors, is at least one of the values true?
 </summary>
 <param name="test">
 zero or more logical vectors. Other objects of zero length are ignored, 
 and the rest are coerced to logical ignoring any class.
 </param>
 <param name="narm">
 logical. If true NA values are removed before the result Is computed.
 </param>
 <returns>
 The value is a logical vector of length one.

 Let x denote the concatenation of all the logical vectors in ... 
 (after coercion), after removing NAs if requested by na.rm = TRUE.
 
 The value returned Is True If at least one Of the values In x Is True, 
 And False If all Of the values In x are False (including If there are 
 no values). Otherwise the value Is NA (which can only occur If 
 na.rm = False And ... contains no True values And at least one NA 
 value).
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.LinqPipeline.linq.all(System.Object,System.Boolean)">
 <summary>
 # Are All Values True?
 
 Given a set of logical vectors, are all of the values true?
 </summary>
 <param name="test">zero or more logical vectors. Other objects of zero 
 length are ignored, and the rest are coerced to logical ignoring any 
 class.</param>
 <param name="narm">
 logical. If true NA values are removed before the result is computed.
 </param>
 <returns>
 The value is a logical vector of length one.

 Let x denote the concatenation of all the logical vectors in ... 
 (after coercion), after removing NAs if requested by na.rm = TRUE.

 The value returned Is True If all Of the values In x are True 
 (including If there are no values), And False If at least one Of 
 the values In x Is False. Otherwise the value Is NA (which can 
 only occur If na.rm = False And ... contains no False values And 
 at least one NA value).
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.LinqPipeline.linq.split(System.Object,System.Object,SMRUCC.Rsharp.Runtime.Internal.Object.list,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 split content sequence with a given condition as element delimiter.
 </summary>
 <param name="x">a given data sequence</param>
 <param name="delimiter">
 an element test function to determine that element is a delimiter object
 </param>
 <param name="argv">
 + parts: will split the input sequence into n(parts = n) multiple parts
 + size: will split the input sequence into m multiple parts, and each part size is n(size=n)
 </param>
 <param name="env"></param>
 <returns></returns>
 <remarks>
 the generated result is different between the vector/list:
 
 + for vector data: split the value array directly
 + for list data: split the list keys array and then break the input list 
       data into multiple parts by keys
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.LinqPipeline.linq.select(SMRUCC.Rsharp.Runtime.Internal.Object.dataframe,System.Boolean,SMRUCC.Rsharp.Runtime.Internal.Object.list,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ### Keep or drop columns using their names and types
 
 Select (and optionally rename) variables in a data frame, using a 
 concise mini-language that makes it easy to refer to variables 
 based on their name (e.g. a:f selects all columns from a on the 
 left to f on the right) or type (e.g. where(is.numeric) selects all
 numeric columns).
 </summary>
 <param name="_data">
 A data frame, data frame extension (e.g. a tibble), or a lazy data 
 frame (e.g. from dbplyr or dtplyr). See Methods, below, for more 
 details.
 </param>
 <param name="selectors">
 &lt;tidy-select> One or more unquoted expressions separated by commas. 
 Variable names can be used as if they were positions in the data frame, 
 so expressions like x:y can be used to select a range of variables.
 
 syntax for the selectors:
 
 1. select by name: ``select(name1, name2)``
 2. field renames: ``select(name1 -> data1)``
 </param>
 <param name="strict">
 By default when this function running in strict mode, an error message 
 will be returned if there is a missing data fields exists in the selector
 list
 </param>
 <param name="env"></param>
 <returns>
 An object of the same type as .data. The output has the following properties:

 1. Rows are Not affected.
 2. Output columns are a subset Of input columns, potentially With a 
    different order. Columns will be renamed If new_name = old_name 
    form Is used.
 3. Data frame attributes are preserved.
 4. Groups are maintained; you can't select off grouping variables.
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.LinqPipeline.parallelApplys.parallelList(System.Collections.IDictionary,SMRUCC.Rsharp.Runtime.Components.Interface.RFunction,System.Int32,System.Int32,System.Boolean,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 
 </summary>
 <param name="list"></param>
 <param name="apply"></param>
 <param name="group"></param>
 <param name="n_threads"></param>
 <param name="verbose"></param>
 <param name="envir"></param>
 <returns>
 the returns result value sequence keeps the 
 same order with the input sequence.
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.LinqPipeline.parallelApplys.deepCloneContext(SMRUCC.Rsharp.Runtime.Environment,System.String)">
 <summary>
 try to make a deep clone of the environment context for run parallel code.
 </summary>
 <param name="env">
 due to the reason of make deep copy of this environment context, 
 so that the global variable value update in the parallel code
 may not effect the environment context in the main thread.
 
 in this point of view, keep less global variable reference will
 be better in parallel
 </param>
 <returns>
 modification of the environment context in the parallel closure 
 will not affects the parent environment context 
 <paramref name="env"/>. 
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.LinqPipeline.reshape2.tuple(System.Object,SMRUCC.Rsharp.Runtime.Internal.Object.list,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 Aggregate two or more sequence
 </summary>
 <param name="zip"></param>
 <param name="args"></param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.LinqPipeline.reshape2.melt(System.Object,System.Boolean,System.String,SMRUCC.Rsharp.Runtime.Internal.Object.list,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 melt: Convert an object into a molten data frame.
 
 This the generic melt function. See the following functions 
 for the details about different data structures
 </summary>
 <param name="data">Data set to melt</param>
 <param name="na_rm">Should NA values be removed from the data set? 
 This will convert explicit missings to implicit missings.</param>
 <param name="value_name">name of variable used to store values</param>
 <param name="args">
 further arguments passed To Or from other methods.
 </param>
 <param name="env"></param>
 <returns>
 1. melt.data.frame for data.frames
 2. melt.array for arrays, matrices And tables
 3. melt.list for lists
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.LinqPipeline.reshape2.shift(System.Object,System.Object,System.Object,System.Object,System.Boolean,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ### shift: Fast lead/lag for vectors and lists
 
 lead or lag vectors, lists, data.frames or data.tables implemented in VisualBasic for speed.
 
 shift accepts vectors, lists, data.frames or data.tables. It always 
 returns a list except when the input is a vector and length(n) == 1 
 in which case a vector is returned, for convenience. This is so that 
 it can be used conveniently within data.table's syntax. For example, 
 DT[, (cols) := shift(.SD, 1L), by=id] would lag every column of .SD by
 1 for each group and DT[, newcol := colA + shift(colB)] would assign 
 the sum of two vectors to newcol.

 Argument n allows multiple values. For example, DT[, (cols) := shift(.SD, 1:2), by=id] 
 would lag every column of .SD by 1 And 2 for each group. If .SD contained
 four columns, the first two elements of the list would correspond to 
 lag=1 And lag=2 for the first column of .SD, the next two for second 
 column of .SD And so on. Please see examples for more.

 shift Is designed mainly for use in data.tables along with := Or set. 
 Therefore, it returns an unnamed list by default as assigning names for 
 each group over And over can be quite time consuming with many groups. 
 It may be useful to set names automatically in other cases, which can 
 be done by setting give.names to TRUE.
 </summary>
 <param name="x">
 A vector, list, data.frame Or data.table.</param>
 <param name="n">integer vector denoting the offset by which 
 to lead or lag the input. To create multiple lead/lag vectors, 
 provide multiple values to n; negative values of n will "flip" 
 the value of type, i.e., n=-1 and type='lead' is the same as 
 n=1 and type='lag'.
 
 this parameter could also be a character vector of the names for 
 removes from a given list, if the input x is a tuple list object
 </param>
 <param name="fill">
 Value to use for padding when the window goes beyond the input 
 length.
 </param>
 <param name="type">default is "lag" (look "backwards"). The other 
 possible values "lead" (look "forwards") and "shift" (behave same 
 as "lag" except given names).</param>
 <param name="give_names">default is FALSE which returns an unnamed
 list. When TRUE, names are automatically generated corresponding 
 to type and n. If answer is an atomic vector, then the argument 
 is ignored.</param>
 <returns>
 A list containing the lead/lag of input x.
 </returns>
 <remarks>
 The function behavior is different at here when compare with the 
 ``shift`` function of the ``data.table`` package from the original
 R language: the shift function from R language not allow the <paramref name="fill"/>
 data be nothing, but the ``shift`` function in R# language will 
 behavior a different result: when the <paramref name="fill"/> value
 is nothing at here, this function will becomes skip for <paramref name="type"/>
 is ``lag`` or ``shift`` and this function will becomes take for <paramref name="type"/>
 is ``lead``.
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.LinqPipeline.reshape2.flip_list(SMRUCC.Rsharp.Runtime.Internal.Object.list,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 flip the list key-value pair mapping to value-key pair mapping
 </summary>
 <param name="l">Should be a tuple list object</param>
 <param name="env"></param>
 <returns></returns>
 <remarks>
 this function only works for the value is character vector, 
 null value inside the list will be ignored
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.LinqPipeline.reshape2.decompose(SMRUCC.Rsharp.Runtime.Internal.Object.dataframe,System.String,System.String,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 split dataframe by a cell string value split result
 </summary>
 <param name="df"></param>
 <param name="by">the colname for do the cell content split</param>
 <param name="split">the delimiter string expression for split the cell contents</param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.LinqPipeline.reshape2.decompose(SMRUCC.Rsharp.Runtime.Internal.Object.dataframe,System.Int32,System.String,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 split dataframe by a cell string value split result
 </summary>
 <param name="df"></param>
 <param name="by">the column index</param>
 <param name="split">the delimiter string for split the text in a cell</param>
 <param name="env"></param>
 <returns>A new dataframe object that split by the 
 given column its cell text value</returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.LinqPipeline.reshape2.ConstructDataframe(System.Collections.Generic.IReadOnlyCollection{Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedCollection{System.Object}},System.String[])">
 <summary>
 Re-construct a dataframe object from a given set of the row data.
 </summary>
 <param name="rows">the row data collection</param>
 <param name="cols">the column names</param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.LinqPipeline.reshape2.vector_fill(System.Object,SMRUCC.Rsharp.Runtime.Internal.Object.list,System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 fill content which is indexed by a given value list
 </summary>
 <param name="x"></param>
 <param name="values"></param>
 <param name="index"></param>
 <param name="env"></param>
 <returns></returns>
 <remarks>
 the length of vector <paramref name="x"/> should be 
 equals to the length of <paramref name="index"/>.
 </remarks>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Internal.Invokes.math">
 <summary>
 R# math module
 </summary>
 
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.math.floor(System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ### Rounding of Numbers
 
 floor takes a single numeric argument x and returns a 
 numeric vector containing the largest integers not
 greater than the corresponding elements of x.
 </summary>
 <param name="x">
 a numeric vector. Or, for round and signif, a complex vector.
 </param>
 <param name="env"></param>
 <returns></returns>
 <remarks>
 These are generic functions: methods can be defined 
 for them individually or via the Math group generic.
 
 Note that for rounding off a 5, the IEC 60559 standard 
 (see also ‘IEEE 754’) is expected to be used, ‘go to 
 the even digit’. Therefore round(0.5) is 0 and 
 round(-1.5) is -2. However, this is dependent on OS 
 services and on representation error (since e.g. 0.15 
 is not represented exactly, the rounding rule applies 
 to the represented number and not to the printed number, 
 and so round(0.15, 1) could be either 0.1 or 0.2).
 
 Rounding to a negative number of digits means rounding 
 to a power of ten, so for example round(x, digits = -2) 
 rounds to the nearest hundred.
 
 For signif the recognized values of digits are 1...22, 
 and non-missing values are rounded to the nearest integer 
 in that range. Complex numbers are rounded to retain the 
 specified number of digits in the larger of the components. 
 Each element of the vector is rounded individually, 
 unlike printing.
 
 These are all primitive functions.
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.math.ceiling(System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ### Rounding of Numbers
 
 ceiling takes a single numeric argument x and returns
 a numeric vector containing the smallest integers not 
 less than the corresponding elements of x.
 </summary>
 <param name="x">
 a numeric vector. Or, for round and signif, a complex vector.
 </param>
 <param name="env"></param>
 <returns></returns>
 <remarks>
 These are generic functions: methods can be defined 
 for them individually or via the Math group generic.
 
 Note that for rounding off a 5, the IEC 60559 standard 
 (see also ‘IEEE 754’) is expected to be used, ‘go to 
 the even digit’. Therefore round(0.5) is 0 and 
 round(-1.5) is -2. However, this is dependent on OS 
 services and on representation error (since e.g. 0.15 
 is not represented exactly, the rounding rule applies 
 to the represented number and not to the printed number, 
 and so round(0.15, 1) could be either 0.1 or 0.2).
 
 Rounding to a negative number of digits means rounding 
 to a power of ten, so for example round(x, digits = -2) 
 rounds to the nearest hundred.
 
 For signif the recognized values of digits are 1...22, 
 and non-missing values are rounded to the nearest integer 
 in that range. Complex numbers are rounded to retain the 
 specified number of digits in the larger of the components. 
 Each element of the vector is rounded individually, 
 unlike printing.
 
 These are all primitive functions.
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.math.trunc(System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ### Rounding of Numbers
 
 trunc takes a single numeric argument x and returns a 
 numeric vector containing the integers formed by truncating 
 the values in x toward 0.
 </summary>
 <param name="x">
 a numeric vector. Or, for round and signif, a complex vector.
 </param>
 <param name="env"></param>
 <returns></returns>
 <remarks>
 These are generic functions: methods can be defined 
 for them individually or via the Math group generic.
 
 Note that for rounding off a 5, the IEC 60559 standard 
 (see also ‘IEEE 754’) is expected to be used, ‘go to 
 the even digit’. Therefore round(0.5) is 0 and 
 round(-1.5) is -2. However, this is dependent on OS 
 services and on representation error (since e.g. 0.15 
 is not represented exactly, the rounding rule applies 
 to the represented number and not to the printed number, 
 and so round(0.15, 1) could be either 0.1 or 0.2).
 
 Rounding to a negative number of digits means rounding 
 to a power of ten, so for example round(x, digits = -2) 
 rounds to the nearest hundred.
 
 For signif the recognized values of digits are 1...22, 
 and non-missing values are rounded to the nearest integer 
 in that range. Complex numbers are rounded to retain the 
 specified number of digits in the larger of the components. 
 Each element of the vector is rounded individually, 
 unlike printing.
 
 These are all primitive functions.
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.math.sign(System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ### Sign Function
 
 sign returns a vector with the signs of the corresponding 
 elements of x (the sign of a real number is 1, 0, or -1−1 
 if the number is positive, zero, or negative, respectively).
 
 Note that sign does not operate on complex vectors.
 </summary>
 <param name="x">a numeric vector</param>
 <param name="env"></param>
 <returns></returns>
 <remarks>
 This is an internal generic primitive function: methods can 
 be defined for it directly or via the Math group generic.
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.math.isNaN(System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ## Finite, Infinite and NaN Numbers
 
 is.finite and is.infinite return a vector of the same 
 length as x, indicating which elements are finite 
 (not infinite and not missing) or infinite.
 
 Inf And -Inf are positive And negative infinity whereas
 NaN means 'Not a Number’. (These apply to numeric values 
 and real and imaginary parts of complex values but not 
 to values of integer vectors.) Inf and NaN are reserved 
 words in the R language.
 </summary>
 <param name="x">
 R object to be tested: the default methods handle atomic 
 vectors.
 </param>
 <param name="env"></param>
 <returns>
 A logical vector of the same length as x: dim, dimnames 
 and names attributes are preserved.
 </returns>
 <remarks>
 is.nan tests if a numeric value is NaN. Do not test equality 
 to NaN, or even use identical, since systems typically have
 many different NaN values. One of these is used for the 
 numeric missing value NA, and is.nan is false for that value. 
 A complex number is regarded as NaN if either the real or 
 imaginary part is NaN but not NA. All elements of logical, 
 integer and raw vectors are considered not to be NaN.

 All three functions accept NULL As input And Return a length 
 zero result. The Default methods accept character And raw vectors, 
 And Return False For all entries. Prior To R version 2.14.0 
 they accepted all input, returning False For most non-numeric 
 values; cases which are Not atomic vectors are now signalled 
 As errors.

 All three functions are generic: you can write methods To handle 
 specific classes Of objects, see InternalMethods.
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.math.isFinite(System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ## Finite, Infinite and NaN Numbers
 
 is.finite and is.infinite return a vector of the same length 
 as x, indicating which elements are finite (not infinite and 
 not missing) or infinite.
 </summary>
 <param name="x">
 R object to be tested: the default methods handle atomic vectors.
 </param>
 <param name="env"></param>
 <returns>
 A logical vector of the same length as x: dim, dimnames and 
 names attributes are preserved.
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.math.isInfinite(System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ## Finite, Infinite and NaN Numbers
 
 is.finite and is.infinite return a vector of the same length as 
 x, indicating which elements are finite (not infinite and not 
 missing) or infinite.
 </summary>
 <param name="x">
 R object to be tested: the default methods handle atomic vectors.
 </param>
 <param name="env"></param>
 <returns>
 A logical vector of the same length as x: dim, dimnames and names 
 attributes are preserved.
 </returns>
 <remarks>
 is.infinite returns a vector of the same length as x the jth 
 element of which is TRUE if x[j] is infinite (i.e., equal to one
 of Inf or -Inf) and FALSE otherwise. This will be false unless x 
 is numeric or complex. Complex numbers are infinite if either the
 real or the imaginary part is.
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.math.diff(System.Object)">
 <summary>
 ### Lagged Differences
 
 Returns suitably lagged and iterated differences.
 </summary>
 <param name="x">
 a numeric vector Or matrix containing the values To be differenced.
 </param>
 <returns></returns>
 <remarks>
 is.finite returns a vector of the same length as x the jth 
 element of which is TRUE if x[j] is finite (i.e., it is not 
 one of the values NA, NaN, Inf or -Inf) and FALSE otherwise. 
 Complex numbers are finite if both the real and imaginary 
 parts are.
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.math.round(System.Object,System.Int32)">
 <summary>
 rounds the values in its first argument to the specified number of decimal places (default 0). 
 See *'Details'* about "round to even" when rounding off a 5.
 </summary>
 <param name="x">a numeric vector. Or, for ``round`` and ``signif``, a complex vector.</param>
 <param name="decimals">
 integer indicating the number of decimal places (``round``) or significant digits (``signif``) to be used. 
 Negative values are allowed (see *'Details'*).
 </param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.math.log(System.Object,System.Double)">
 <summary>
 computes logarithms, by default natural logarithms, log10 computes common (i.e., base 10) logarithms, 
 and log2 computes binary (i.e., base 2) logarithms. 
 The general form log(x, base) computes logarithms with base base.
 </summary>
 <param name="x">a numeric or complex vector.</param>
 <param name="newBase">
 a positive or complex number: the base with respect to which logarithms are computed. 
 Defaults to ``e=exp(1)``.
 </param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.math.log1p(System.Object)">
 <summary>
 Computes log(1+x) without losing precision for small values of x.
 </summary>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.math.log1m(System.Object)">
 <summary>
 Computes log(1-x) without losing precision for small values of x.
 </summary>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.math.log2(System.Object)">
 <summary>
 ### Logarithms and Exponentials
 
 log2 computes binary (i.e., base 2) logarithms. 
 </summary>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.math.log10(System.Object)">
 <summary>
 ### Logarithms and Exponentials
 
 log10 computes common (i.e., base 10) logarithms
 </summary>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.math.cos(System.Object)">
 <summary>
 evaluate the cosine alpha
 </summary>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.math.prod(System.Object,System.Boolean)">
 <summary>
 Product of Vector Elements
 
 prod returns the product of all the values present in its arguments.
 </summary>
 <param name="x">numeric or complex or logical vectors.</param>
 <param name="na_rm">
 logical. Should missing values be removed?
 </param>
 <returns>The product, a numeric (of type "double") or complex vector of length one. NB: the product of an empty set is one, by definition.</returns>
 <remarks>
 If na.rm is FALSE an NA value in any of the arguments will cause a value of NA to be returned, otherwise NA values are ignored.
 This is a generic function: methods can be defined for it directly or via the Summary group generic. For this to work properly, the arguments ... should be unnamed, and dispatch is on the first argument.
 Logical true values are regarded as one, false values as zero. For historical reasons, NULL is accepted and treated as if it were numeric(0).
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.math.sum(System.Object,System.Boolean)">
 <summary>
 #### Sum of Vector Elements
 
 sum returns the sum of all the values present in its arguments.
 </summary>
 <param name="x">numeric or complex or logical vectors.</param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.math.exp(System.Array)">
 <summary>
 #### Logarithms and Exponentials
 
 computes the exponential function.
 </summary>
 <param name="x">a numeric or complex vector.</param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.math.max(System.Object,System.Boolean,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 
 </summary>
 <param name="x"></param>
 <param name="na_rm">a logical indicating whether missing values should be removed.</param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.math.min(System.Object,System.Boolean,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 
 </summary>
 <param name="x"></param>
 <param name="na_rm">
 a logical indicating whether missing values should be removed.
 </param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.math.mean(System.Object,System.Boolean)">
 <summary>
 Arithmetic Mean
 </summary>
 <param name="x">An R object. Currently there are methods for numeric/logical 
 vectors and date, date-time and time interval objects. Complex vectors are 
 allowed for trim = 0, only.</param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.math.weighted_mean(System.Object,System.Object)">
 <summary>
 ### Weighted Arithmetic Mean
 
 Compute a weighted mean.
 </summary>
 <param name="x">
 an object containing the values whose weighted mean is to be computed.
 </param>
 <param name="w">
 a numerical vector of weights the same length as x giving the weights to use for elements of x.
 </param>
 <returns>For the default method, a length-one numeric vector.</returns>
 <remarks>
 This is a generic function and methods can be defined for the first
 argument x: apart from the default methods there are methods for the
 date-time classes "POSIXct", "POSIXlt", "difftime" and "Date". The 
 default method will work for any numeric-like object for which [,
 multiplication, division and sum have suitable methods, including 
 complex vectors.
 
 If w is missing then all elements of x are given the same weight, otherwise 
 the weights are normalized to sum to one (if possible: if their sum
 is zero or infinite the value is likely to be NaN).
 
 Missing values in w are not handled specially and so give a missing value as 
 the result. However, zero weights are handled specially and the 
 corresponding x values are omitted from the sum.
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.math.median(System.Object,System.Boolean)">
 <summary>
 ### Median Value
 
 Compute the sample median.
 </summary>
 <param name="x">an object for which a method has been defined, 
 or a numeric vector containing the values whose median is to 
 be computed.</param>
 <param name="na_rm">
 a logical value indicating whether NA values should be stripped 
 before the computation proceeds.
 </param>
 <returns>
 The default method returns a length-one object of the same type 
 as x, except when x is logical or integer of even length, when 
 the result will be double.
 
 If there are no values Or If na.rm = False And there are NA 
 values the result Is NA Of the same type As x (Or more generally 
 the result Of x[FALSE][NA]).
 </returns>
 <remarks>
 This is a generic function for which methods can be written. 
 However, the default method makes use of is.na, sort and mean 
 from package base all of which are generic, and so the default 
 method will work for most classes (e.g., "Date") for which 
 a median is a reasonable concept.
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.math.abs(System.Object)">
 <summary>
 abs(x) computes the absolute value of x
 </summary>
 <param name="x">a numeric Or complex vector Or array.</param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.math.rsd(System.Object)">
 <summary>
 ## relative standard deviation
 
 Relative standard deviation is a common formula 
 used in statistics and probability theory to determine
 a standardized measure of the ratio of the standard
 deviation to the mean. This formula is useful in
 various situations including when comparing your 
 own data to other related data and in financial 
 settings such as the stock market.
 
 Relative standard deviation, which also may be referred 
 to as RSD or the coefficient of variation, is used 
 to determine if the standard deviation of a set of 
 data is small or large when compared to the mean.
 In other words, the relative standard deviation can
 tell you how precise the average of your results is.
 This formula is most frequently used in chemistry, 
 statistics and other math-related settings but can 
 also be used in the business world when assessing
 finances and the stock market.
 
 The relative standard deviation Of a Set Of data can be
 depicted As either a percentage Or As a number. The 
 higher the relative standard deviation, the more spread 
 out the results are from the mean Of the data. On the
 other hand, a lower relative standard deviation means 
 that the measurement Of data Is more precise.
 </summary>
 <param name="x"></param>
 <returns></returns>
 
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.math.sd(System.Object,System.Boolean)">
 <summary>
 ### Standard Deviation
 
 This function computes the standard deviation of the values in x. 
 If na.rm is TRUE then missing values are removed before computation 
 proceeds.
 </summary>
 <param name="x">
 a numeric vector or an R object but not a factor coercible to numeric by as.double(x)
 </param>
 <param name="sample">
 sample or population
 </param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.math.pearson(System.Object,System.Object,System.Int32,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ## Pearson Correlation Testing in R Programming
 
 Correlation is a statistical measure that indicates 
 how strongly two variables are related. It involves 
 the relationship between multiple variables as well. 
 For instance, if one is interested to know whether 
 there is a relationship between the heights of fathers 
 and sons, a correlation coefficient can be calculated 
 to answer this question. Generally, it lies between 
 -1 and +1. It is a scaled version of covariance and 
 provides the direction and strength of a relationship. 
 
 this function measure a Parametric Correlation – Pearson correlation(r): 
 It measures a linear dependence between two variables (x and y) 
 is known as a parametric correlation test because it depends on 
 the distribution of the data.
 
 Pearson Rank Correlation is a parametric correlation. 
 The Pearson correlation coefficient is probably the most
 widely used measure for linear relationships between two 
 normal distributed variables and thus often just called 
 "correlation coefficient". 
 </summary>
 <param name="x"></param>
 <param name="y"></param>
 <param name="MAXIT"></param>
 <returns>
 1. r takes a value between -1 (negative correlation) and 1 (positive correlation).
 2. r = 0 means no correlation.
 3. Can Not be applied to ordinal variables.
 4. The sample size should be moderate (20-30) For good estimation.
 5. Outliers can lead To misleading values means Not robust With outliers.
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.math.cor_test(System.Double[],System.Double[],System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ### Test for Association/Correlation Between Paired Samples
 
 Test for association between paired samples, using one of 
 Pearson's product moment correlation coefficient, Kendall's 
 \tauτ or Spearman's \rhoρ.
 </summary>
 <param name="x">numeric vectors of data values. x and y must have the same length.</param>
 <param name="y">numeric vectors of data values. x and y must have the same length.</param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.math.set_seed(System.Int32)">
 <summary>
 set.seed is the recommended way to specify seeds.
 </summary>
 <param name="seed">
 a single value, interpreted as an integer, 
 or NULL (see ‘Details’).
 </param>
 <remarks>
 set.seed returns NULL, invisibly.
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.math.getRandom">
 <summary>
 get a random number value between ``[0,1]``.
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.math.runif(System.Int32,System.Double,System.Double)">
 <summary>
 runif generates random deviates.
 </summary>
 <param name="n">
 number of observations. If length(n) > 1, the length is taken to be the number required.
 </param>
 <param name="min">lower And upper limits of the distribution. Must be finite.</param>
 <param name="max">lower And upper limits of the distribution. Must be finite.</param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.math.rexp(System.Int32,System.Double)">
 <summary>
 ### The Exponential Distribution
 
 Density, distribution function, quantile function and random generation for the exponential 
 distribution with rate rate (i.e., mean 1/rate).
 </summary>
 <param name="n">number of observations. If length(n) > 1, the length is taken to be the number required.</param>
 <param name="rate">vector of rates.</param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.math.rnorm(System.Int32,System.Double,System.Double)">
 <summary>
 ### The Normal Distribution
 
 Density, distribution function, quantile function and random generation for 
 the normal distribution with mean equal to mean and standard deviation equal 
 to sd.
 </summary>
 <param name="n">	
 number of observations. If length(n) > 1, the length is taken to 
 be the number required.
 </param>
 <param name="mean">vector of means.</param>
 <param name="sd">vector of standard deviations.</param>
 <returns></returns>
 <remarks>
 dnorm gives the density, 
 pnorm gives the distribution function, 
 qnorm gives the quantile function, 
 and rnorm generates random deviates.
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.math.sample(System.Object,System.Object,System.Boolean,System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ### Random Samples and Permutations
 
 ``sample`` takes a sample of the specified size from the elements 
 of x using either with or without replacement.
 </summary>
 <param name="x">
 either a vector Of one Or more elements from which To choose, Or a positive Integer. See 'Details.’
 </param>
 <param name="size">a non-negative integer giving the number of items to choose.</param>
 <param name="replace">should sampling be with replacement?</param>
 <param name="prob">
 a vector Of probability weights For obtaining the elements Of the vector being sampled.
 </param>
 <remarks>
 If x has length 1, is numeric (in the sense of is.numeric) and ``x >= 1``, sampling 
 via sample takes place from ``1:x``. Note that this convenience feature may lead to 
 undesired behaviour when x is of varying length in calls such as sample(x). 
 See the examples.

 Otherwise x can be any R Object For which length And subsetting by integers make sense: 
 S3 Or S4 methods for these operations will be dispatched as appropriate.

 For sample the default for size Is the number of items inferred from the first argument, 
 so that sample(x) generates a random permutation of the elements of x (Or 1:x).

 It Is allowed to ask for size = 0 samples with n = 0 Or a length-zero x, but otherwise 
 ``n > 0`` Or positive length(x) Is required.

 Non-integer positive numerical values of n Or x will be truncated to the next smallest 
 integer, which has to be no larger than ``.Machine$integer.max``.

 The optional prob argument can be used to give a vector of weights for obtaining the elements 
 of the vector being sampled. They need Not sum to one, but they should be non-negative And 
 Not all zero. If replace Is true, Walker's alias method (Ripley, 1987) is used when there 
 are more than 200 reasonably probable values: this gives results incompatible with those 
 from ``R &lt; 2.2.0``.

 If replace Is False, these probabilities are applied sequentially, that Is the probability 
 Of choosing the Next item Is proportional To the weights amongst the remaining items. The 
 number Of nonzero weights must be at least size In this Case.
 </remarks>
 <returns>
 For sample a vector of length size with elements drawn from either ``x`` or from the 
 integers ``1:x``.
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.math.sample_int(System.Int32,System.Object,System.Boolean,System.Object)">
 <summary>
 
 </summary>
 <param name="n"></param>
 <param name="size"></param>
 <param name="replace"></param>
 <param name="prob"></param>
 <returns>
 returns an integer vector that could be used for represents the element index
 the generated integer vector in this function is base from 1 
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.math.cluster1D(System.Object,System.Object,System.Double,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 grouping data input by given numeric tolerance
 </summary>
 <param name="sequence"></param>
 <param name="eval">
 this parameter should be a lambda function which 
 evaluate a numeric value for each elements in 
 the given sequence data.
 </param>
 <param name="offset">
 the max tolerance error of the cluster data
 </param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.math.var(System.Object,System.Object,System.Boolean,SMRUCC.Rsharp.Runtime.Internal.Invokes.varUseMethods)">
 <summary>
 ### Correlation, Variance and Covariance (Matrices)
 
 var, cov and cor compute the variance of x and the covariance or 
 correlation of x and y if these are vectors. If x and y are 
 matrices then the covariances (or correlations) between the columns 
 of x and the columns of y are computed.
 </summary>
 <param name="x">a numeric vector, matrix or data frame.</param>
 <param name="y">
 NULL (default) or a vector, matrix or data frame with compatible dimensions to x. 
 The default is equivalent to y = x (but more efficient).
 </param>
 <param name="na_rm">logical. Should missing values be removed?</param>
 <param name="use">
 an optional character string giving a method for computing covariances 
 in the presence of missing values. This must be (an abbreviation of) 
 one of the strings "everything", "all.obs", "complete.obs", "na.or.complete", 
 or "pairwise.complete.obs".</param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.math.cor(System.Object,System.Object,System.Object,System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ### Correlation, Variance and Covariance (Matrices)
 
 var, cov and cor compute the variance of x and the covariance or 
 correlation of x and y if these are vectors. If x and y are matrices 
 then the covariances (or correlations) between the columns of x and
 the columns of y are computed.
 </summary>
 <param name="x">a numeric vector, matrix or data frame.</param>
 <param name="y">NULL (default) or a vector, matrix or data frame 
 with compatible dimensions to x. The default is equivalent to 
 y = x (but more efficient).</param>
 <param name="use">an optional character string giving a method for
 computing covariances in the presence of missing values. This must
 be (an abbreviation of) one of the strings "everything", "all.obs",
 "complete.obs", "na.or.complete", or "pairwise.complete.obs".
 </param>
 <param name="method">a character string indicating which correlation 
 coefficient (or covariance) is to be computed. One of "pearson" 
 (default), "kendall", or "spearman": can be abbreviated.</param>
 <param name="env"></param>
 <returns>
 For r &lt;- cor(*, use = "all.obs"), it is now guaranteed that all(abs(r) &lt;= 1).
 </returns>
 <remarks>
 For cov and cor one must either give a matrix or data frame for x 
 or give both x and y.
 
 The inputs must be numeric (as determined by is.numeric: logical 
 values are also allowed for historical compatibility): the "kendall" 
 and "spearman" methods make sense for ordered inputs but xtfrm can 
 be used to find a suitable prior transformation to numbers.

 var is just another interface to cov, where na.rm is used to determine 
 the default for use when that is unspecified. If na.rm is TRUE then 
 the complete observations (rows) are used (use = "na.or.complete") to 
 compute the variance. Otherwise, by default use = "everything".

 If use is "everything", NAs will propagate conceptually, i.e., a 
 resulting value will be NA whenever one of its contributing observations 
 is NA.

 If use is "all.obs", then the presence of missing observations will 
 produce an error. If use is "complete.obs" then missing values are 
 handled by casewise deletion (and if there are no complete cases, 
 that gives an error).
 
 "na.or.complete" is the same unless there are no complete cases, that gives
 NA. Finally, if use has the value "pairwise.complete.obs" then the 
 correlation or covariance between each pair of variables is computed 
 using all complete pairs of observations on those variables. This can 
 result in covariance or correlation matrices which are not positive 
 semi-definite, as well as NA entries if there are no complete pairs 
 for that pair of variables. For cov and var, "pairwise.complete.obs" 
 only works with the "pearson" method. Note that (the equivalent of) 
 var(double(0), use = *) gives NA for use = "everything" and "na.or.complete", 
 and gives an error in the other cases.

 The denominator n - 1n−1 is used which gives an unbiased estimator of 
 the (co)variance for i.i.d. observations. These functions return NA 
 when there is only one observation (whereas S-PLUS has been returning 
 NaN).

 For cor(), if method is "kendall" or "spearman", Kendall's \tauτ or Spearman's 
 \rhoρ statistic is used to estimate a rank-based measure of association. 
 These are more robust and have been recommended if the data do not 
 necessarily come from a bivariate normal distribution.
 
 For cov(), a non-Pearson method is unusual but available for the sake of 
 completeness. Note that "spearman" basically computes cor(R(x), R(y)) (or 
 cov(., .)) where R(u) := rank(u, na.last = "keep"). In the case of missing 
 values, the ranks are calculated depending on the value of use, either 
 based on complete observations, or based on pairwise completeness with 
 reranking for each pair.

 When there are ties, Kendall's \tau_bτ b
 is computed, as proposed by Kendall (1945).

 Scaling a covariance matrix into a correlation one can be achieved in 
 many ways, mathematically most appealing by multiplication with a 
 diagonal matrix from left and right, or more efficiently by using 
 sweep(.., FUN = "/") twice. The cov2cor function is even a bit more 
 efficient, and provided mostly for didactical reasons.
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.math.lcm_r(System.Object,System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 Function to calculate the Least Common Multiple (LCM)
 </summary>
 <param name="a"></param>
 <param name="b"></param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.math.root(System.Object,System.Int32,System.Double)">
 <summary>
 finds root of specific degree of number.
 </summary>
 <param name="x">should be a numeric vector</param>
 <param name="n">
 Degree of root.
 </param>
 <param name="eps">
 Precision with which the calculations are performed. value should be in range (0,1).
 </param>
 <returns>Root of number.</returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.ranking.rank(System.Double[],System.Boolean,Microsoft.VisualBasic.Math.Correlations.Ranking.Strategies)">
 <summary>
 ### Sample Ranks
 
 Returns the sample ranks of the values in a vector. Ties 
 (i.e., equal values) and missing values can be handled in
 several ways.
 </summary>
 <param name="x">a numeric, complex, character Or logical vector.</param>
 <param name="na_last">	
 For controlling the treatment of NAs. If TRUE, missing values in the 
 data are put last; if FALSE, they are put first; if NA, they are 
 removed; if "keep" they are kept with rank NA.</param>
 <param name="ties_method">
 a character string specifying how ties are treated, see ‘Details’; 
 can be abbreviated.
 </param>
 <returns>
 A numeric vector of the same length as x with names copied from x 
 (unless na.last = NA, when missing values are removed). The vector is 
 of integer type unless x is a long vector or ties.method = "average" when 
 it is of double type (whether or not there are any ties).
 </returns>
 <remarks>
 If all components are different (and no NAs), the ranks are well defined, 
 with values in seq_along(x). With some values equal (called ‘ties’), 
 the argument ties.method determines the result at the corresponding indices. 
 The "first" method results in a permutation with increasing values at each 
 index set of ties, and analogously "last" with decreasing values. The 
 "random" method puts these in random order whereas the default, "average", 
 replaces them by their mean, and "max" and "min" replaces them by their 
 maximum and minimum respectively, the latter being the typical sports 
 ranking.

 NA values are never considered to be equal: for na.last = TRUE and ``na.last = FALSE``
 they are given distinct ranks in the order in which they occur in x.

 NB: rank is not itself generic but xtfrm is, and rank(xtfrm(x), ....) will have 
 the desired result if there is a xtfrm method. Otherwise, rank will make use 
 of ==, >, is.na and extraction methods for classed objects, possibly rather 
 slowly.
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.ranking.order(System.Array,System.Boolean,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ### Ordering Permutation
 
 order returns a permutation which rearranges its first argument 
 into ascending or descending order, breaking ties by further 
 arguments. sort.list is the same, using only one argument.
 </summary>
 <param name="x">a sequence of numeric, complex, character or 
 logical vectors, all of the same length, or a classed R object.
 </param>
 <param name="decreasing">
 logical. Should the sort order be increasing or decreasing? 
 For the "radix" method, this can be a vector of length equal to 
 the number of arguments in .... For the other methods, it must 
 be length one.</param>
 <returns>An integer vector unless any of the inputs has 2^31 or 
 more elements, when it is a double vector.</returns>
 <remarks>
 In the case of ties in the first vector, values in the second are 
 used to break the ties. If the values are still tied, values in 
 the later arguments are used to break the tie (see the first 
 example). The sort used is stable (except for method = "quick"), 
 so any unresolved ties will be left in their original ordering.

 Complex values are sorted first by the real part, then the imaginary 
 part.

 Except for method "radix", the sort order for character vectors will 
 depend on the collating sequence of the locale in use: see 
 Comparison.

 The "shell" method is generally the safest bet and is the default 
 method, except for short factors, numeric vectors, integer vectors 
 and logical vectors, where "radix" is assumed. Method "radix" stably 
 sorts logical, numeric and character vectors in linear time. It 
 outperforms the other methods, although there are caveats (see sort). 
 Method "quick" for sort.list is only supported for numeric x with 
 na.last = NA, is not stable, and is slower than "radix".

 partial = NULL is supported for compatibility with other implementations 
 of S, but no other values are accepted and ordering is always complete.

 For a classed R object, the sort order is taken from xtfrm: as its help 
 page notes, this can be slow unless a suitable method has been defined 
 or is.numeric(x) is true. For factors, this sorts on the internal 
 codes, which is particularly appropriate for ordered factors.
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.time.days(System.Double)">
 <summary>
 create time span from given days value.
 </summary>
 <param name="d"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.time.time_span(System.Double,System.Double,System.Double,System.Double)">
 <summary>
 create timespan value
 </summary>
 <param name="seconds"></param>
 <param name="minutes"></param>
 <param name="hours"></param>
 <param name="days"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.reflections.attr(System.Object,System.String,System.Boolean,System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ### Object Attributes
 
 Get or set specific attributes of an object.
 </summary>
 <param name="x">an object whose attributes are to be accessed.</param>
 <param name="which">a non-empty character string specifying which attribute is to be accessed.</param>
 <param name="exact">logical: should which be matched exactly?</param>
 <param name="value">an object, the new value of the attribute, or NULL to remove the attribute.</param>
 <param name="env"></param>
 <returns>For the extractor, the value of the attribute matched, or NULL if no exact 
 match is found and no or more than one partial match is found.</returns>
 <remarks>
 These functions provide access to a single attribute of an object. The replacement 
 form causes the named attribute to take the value specified (or create a new attribute
 with the value given).
 
 The extraction Function first looks For an exact match To which amongst the attributes 
 Of x, Then (unless exact = True) a unique Partial match. (Setting options(warnPartialMatchAttr = True) 
 causes Partial matches To give warnings.)
 
 The replacement Function only uses exact matches.
 
 Note that some attributes (namely Class, comment, Dim, dimnames, names, row.names And tsp) 
 are treated specially And have restrictions On the values which can be Set. (Note that 
 this Is Not True Of levels which should be Set For factors via the levels replacement 
 Function.)
 
 The extractor Function allows (And does Not match) empty And missing values Of which: the 
 replacement Function does Not.
 
 NULL objects cannot have attributes And attempting To assign one by attr gives an Error.
 
 Both are primitive functions.
 </remarks>
 <example>
 # create a 2 by 5 matrix
 x &lt;- 110
 attr(x,"dim") &lt;- c(2, 5)
 </example>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.reflections.attributes(System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ### Object Attribute Lists
 
 These functions access an object's attributes. The first form 
 below returns the object's attribute list. The replacement 
 forms uses the list on the right-hand side of the assignment 
 as the object's attributes (if appropriate).
 </summary>
 <param name="x">any R object</param>
 <returns></returns>
 <remarks>
 Unlike attr it is not an error to set attributes on a NULL object:
 it will first be coerced to an empty list.
 
 Note that some attributes (namely Class, comment, Dim, dimnames, 
 names, row.names And tsp) are treated specially And have restrictions
 On the values which can be Set. (Note that this Is Not True Of 
 levels which should be Set For factors via the levels replacement 
 Function.)
 
 Attributes are Not stored internally As a list And should be thought
 Of As a Set And Not a vector, i.e, the order Of the elements Of 
 attributes() does Not matter. This Is also reflected by identical()'s
 behaviour with the default argument attrib.as.set = TRUE. Attributes 
 must have unique names (and NA is taken as "NA", not a missing value).
 
 Assigning attributes first removes all attributes, Then sets any Dim 
 attribute And Then the remaining attributes In the order given: this
 ensures that setting a Dim attribute always precedes the dimnames 
 attribute.
 
 The mostattributes assignment takes special care For the Dim, names And
 dimnames attributes, And assigns them only When known To be valid 
 whereas an attributes assignment would give an Error If any are Not. 
 It Is principally intended For arrays, And should be used With care
 On classed objects. For example, it does Not check that row.names
 are assigned correctly For data frames.
 
 The names Of a pairlist are Not stored As attributes, but are reported 
 As If they were (And can be Set by the replacement form Of attributes).
 
 NULL objects cannot have attributes And attempts To assign them will
 promote the Object To an empty list. Both assignment And replacement
 forms Of attributes are primitive functions.
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.reflections.getClass(System.Object)">
 <summary>
 ### Object Classes
 
 R possesses a simple generic function mechanism which 
 can be used for an object-oriented style of programming. 
 Method dispatch takes place based on the class of the 
 first argument to the generic function.
 </summary>
 <param name="x">a R object</param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.reflections.formals(System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ### Access to and Manipulation of the Formal Arguments
 
 Get or set the formal arguments of a function.
 
 For the first form, fun can also be a character string naming 
 the function to be manipulated, which is searched for from the 
 parent frame. If it is not specified, the function calling 
 formals is used.

 Only closures have formals, Not primitive functions.
 </summary>
 <param name="fun">a Function, Or see 'Details’.</param>
 <param name="env">environment in which the function should be defined.</param>
 <returns>
 formals returns the formal argument list of the function specified, 
 as a pairlist, or NULL for a non-function or primitive.
 
 The replacement form sets the formals Of a Function To the list/pairlist 
 On the right hand side, And (potentially) resets the environment Of 
 the Function.
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.reflections.eval(System.Object,SMRUCC.Rsharp.Runtime.Internal.Object.dataframe,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ### Evaluate an (Unevaluated) Expression
 
 Evaluate an R expression in a specified environment.
 </summary>
 <param name="expr">an object to be evaluated. See 'Details’.</param>
 <param name="env">the environment In which expr Is To be evaluated. 
 May also be NULL, a list, a data frame, a pairlist Or an Integer 
 As specified To sys.Call.</param>
 <returns>
 The result of evaluating the object: for an expression vector this is 
 the result of evaluating the last element.
 </returns>
 <remarks>
 eval evaluates the expr argument in the environment specified by envir 
 and returns the computed value. If envir is not specified, then the 
 default is parent.frame() (the environment where the call to eval was 
 made).
 
 Objects to be evaluated can be of types call Or expression Or name 
 (when the name Is looked up in the current scope And its binding Is 
 evaluated), a promise Or any of the basic types such as vectors, 
 functions And environments (which are returned unchanged).
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.reflections.parse(System.String,System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ### Parse Expressions
 
 parse returns the parsed but unevaluated expressions in a list.
 </summary>
 <param name="text">
 character vector. The text to parse. Elements are treated as if 
 they were lines of a file. Other R objects will be coerced to 
 character if possible.
 </param>
 
 <param name="file">
 a connection, or a character String giving the name Of a file Or a URL To read 
 the expressions from. If file Is "" And text Is missing Or NULL Then input 
 Is taken from the console.
 </param>
 
 <returns>An object of type "expression", with up to n elements if 
 specified as a non-negative integer.
 
 A syntax error (including an incomplete expression) will throw an error.
 
 Character strings In the result will have a declared encoding 
 If encoding Is "latin1" Or "UTF-8", Or If text Is supplied With 
 every element Of known encoding In a Latin-1 Or UTF-8 locale.
 </returns>
 
 <remarks>
 If text has length greater than zero (after coercion) it is used 
 in preference to file.
 
 All versions Of R accept input from a connection With End Of line
 marked by LF (As used On Unix), CRLF (As used On DOS/Windows) Or 
 CR (As used On classic Mac OS). The final line can be incomplete, 
 that Is missing the final EOL marker.
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.reflections.sys_calls(SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 Functions to Access the Function Call Stack
 
 These functions provide access to environments (‘frames’ in S terminology) 
 associated with functions further up the calling stack.
 </summary>
 <returns>
 sys.calls and sys.frames give a pairlist of all the active calls and 
 frames, respectively, and sys.parents returns an integer vector of 
 indices of the parent frames of each of those frames.
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.reflections.sys_call(System.Int32,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 Functions to Access the Function Call Stack
 
 These functions provide access to environments (‘frames’ in S terminology) 
 associated with functions further up the calling stack.
 </summary>
 <param name="which">	
 the frame number If non-negative, the number Of frames To go back If negative.
 </param>
 <returns>
 sys.call, sys.function and sys.frame accept integer values for the 
 argument which. Non-negative values of which are frame numbers starting 
 from .GlobalEnv whereas negative values are counted back from the frame 
 number of the current evaluation.
 </returns>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Internal.Invokes.set">
 <summary>
 Set Operations
 </summary>
 
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.set.unset(System.Object,SMRUCC.Rsharp.Runtime.Internal.Object.list,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 unset — Unset the feature slots value from a given variable
 </summary>
 <param name="x">
 should be a tuple list object or dataframe object
 </param>
 <param name="args">the features names to deletes from the given object <paramref name="x"/>.</param>
 <param name="env"></param>
 <returns></returns>
 <remarks>
 the orginal object will be modified by this function
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.set.table(System.String[],System.Nullable{System.Boolean})">
 <summary>
 ### Cross Tabulation and Table Creation
 
 table uses the cross-classifying factors to build
 a contingency table of the counts at each combination 
 of factor levels.
 </summary>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.set.setdiff(System.Array,System.Array,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ### setdiff: Set Difference of Subsets
 </summary>
 <returns></returns>
 
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.set.rev(System.Object,SMRUCC.Rsharp.Runtime.Internal.Object.list,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ## Reverse Elements
 
 rev provides a reversed version of its argument. 
 It is generic function with a default method for 
 vectors and one for dendrograms.
 
 Note that this Is no longer needed (nor efficient) 
 For obtaining vectors sorted into descending order,
 since that Is now rather more directly achievable 
 by sort(x, decreasing = True).
 </summary>
 <param name="x">
 a vector Or another Object For which reversal Is 
 defined.
 </param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.set.count(System.Array)">
 <summary>
 is a ``table`` liked function for count string occurance number
 </summary>
 <param name="str">
 A character vector that may contains the
 duplicated string value
 </param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.set.intersect(System.Object,System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 Performs set intersection
 </summary>
 <param name="x">vectors (of the same mode) containing a sequence of items (conceptually) with no duplicated values.</param>
 <param name="y">vectors (of the same mode) containing a sequence of items (conceptually) with no duplicated values.</param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.set.union(System.Object,System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 Performs set union
 </summary>
 <param name="x">vectors (of the same mode) containing a sequence of items (conceptually) with no duplicated values.</param>
 <param name="y">vectors (of the same mode) containing a sequence of items (conceptually) with no duplicated values.</param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.set.indexOf(System.Object,System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 Create the hash index for element search
 </summary>
 <param name="x"></param>
 <param name="getKey">extract a character vector from one of the elements 
 inside the collection x, using as the index key.</param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.set.match_val_against(SMRUCC.Rsharp.Runtime.Internal.Object.list,System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 create subset of the given <paramref name="listSet"/> via 
 tuple value match against with the given 
 <paramref name="index_set"/>.
 </summary>
 <param name="listSet"></param>
 <param name="index_set"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.set.duplicated(System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ### Determine Duplicate Elements
 
 ``duplicated()`` determines which elements of a vector or data frame 
 are duplicates of elements with smaller subscripts, and returns a 
 logical vector indicating which elements (rows) are duplicates.
 </summary>
 <param name="x">a vector Or a data frame Or an array Or NULL.</param>
 <returns>duplicated(): For a vector input, a logical vector of the 
 same length as x. For a data frame, a logical vector with one element 
 for each row. For a matrix or array, and when MARGIN = 0, a logical 
 array with the same dimensions and dimnames.</returns>
 <remarks>
 These are generic functions with methods for vectors (including lists), data frames 
 and arrays (including matrices).

 For the default methods, And whenever there are equivalent method definitions for 
 duplicated And anyDuplicated, anyDuplicated(x, ...) Is a “generalized” shortcut 
 for any(duplicated(x, ...)), in the sense that it returns the index i of the first 
 duplicated entry x[i] if there Is one, And 0 otherwise. Their behaviours may be 
 different when at least one of duplicated And anyDuplicated has a relevant method.

 duplicated(x, fromLast = TRUE) Is equivalent to but faster than rev(duplicated(rev(x))).

 The data frame method works by pasting together a character representation Of the 
 rows separated by \r, so may be imperfect If the data frame has characters With 
 embedded carriage returns Or columns which Do Not reliably map To characters.

 The array method calculates For Each element Of the Sub-array specified by MARGIN 
 If the remaining dimensions are identical To those For an earlier (Or later, When 
 fromLast = True) element (In row-major order). This would most commonly be used 
 To find duplicated rows (the Default) Or columns (With MARGIN = 2). Note that 
 MARGIN = 0 returns an array Of the same dimensionality attributes As x.

 Missing values("NA") are regarded As equal, numeric And complex ones differing from 
 NaN; character strings will be compared In a “common encoding”; For details, see 
 match (And unique) which use the same concept.

 Values in incomparables will never be marked as duplicated. This Is intended to be 
 used for a fairly small set of values And will Not be efficient for a very large 
 set.

 When used on a data frame with more than one column, Or an array Or matrix when 
 comparing dimensions of length greater than one, this tests for identity of character 
 representations. This will catch people who unwisely rely on exact equality of 
 floating-point numbers!

 Except for factors, logical And raw vectors the default nmax = NA Is equivalent 
 to nmax = length(x). Since a hash table of size 8*nmax bytes Is allocated, setting 
 nmax suitably can save large amounts of memory. For factors it Is automatically 
 set to the smaller of length(x) And the number of levels plus one (for NA). 
 If nmax Is set too small there Is liable to be an error nmax = 1 Is silently 
 ignored.

 Long vectors are supported For the Default method Of duplicated, but may only be 
 usable if nmax Is supplied.
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.set.crossing(System.Array,System.Array,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 Find Unique Combinations of All Elements 
 from Two Vectors in R. Expand data frame 
 to include all possible combinations of 
 values.
 </summary>
 <param name="a"></param>
 <param name="b"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.set.combn(System.Array,System.Int32,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 Generate All Combinations of n Elements, Taken m at a Time
 
 Generate all combinations of the elements of x taken 
 m at a time. If x is a positive integer, returns all 
 combinations of the elements of seq(x) taken m at a 
 time. If argument FUN is not NULL, applies a function 
 given by the argument to each point. If simplify is 
 FALSE, returns a list; otherwise returns an array, typically 
 a matrix. ... are passed unchanged to the FUN function, 
 if specified.
 </summary>
 <remarks>Factors x are accepted.</remarks>
 <param name="x">
 vector source For combinations, Or Integer n For x &lt;- seq_len(n).
 </param>
 <param name="m">
 number of elements to choose.
 </param>
 <returns>
 A list or array, see the simplify argument above. In the 
 latter case, the identity dim(combn(n, m)) == c(m, choose(n, m)) 
 holds.
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.set.jaccard(System.Array,System.Array,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 The Jaccard Index, also known as the Jaccard similarity coefficient, 
 is a statistic used in understanding the similarities between sample 
 sets. The measurement emphasizes similarity between finite sample 
 sets, and is formally defined as the size of the intersection divided
 by the size of the union of the sample sets.
 </summary>
 <param name="x"></param>
 <param name="y"></param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.set.createSet(System.Object,System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 create a collection set based on a given vector or tuple list
 </summary>
 <param name="x"></param>
 <param name="mode"></param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.set.set_ratio(Microsoft.VisualBasic.ComponentModel.DataStructures.Set,Microsoft.VisualBasic.ComponentModel.DataStructures.Set)">
 <summary>
 equivalent to: length(a) / length(b)
 </summary>
 <param name="a"></param>
 <param name="b"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.humanReadableFormatter.size(System.Double[])">
 <summary>
 convert byte number into human readable size string
 </summary>
 <param name="bytes"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.humanReadableFormatter.timespanStr(System.TimeSpan[],System.Boolean)">
 <summary>
 cast timespan value to human readable string
 </summary>
 <param name="spans"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.humanReadableFormatter.splitParagraph(System.String,System.Int32,System.String,System.Int32)">
 <summary>
 split a given text data into multiple lines
 </summary>
 <param name="text"></param>
 <param name="len"></param>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Internal.Invokes.stringr">
 <summary>
 the R text data helper
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.stringr.html(System.Object,SMRUCC.Rsharp.Runtime.Internal.Object.list,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 comvert any object to html text document
 </summary>
 <param name="x"></param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.stringr.objToString(System.Object,System.String,System.Globalization.CultureInfo,SMRUCC.Rsharp.Runtime.Internal.Object.list,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 # Convert an R Object to a Character String
 
 This is a helper function for format to produce a 
 single character string describing an R object.
 </summary>
 <param name="x">The object to be converted.</param>
 <param name="env"></param>
 <returns></returns>
 <remarks>
 this function just invoke the <see cref="M:System.Object.ToString"/> method.
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.stringr.getElementFormat(System.Type,System.String,System.Globalization.CultureInfo,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 
 </summary>
 <param name="type">
 the element type
 </param>
 <returns></returns>
 
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.stringr.loadXml(System.Object,System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 load a .NET object from the xml data file
 </summary>
 <param name="file">
 any kind of data value inputs:
 
 1. file path to the xml document file
 2. the xml document content text
 3. a stream object that contains the xml document text data
 </param>
 <param name="env"></param>
 <returns></returns>
 <remarks>
 this function will try to parse the object model information
 from the meta data in the xml data file
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.stringr.xml(System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 Convert most of the R# object or VB.NET object to xml document string. 
 </summary>
 <param name="x"></param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.stringr.json(System.Object,System.Boolean,SMRUCC.Rsharp.Runtime.Internal.Object.list,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 Convert most of the R# object or VB.NET object to json string. 
 </summary>
 <param name="x"></param>
 <param name="compress"></param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.stringr.base64Str(System.Object,System.Int32,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 encode byte stream or text content into base64 string
 </summary>
 <param name="raw">
 R# object or any supported .NET object:
 
 1. text content
 2. bytes buffer
 3. image data
 4. any object can be converts to bytes
 </param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.stringr.base64Decode(System.String,System.Object,System.Boolean,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 decode base64 string as text or the raw bytes buffer object.
 </summary>
 <param name="base64">a string in base64 encode pattern</param>
 <param name="asText_encoding">
 if this parameter is not nothing, then the output will be convert as text
 </param>
 <param name="wrap">
 wrap the result as memory stream object instead of the raw bytes vector output
 </param>
 <param name="env"></param>
 <returns>
 this function returns a text data or memory stream buffer object.
 </returns>
 <remarks>
 if the base64 encoded data is text data, that parameter 
 ``asText_encoding`` assign of value ``utf8`` usually. 
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.stringr.urldecode(System.String[])">
 <summary>
 Decodes URL-encoded string
 
 Decodes any ``%##`` encoding in the given string. 
 Plus symbols ('+') are decoded to a space character.
 </summary>
 <param name="str">The string to be decoded.</param>
 <returns>Returns the decoded string.</returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.stringr.nchar(System.Object)">
 <summary>
 ### Count the Number of Characters (or Bytes or Width)
 
 nchar takes a character vector as an argument and 
 returns a vector whose elements contain the sizes 
 of the corresponding elements of x.
 </summary>
 <param name="strs">
 character vector, or a vector to be coerced to a character 
 vector. Giving a factor is an error.</param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.stringr.regexp(System.String,System.String,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 Initializes a new instance of the ``RegularExpression`` class
 for the specified regular expression <paramref name="pattern"/>.
 </summary>
 <param name="pattern">the specified regular expression</param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.stringr.match(System.Text.RegularExpressions.Regex,System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 Searches the specified input string for the first 
 occurrence of the regular expression specified in 
 the System.Text.RegularExpressions.Regex 
 constructor.
 </summary>
 <param name="regexp">Represents an immutable regular expression.
 To browse the .NET Framework source code for this type, 
 see the Reference Source.</param>
 <param name="strings">The string to search for a match.</param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.stringr.Csprintf(System.Array,System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 #### Use C-style String Formatting Commands
 
 A wrapper for the C function sprintf, that returns a character 
 vector containing a formatted combination of text and variable 
 values.
 </summary>
 <param name="format"></param>
 <param name="arguments"></param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.stringr.strsplit(System.String[],System.Object,System.Boolean,System.Boolean,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ### Split the Elements of a Character Vector
 
 Split the elements of a character vector x into substrings
 according to the matches to substring split within them.
 </summary>
 <param name="text">
 character vector, each element of which is to be split. Other inputs, 
 including a factor, will give an error.
 </param>
 <param name="delimiter">
 character vector (or object which can be coerced to such) containing 
 regular expression(s) (unless fixed = TRUE) to use for splitting. 
 If empty matches occur, in particular if split has length 0, x is 
 split into single characters. If split has length greater than 1, 
 it is re-cycled along x.
 </param>
 <param name="fixed">
 logical. If TRUE match split exactly, otherwise use regular expressions. 
 Has priority over perl.</param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.stringr.str_trim(System.Object,System.Object)">
 <summary>
 ## Remove whitespace
 
 str_trim() removes whitespace from start and end of string; str_squish() removes whitespace at 
 the start and end, and replaces all internal whitespace with a single space.
 </summary>
 <param name="string">Input vector. Either a character vector, Or something coercible To one.</param>
 <param name="side">Side on which to remove whitespace: "left", "right", or "both", the default.</param>
 <returns>A character vector the same length as string.</returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.stringr.str_squish(System.Object)">
 <summary>
 ## Remove whitespace
 
 str_trim() removes whitespace from start and end of string; str_squish() removes whitespace at 
 the start and end, and replaces all internal whitespace with a single space.
 </summary>
 <param name="string">	
 Input vector. Either a character vector, Or something coercible To one.</param>
 <returns>
 A character vector the same length as string.
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.stringr.paste0(SMRUCC.Rsharp.Runtime.Internal.Object.list,System.String,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ## Concatenate Strings
 
 Concatenate vectors after converting to character. Concatenation happens in two basically different ways, 
 determined by collapse being a string or not.
 
 ``paste0(..., collapse)`` is equivalent to ``paste(..., sep = "", collapse)``, slightly more efficiently.
 </summary>
 <param name="x">one or more R objects, to be converted to character vectors.</param>
 <param name="collapse">an optional character string to separate the results. Not NA_character_. When collapse
 is a string, the result is always a string (character of length 1).</param>
 <param name="env"></param>
 <returns>
 A character vector of the concatenated values. This will be of length zero if all the objects are, unless 
 collapse is non-NULL, in which case it is "" (a single empty string).

 If any input into an element Of the result Is In UTF-8 (And none are declared With encoding "bytes", see Encoding), 
 that element will be In UTF-8, otherwise In the current encoding In which Case the encoding Of the element 
 Is declared If the current locale Is either Latin-1 Or UTF-8, at least one Of the corresponding inputs (including 
 separators) had a declared encoding And all inputs were either ASCII Or declared.

 If an input into an element Is declared With encoding "bytes", no translation will be done Of any Of the elements 
 And the resulting element will have encoding "bytes". If collapse Is non-NULL, this applies also To the second, 
 collapsing, phase, but some translation may have been done In pasting Object together In the first phase.
 </returns>
 
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.stringr.paste(SMRUCC.Rsharp.Runtime.Internal.Object.list,System.String,System.String,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ### Concatenate Strings
 
 string join with given delimiter, concatenate vectors after converting to character.
 </summary>
 <param name="x">one Or more R objects, to be converted to character vectors.</param>
 <param name="sep">
 a character String To separate the terms. Not NA_character_.
 </param>
 <param name="collapse">
 an optional character string to separate the results. Not NA_character_.
 </param>
 <returns>A character vector of the concatenated values. This will be of length zero
 if all the objects are, unless collapse is non-NULL, in which case it is "" 
 (a single empty string).

        If any input into an element Of the result Is In UTF-8 (And none are declared
        With encoding "bytes", see Encoding), that element will be In UTF-8, otherwise 
        In the current encoding In which Case the encoding Of the element Is declared 
        If the current locale Is either Latin-1 Or UTF-8, at least one Of the corresponding
        inputs (including separators) had a declared encoding And all inputs were either 
        ASCII Or declared.

 If an input into an element Is declared With encoding "bytes", no translation will be done
 Of any Of the elements And the resulting element will have encoding "bytes". If collapse 
 Is non-NULL, this applies also To the second, collapsing, phase, but some translation may
 have been done In pasting Object together In the first phase.</returns>
 <remarks>
 paste converts its arguments (via as.character) to character strings, 
 and concatenates them (separating them by the string given by sep). 
 If the arguments are vectors, they are concatenated term-by-term to 
 give a character vector result. Vector arguments are recycled as needed,
 with zero-length arguments being recycled to "" only if recycle0 is not 
 true or collapse is not NULL.

 Note that paste() coerces NA_character_, the character missing value, To 
 "NA" which may seem undesirable, e.g., When pasting two character vectors,
 Or very desirable, e.g. In paste("the value of p is ", p).

 paste0(..., collapse) Is equivalent to paste(..., sep = "", collapse), 
 slightly more efficiently.

 If a value Is specified For collapse, the values In the result are Then 
 concatenated into a Single String, With the elements being separated by
 the value Of collapse.
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.stringr.str_replace(System.String[],System.String,System.String,System.Boolean,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 Pattern Matching and Replacement
 </summary>
 <param name="subj">a character vector</param>
 <param name="search$"></param>
 <param name="replaceAs"></param>
 <param name="regexp">
 the search target is a regex pattern expression?
 </param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.stringr.str_pad(System.String[],System.Int32,SMRUCC.Rsharp.Runtime.Internal.Invokes.str_padSides,System.Char)">
 <summary>
 Pad A String.
 </summary>
 <param name="string">A character vector.</param>
 <param name="width">Minimum width of padded strings.</param>
 <param name="side">Side on which padding character is added (left, right or both).</param>
 <param name="pad">Single padding character (default is a space).</param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.stringr.str_empty(System.String[],System.Boolean,System.Boolean)">
 <summary>
 test of the give character vector is empty string or not
 </summary>
 <param name="x">a character vector that contains multiple string for do the test</param>
 <returns>
 a logical vector of the test result. TRUE means the given string
 is asserted as an empty factor.
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.stringr.tagvalue(System.String[],System.String,System.Boolean,System.Boolean,System.Boolean,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 parse the string text in format like ``tag{delimiter}value``
 </summary>
 <param name="string"></param>
 <param name="delimiter"></param>
 <param name="trim_value"></param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.stringr.tolower(System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ### Character Translation and Casefolding
 
 Translate characters in character vectors, in particular 
 from upper to lower case or vice versa.
 </summary>
 <param name="x">
 a character vector, or an object that can be coerced to character by 
 ``as.character``.
 </param>
 <returns>
 A character vector of the same length and with the same attributes as 
 ``x`` (after possible coercion).
 
 Elements of the result will be have the encoding declared as that of 
 the current locale (see Encoding) if the corresponding input had a 
 declared encoding And the current locale Is either Latin-1 Or UTF-8. 
 The result will be in the current locale's encoding unless the 
 corresponding input was in UTF-8, when it will be in UTF-8 when the 
 system has Unicode wide characters.
 </returns>
 <remarks>
 chartr translates each character in x that is specified in old 
 to the corresponding character specified in new. Ranges are 
 supported in the specifications, but character classes and 
 repeated characters are not. If old contains more characters than 
 new, an error is signaled; if it contains fewer characters, the 
 extra characters at the end of new are ignored.
 
 ``tolower`` And ``toupper`` convert upper-case characters in a 
 character vector to lower-case, Or vice versa. Non-alphabetic 
 characters are left unchanged.
 </remarks>
 
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.stringr.concatenate(System.Object,System.String,System.String,System.String,System.Boolean,System.Boolean)">
 <summary>
 
 </summary>
 <param name="data"></param>
 <param name="comma"></param>
 <param name="andalso"></param>
 <param name="etc"></param>
 <param name="joinSpace"></param>
 <param name="enUS"></param>
 <returns>
 if the input data list contains no elements or it is 
 nothing, then this function will returns nothing
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.stringr.chr(System.Int32[])">
 <summary>
 ``chr`` returns the characters corresponding to the 
 specified ASCII codes.
 </summary>
 <param name="ascii">
 vector or list of vectors containing integer ASCII codes
 </param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.stringr.substr(System.Object,System.Int32,System.Int32,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ### Substrings of a Character Vector
 
 Extract or replace substrings in a character vector.
 </summary>
 <param name="x">
 a character vector.
 </param>
 <param name="start">integer. The first element To be replaced.</param>
 <param name="stop">integer. The last element to be replaced.</param>
 <returns>For ``substr``, a character vector of the same length 
 and with the same attributes as x (after possible coercion).
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.stringr.str_replace(System.String[],System.String,System.String,System.Boolean)">
 <summary>
 The str_replace() function from the stringr package in R 
 can be used to replace matched patterns in a string.
 </summary>
 <param name="strings">Character vector</param>
 <param name="pattern">Pattern to look for</param>
 <param name="replacement">
 A character vector of replacements
 </param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.stringr.randomAsciiStr(System.Int32,System.Int32,System.Boolean)">
 <summary>
 generate random string which is all consist 
 with ascii chars.
 </summary>
 <param name="nchar"></param>
 <param name="count"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.stringr.text_equals(System.Object,System.Object,System.Boolean,System.Boolean,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 check of the text equals between two character vector.
 </summary>
 <param name="x">should be a character vector</param>
 <param name="y">another character vector</param>
 <param name="null_equals">null string value as equals? example as NULL is equals to NULL, or NULL is equals to empty string</param>
 <param name="empty_equals">empty factor string value as equals? example as NA is equals to n/a, or NA is equals to NULL, etc.</param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.stringr.text_grep(System.String,System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 apply for batch text grep/trimming/strip
 </summary>
 <param name="grep_regexp">a regular expression value for produce new text value.</param>
 <param name="x">should be a character vector for apply such operation. omit this parameter value will create a lambda function for grep text.</param>
 <param name="env"></param>
 <returns></returns>
 <example>
 let names = ["258_Herniarin_[M+H2O+H]+" "993_Geranyl acetate_[M+H2O+H]+" "3229_Glycerol_[M+NH4]+" "398587_Cytidine_[M+H]+" "398007_Adenosine_[M+H]+"];
 let grep = "$(\d+)_$(\[\d*M.*\]\d*[+-])";
 
 print(text_grep(grep, names));
 # [1] "258_[M+H2O+H]+" "993_[M+H2O+H]+" "3229_[M+NH4]+" "398587_[M+H]+" "398007_[M+H]+"
 </example>
 <remarks>
 the text grep regexp pattern token should be wrapped inside a bracket: ``$(regexp_token)``, 
 any text outside this bracket will be treated as an regular string.
 
 example as the token parser string: ``$(\d+)_$(\[\d*M.*\]\d*[+-])`` will be split into
 3 tokens: ``$(\d+)`` for matches integer string token, ``_`` will always produce a regular string token ``_``,
 ``$(\[\d*M.*\]\d*[+-])`` for matches another string token that wrapped with bracket [] and 
 ends with signed integer number as suffix.
 </remarks>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Internal.Invokes.strings">
 <summary>
 Simulation of the <see cref="T:Microsoft.VisualBasic.Strings"/> module
 </summary>
 
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.strings.GetStackValue(System.Object,System.String,System.String)">
 <summary>
 get string between two stack string
 </summary>
 <param name="str"></param>
 <param name="left">the stack string on the left</param>
 <param name="right">the stack string on the right</param>
 <returns></returns>
 <remarks>
 this function will get max length string between left and right stack string
 </remarks>
 <example>
 # get tag value string in html
 let html_str  = "&lt;title>this is title string&lt;/title>";
 let title_str = html_str |> stack_str(">", "&lt;");
 
 # [1] this is title string
 print(title_str);
 
 html_str = "&lt;title>this is &lt; title string&lt;/title>";
 title_str = html_str |> stack_str(">", "&lt;");
 
 # [1] this is &lt; title string
 print(title_str);
 </example>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.strings.getBetweenString(System.Object,System.String,System.String)">
 <summary>
 get between string function is similar to the ``stack_str`` function, 
 but this function will get the min length string between two flag
 </summary>
 <param name="str"></param>
 <param name="left"></param>
 <param name="right"></param>
 <returns></returns>
 <example>
 # get tag value string in html
 let html_str  = "&lt;title>this is title string&lt;/title>";
 let title_str = html_str |> between_str(">", "&lt;");
 
 # [1] this is title string
 print(title_str);
 
 html_str = "&lt;title>this is &lt; title string&lt;/title>";
 title_str = html_str |> between_str(">", "&lt;");
 
 # [1] this is
 print(title_str);
 </example>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.strings.MidString(System.String[],System.Int32,System.Int32)">
 <summary>
 Returns a string that contains a specified number of characters starting from
 a specified position in a string.
 </summary>
 <param name="strings">Required. String expression from which characters are returned.</param>
 <param name="start">
 Required. Integer expression. Starting position of the characters to return.
 If Start is greater than the number of characters in str, the Mid function returns
 a zero-length string (""). Start is one based.
 </param>
 <param name="len">
 Optional. Integer expression. Number of characters to return. If omitted or if
 there are fewer than Length characters in the text (including the character at
 position Start), all characters from the start position to the end of the string
 are returned.
 </param>
 <returns>
 A string that consists of the specified number of characters starting from the
 specified position in the string.
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.strings.LCaseStrings(System.String[])">
 <summary>
 Returns a string or character converted to lowercase.
 </summary>
 <param name="strings">Required. Any valid String or Char expression.</param>
 <returns>
 Returns a string or character converted to lowercase.
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.strings.UCase(System.String[])">
 <summary>
 Returns a string or character containing the specified string converted to uppercase.
 </summary>
 <param name="strings">Required. Any valid String or Char expression.</param>
 <returns>
 Returns a string or character containing the specified string converted to uppercase.
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.strings.Trim(System.String[],System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 Removes all leading and trailing occurrences of a set of characters specified
 in an array from the current System.String object.
 </summary>
 <param name="strings">a character vector</param>
 <param name="characters">An array of Unicode characters to remove, or null.</param>
 <param name="env"></param>
 <returns>
 The string that remains after all occurrences of the characters in the trimChars
 parameter are removed from the start and end of the current string. If trimChars
 is null or an empty array, white-space characters are removed instead. If no
 characters can be trimmed from the current instance, the method returns the current
 instance unchanged.
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.strings.ltrim(System.String[])">
 <summary>
 Returns a string containing a copy of a specified string with no leading spaces
 (LTrim), no trailing spaces (RTrim), Or no leading Or trailing spaces (Trim).
 </summary>
 <param name="strings">Required. Any valid String expression.</param>
 <returns>
 A string containing a copy of a specified string with no leading spaces (LTrim),
 no trailing spaces (RTrim), Or no leading Or trailing spaces (Trim).</returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.strings.InStr(System.String[],System.String[],System.Boolean,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 Returns an integer specifying the start position of the first occurrence of one
 string within another.
 </summary>
 <param name="strings">Required. String expression being searched.</param>
 <param name="substr">Required. String expression sought.</param>
 <param name="ignoreCase">
 Optional. Specifies the type of string comparison. If Compare is omitted, the
 Option Compare setting determines the type of comparison.
 </param>
 <param name="envir"></param>
 <returns>
 If InStr returns String1 is zero length or Nothing0 String2 is zero length or
 NothingThe starting position for the search, which defaults to the first character
 position. String2 is not found0 String2 is found within String1Position where
 match begins
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.strings.AscW(System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 Returns an Integer value representing the character code corresponding to a character.
 </summary>
 <param name="x">
 Required. Any valid Char or String expression. If [String] is a String expression,
 only the first character of the string is used for input. If [String] is Nothing
 or contains no characters, an System.ArgumentException error occurs.
 </param>
 <param name="envir"></param>
 <returns>
 Returns an Integer value representing the character code corresponding to a character.
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.strings.startsWith(System.String[],System.String,System.Boolean)">
 <summary>
 ### Does String Start or End With Another String?
 
 Determines if entries of x start or end with string (entries of) 
 prefix or suffix respectively, where strings are recycled to 
 common lengths.
 </summary>
 <param name="x">vector of character string whose ``starts`` are considered.</param>
 <param name="prefix">character vector(often of length one).</param>
 <returns>
 A logical vector, of “common length” of x and prefix (or suffix), i.e., 
 of the longer of the two lengths unless one of them is zero when the result 
 is also of zero length. A shorter input is recycled to the output length.
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.strings.endsWith(System.String[],System.String)">
 <summary>
 ### Does String Start or End With Another String?
 
 Determines if entries of x start or end with string (entries of) 
 prefix or suffix respectively, where strings are recycled to 
 common lengths.
 </summary>
 <param name="x">vector of character string whose ``starts`` are considered.</param>
 <param name="suffix">character vector(often of length one).</param>
 <returns>
 A logical vector, of “common length” of x and prefix (or suffix), i.e., 
 of the longer of the two lengths unless one of them is zero when the result 
 is also of zero length. A shorter input is recycled to the output length.
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.strings.textLines(System.String,System.Boolean,System.Boolean)">
 <summary>
 split text to lines
 </summary>
 <param name="text"></param>
 <param name="trim"></param>
 <param name="escape"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.strings.makeQGram(System.Object,System.Int32)">
 <summary>
 make text index based on the qgram algorithm
 </summary>
 <param name="text"></param>
 <param name="qgram"></param>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Internal.Invokes.utils">
 <summary>
 helper tools for the R# programming
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.utils.progress_bar(System.Int32,System.Int32,System.Int32)">
 <summary>
 Create a progress bar helper function
 </summary>
 <param name="total"></param>
 <param name="width"></param>
 <param name="interval">
 the progress display internal, should be value in range [1,100].
 </param>
 <returns></returns>
 <example>
 let bar = progress_bar(total = 10);
 
 bar("test 1");
 bar("test 2");
 bar("test 3");
 </example>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.utils.setTqdmProgressBarlabel(System.String)">
 <summary>
 set progress task for current used tqdm wrapped progressbar in for loop
 </summary>
 <param name="label"></param>
 <returns></returns>
 <remarks>
 this function is thread unsafe
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.utils.tqdm_wrap(System.Object,System.Int32,System.Int32,System.Boolean,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 Wraps a collection with a progress bar for iteration, providing visual feedback on progress.
 </summary>
 <param name="x">The collection to iterate over.</param>
 <param name="width">The width of the progress bar.</param>
 <param name="prints_perSecond">The update frequency of the progress bar.</param>
 <param name="use_color">Indicates whether to use colored output for the progress bar.</param>
 <returns>An enumerable that iterates over the collection with progress tracking.</returns> 
 <remarks>
 this function is thread unsafe
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.utils.installPackages(System.String[],SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 # Install Packages from Repositories or Local Files
 
 Download and install packages from CRAN-like repositories or from local files.
 
 This is the main function to install packages. It takes a vector of names and 
 a destination library, downloads the packages from the repositories and installs 
 them. (If the library is omitted it defaults to the first directory in 
 .libPaths(), with a message if there is more than one.) If lib is omitted or 
 is of length one and is not a (group) writable directory, in interactive use 
 the code offers to create a personal library tree (the first element of 
 Sys.getenv("R_LIBS_USER")) and install there. Detection of a writable 
 directory is problematic on Windows: see the ‘Note’ section.

 For installs from a repository an attempt Is made To install the packages In 
 an order that respects their dependencies. This does assume that all the 
 entries In Lib are On the Default library path For installs (Set by 
 environment variable R_LIBS).

 You are advised To run update.packages before install.packages To ensure that 
 any already installed dependencies have their latest versions.
 </summary>
 <param name="packages">The dll file name, character vector of the names of 
 packages whose current versions should be downloaded from the repositories.
 </param>
 <param name="envir"></param>
 <returns></returns>
 <remarks>
 install.packages tries to detect if you have write permission on the library 
 directories specified, but Windows reports unreliably. If there is only one 
 library directory (the default), R tries to find out by creating a test directory, 
 but even this need not be the whole story: you may have permission to write 
 in a library directory but lack permission to write binary files (such as ‘.dll’ 
 files) there. See the ‘R for Windows FAQ’ for workarounds.
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.utils.GetInstalledPackages(System.String,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ## Find Installed Packages
 
 Find (or retrieve) details of all packages installed in the specified libraries.
 
 ``installed.packages`` scans the ‘DESCRIPTION’ files of each package found along 
 ``lib.loc`` and returns a matrix of package names, library paths and version numbers.

 The information found Is cached (by library) For the R session And specified fields argument, 
 And updated only If the top-level library directory has been altered, 
 For example by installing Or removing a package. If the cached information becomes confused, 
 it can be refreshed by running ``installed.packages(noCache = True)``.
 </summary>
 <param name="envir"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.utils.keyGroups(System.String[])">
 <summary>
 
 </summary>
 <param name="keys"></param>
 <returns>index value is zero based</returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.utils.wget_file(System.String,System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 retrieving files using HTTP, HTTPS, FTP and FTPS, the most widely used Internet protocols.
 </summary>
 <param name="url"></param>
 <param name="save">
 this parameter could be a character vector for specific a local file path to save the 
 target remote file, or it also could be a file reference wrapper object for store in 
 a cache pack. This function will returns a stream object if this parameter is nothing.
 </param>
 <param name="env"></param>
 <returns>
 this function will returns the data stream which is download from the given 
 <paramref name="url"/> if the <paramref name="save"/> parameter value is 
 nothing by default, or this function will returns nothing if the <paramref name="save"/> 
 parameter value is exists and also the http resource data will be placed at 
 <paramref name="save"/> file location. 
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.utils.cls">
 <summary>
 Clears the console buffer and corresponding console window of display information.
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.utils.sleep(System.Double)">
 <summary>
 Suspends the current thread for the specified number of seconds.
 </summary>
 <param name="sec"></param>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.utils.head(System.Object,System.Int32,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 Return the First or Last Part of an Object
 
 Returns the first or last parts of a vector, matrix, table, data frame or function. 
 Since head() and tail() are generic functions, they may also have been extended 
 to other classes.
 </summary>
 <param name="x">an object</param>
 <param name="n">
 a single integer. If positive or zero, size for the resulting object: number of 
 elements for a vector (including lists), rows for a matrix or data frame or lines 
 for a function. If negative, all but the n last/first number of elements of x.
 </param>
 <param name="env"></param>
 <remarks>
 For matrices, 2-dim tables and data frames, head() (tail()) returns the first (last) 
 n rows when n >= 0 or all but the last (first) n rows when n &lt; 0. head.matrix() 
 and tail.matrix() are exported. For functions, the lines of the deparsed function 
 are returned as character strings.

 If a matrix has no row names, Then tail() will add row names Of the form "[n,]" 
 To the result, so that it looks similar To the last lines Of x When printed. 
 Setting addrownums = False suppresses this behaviour.
 </remarks>
 <returns>An object (usually) like x but generally smaller. For ftable objects x, 
 a transformed format(x).</returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.utils.memorySize(System.Boolean)">
 <summary>
 ### Report on Memory Allocation
 
 ``memory.size`` reports the current or maximum memory allocation 
 of the malloc function used in this version of R.
 </summary>
 <param name="max">	
 logical. If TRUE the maximum amount of memory obtained from the OS 
 Is reported, if FALSE the amount currently in use, if NA the memory 
 limit.
 </param>
 <returns>
 Size in Mb (1048576 bytes), rounded to 0.01 Mb for memory.size
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.utils.createCommandLine(SMRUCC.Rsharp.Runtime.Internal.Object.list,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 create commandline string
 </summary>
 <param name="argv"></param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.utils.createArgumentString(SMRUCC.Rsharp.Runtime.Internal.Object.list,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 build commandline argument string from a tuple list object
 </summary>
 <param name="argv"></param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.utils.createArgumentString(System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 generates commandline arguments string from different types of input data
 </summary>
 <param name="args"></param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.utils.system2(System.String,System.Object,System.String,System.String,System.String,System.Object,System.Boolean,System.Boolean,System.Boolean,System.Single,System.Boolean,System.Boolean,System.Nullable{System.Boolean},SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ### Invoke a System Command
 
 ``system2`` invokes the OS command specified by command.
 </summary>
 <param name="command">the system command to be invoked, as a character string.</param>
 <param name="args">a character vector of arguments to command.</param>
 <param name="stdout">where output to ‘stdout’ or ‘stderr’ should be sent. 
 Possible values are "", to the R console (the default), NULL or FALSE 
 (discard output), TRUE (capture the output in a character vector) or a 
 character string naming a file.</param>
 <param name="stderr">where output to ‘stdout’ or ‘stderr’ should be sent. 
 Possible values are "", to the R console (the default), NULL or FALSE 
 (discard output), TRUE (capture the output in a character vector) or 
 a character string naming a file.</param>
 <param name="stdin">should input be diverted? "" means the default, alternatively 
 a character string naming a file. Ignored if input is supplied.</param>
 <param name="input">if a character vector is supplied, this is copied one
 string per line to a temporary file, and the standard input of command is 
 redirected to the file.</param>
 <param name="wait">a logical (not NA) indicating whether the R interpreter 
 should wait for the command to finish, or run it asynchronously. This will 
 be ignored (and the interpreter will always wait) if stdout = TRUE or stderr = TRUE. 
 When running the command asynchronously, no output will be displayed on the 
 Rgui console in Windows (it will be dropped, instead).</param>
 <param name="minimized">logical (not NA), indicates whether the command 
 window should be displayed initially as a minimized window.</param>
 <param name="invisible">logical (not NA), indicates whether the command
 window should be visible on the screen.</param>
 <param name="timeout">timeout in seconds, ignored if 0. This is a limit 
 for the elapsed time running command in a separate process. Fractions 
 of seconds are ignored.</param>
 <param name="env">character vector of name=value strings to set environment
 variables.</param>
 <returns>
 If stdout = TRUE or stderr = TRUE, a character vector giving the output of
 the command, one line per character string. (Output lines of more than 8095 
 bytes will be split.) If the command could not be run an R error is generated. 
 If command runs but gives a non-zero exit status this will be reported with 
 a warning and in the attribute "status" of the result: an attribute "errmsg" 
 may also be available.

 In other cases, the return value is an error code (0 for success), given the 
 invisible attribute (so needs to be printed explicitly). If the command could 
 not be run for any reason, the value is 127 and a warning is issued (as from 
 R 3.5.0). Otherwise if wait = TRUE the value is the exit status returned by 
 the command, and if wait = FALSE it is 0 (the conventional success value).

 If the command times out, a warning is issued and the exit status is 124.

 Some Windows commands return out-of-range status values (e.g., -1) and so 
 only the bottom 16 bits of the value are used.
 </returns>
 <remarks>
 Unlike system, command is always quoted by shQuote, so it must be a single command without arguments.

 For details of how command is found see system.
 
 On Windows, env is only supported for commands such as R and make which accept 
 environment variables on their command line.
 
 Some Unix commands (such as some implementations of ls) change their output if 
 they consider it to be piped or redirected: stdout = TRUE uses a pipe whereas 
 stdout = "some_file_name" uses redirection.
 
 Because of the way it is implemented, on a Unix-alike stderr = TRUE implies 
 stdout = TRUE: a warning is given if this is not what was specified.
 
 When timeout is non-zero, the command is terminated after the given number of 
 seconds. The termination works for typical commands, but is not guaranteed: 
 it is possible to write a program that would keep running after the time is 
 out. Timeouts can only be set with wait = TRUE.
 
 system2 is a more portable and flexible interface than system. It allows redirection 
 of output without needing to invoke a shell on Windows, a portable way to set environment 
 variables for the execution of command, and finer control over the redirection of 
 stdout and stderr. Conversely, system (and shell on Windows) allows the invocation 
 of arbitrary command lines.

 There is no guarantee that if stdout and stderr are both TRUE or the same file that 
 the two streams will be interleaved in order. This depends on both the buffering 
 used by the command and the OS.
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.utils.shQuote(System.Object,System.Object)">
 <summary>
 ### Quote Strings for Use in OS Shells
 
 Quote a string to be passed to an operating system shell.
 </summary>
 <param name="string">a character vector, usually of length one.</param>
 <param name="type">character: the type of shell quoting. Partial matching is supported. 
 "cmd" and "cmd2" refer to the Windows shell. "cmd" is the default under Windows.
 </param>
 <returns>A character vector of the same length as string.</returns>
 <remarks>
 The default type of quoting supported under Unix-alikes is that for the Bourne shell sh. 
 If the string does not contain single quotes, we can just surround it with single quotes.
 Otherwise, the string is surrounded in double quotes, which suppresses all special 
 meanings of metacharacters except dollar, backquote and backslash, so these (and of course
 double quote) are preceded by backslash. This type of quoting is also appropriate for 
 bash, ksh and zsh.
 
 The other type of quoting is for the C-shell (csh and tcsh). Once again, if the string 
 does not contain single quotes, we can just surround it with single quotes. If it does 
 contain single quotes, we can use double quotes provided it does not contain dollar or 
 backquote (and we need to escape backslash, exclamation mark and double quote). As a last
 resort, we need to split the string into pieces not containing single quotes (some may 
 be empty) and surround each with single quotes, and the single quotes with double quotes.
 
 In Windows, command line interpretation is done by the application as well as the shell.
 It may depend on the compiler used: Microsoft's rules for the C run-time are given at
 https://learn.microsoft.com/en-us/cpp/c-language/parsing-c-command-line-arguments?view=msvc-160. 
 It may depend on the whim of the programmer of the application: check its documentation. 
 The type = "cmd" prepares the string for parsing as an argument by the Microsoft's rules 
 and makes shQuote safe for use with many applications when used with system or system2. 
 It surrounds the string by double quotes and escapes internal double quotes by a 
 backslash. Any trailing backslashes and backslashes that were originally before double 
 quotes are doubled.
 
 The Windows cmd.exe shell (used by default with shell) uses type = "cmd2" quoting: 
 special characters are prefixed with "^". In some cases, two types of quoting should 
 be used: first for the application, and then type = "cmd2" for cmd.exe. 
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.utils.system(System.String,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Object,System.Boolean,System.Boolean,System.Boolean,System.Double,System.Boolean,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ### Invoke a System Command
 
 ``system`` invokes the OS command specified by ``command``.
 </summary>
 <param name="command">the system command to be invoked, as a character string.</param>
 <param name="intern">a logical (not NA) which indicates whether to capture the 
 output of the command as an R character vector.</param>
 <param name="ignore_stdout"></param>
 <param name="ignore_stderr"></param>
 <param name="wait"></param>
 <param name="input"></param>
 <param name="show_output_on_console">
 logical (Not NA), indicates whether to capture the output of the command And show 
 it on the R console (Not used by Rterm, which shows the output in the terminal 
 unless wait Is false).
 </param>
 <param name="minimized">
 logical (Not NA), indicates whether a command window should be displayed initially 
 as a minimized window.
 </param>
 <param name="invisible"></param>
 <param name="timeout"></param>
 <remarks>
 This interface has become rather complicated over the years: see system2 for a more 
 portable and flexible interface which is recommended for new code.

 command Is parsed as a command plus arguments separated by spaces. So if the path to 
 the command (Or a single argument such as a file path) contains spaces, it must be 
 quoted e.g. by shQuote. Only double quotes are allowed on Windows: see the examples. 
 (Note: a Windows path name cannot contain a Double quote, so we Do Not need To worry 
 about escaping embedded quotes.)

 command must be an executable (extensions '.exe’, ‘.com’) or a batch file (extensions 
 ‘.cmd’ and ‘.bat’): these extensions are tried in turn if none is supplied. This 
 means that redirection, pipes, DOS internal commands, ... cannot be used: see shell 
 if you want to pass a shell command-line.

 The search path For command may be system-dependent: it will include the R 'bin’ 
 directory, the working directory and the Windows system directories before PATH.

 When timeout Is non-zero, the command Is terminated after the given number of seconds. 
 The termination works for typical commands, but Is Not guaranteed it Is possible to 
 write a program that would keep running after the time Is out. Timeouts can only be 
 set with wait = TRUE.

 The ordering Of arguments after the first two has changed from time To time: it Is 
 recommended to name all arguments after the first.

 There are many pitfalls In Using system To ascertain If a command can be run — 
 Sys.which Is more suitable.
 </remarks>
 <returns>
 If intern = TRUE, a character vector giving the output of the command, one line per 
 character string. (Output lines of more than 8095 bytes will be split.) If the command 
 could not be run an R error is generated. Under the Rgui console intern = TRUE also 
 captures stderr unless ignore.stderr = TRUE. If command runs but gives a non-zero exit 
 status this will be reported with a warning and in the attribute "status" of the result: 
 an attribute "errmsg" may also be available.

 If intern = False, the Return value Is an Error code (0 For success), given the invisible 
 attribute (so needs To be printed explicitly). If the command could Not be run For any 
 reason, the value Is 127 And a warning Is issued (As from R 3.5.0). Otherwise If 
 wait = True the value Is the Exit status returned by the command, And If wait = False it 
 Is 0 (the conventional success value).

 If the command times out, a warning Is reported And the Exit status Is 124. Some Windows 
 commands Return out-Of-range status values (e.g., -1) And so only the bottom 16 bits Of 
 the value are used.

 If intern = False, wait = True, show.output.On.console = True the 'stdout’ and ‘stderr’ 
 (unless ignore.stdout = TRUE or ignore.stderr = TRUE) output from a command that is a 
 ‘console application’ should appear in the R console (Rgui) or the window running R 
 (Rterm).

 Not all Windows executables properly respect redirection of output, Or may only do so 
 from a console application such as Rterm And Not from Rgui For example, 'fc.exe’ was 
 among these in the past, but we have had more success recently.
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.utils.workdir(System.String)">
 <summary>
 Create a new temporary work directory environment for the code
 </summary>
 <param name="dir"></param>
 <returns></returns>
 <remarks>
 the work directory path will be restore to previous work directory
 when the generated temporary work directory has been close and disposed
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.utils.md5(System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ## Vectorized hash/hmac functions
 </summary>
 <param name="x">
 character vector, raw vector or connection object.
 </param>
 <param name="env"></param>
 <returns></returns>
 <remarks>
 Digest types: https://www.openssl.org/docs/man1.1.1/man1/openssl-dgst.html
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.utils.debugTool(SMRUCC.Rsharp.Interpreter.ExecuteEngine.Expression,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ### Debug an Expression
 
 apply for debug in Visual Studio, like a script breakpoint
 </summary>
 <param name="expr">any interpreted R expression.</param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.utils.pause">
 <summary>
 Pause the current console program.
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.utils.data(System.Object,System.String[],System.String,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ### Data Sets
 
 Loads specified data sets, or list the available data sets.
 </summary>
 <param name="x">literal character strings Or names.</param>
 <param name="package">
 a character vector giving the package(s) to look in for data sets, or NULL.
 By Default, all packages in the search path are used, then the 'data’ 
 subdirectory (if present) of the current working directory.
 </param>
 <param name="lib_loc">
 a character vector of directory names of R libraries, or NULL. 
 The default value of NULL corresponds to all libraries currently 
 known.
 </param>
 <param name="env"></param>
 <returns></returns>
 <remarks>
 Currently, four formats of data files are supported:
 
    1. files ending ‘.R’ or ‘.r’ are source()d in, with the R working directory changed 
       temporarily to the directory containing the respective file. (data ensures that the 
       utils package is attached, in case it had been run via utils::data.)
    2. files ending ‘.RData’ or ‘.rda’ are load()ed.
    3. files ending ‘.tab’, ‘.txt’ or ‘.TXT’ are read using read.table(..., header = TRUE, as.is=FALSE), 
       and hence result in a data frame.
    4. files ending ‘.csv’ or ‘.CSV’ are read using read.table(..., header = TRUE, sep = ";", as.is=FALSE), 
       and also result in a data frame.
       
 If more than one matching file name is found, the first on this list is used. (Files with 
 extensions ‘.txt’, ‘.tab’ or ‘.csv’ can be compressed, with or without further 
 extension ‘.gz’, ‘.bz2’ or ‘.xz’.)
 
 The data sets to be loaded can be specified as a set of character strings or names, or as 
 the character vector list, or as both.
 
 For each given data set, the first two types (‘.R’ or ‘.r’, and ‘.RData’ or ‘.rda’ 
 files) can create several variables in the load environment, which might all be named differently 
 from the data set. The third and fourth types will always result in the creation of a single 
 variable with the same name (without extension) as the data set.
 
 If no data sets are specified, data lists the available data sets. It looks for a new-style 
 data index in the ‘Meta’ or, if this is not found, an old-style ‘00Index’ file in the ‘data’ 
 directory of each specified package, and uses these files to prepare a listing. If there is a 
 ‘data’ area but no index, available data files for loading are computed and included in the 
 listing, and a warning is given: such packages are incomplete. The information about available 
 data sets is returned in an object of class "packageIQR". The structure of this class is experimental. 
 Where the datasets have a different name from the argument that should be used to retrieve them 
 the index will have an entry like beaver1 (beavers) which tells us that dataset beaver1 can be 
 retrieved by the call data(beaver).
 
 If lib.loc and package are both NULL (the default), the data sets are searched for in all the 
 currently loaded packages then in the ‘data’ directory (if any) of the current working 
 directory.
 
 If lib.loc = NULL but package is specified as a character vector, the specified package(s) are 
 searched for first amongst loaded packages and then in the default library/ies (see .libPaths).
 
 If lib.loc is specified (and not NULL), packages are searched for in the specified library/ies, 
 even if they are already loaded from another library.
 
 To just look in the ‘data’ directory of the current working directory, set package = character(0) 
 (and lib.loc = NULL, the default).
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.utils.dataSearchByPackageDir(SMRUCC.Rsharp.Runtime.Environment,System.String,Microsoft.VisualBasic.ApplicationServices.IFileSystemEnvironment,System.Boolean@)">
 <summary>
 
 </summary>
 <param name="env"></param>
 <param name="name"></param>
 <param name="lib_pkgdir">the folder path of the given installed package module</param>
 <param name="hit"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.utils.systemFile(System.String,System.String,System.Boolean,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ### Find Names of R System Files
 
 Finds the full file names of files in packages etc.
 </summary>
 <param name="fileName"></param>
 <param name="package">a character String With the name Of a Single package.
 An Error occurs If more than one package name Is given.
 </param>
 <param name="env"></param>
 <returns>
 this function maybe returns a clr stream object if the required file is 
 inside an in-memory zip archive virtual filesystem.
 </returns>
 <remarks>
 do not add extension suffix name for csv data set due to 
 the reason of csv file extension suffix will be removed
 automatically in the progress of R compile the data file 
 into package file.
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.utils.description(System.String,System.Boolean,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 loading a ``DESCRIPTION`` file
 </summary>
 <param name="package">
 loading current package if the parameter is nothing
 </param>
 <returns>
 a list object that contains the meta data of the 
 package descirption information. details data members
 see the clr object: <see cref="T:SMRUCC.Rsharp.Development.Package.File.DESCRIPTION"/>.
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.utils.now">
 <summary>
 get current system time
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.utils.createTimespan(System.Object,SMRUCC.Rsharp.Runtime.Internal.Invokes.utils.TimeSpanUnits,System.Boolean,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 create the time span value based on the given time ticks
 </summary>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Internal.Invokes.utils.TimeSpanUnits">
 <summary>
 the data unit of the timespan value
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.utils.package_skeleton(System.String,System.String,System.Boolean,System.String[],System.String,SMRUCC.Rsharp.Runtime.Internal.Object.list,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ### Create a Skeleton for a New Source Package
 
 package.skeleton automates some of the setup for a new source 
 package. It creates directories, saves functions, data, and 
 R code files to appropriate places, and creates skeleton help
 files and a ‘Read-and-delete-me’ file describing further steps 
 in packaging.
 </summary>
 <param name="name">
 character string: the package name and directory name for your package. 
 Must be a valid package name.
 </param>
 <param name="path">path to put the package directory in.</param>
 <param name="force">
 If False will Not overwrite an existing directory.</param>
 <param name="code_files">
 a character vector with the paths to R code files to build the 
 package around. See ‘Details’.
 </param>
 <param name="encoding">
 optionally a character string with an encoding for an optional 
 Encoding: line in ‘DESCRIPTION’ when non-ASCII characters will 
 be used; typically one of "latin1", "latin2", or "UTF-8"; see 
 the WRE manual.
 </param>
 <param name="list">
 character vector naming the R objects to put in the package. Usually, 
 at most one of list, environment, or code_files will be supplied. 
 See ‘Details’.
 </param>
 <param name="environment">
 an environment where objects are looked for. See ‘Details’.
 </param>
 <remarks>
 The arguments list, environment, and code_files provide alternative
 ways to initialize the package. If code_files is supplied, the files
 so named will be sourced to form the environment, then used to 
 generate the package skeleton. Otherwise list defaults to the objects
 in environment (including those whose names start with .), but can 
 be supplied to select a subset of the objects in that environment.
 
 Stubs of help files are generated for functions, data objects, And S4 
 classes And methods, using the prompt, promptClass, And promptMethods 
 functions. If an object from another package Is intended to be imported 
 And re-exported without changes, the promptImport function should be 
 used after package.skeleton to generate a simple help file linking to 
 the original one.
 
 The package sources are placed In subdirectory name Of path. If code_files 
 Is supplied, these files are copied; otherwise, objects will be dumped 
 into individual source files. The file names In code_files should have 
 suffix ".R" And be In the current working directory.
 
 The filenames created For source And documentation Try To be valid For
 all OSes known To run R. Invalid characters are replaced by _, invalid 
 names are preceded by zz, names are converted To lower Case (To avoid 
 Case collisions On Case-insensitive file systems) And Finally the converted 
 names are made unique by make.unique(sep = "_"). This can be done For 
 code And help files but Not data files (which are looked For by name). 
 Also, the code And help files should have names starting With an ASCII 
 letter Or digit, And this Is checked And If necessary z prepended.
 Functions with names starting with a dot are placed in file 'R/name-internal.R’.
 When you are done, delete the 'Read-and-delete-me’ file, as it should 
 not be distributed.
 </remarks>
 <returns>
 Used for its side-effects.
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.utils.unzipFile(System.String,System.Object,System.Boolean,System.Boolean,System.Boolean,System.String,System.String,System.Boolean)">
 <summary>
 ### Extract or List Zip Archives
 
 Extract files from or list a zip archive.
 </summary>
 <param name="zipfile">
 The pathname of the zip file: tilde expansion (see 
 path.expand) will be performed.
 </param>
 <param name="files">
 A character vector of recorded filepaths to be extracted: 
 the default is to extract all files.
 </param>
 <param name="list">
 If TRUE, list the files and extract none. The 
 equivalent of unzip -l.
 </param>
 <param name="overwrite">
 If TRUE, overwrite existing files (the equivalent of unzip -o),
 otherwise ignore such files (the equivalent of unzip -n).
 </param>
 <param name="junkpaths">
 If TRUE, use only the basename of the stored filepath when 
 extracting. The equivalent of unzip -j.
 </param>
 <param name="exdir">
 The directory to extract files to (the equivalent of unzip -d). 
 It will be created if necessary.
 </param>
 <param name="unzip">
 The method to be used. An alternative is to use getOption("unzip"),
 which on a Unix-alike may be set to the path to a unzip program.
 </param>
 <param name="setTimes">
 logical. For the internal method only, should the file times be set 
 based on the times in the zip file? (NB: this applies to included 
 files, not to directories.)
 </param>
 <returns>
 If list = TRUE, a data frame with columns Name (character) Length 
 (the size of the uncompressed file, numeric) and Date (of class
 "POSIXct").
 Otherwise for the "internal" method, a character vector of the 
 filepaths extracted to, invisibly.
 </returns>
 <remarks>
 The default internal method is a minimal implementation, principally 
 designed for Windows' users to be able to unpack Windows binary 
 packages without external software. It does not (for example) support 
 Unicode filenames as introduced in zip 3.0: for that use unzip = 
 "unzip" with unzip 6.00 or later. It does have some support for bzip2 
 compression and > 2GB zip files (but not >= 4GB files pre-compression 
 contained in a zip file: like many builds of unzip it may truncate 
 these, in R's case with a warning if possible).
 If unzip specifies a program, the format of the dates listed with 
 list = TRUE is unknown (on Windows it can even depend on the current
 locale) and the return values could be NA or expressed in the wrong 
 time zone or misinterpreted (the latter being far less likely as from 
 unzip 6.00).
 File times in zip files are stored in the style of MS-DOS, as local 
 times to an accuracy of 2 seconds. This is not very useful when transferring 
 zip files between machines (even across continents), so we chose not 
 to restore them by default.
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.utils.create_zip(System.String,System.Object,System.String,System.String,System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 Create Zip Archives
 
 A wrapper for an external zip command to create zip archives.
 </summary>
 <param name="zipfile">
 The pathname of the zip file: tilde expansion (see path.expand) will be performed.
 </param>
 <param name="files">
 A character vector of recorded filepaths to be included.
 </param>
 <param name="flags">
 A character string of flags to be passed to the command: see ‘Details’.
 </param>
 <param name="extras">
 An optional character vector: see ‘Details’.
 </param>
 <param name="zip">
 A character string specifying the external command to be used.
 </param>
 <param name="env"></param>
 <returns>
 The status value returned by the external command, invisibly.
 </returns>
 <remarks>
 On a Unix-alike, the default for zip will by default use the value of 
 R_ZIPCMD, which is set in ‘etc/Renviron’ if an unzip command was found
 during configuration. On Windows, the default relies on a zip program
 (for example that from Rtools) being in the path.
 
 The default for flags is that appropriate for zipping up a directory
 tree in a portable way: see the system-specific help for the zip command 
 for other possibilities.
 
 Argument extras can be used to specify -x or -i followed by a list of 
 filepaths to exclude or include. Since extras will be treated as if 
 passed to system, if the filepaths contain spaces they must be quoted 
 e.g. by shQuote.
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.utils.sendMessage(System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 send task message to the parent node
 </summary>
 <param name="x"></param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Internal.invoke">
 <summary>
 The R internal function invoke helper module
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Runtime.Internal.invoke.index">
 <summary>
 内部函数索引
 </summary>
 <remarks>
 a mapping of [R function name => function body]
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.invoke.pushEnvir(System.Type)">
 <summary>
 load an internal package module
 </summary>
 <param name="baseModule"></param>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.invoke.getAllInternals">
 <summary>
 get all internal functions from the R# runtime environment base module
 </summary>
 <returns></returns>
 
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.invoke.getFunction(System.String)">
 <summary>
 get function by name
 </summary>
 <param name="name"></param>
 <returns>
 this query function will returns nothing if the target symbol is not found
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.invoke.stop(System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 In debug mode, will throw exception at the caller site
 </summary>
 <param name="message"></param>
 <param name="envir"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.invoke.invokeInternals(SMRUCC.Rsharp.Runtime.Environment,System.String,SMRUCC.Rsharp.Runtime.Components.InvokeParameter[])">
 <summary>
 Invoke the runtime internal functions
 </summary>
 <param name="envir"></param>
 <param name="funcName$"></param>
 <param name="paramVals"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.lambdaExtensions.invokeArgument(System.Object[])">
 <summary>
 主要是应用于单个参数的R运行时函数的调用
 </summary>
 <param name="value"></param>
 <returns></returns>
 
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.baseOp.dataframeOp.cbindOp.castPartData(System.String,System.Object,System.Boolean,System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 just try to cast the given part of data as dataframe
 </summary>
 <param name="nameKey"></param>
 <param name="col"></param>
 <param name="strict"></param>
 <param name="[default]"></param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.baseOp.dataframeOp.cbindOp.columnCombine(SMRUCC.Rsharp.Runtime.Internal.Object.dataframe,System.String,System.Object,System.Boolean,System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 try to combine two dataframe by columns
 </summary>
 <param name="d"></param>
 <param name="nameKey"></param>
 <param name="col"></param>
 <param name="strict"></param>
 <param name="[default]">the default fill value for the missing row data if 
 the row numbers between two dataframe is mis-matched, and safe mode is
 enabled.</param>
 <param name="env"></param>
 <returns></returns>
 <remarks>
 the duplicated column name will be renamed
 </remarks>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Internal.Object.baseOp.dataframeOp.rbindOp">
 <summary>
 rbind function helpers
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.baseOp.dataframeOp.rbindOp.safeRowBindDataFrame(SMRUCC.Rsharp.Runtime.Internal.Object.dataframe,SMRUCC.Rsharp.Runtime.Internal.Object.dataframe,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 this function will deal with the missing column name problem
 (missing column will be added into the result dataframe)
 </summary>
 <param name="d"></param>
 <param name="row"></param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.baseOp.dataframeOp.rbindOp.rowBindDataFrame(SMRUCC.Rsharp.Runtime.Internal.Object.dataframe,SMRUCC.Rsharp.Runtime.Internal.Object.dataframe,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 combine two dataframe by rows
 </summary>
 <param name="d"></param>
 <param name="row"></param>
 <param name="env"></param>
 <returns></returns>
 <remarks>
 this function will check for the column name matches
 </remarks>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Internal.Object.IdataframeReader">
 <summary>
 syntax helper for a readonly dataframe liked clr object
 </summary>
 <remarks>
 get column by index, get row by index, and get row names
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.IdataframeReader.getColumn(System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 get column feature data from current readonly dataframe liked clr object
 </summary>
 <param name="index"></param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.IdataframeReader.getRow(System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 get row samples data from current readonly dataframe liked clr object
 </summary>
 <param name="index"></param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Internal.Object.dataframe">
 <summary>
 A data frame, a matrix-like structure whose columns 
 may be of differing types (numeric, logical, factor 
 and character and so on).
 
 How the names Of the data frame are created Is complex, 
 And the rest Of this paragraph Is only the basic 
 story. If the arguments are all named And simple objects 
 (Not lists, matrices Of data frames) Then the argument 
 names give the column names. For an unnamed simple 
 argument, a deparsed version Of the argument Is used 
 As the name (With an enclosing I(...) removed). For a 
 named matrix/list/data frame argument With more than 
 one named column, the names Of the columns are the name 
 Of the argument followed by a dot And the column name 
 inside the argument: If the argument Is unnamed, the 
 argument's column names are used. For a named or unnamed 
 matrix/list/data frame argument that contains a single 
 column, the column name in the result is the column 
 name in the argument. Finally, the names are adjusted 
 to be unique and syntactically valid unless 
 ``check.names = FALSE``.
 </summary>
 <remarks>
 A data frame is a list of variables of the same number of 
 rows with unique row names, given class "data.frame". If 
 no variables are included, the row names determine the 
 number of rows.
 The column names should be non-empty, And attempts To use 
 empty names will have unsupported results. Duplicate column 
 names are allowed, but you need To use ``check.names = False``
 For data.frame To generate such a data frame. However, 
 Not all operations On data frames will preserve duplicated 
 column names: For example matrix-Like subsetting will 
 force column names in the result To be unique.
 data.frame converts each of its arguments to a data frame 
 by calling ``as.data.frame(optional = TRUE)``. As that Is a 
 generic function, methods can be written to change the 
 behaviour of arguments according to their classes: R comes 
 With many such methods. Character variables passed To 
 data.frame are converted To factor columns unless Protected 
 by I Or argument stringsAsFactors Is False. If a list Or 
 data frame Or matrix Is passed To data.frame it Is As If 
 Each component Or column had been passed As a separate 
 argument (except For matrices Protected by I).
 Objects passed To data.frame should have the same number 
 Of rows, but atomic vectors (see Is.vector), factors And 
 character vectors Protected by I will be recycled a whole 
 number Of times If necessary (including As elements Of 
 list arguments).
 If row names are Not supplied In the Call To data.frame, 
 the row names are taken from the first component that has 
 suitable names, For example a named vector Or a matrix With 
 rownames Or a data frame. (If that component Is subsequently 
 recycled, the names are discarded With a warning.) If 
 row.names was supplied As NULL Or no suitable component was 
 found the row names are the Integer sequence starting at one 
 (And such row names are considered To be 'automatic’, and 
 not preserved by as.matrix).
 If row names are supplied Of length one And the data frame 
 has a Single row, the row.names Is taken To specify the 
 row names And Not a column (by name Or number).
 Names are removed from vector inputs Not Protected by I.
 Default.stringsAsFactors Is a utility that takes 
 ``getOption("stringsAsFactors")`` And ensures the result Is 
 ``TRUE`` Or ``FALSE`` (Or throws an error if the value Is Not
 NULL).
 
 > Chambers, J. M. (1992) Data for models. Chapter 3 of 
 Statistical Models in S eds J. M. Chambers and T. J. 
 Hastie, Wadsworth &amp; Brooks/Cole.
 </remarks>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Internal.Object.dataframe.columns">
 <summary>
 the field vectors inside current data frame object, the vector 
 dimension size of the fields could be a scalar value with just
 one element or vector dimension should equals to the dimension
 size of <see cref="P:SMRUCC.Rsharp.Runtime.Internal.Object.dataframe.rownames"/>.
 </summary>
 <returns></returns>
 <remarks>
 长度为1或者长度为n
 </remarks>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Internal.Object.dataframe.rownames">
 <summary>
 the dataframe rownames
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Internal.Object.dataframe.colnames">
 <summary>
 get all keys names of <see cref="P:SMRUCC.Rsharp.Runtime.Internal.Object.dataframe.columns"/> data
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Internal.Object.dataframe.nrows">
 <summary>
 column <see cref="P:System.Array.Length"/>
 </summary>
 <returns>
 the row number is tested based on the ncol, if the ncol is zero, then the 
 function GetRowNumbers will returns zero directly.
 </returns>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Internal.Object.dataframe.ncols">
 <summary>
 the number of the features in current dataframe object
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Internal.Object.dataframe.empty">
 <summary>
 current dataframe object contains any data or not?
 </summary>
 <returns>empty is true means contains no rows data or no columns</returns>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Internal.Object.dataframe.getColumnVector(System.String)">
 <summary>
 get column by name
 </summary>
 <returns>
 this property always returns a vector in full size(length is equals to <see cref="P:SMRUCC.Rsharp.Runtime.Internal.Object.dataframe.nrows"/>),
 orelse the value null if the given <paramref name="columnName"/> is not exists in the 
 dataframe column fields.
 </returns>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Internal.Object.dataframe.getColumnVector(System.Int32)">
 <summary>
 <see cref="M:SMRUCC.Rsharp.Runtime.Internal.Object.dataframe.getKeyByIndex(System.Int32)"/>, get column by 1-based offset
 </summary>
 <param name="index"></param>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Internal.Object.dataframe.rowViews">
 <summary>
 debug view of this dataframe object in rows, debug used only.
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.dataframe.#ctor(SMRUCC.Rsharp.Runtime.Internal.Object.dataframe)">
 <summary>
 do data clone
 </summary>
 <param name="clone"></param>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.dataframe.add``1(System.String,``0[])">
 <summary>
 add or replace a column vector
 </summary>
 <typeparam name="T"></typeparam>
 <param name="key"></param>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.dataframe.add``1(System.String,System.Collections.Generic.IEnumerable{``0})">
 <summary>
 add or replace a column vector
 </summary>
 <typeparam name="T"></typeparam>
 <param name="key"></param>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.dataframe.add(System.String,System.Array)">
 <summary>
 add or replace a column vector
 </summary>
 <param name="key"></param>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.dataframe.delete(System.String[])">
 <summary>
 delete columns from the dataframe.
 </summary>
 <param name="keys"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.dataframe.detach(System.String)">
 <summary>
 delete the specific col and get the deleted col array
 </summary>
 <param name="col"></param>
 <returns>this function will returns nothing if the given <paramref name="col"/> 
 is not existed inside the dataframe columns.</returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.dataframe.getKeyByIndex(System.Int32)">
 <summary>
 将列索引号转换为列名称
 </summary>
 <param name="index">以1为底的列索引号</param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.dataframe.getVector``1(System.String[])">
 <summary>
 get column by name
 </summary>
 <typeparam name="T"></typeparam>
 <param name="synonym">同意名列表</param>
 <returns>
 function may returns nothing if all of the given name 
 is missing from the dataframe object.
 
 (这个函数只会返回碰见的第一个同意名的列数据)
 </returns>
 <remarks>
 this function returns a vector in full size always
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.dataframe.getVector(System.String,System.Boolean)">
 <summary>
 get a vector from column data
 </summary>
 <param name="name"></param>
 <param name="fullSize">
 the data vector should be fill with the 
 identical value when deal with the scalar
 value. This function just returns the 
 scalar value by default is the target 
 column contains just one element
 </param>
 <returns>
 this function returns nothing if the given <paramref name="name"/> is not
 exists in the dataframe fields.
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.dataframe.ToString">
 <summary>
 show the dataframe dimension information
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.dataframe.projectByColumn(System.Array,SMRUCC.Rsharp.Runtime.Environment,System.Boolean,System.Boolean,System.Boolean)">
 <summary>
 ``data[, selector]``
 </summary>
 <param name="selector"></param>
 <param name="reverse">
 only works for the character index
 </param>
 <param name="strict">
 the strict option for the dataframe column projection, this option has different behaviours for deal with the missing data column:
 
 for strict mode, an error exception will generates for break the program executation
 for non-strict mode, the missing column will be added with all element vector is NULL
 </param>
 <returns>dataframe</returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.dataframe.sliceByRow(System.Boolean[],SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 
 </summary>
 <param name="flags"></param>
 <param name="env"></param>
 <returns></returns>
 <remarks>
 which is true is zero-based by default
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.dataframe.sliceByRow(System.Array,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ``data[selector, ]``
 </summary>
 <param name="selector">
 accepts:
 
 1. logical vector as row selector
 2. integer vector for take rows by row number
 3. character vector for take rows by row name
 
 </param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.dataframe.getRowList(System.Int32,System.Boolean)">
 <summary>
 所传递进来这个函数的索引编号应该是以零为底的
 </summary>
 <param name="index">
 index: integer 0 based
 </param>
 <param name="drop">
 当drop参数为false的时候，返回一个数组向量
 反之返回一个list
 </param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.dataframe.forEachRow(System.String[])">
 <summary>
 获取得到数据框之中每一行的数据(``[rowname => columns[]]``)
 </summary>
 <param name="colKeys"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.dataframe.getRowIndex(System.Object)">
 <summary>
 这个函数返回的是以零为底的索引值
 </summary>
 <param name="any"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.dataframe.FilterByRowIndex(System.Int32[],SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 
 </summary>
 <param name="skips">1-based index to be filter</param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.dataframe.GetByRowIndex(System.Int32[],SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 所传递进来的索引编号，应该是以零为底的
 </summary>
 <param name="index">
 以零为底的索引号列表，-1对应的行将会返回空值的行数据
 </param>
 <returns>
 a dataframe object with row subset or an error message
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.dataframe.subsetColData(System.Array,System.Int32[],SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 索引编号，应该是以零为底的
 </summary>
 <param name="c">the column data, length of this array data maybe 1 or nrows</param>
 <param name="index">
 索引编号，应该是以零为底的。-1的元素返回空值
 </param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.dataframe.getRowNames">
 <summary>
 这个函数会自动处理空值的情况
 </summary>
 <returns>
 this function will generated a index row names automatically if
 the <see cref="P:SMRUCC.Rsharp.Runtime.Internal.Object.dataframe.rownames"/> data is nothing, or this function will
 make a copy of the <see cref="P:SMRUCC.Rsharp.Runtime.Internal.Object.dataframe.rownames"/> array.
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.dataframe.GetRowNumbers">
 <summary>
 get max length of the column vectors
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.dataframe.CreateDataFrame``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>
 Cast a vector of CLR object to a dataframe
 </summary>
 <typeparam name="T"></typeparam>
 <param name="data"></param>
 <returns></returns>
 <remarks>
 the class object property used as the dataframe column data
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.dataframe.CreateDataFrame``1(Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedCollection{``0}[],System.Collections.Generic.IEnumerable{System.String})">
 <summary>
 Create dataframe from row data
 </summary>
 <typeparam name="T"></typeparam>
 <param name="rows"></param>
 <param name="colNames"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.dataframe.setNames(System.String[],SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 set column names via names function
 </summary>
 <param name="names"></param>
 <param name="envir"></param>
 <returns></returns>
 <example>
 names(df) = x;
 ' equals to
 colnames(df) = x;
 </example>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.dataframe.hasName(System.String)">
 <summary>
 has column name?
 </summary>
 <param name="name"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.dataframe.getNames">
 <summary>
 get column names
 </summary>
 <returns></returns>
 
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Internal.Object.factor">
 <summary>
 string to integer dictionary
 </summary>
 <remarks>
 这个对象只是相当于unit的一个存在
 </remarks>
</member>
<member name="F:SMRUCC.Rsharp.Runtime.Internal.Object.factor.m_levels">
 <summary>
 order in character asc
 </summary>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Internal.Object.factor.nlevel">
 <summary>
 level的数量
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.factor.GetFactor(System.String)">
 <summary>
 
 </summary>
 <param name="lb"></param>
 <returns>
 get 1 based factor level integer value, zero means nothing or missing
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.factor.asCharacter(System.Int32[],SMRUCC.Rsharp.Runtime.Internal.Object.factor)">
 <summary>
 将目标等级值转换为原始字符串值
 </summary>
 <param name="levels"></param>
 <param name="factor"></param>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Internal.Object.generator">
 <summary>
 A generator function wrapper
 </summary>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Internal.Object.invalidObject">
 <summary>
 NA literal value
 </summary>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Internal.Object.invalidObject.value">
 <summary>
 a single object across the entire R# runtime environment
 </summary>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Internal.Object.list">
 <summary>
 A tuple paired list object model
 </summary>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Internal.Object.list.length">
 <summary>
 gets the <see cref="P:SMRUCC.Rsharp.Runtime.Internal.Object.list.slots"/> collection size
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Internal.Object.list.data">
 <summary>
 get all values collection from the ``slots`` symbol.
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Internal.Object.list.is_empty">
 <summary>
 check of the data <see cref="P:SMRUCC.Rsharp.Runtime.Internal.Object.list.slots"/> is null or empty or not?
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Internal.Object.list.SlotValue(System.String)">
 <summary>
 Get slot value by name
 </summary>
 <param name="name"></param>
 <returns>
 returns nothing if there is no given 
 <paramref name="name"/> exists in the
 slots
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.list.#ctor(SMRUCC.Rsharp.Runtime.Internal.Object.list)">
 <summary>
 data clone
 </summary>
 <param name="list"></param>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.list.#ctor(System.Collections.IDictionary)">
 <summary>
 Create tuple list from a general dictionary set, dictionary value type could be anything
 </summary>
 <param name="table"></param>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.list.#ctor(System.Type)">
 <summary>
 
 </summary>
 <param name="type">
 <see cref="P:SMRUCC.Rsharp.Runtime.Components.RsharpDataObject.elementType"/>
 </param>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.list.#ctor(SMRUCC.Rsharp.Runtime.Interop.RType)">
 <summary>
 
 </summary>
 <param name="type">
 <see cref="P:SMRUCC.Rsharp.Runtime.Components.RsharpDataObject.elementType"/>
 </param>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.list.#ctor(Microsoft.VisualBasic.Language.ArgumentReference[])">
 <summary>
 construct a new tuple list object from a named slot value collection.
 </summary>
 <param name="data">a named slot value collection.</param>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.list.add(System.String,System.Object)">
 <summary>
 add key-value directly, for add content data with possible duplicated names safely, use the <see cref="M:SMRUCC.Rsharp.Runtime.Internal.Object.list.unique_add(System.String,System.Object)"/> method. 
 </summary>
 <param name="name"></param>
 <param name="value"></param>
 <remarks>
 this function has different behaviours when compares with
 the <see cref="M:SMRUCC.Rsharp.Runtime.Internal.Object.list.setByName(System.String,System.Object,SMRUCC.Rsharp.Runtime.Environment)"/>:
 
 1. this function just add slot value directly even if the given value is nothing
 2. ``setByName`` function will removes slot if the value is nothing
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.list.unique_add(System.String,System.Object)">
 <summary>
 add unique key-value safely
 </summary>
 <param name="name">duplicated name will be appends a suffix string for avoid the key conflicts</param>
 <param name="value"></param>
 <remarks>
 the duplicated name will be resolved safely in this function.
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.list.add(System.String,System.String)">
 <summary>
 add a string value
 </summary>
 <param name="name"></param>
 <param name="str"></param>
 <remarks>
 due to the reason of string is kind of a char collection
 so that the overlaod of the generic collection add method
 may caused the incorrect method reference.
 
 create this function for deal with the string value overloads bug.
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.list.add``1(System.String,System.Collections.Generic.IEnumerable{``0})">
 <summary>
 cast the given collection as array and then add into current tuple list
 </summary>
 <typeparam name="T"></typeparam>
 <param name="name"></param>
 <param name="collection"></param>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.list.hasName(System.String)">
 <summary>
 does <see cref="P:SMRUCC.Rsharp.Runtime.Internal.Object.list.slots"/> has the specific <paramref name="name"/>?
 </summary>
 <param name="name"></param>
 <returns></returns>
 <remarks>
 check for the dictionary key is existsed?
 </remarks>
 
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.list.hasNames(System.String[])">
 <summary>
 check that all name inside the given <paramref name="names"/> is
 exists in current data list.
 </summary>
 <param name="names"></param>
 <returns></returns>
 
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.list.slotKeys">
 <summary>
 get names with uncheck default index
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.list.listOf(SMRUCC.Rsharp.Runtime.Components.TypeCodes)">
 <summary>
 all value element inside current tuple list is the given element type
 </summary>
 <param name="elementMode">the element type for test</param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.list.getNames">
 <summary>
 this function may returns nothing if all index names are default index, example as: [[1]]
 </summary>
 <returns></returns>
 <remarks>
 for get key names safely(avoid null reference) in the clr code, 
 expression like ``slots.Keys.ToArray`` could be used. analso the
 function <see cref="M:SMRUCC.Rsharp.Runtime.Internal.Object.list.slotKeys"/> works for this situation.
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.list.setNames(System.String[],SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 出错会返回错误消息
 </summary>
 <param name="names"></param>
 <param name="envir"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.list.getValue``1(System.String[],SMRUCC.Rsharp.Runtime.Environment,``0,SMRUCC.Rsharp.Runtime.Components.Message@)">
 <summary>
 get value or default
 </summary>
 <typeparam name="T"></typeparam>
 <param name="synonym"></param>
 <param name="env"></param>
 <param name="default">the default value.</param>
 <returns></returns>
 <remarks>
 this method will evaluate the value <see cref="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.Expression"/> 
 to target <typeparamref name="T"/> automatically.
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.list.ctypeInternal``1(System.Object,SMRUCC.Rsharp.Runtime.Environment,SMRUCC.Rsharp.Runtime.Components.Message@)">
 <summary>
 cast data type
 </summary>
 <typeparam name="T"></typeparam>
 <param name="value">
 if value is an expression andalso <typeparamref name="T"/> 
 type is not an expression, then this function will try to 
 evaluate the expression as value and then cast data type 
 again.
 </param>
 <param name="env"></param>
 <param name="err"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.list.getValue``1(System.String,SMRUCC.Rsharp.Runtime.Environment,``0,SMRUCC.Rsharp.Runtime.Components.Message@)">
 <summary>
 get value or default
 </summary>
 <typeparam name="T"></typeparam>
 <param name="name"></param>
 <param name="env"></param>
 <param name="default">the default value.</param>
 <returns></returns>
 <remarks>
 this method will evaluate the value <see cref="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.Expression"/> 
 to target <typeparamref name="T"/> automatically.
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.list.AsGeneric``1(SMRUCC.Rsharp.Runtime.Environment,``0,SMRUCC.Rsharp.Runtime.Components.Message@)">
 <summary>
 Try cast of the object type value to a generic type value
 </summary>
 <typeparam name="T">the generic type that cast to</typeparam>
 <param name="env"></param>
 <param name="default">the default element generic value if the type cast failure.</param>
 <param name="err">gets the error message for the type cast failure from this parameter.</param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.list.getByIndex(System.Int32)">
 <summary>
 
 </summary>
 <param name="i">1-based index</param>
 <returns></returns>
 <remarks>
 the given index value <paramref name="i"/> should be a integer value from 1-based.
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.list.setByIndex(System.Int32,System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 set value by index
 </summary>
 <param name="i">1-based index</param>
 <param name="value">any kind of the clr runtime value to store in this tuple list that associated with this index.</param>
 <param name="envir"></param>
 <returns></returns>
 <remarks>
 the given index value <paramref name="i"/> should be a integer value from 1-based.
 </remarks>
 
 <exception cref="T:System.NotImplementedException"></exception>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.list.getByName(System.String)">
 <summary>
 If target key name is not found in list, then
 function will returns nothing
 </summary>
 <param name="name"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.list.getBySynonyms(System.String[])">
 <summary>
 get raw value by a set of given synonyms.
 </summary>
 <param name="synonym"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.list.getByName(System.String[])">
 <summary>
 Create a list subset
 </summary>
 <param name="names">
 A specific list keys that will be used for extract the subset 
 elements from the original list to create a new list object.
 </param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.list.setByName(System.String,System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 add/updates of the key <paramref name="name"/> associated <paramref name="value"/> data.
 </summary>
 <param name="name"></param>
 <param name="value"></param>
 <param name="envir"></param>
 <returns></returns>
 <remarks>
 NULL <paramref name="value"/> will remove the target slot by <paramref name="name"/>
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.list.empty(SMRUCC.Rsharp.Runtime.Internal.Object.list)">
 <summary>
 check of the given tuple list object is null or empty?
 </summary>
 <param name="list"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.list.set_empty(System.Collections.Generic.IEnumerable{System.String})">
 <summary>
 create a list with given slot names, but the 
 corresponding slot value is nothing
 </summary>
 <param name="slot_names"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.list.subset(System.String[])">
 <summary>
 A shortcut of function <see cref="M:SMRUCC.Rsharp.Runtime.Internal.Object.list.getByName(System.String[])"/>
 </summary>
 <param name="keys"></param>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Internal.Object.matrix">
 <summary>
 all element inside the matrix has the sample data type
 </summary>
 <remarks>
 kind of liked <see cref="T:SMRUCC.Rsharp.Runtime.Internal.Object.dataframe"/> type
 </remarks>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Internal.Object.matrix.mat">
 <summary>
 a rectangle array
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.matrix.getNames">
 <summary>
 get the matrix col names
 </summary>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Internal.Object.pipeline">
 <summary>
 The R# data pipeline
 
 this model object is a kind of wrapper of the .net clr <see cref="T:System.Collections.IEnumerable"/> interface
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Runtime.Internal.Object.pipeline.populatorFirstErr">
 <summary>
 在抛出数据的时候所遇到的第一个错误消息
 </summary>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Internal.Object.pipeline.pipeFinalize">
 <summary>
 The action will be called after finish loop on the sequence. 
 Null value of this property will be ignored
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Internal.Object.pipeline.isError">
 <summary>
 contains an error message in the pipeline populator or 
 the pipeline data is an error message. You can get the
 error message via function <see cref="M:SMRUCC.Rsharp.Runtime.Internal.Object.pipeline.getError"/> when
 this property value is TRUE
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Internal.Object.pipeline.isMessage">
 <summary>
 current data pipeline is a data message?
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.pipeline.getError">
 <summary>
 Gets the R# error message data
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.pipeline.createVector(SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 Only suite for small set of data
 </summary>
 <param name="env"></param>
 <returns></returns>
 <remarks>
 If the data in current pipeline is super large, then
 the program will be crashed.
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.pipeline.populates``1(SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 populate the data element from the pipeline stream
 </summary>
 <typeparam name="T">the .net clr generic type constraint</typeparam>
 <param name="env"></param>
 <returns>direct cast</returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.pipeline.CreateFromPopulator``1(System.Collections.Generic.IEnumerable{``0},System.Action)">
 <summary>
 Create pipeline object from the given upstream data
 </summary>
 <typeparam name="T"></typeparam>
 <param name="upstream">the upstream data</param>
 <param name="finalize"></param>
 <returns>
 </returns>
 <remarks>
 just a simple wrapper to the <see cref="F:SMRUCC.Rsharp.Runtime.Internal.Object.pipeline.pipeline"/> object constructor function.
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.pipeline.TryCreatePipeline``1(System.Object,SMRUCC.Rsharp.Runtime.Environment,System.Boolean,System.String)">
 <summary>
 try create populator with specific type constraint
 </summary>
 <typeparam name="T"></typeparam>
 <param name="upstream"></param>
 <param name="env"></param>
 <param name="suppress"></param>
 <param name="callerFrameName">debug used only</param>
 <returns>
 the required data sequence or an error message if the 
 upstream element type is not matched of the required 
 target type.
 
 this function also will returns a null reference error
 message if the given <paramref name="upstream"/> data is
 ``Nothing``.
 </returns>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Internal.Object.vbObject">
 <summary>
 Proxy for VB.NET class <see cref="T:System.Object"/>
 </summary>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Internal.Object.vbObject.target">
 <summary>
 that target clr object to wrap in R# runtime.
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Internal.Object.vbObject.elementType">
 <summary>
 R# type wrapper of the type data for <see cref="P:SMRUCC.Rsharp.Runtime.Internal.Object.vbObject.target"/>
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.vbObject.getByName(System.String)">
 <summary>
 Get property value/method reference by name
 </summary>
 <param name="name"></param>
 <returns>
 Function will returns nothing when target not found, but 
 property value read getter result may be nothing, please 
 check member exists or not by method <see cref="M:SMRUCC.Rsharp.Runtime.Internal.Object.vbObject.existsName(System.String)"/> 
 if the result value is nothing of this function.
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.vbObject.getByName(System.String[])">
 <summary>
 Get properties value collection by a given name list
 </summary>
 <param name="names"></param>
 <returns></returns>
 
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.vbObject.setByName(System.String,System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 set property value by name
 </summary>
 <param name="name"></param>
 <param name="value"></param>
 <param name="envir"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.vbObject.setByName(System.String[],System.Array,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 set properties values by given name list
 </summary>
 <param name="names"></param>
 <param name="value"></param>
 <param name="envir"></param>
 <returns></returns>
 
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Internal.Object.vector.unit">
 <summary>
 do conversion from current vector to another scale.
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.vector.#ctor(SMRUCC.Rsharp.Runtime.Internal.Object.vector)">
 <summary>
 value copy
 </summary>
 <param name="vec"></param>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.vector.#ctor(System.Array,SMRUCC.Rsharp.Runtime.Interop.RType)">
 <summary>
 这个构造函数主要是应用于内部编程的快速创建
 </summary>
 <param name="input"></param>
 <param name="type">
 should be the array element type
 </param>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.vector.#ctor(System.Type,System.Collections.IEnumerable,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 Create a vector from a pipeline model and given array element <paramref name="model"/> type
 </summary>
 <param name="model">element type of the array</param>
 <param name="input"></param>
 <remarks>
 try to make the collection data generic in this constructor function
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.vector.setNames(System.String[],SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 出错的时候会返回<see cref="T:SMRUCC.Rsharp.Runtime.Components.Message"/>
 </summary>
 <param name="names"></param>
 <param name="envir"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.vector.getByIndex(System.Int32)">
 <summary>
 以R语言中的下表的方式访问数组元素，所以这个函数的i参数应该是从1开始的
 </summary>
 <param name="i">
 这个下标值应该是从1开始的
 </param>
 <returns></returns>
 <remarks>
 这个函数是一个安全的函数，下表越界的时候按照R语言的处理规则，不会抛出错误，而是返回空值
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.vector.getByIndex(System.Int32[])">
 <summary>
 
 </summary>
 <param name="i">
 这个下标值应该是从1开始的
 </param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.vector.fromScalar(System.Object)">
 <summary>
 create a vector from a scalar value
 </summary>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Internal.Object.margins">
 <summary>
 row or column?
 </summary>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Internal.Object.invisible">
 <summary>
 do not print the result object on the console
 unless an explicit call of the ``print`` or ``cat``
 function have been invoke
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.invisible.#ctor">
 <summary>
 construct a new invisible value object
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.invisible.NULL">
 <summary>
 invisible(NULL);
 </summary>
 <returns></returns>
 
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.Linq.DataframeGroup.groupBy(SMRUCC.Rsharp.Runtime.Internal.Object.dataframe,System.String,System.Boolean)">
 <summary>
 group by the string factor values in dataframe column as key
 </summary>
 <param name="data"></param>
 <param name="key"></param>
 <param name="safe">
 will cast null to empty string if this parameter value is set to TRUE
 </param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.names.setNames(System.Object,System.Array,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 
 </summary>
 <param name="[object]"></param>
 <param name="names">This method will ensure that the value is a string vector</param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.names.getRowNames(System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 try to get the dataframe rownames
 </summary>
 <param name="[object]"></param>
 <param name="envir"></param>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Internal.Object.Converts.castList">
 <summary>
 cast ``R#`` <see cref="T:SMRUCC.Rsharp.Runtime.Internal.Object.list"/> to <see cref="T:System.Collections.Generic.Dictionary`2"/>
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.Converts.castList.listInternal(System.Object,SMRUCC.Rsharp.Runtime.Internal.Object.list,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 cast any clr object to R# tuple list object
 </summary>
 <param name="obj"></param>
 <param name="args"></param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.Converts.castList.objCastList(SMRUCC.Rsharp.Runtime.Internal.Object.vbObject,SMRUCC.Rsharp.Runtime.Internal.Object.list,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 cast .NET CLR object to R# list object
 </summary>
 <param name="vbobj"></param>
 <param name="args"></param>
 <param name="env"></param>
 <returns>
 this function may returns an error message if the clr object property read error.
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.Converts.castRaw.castToRawRoutine(SMRUCC.Rsharp.Runtime.Environment,System.Object,Microsoft.VisualBasic.Text.Encodings,System.Boolean)">
 <summary>
 返回一个stream对象
 </summary>
 <param name="env"></param>
 <param name="obj"></param>
 <param name="encoding"></param>
 <param name="networkByteOrder"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.Converts.RConversion.asDate2(System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 parse string text content as date time values
 </summary>
 <param name="obj"></param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.Converts.RConversion.isDateTime(System.String)">
 <summary>
 the given string is in datetime format?
 </summary>
 <param name="str"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.Converts.RConversion.asDate(System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 parse string text content as date time values
 </summary>
 <param name="obj"></param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.Converts.RConversion.asObject(System.Object)">
 <summary>
 Cast .NET object to R# object
 </summary>
 <param name="obj"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.Converts.RConversion.unlist(System.Object,System.Object,System.Boolean,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ### Flatten Lists
 
 Given a list structure x, unlist simplifies it to produce a vector 
 which contains all the atomic components which occur in <paramref name="x"/>.
 </summary>
 <param name="x">an R Object, typically a list Or vector.</param>
 <param name="[typeof]">element type of the array</param>
 <param name="env"></param>
 <returns>
 NULL or an expression or a vector of an appropriate mode to hold 
 the list components.

 The output type Is determined from the highest type Of the components 
 In the hierarchy ``NULL`` &lt; ``raw`` &lt; ``logical`` &lt; ``Integer`` 
 &lt; ``Double`` &lt; ``complex`` &lt; ``character`` &lt; ``list`` &lt; 
 ``expression``, after coercion Of pairlists To lists.
 </returns>
 <remarks>
 unlist is generic: you can write methods to handle specific classes of 
 objects, see InternalMethods, and note, e.g., relist with the unlist
 method for relistable objects.

 If recursive = False, the Function will Not recurse beyond the first level 
 items In x.

 Factors are treated specially. If all non-list elements Of x are factors 
 (Or ordered factors) Then the result will be a factor With levels the union 
 Of the level sets Of the elements, In the order the levels occur In the 
 level sets Of the elements (which means that If all the elements have the 
 same level Set, that Is the level Set Of the result).

 x can be an atomic vector, but Then unlist does Nothing useful, Not even 
 drop names.

 By Default, unlist tries to retain the naming information present in x. If 
 ``use.names = FALSE`` all naming information Is dropped.

 Where possible the list elements are coerced To a common mode during the 
 unlisting, And so the result often ends up As a character vector. Vectors 
 will be coerced To the highest type Of the components In the hierarchy 
 ``NULL`` &lt; ``raw`` &lt; ``logical`` &lt; ``Integer`` &lt; ``Double`` &lt;
 ``complex`` &lt; ``character`` &lt; ``list`` &lt; ``expression``: pairlists 
 are treated As lists.

 A list Is a (generic) vector, And the simplified vector might still be a list 
 (And might be unchanged). Non-vector elements Of the list (For example language 
 elements such As names, formulas And calls) are Not coerced, And so a list 
 containing one Or more Of these remains a list. (The effect Of unlisting an lm 
 fit Is a list which has individual residuals As components.) Note that 
 ``unlist(x)`` now returns x unchanged also For non-vector x, instead Of signaling 
 an Error In that Case.
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.Converts.RConversion.unlistOfRList(SMRUCC.Rsharp.Runtime.Internal.Object.list,Microsoft.VisualBasic.Language.Value{System.Boolean})">
 <summary>
 
 </summary>
 <param name="rlist"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.Converts.RConversion.asDataframe(System.Object,System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ### Coerce to a Data Frame
 
 Functions to check if an object is a data frame, or coerce it if possible.
 </summary>
 <param name="x">any R object.</param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.Converts.RConversion.castListRowsToDataframe(System.Collections.Generic.IEnumerable{SMRUCC.Rsharp.Runtime.Internal.Object.list},SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 cast row list data to a data table object.
 </summary>
 <param name="rows">
 each elements list in this collection data is a row in the generated dataframe object. 
 </param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.Converts.RConversion.castListMatrix(System.Collections.Generic.KeyValuePair{System.String,System.Object}[],System.String[],SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 each item in listdata is a row?
 </summary>
 <param name="rows"></param>
 <param name="env"></param>
 <returns></returns>
 
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.Converts.RConversion.castListToDataframe(System.Collections.Generic.Dictionary{System.String,System.Object},SMRUCC.Rsharp.Runtime.Internal.Object.list,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 cast column list to dataframe
 </summary>
 <param name="listData"></param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.Converts.RConversion.asVector(System.Object,System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ### Vectors
 
 vector produces a vector of the given length and mode.
 
 as.vector, a generic, attempts to coerce its argument into a 
 vector of mode mode (the default is to coerce to whichever 
 vector mode is most convenient): if the result is atomic all 
 attributes are removed.
 </summary>
 <param name="x">an R object.</param>
 <param name="mode">
 character string naming an atomic mode or "list" or "expression" 
 or (except for vector) "any". Currently, is.vector() allows any 
 type (see typeof) for mode, and when mode is not "any", 
 ``is.vector(x, mode)`` is almost the same as ``typeof(x) == mode``.
 </param>
 <param name="env"></param>
 <remarks>
 The atomic modes are "logical", "integer", "numeric" (synonym 
 "double"), "complex", "character" and "raw".

 If mode = "any", Is.vector may Return True For the atomic modes, 
 list And expression. For any mode, it will Return False If x has 
 any attributes except names. (This Is incompatible With S.) On 
 the other hand, As.vector removes all attributes including names 
 For results Of atomic mode (but Not those Of mode "list" nor 
 "expression").

 Note that factors are Not vectors; Is.vector returns False And 
 ``as.vector`` converts a factor To a character vector For 
 ``mode = "any"``.
 
 as.vector and is.vector are quite distinct from the meaning of the 
 formal class "vector" in the methods package, and hence as(x, "vector") 
 and is(x, "vector").

 Note that ``as.vector(x)`` Is Not necessarily a null operation if 
 ``is.vector(x)`` Is true: any names will be removed from an atomic 
 vector.

 Non-vector modes "symbol" (synonym "name") And "pairlist" are accepted 
 but have long been undocumented: they are used To implement As.name And 
 As.pairlist, And those functions should preferably be used directly. 
 None Of the description here applies To those modes: see the help For 
 the preferred forms.
 </remarks>
 <returns>
 For vector, a vector of the given length and mode. Logical vector 
 elements are initialized to FALSE, numeric vector elements to 0, 
 character vector elements to "", raw vector elements to nul bytes and 
 list/expression elements to NULL.

 For as.vector, a vector (atomic Or of type list Or expression). All 
 attributes are removed from the result if it Is of an atomic mode, but 
 Not in general for a list result. The default method handles 24 input 
 types And 12 values of type: the details Of most coercions are 
 undocumented And subject To change.

 For Is.vector, TRUE Or FALSE. Is.vector(x, mode = "numeric") can be 
 true for vectors of types "integer" Or "double" whereas 
 ``is.vector(x, mode = "double")`` can only be true for those of type 
 "double".
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.Converts.RConversion.asList(System.Object,System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ### Lists – Generic and Dotted Pairs
 
 Functions to construct, coerce and check for both kinds of R lists.
 Cast the raw dictionary object to R# list object
 </summary>
 <param name="x">
 object to be coerced or tested.
 this function will make a data copy if the input 
 data is already a <see cref="T:SMRUCC.Rsharp.Runtime.Internal.Object.list"/>
 </param>
 <param name="args">
 for dataframe type:
 
 + ``byrow``: logical, default is FALSE, means cast dataframe to list directly by column hash table values
 + ``names``: character, the column names that will be used as the list names
 
 </param>
 <returns></returns>
 <remarks>
 this function supports the generic function calls
 
 Almost all lists in R internally are Generic Vectors, whereas traditional 
 dotted pair lists (as in LISP) remain available but rarely seen by users 
 (except as formals of functions).
 
 The arguments To list Or pairlist are Of the form value Or tag = value. The 
 functions Return a list Or dotted pair list composed Of its arguments With
 Each value either tagged Or untagged, depending On how the argument was 
 specified.

 alist handles its arguments as if they described function arguments. So the 
 values are Not evaluated, And tagged arguments with no value are allowed 
 whereas list simply ignores them. alist Is most often used in conjunction 
 with formals.

 as.list attempts to coerce its argument to a list. For functions, this returns 
 the concatenation of the list of formal arguments And the function body. For 
 expressions, the list of constituent elements Is returned. as.list Is generic, 
 And as the default method calls as.vector(mode = "list") for a non-list, 
 methods for as.vector may be invoked. as.list turns a factor into a list of 
 one-element factors, keeping names. Other attributes may be dropped unless the 
 argument already Is a list Or expression. (This Is inconsistent with functions 
 such as as.character which always drop attributes, And Is for efficiency since 
 lists can be expensive to copy.)

 Is.list returns TRUE if And only if its argument Is a list Or a pairlist of 
 length > 0>0. Is.pairlist returns TRUE if And only if the argument Is a pairlist 
 Or NULL (see below).

 The "environment" method for as.list copies the name-value pairs (for names Not 
 beginning with a dot) from an environment to a named list. The user can request 
 that all named objects are copied. Unless sorted = TRUE, the list Is in no 
 particular order (the order depends on the order of creation of objects And whether 
 the environment Is hashed). No enclosing environments are searched. (Objects 
 copied are duplicated so this can be an expensive operation.) Note that there 
 Is an inverse operation, the as.environment() method for list objects.

 An empty pairlist, pairlist() Is the same As NULL. This Is different from list(): 
 some but Not all operations will promote an empty pairlist To an empty list.

 as.pairlist Is implemented as as.vector(x, "pairlist"), And hence will dispatch 
 methods for the generic function as.vector. Lists are copied element-by-element 
 into a pairlist And the names of the list used as tags for the pairlist the return 
 value for other types of argument Is undocumented.

 list, Is.list And Is.pairlist are primitive functions.
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.Converts.RConversion.asInteger(System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 Cast the given vector or list to integer type
 </summary>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.Converts.RConversion.asDouble(System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 # Double-Precision Vectors
 
 Create, coerce to or test for a double-precision vector.
 </summary>
 <param name="x">object to be coerced or tested.</param>
 <param name="env"></param>
 <returns>
 as.double attempts to coerce its argument to be of double
 type: like as.vector it strips attributes including names. 
 (To ensure that an object is of double type without 
 stripping attributes, use storage.mode.) Character strings 
 containing optional whitespace followed by either a 
 decimal representation or a hexadecimal representation 
 (starting with 0x or 0X) can be converted, as can special 
 values such as "NA", "NaN", "Inf" and "infinity", 
 irrespective of case.
 </returns>
 <remarks>
 as.double is a generic function. It is identical to as.numeric. 
 Methods should return an object of base type "double".
 
 ### Double-precision values
 All R platforms are required To work With values conforming To
 the IEC 60559 (also known As IEEE 754) standard. This basically
 works With a precision Of 53 bits, And represents To that 
 precision a range Of absolute values from about 2E-308 To 2E+308.
 It also has special values NaN (many Of them), plus And minus 
 infinity And plus And minus zero (although R acts As If these 
 are the same). There are also denormal(ized) (Or subnormal)
 numbers With absolute values above Or below the range given
 above but represented To less precision.
 
 See .Machine for precise information on these limits. Note that
 ultimately how double precision numbers are handled Is down to 
 the CPU/FPU And compiler.
 
 In IEEE 754-2008/IEC605592011 this Is called 'binary64’ format.
 
 ### Note on names
 It Is a historical anomaly that R has two names for its floating-
 point vectors, double And numeric (And formerly had real).
 
 Double Is the name Of the type. numeric Is the name Of the mode 
 And also Of the implicit Class. As an S4 formal Class, use 
 "numeric".
 
 The potential confusion Is that R has used mode "numeric" To mean 
 'double or integer’, which conflicts with the S4 usage. Thus is.numeric
 tests the mode, not the class, but as.numeric (which is identical
 to as.double) coerces to the class.
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.Converts.RConversion.asNumeric(System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 # Numeric Vectors
 
 Creates or coerces objects of type "numeric". is.numeric is a more 
 general test of an object being interpretable as numbers.
 </summary>
 <param name="x">object to be coerced or tested.</param>
 <param name="env"></param>
 <returns></returns>
 <remarks>
 ``NULL`` will be treated as ZERO based on the rule of VisualBasic 
 runtime conversion, the ``as.numeric`` function makes an array value 
 copy always.
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.Converts.RConversion.asCharacters(System.Object,SMRUCC.Rsharp.Runtime.Internal.Object.list,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 ### Character Vectors
 
 Create or test for objects of type "character".
 </summary>
 <param name="x">object to be coerced or tested.</param>
 <param name="args">
 the additional argument values for format values to string, 
 example as ``format = "F4"``.
 </param>
 <param name="env"></param>
 <returns>
 as.character attempts to coerce its argument to character type; 
 like as.vector it strips attributes including names. For lists 
 and pairlists (including language objects such as calls) it deparses 
 the elements individually, except that it extracts the first element 
 of length-one character vectors.
 </returns>
 <remarks>
 as.character and is.character are generic: you can write methods 
 to handle specific classes of objects, see InternalMethods. 
 Further, for as.character the default method calls as.vector, 
 so dispatch is first on methods for as.character and then for methods 
 for as.vector.

 as.character represents real And complex numbers to 15 significant 
 digits (technically the compiler's setting of the ISO C constant 
 DBL_DIG, which will be 15 on machines supporting IEC60559 arithmetic 
 according to the C99 standard). This ensures that all the digits in 
 the result will be reliable (and not the result of representation 
 error), but does mean that conversion to character and back to numeric 
 may change the number. If you want to convert numbers to character 
 with the maximum possible precision, use format.
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.Converts.RConversion.isCharacter(System.Object)">
 <summary>
 ### Character Vectors
 
 Create or test for objects of type "character".
 </summary>
 <param name="x">object to be coerced or tested.</param>
 <returns>is.character returns TRUE or FALSE depending on 
 whether its argument is of character type or not.
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.Converts.RConversion.isLogical(System.Object)">
 <summary>
 ### Logical Vectors
 
 Create or test for objects of type "logical", and the basic logical constants.
 </summary>
 <param name="x">	
 Object To be coerced Or tested.
 </param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.Converts.RConversion.asRaw(System.Object,Microsoft.VisualBasic.Text.Encodings,System.Boolean,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 cast any R# object to raw buffer
 </summary>
 <param name="obj">numeric values or character vector</param>
 <param name="env"></param>
 <returns>A stream object that contains raw bytes data</returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.Converts.RConversion.asPipeline(System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 running pipeline function in linq pipeline mode
 </summary>
 <param name="seq">any kind of object sequence in R# environment</param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.Converts.RConversion.castType(System.Object,System.String,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 try to cast type class of the given data sequence 
 </summary>
 <param name="any"></param>
 <param name="type"></param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Internal.Object.Converts.IMakeDataFrame">
 <summary>
 handler for cast any clr runtime object as R# runtime dataframe object
 </summary>
 <param name="x"></param>
 <param name="args"></param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Internal.Object.Converts.makeDataframe">
 <summary>
 ``as.data.frame``
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.Converts.makeDataframe.addHandler(System.Type,SMRUCC.Rsharp.Runtime.Internal.Object.Converts.IMakeDataFrame)">
 <summary>
 Public <see cref="T:System.Delegate"/> Function IMakeDataFrame(
     x As <see cref="T:System.Object"/>, 
     args As <see cref="T:SMRUCC.Rsharp.Runtime.Internal.Object.list"/>, 
     env As <see cref="T:SMRUCC.Rsharp.Runtime.Environment"/>
 ) As <see cref="T:SMRUCC.Rsharp.Runtime.Internal.Object.dataframe"/>
 </summary>
 <param name="type"></param>
 <param name="handler"></param>
 
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.Converts.makeDataframe.CheckRowDimension(SMRUCC.Rsharp.Runtime.Internal.Object.dataframe,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 Do check of the row names its vector length is equals to the dataframe rows?
 </summary>
 <param name="data"></param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.Converts.makeDataframe.CheckDimension(SMRUCC.Rsharp.Runtime.Internal.Object.dataframe,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 check column dimension is matched to rows or not?
 (arguments imply differing number of rows)
 </summary>
 <param name="data"></param>
 <param name="env"></param>
 <returns>
 returns the input data frame if no error, 
 otherwise returns the error message.
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.Converts.makeDataframe.RDataframe(System.Collections.Generic.IEnumerable{Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedValue{System.Object}},SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 Internal implementation for <see cref="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.base.Rdataframe(System.Object,SMRUCC.Rsharp.Runtime.Environment)"/> api
 </summary>
 <param name="values"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.Converts.makeDataframe.fromList(SMRUCC.Rsharp.Runtime.Internal.Object.list,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 each slot features in the list should be an array 
 will be project to the dataframe. 
 </summary>
 <param name="firstList"></param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.Converts.makeList.listByRows(SMRUCC.Rsharp.Runtime.Internal.Object.dataframe)">
 <summary>
 cast the dataframe object to row list
 </summary>
 <param name="data"></param>
 <returns>
 row list wrap the column list
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.Converts.RCType.CTypeDynamic(System.Object,System.Type,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 If target <paramref name="type"/> is <see cref="T:System.Object"/>, then this function 
 will stop the narrowing conversion from <see cref="T:SMRUCC.Rsharp.Runtime.Internal.Object.vbObject"/> wrapper to 
 object type
 </summary>
 <param name="obj"></param>
 <param name="type">Target data type to cast in R# runtime</param>
 <returns>
 an error <see cref="T:SMRUCC.Rsharp.Runtime.Components.Message"/> will be returns if the conversion error happends
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.Converts.RCType.castUnsure(System.Object,System.Type,System.Type,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 Make ctype function cache at here based on the type assigned rule
 </summary>
 <param name="obj"></param>
 <param name="objType"></param>
 <param name="type"></param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.reflector.GetStructure(System.Object,SMRUCC.Rsharp.Runtime.GlobalEnvironment,System.String,System.Int32)">
 <summary>
 a helper method for view data structure of the given object
 </summary>
 <param name="x"></param>
 <param name="env"></param>
 <param name="indent$"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.reflector.strGenericArray(System.Array,System.Type,SMRUCC.Rsharp.Runtime.GlobalEnvironment,System.String,System.Int32)">
 <summary>
 
 </summary>
 <param name="a"></param>
 <param name="type">the element type</param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.reflector.strVector(System.Array,System.Type,SMRUCC.Rsharp.Runtime.GlobalEnvironment)">
 <summary>
 inspect the vector data structure
 </summary>
 <param name="a"></param>
 <param name="type"></param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.Object.Utils.TableFormatter.GetTable(SMRUCC.Rsharp.Runtime.Internal.Object.dataframe,SMRUCC.Rsharp.Runtime.GlobalEnvironment,System.Boolean,System.Object)">
 <summary>
 Each element in a return result array is a row in table matrix
 </summary>
 <param name="showRowNames">
 一个逻辑值开关或者一个向量用于产生替换rownames
 </param>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Internal.Object.Utils.TableRow">
 <summary>
 table row object for save dataframe to file
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Runtime.Internal.Object.Utils.TableRow.id">
 <summary>
 the row id
 </summary>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Internal.ConsolePrinter.classPrinter">
 <summary>
 Console print formatter for non System user class type
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.ConsolePrinter.classPrinter.printClass(System.Object)">
 <summary>
 A utils function for print user defined structure and class object instance. 
 </summary>
 <param name="obj">
 The object class is ensure that not nothing!
 </param>
 <returns></returns>
 <remarks>
 All of the method is non generic, and the property without arguments!
 All of the sub program will be mapping as returns nothing
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.ConsolePrinter.enumPrinter.printClass(System.Object)">
 <summary>
 
 </summary>
 <param name="obj">
 This object should be an enum value.
 </param>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Internal.ConsolePrinter.InternalToString">
 <summary>
 A delegate function for produce the data handler for build print string 
 </summary>
 <param name="printContent"></param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Internal.ConsolePrinter.printer">
 <summary>
 R# console nice print supports.
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.ConsolePrinter.printer.f64_InternalToString(System.Boolean,SMRUCC.Rsharp.Runtime.GlobalEnvironment)">
 <summary>
 get formatter function for double to string
 </summary>
 <param name="printContent"></param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.ConsolePrinter.printer.AttachConsoleFormatter``1(Microsoft.VisualBasic.Serialization.IStringBuilder)">
 <summary>
 <see cref="T:System.Object"/> -> <see cref="T:System.String"/>
 </summary>
 <typeparam name="T"></typeparam>
 <param name="formatter"></param>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.ConsolePrinter.printer.AttachInternalConsoleFormatter``1(SMRUCC.Rsharp.Runtime.Internal.ConsolePrinter.InternalToString)">
 <summary>
 <see cref="T:System.Object"/> -> <see cref="T:System.String"/>
 </summary>
 <typeparam name="T"></typeparam>
 <param name="formatter"></param>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.ConsolePrinter.printer.printInternal(System.Object,System.String,SMRUCC.Rsharp.Runtime.Internal.Invokes.base.PrinterOptions,SMRUCC.Rsharp.Runtime.GlobalEnvironment)">
 <summary>
 Print the internal R# runtime object
 </summary>
 <param name="x"></param>
 <param name="listPrefix"></param>
 <param name="opts"></param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.ConsolePrinter.printer.ValueToString(System.Object,SMRUCC.Rsharp.Runtime.GlobalEnvironment)">
 <summary>
 Debugger test api of <see cref="M:SMRUCC.Rsharp.Runtime.Internal.ConsolePrinter.printer.ToString(System.Type,SMRUCC.Rsharp.Runtime.GlobalEnvironment,System.Boolean,System.Boolean)"/>
 </summary>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.ConsolePrinter.printer.ToString(System.Type,SMRUCC.Rsharp.Runtime.GlobalEnvironment,System.Boolean,System.Boolean)">
 <summary>
 The external string formatter will overrides the internal formatter
 </summary>
 <param name="elementType"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.ConsolePrinter.printer.getStrings(System.Array,System.Type@,SMRUCC.Rsharp.Runtime.GlobalEnvironment)">
 <summary>
 populate strings from the data array
 </summary>
 <param name="xVec"></param>
 <param name="elementType"></param>
 <param name="env"></param>
 <returns>
 try to convert any kind of array as the string collection for do console print
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.ConsolePrinter.printer.printArray(System.Array,System.Int32,SMRUCC.Rsharp.Runtime.GlobalEnvironment)">
 <summary>
 Print vector elements
 </summary>
 <param name="xvec"></param>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.ConsolePrinter.printer.getMaxColumns(SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 get max width to break the table
 </summary>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Internal.ConsolePrinter.tablePrinter">
 <summary>
 R# runtime dataframe object printer
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.ConsolePrinter.tablePrinter.PartOfTable(System.Collections.Generic.List{Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedCollection{System.String}},System.Int32)">
 <summary>
 Get console print table data
 </summary>
 <param name="part"></param>
 <param name="nrows"></param>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Internal.htmlPrinter">
 <summary>
 generates html document text from the given object
 </summary>
 <remarks>
 generic function supports for the <see cref="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.stringr.html(System.Object,SMRUCC.Rsharp.Runtime.Internal.Object.list,SMRUCC.Rsharp.Runtime.Environment)"/> function.
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Internal.htmlPrinter.AttachHtmlFormatter``1(SMRUCC.Rsharp.Runtime.Internal.GenericFunction)">
 <summary>
 Create html document from given object. (<see cref="T:System.Object"/> -> html <see cref="T:System.String"/>)
 </summary>
 <typeparam name="T"></typeparam>
 <param name="formatter"></param>
 <remarks>
 the generic overloads function should be a delegate function of:
 
 ```
 Delegate GenericFunction(x As <see cref="T:System.Object"/>, args As <see cref="M:SMRUCC.Rsharp.ApiArgumentHelpers.list(Microsoft.VisualBasic.Language.ArgumentReference[])"/>, env As <see cref="T:SMRUCC.Rsharp.Runtime.Environment"/>) As <see cref="T:System.Object"/>
 ```
 </remarks>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Interop.CType.ICTypeList">
 <summary>
 An interface for cast current .NET clr object to R# list object.
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Interop.CType.ICTypeList.toList">
 <summary>
 cast current .NET clr object to R# list object.
 </summary>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Interop.CType.ICTypeDataframe">
 <summary>
 An interface for cast current .NET clr object to R# dataframe object.
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Interop.CType.ICTypeDataframe.toDataframe">
 <summary>
 cast current .NET clr object to R# dataframe object.
 </summary>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Interop.RDispose">
 <summary>
 Helper for implements using in R#
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Interop.RDispose.#ctor(System.Object,System.Action{System.Object})">
 <summary>
 
 </summary>
 <param name="x"></param>
 <param name="final">
 this finallize method is running on the input <paramref name="x"/> object.
 </param>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Interop.REnum">
 <summary>
 VB.NET enum type wrapper in R#
 </summary>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Interop.REnum.raw">
 <summary>
 the source clr type of current enum object
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Interop.REnum.GetByName(System.String)">
 <summary>
 get enum value by enum name or enum description text
 </summary>
 <param name="name">
 case ignored enum name or enum description text
 </param>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Interop.RApiReturnAttribute">
 <summary>
 For make compatibale with return value and exception message or R# object wrapper
 The .NET api is usually declare as returns object value, then we could use this
 attribute to let user known the actual returns type of the target api function
 </summary>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Interop.RApiReturnAttribute.isClassGraph">
 <summary>
 Do we can create a <see cref="T:SMRUCC.Rsharp.Runtime.Interop.RS4ClassGraph"/> from the attribute values?
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Interop.RApiReturnAttribute.uuid">
 <summary>
 the unique reference id of current generated R# runtime <see cref="T:SMRUCC.Rsharp.Runtime.Interop.IRType"/>
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Interop.RApiReturnAttribute.#ctor(System.Type[])">
 <summary>
 this function returns a typescript language liked union type
 </summary>
 <param name="type"></param>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Interop.RApiReturnAttribute.#ctor(SMRUCC.Rsharp.Runtime.Components.TypeCodes)">
 <summary>
 Create a type reference via the R# type code enumeration 
 flag for indicate this function return value.
 </summary>
 <param name="type"></param>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Interop.RApiReturnAttribute.#ctor(System.String[])">
 <summary>
 this function returns a R# <see cref="M:SMRUCC.Rsharp.ApiArgumentHelpers.list(Microsoft.VisualBasic.Language.ArgumentReference[])"/> with these specific first level slot keys
 </summary>
 <param name="slots"></param>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Interop.RApiReturnAttribute.GetClass">
 <summary>
 Get R# runtime type definition
 </summary>
 <returns>
 this function returns nothing if not <see cref="P:SMRUCC.Rsharp.Runtime.Interop.RApiReturnAttribute.isClassGraph"/>.
 </returns>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Interop.RDefaultExpressionAttribute">
 <summary>
 the default string literal value of the parameter 
 can be parsed end evaluated as R expression 
 result.
 </summary>
 <remarks>
 for example, there is an optional argument in package api:
 
 ```
 &lt;<see cref="T:SMRUCC.Rsharp.Runtime.Interop.RDefaultExpressionAttribute"/>> 
 Optional time As <see cref="T:System.Object"/> = "~now()"
 ```
 
 then the default value of the parameter time can be the 
 evaluated result of the default expression ``now()``.
 
 </remarks>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Interop.RDefaultFunction">
 <summary>
 A template for check of the <see cref="T:SMRUCC.Rsharp.Runtime.Interop.RDefaultExpressionAttribute"/>
 </summary>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Interop.RDefaultValueAttribute">
 <summary>
 这个需要在目标类型与字符串之间存在有一个隐式转换的操作符定义
 param as type = "xxxxxx"
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Interop.RDefaultValueAttribute.ParseDefaultValue(System.Type)">
 <summary>
 This method require a implit ctype operator that parse string to target <paramref name="parameterType"/>
 </summary>
 <param name="parameterType"></param>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Interop.RGenericOverloadsAttribute">
 <summary>
 construct a flag that indicates that target clr function will 
 be overloads in R# environment, the function overloads is 
 determined based on the data type of the first parameter. 
 
 the function overloads in R# usually be ``plot(...)``, ``as.data.frame(...)``,
 typically.
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Interop.RGenericOverloadsAttribute.#ctor(System.String,System.Type[])">
 <summary>
 construct a flag that indicates that target clr function will 
 be overloads in R# environment, the function overloads is 
 determined based on the data type of the first parameter. 
 
 the function overloads in R# usually be ``plot(...)``, ``as.data.frame(...)``,
 typically.
 </summary>
 <param name="func">
 The name of the target function for overloads
 </param>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Interop.RGenericOverloads">
 <summary>
 <see cref="T:SMRUCC.Rsharp.Runtime.Interop.RGenericOverloadsAttribute"/> parser result
 </summary>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Interop.RGenericOverloads.name">
 <summary>
 the name of the target generic overloads function
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Interop.RGenericOverloads.overloads">
 <summary>
 the clr overloads type
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Interop.RGenericOverloads.GetOverloads(System.Type)">
 <summary>
 get generic overloads methods
 </summary>
 <param name="pkg"></param>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Interop.RInitializeAttribute">
 <summary>
 如果使用sub new初始化的话，则在导入程序包的时候sub new里面的代码是不会被自动调用的
 对sub new构造函数的调用只在发生实际的api调用的时候才会发生
 所以才在这里使用这个属性来标记一些需要在导入程序包的时候自动化运行的代码来进行一些初始化操作
 </summary>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Interop.RByRefValueAssignAttribute">
 <summary>
 这个参数是接受``a(x) &lt;- y``操作之中的``y``结果值的
 </summary>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Interop.RTypeExportAttribute">
 <summary>
 export data type to ``R#`` runtime environment
 </summary>
 <remarks>
 type information will be imports into current runtime 
 context environment when do package module imports at 
 function invoke 
 <see cref="M:SMRUCC.Rsharp.Development.Package.ImportsPackage.ImportsStaticInternalImpl(SMRUCC.Rsharp.Runtime.Environment,System.Type,System.Boolean)"/>
 
 the type export information usually be used for the .NET clr de-serilization
 operation, example as:
 
 1. xml de-serialization:  loadXml("...", typeof = "type_export_name")
 </remarks>
 
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Interop.RTypeExportAttribute.name">
 <summary>
 type name
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Interop.RTypeExportAttribute.#ctor(System.String,System.Type)">
 <summary>
 export type with given alias name
 </summary>
 <param name="name">the type alias name in R# runtime environment</param>
 <param name="target"></param>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Interop.RListObjectArgumentAttribute">
 <summary>
 表示当前的函数参数为一个 ``...`` 可以产生一个字典list对象值的参数列表
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Interop.RListObjectArgumentAttribute.getObjectList(System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 Safe get a collection of argument name and value tuple
 </summary>
 <param name="objects"></param>
 <param name="envir"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Interop.ROperatorAttribute.#ctor(System.String)">
 <summary>
 
 </summary>
 <param name="[operator]"></param>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Interop.RPackageModuleAttribute">
 <summary>
 标注这个程序集是一个``R#``程序包
 </summary>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Interop.RPlotStyleCSSAttribute">
 <summary>
 这个主要是针对plot泛型函数，因为泛型函数没有办法正常展示与绘图样式相关的函数参数，所以会需要使用这个参数来进行展示
 </summary>
 
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Interop.RPlotStyleCSSAttribute.bg">
 <summary>
 the background color or texture image path
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Interop.RPlotStyleCSSAttribute.main">
 <summary>
 the main title
 </summary>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Interop.RSuppressPrintAttribute">
 <summary>
 The return value will not be print on the console.
 (函数的返回值不会被自动打印出来)
 </summary>
 <remarks>
 this custom attribute will create an <see cref="T:SMRUCC.Rsharp.Runtime.Internal.Object.invisible"/>
 wrapper of the object value.
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Interop.RSuppressPrintAttribute.IsPrintInvisible(System.Reflection.MethodInfo)">
 <summary>
 
 </summary>
 <param name="api"></param>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Interop.RSymbolLanguageMaskAttribute">
 <summary>
 没有被找到的符号会被这个标记所指定的函数解析为对象参加运算
 </summary>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Interop.RSymbolLanguageMaskAttribute.Test">
 <summary>
 <see cref="T:SMRUCC.Rsharp.Runtime.Interop.ITestSymbolTarget"/>
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Interop.RSymbolLanguageMaskAttribute.#ctor(System.String,System.Boolean)">
 <summary>
 创建一个自动符号映射标记 
 </summary>
 <param name="pattern">用于测试目标符号文本是否适合用于本解析器的处理</param>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Interop.RSymbolTextArgumentAttribute">
 <summary>
 表示当前的这个参数的参数值可以接受文本或者未找到符号的变量名作为参数值
 </summary>
 
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Interop.DefaultVectorParser">
 <summary>
 1. 字符串类型默认使用``|``作为分隔符
 2. 数值类型默认使用``,``作为分隔符
 </summary>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Interop.RRawVectorArgumentAttribute">
 <summary>
 表示这个参数是一个数组，环境系统不应该自动调用getFirst取第一个值
 </summary>
 <remarks>
 there are some string literal rule for the default 
 vector string parser:
 
 1. 字符串类型默认使用``|``作为分隔符
 2. 数值类型默认使用``,``作为分隔符
 </remarks>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Interop.RRawVectorArgumentAttribute.vector">
 <summary>
 The element type of the target vector type
 </summary>
 <returns></returns>
 <remarks>
 If this property is not null, then it means the optional argument have 
 a default string expression value which could be parsed as current vector
 type.
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Interop.RRawVectorArgumentAttribute.#ctor(System.Type,System.Type)">
 <summary>
 <paramref name="parser"/>参数的默认值为<see cref="T:SMRUCC.Rsharp.Runtime.Interop.DefaultVectorParser"/>
 </summary>
 <param name="vector">The element type of the target vector type</param>
 <param name="parser">
 <see cref="T:SMRUCC.Rsharp.Runtime.Interop.IVectorExpressionLiteral"/>
 
 use <see cref="T:SMRUCC.Rsharp.Runtime.Interop.DefaultVectorParser"/> by default.
 </param>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Interop.RRawVectorArgumentAttribute.#ctor">
 <summary>
 construct a vector flag with any object type and use the <see cref="T:SMRUCC.Rsharp.Runtime.Interop.DefaultVectorParser"/>.
 </summary>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Interop.RReturn">
 <summary>
 VB.NET api to R# function invoke result wrapper, with additional warning, debug, errors messages, etc
 </summary>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Interop.RReturn.invisible">
 <summary>
 Change the Print Mode to Invisible
 </summary>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Interop.RS4ClassGraph">
 <summary>
 An clr interface liked type define in R#
 </summary>
 <remarks>
 this is a model of the R# runtime generated type
 </remarks>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Interop.RS4ClassGraph.className">
 <summary>
 the type name
 </summary>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Interop.ListObjectArgumentMargin">
 <summary>
 indicates the location of ``...`` list arguments
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Runtime.Interop.ListObjectArgumentMargin.none">
 <summary>
 the function didn't contains any ``...``
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Runtime.Interop.ListObjectArgumentMargin.invalid">
 <summary>
 invalid function information
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Runtime.Interop.ListObjectArgumentMargin.left">
 <summary>
 the first parameter of the function is a ``...`` list parameter
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Runtime.Interop.ListObjectArgumentMargin.right">
 <summary>
 the last parameter or the last -1 parameter(if the last parameter 
 is a preserved <see cref="T:SMRUCC.Rsharp.Runtime.Environment"/> object) of the function 
 is a ``...`` list parameter.
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Interop.RArgumentList.objectListArgumentIndex(SMRUCC.Rsharp.Runtime.Interop.RMethodInfo)">
 <summary>
 get index of list argument
 </summary>
 <param name="[declare]"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Interop.RArgumentList.CreateLeftMarginArguments(SMRUCC.Rsharp.Runtime.Interop.RMethodInfo,SMRUCC.Rsharp.Runtime.Components.InvokeParameter[],SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 
 </summary>
 <param name="[declare]">
 the first argument in api parameters is the list object argument
 all of the argument 
 </param>
 <param name="env"></param>
 <param name="params">
 parameter declares example as: ``(..., file, env)``
 
 valids syntax:
 
 1. ``(a,b,c,d,e,f,g, file = "...")``
 2. ``(a= 1, b=2, c=a, d= 55, bb, ee, file = "...")``
 </param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Interop.RArgumentList.TryCastListObjects(System.Object[],System.Int32,SMRUCC.Rsharp.Runtime.Interop.RMethodArgument,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 
 </summary>
 <param name="parameterVals"></param>
 <param name="listIndex"></param>
 <param name="argument"></param>
 <param name="env"></param>
 <returns>
 error message could be put into this return array, and the callee 
 function will check the error message and then populate out to the
 upper environment context
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Interop.RArgumentList.TryCastListObjectsInternal(System.Object,SMRUCC.Rsharp.Runtime.Environment,System.Boolean)">
 <summary>
 try to resolve the argument parameter list
 </summary>
 <param name="values"></param>
 <param name="env"></param>
 <param name="lazy"></param>
 <returns>
 should be a tuple list for the additional parameters, or error message
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Interop.RArgumentList.CreateRightMarginArguments(SMRUCC.Rsharp.Runtime.Interop.RMethodInfo,SMRUCC.Rsharp.Runtime.Components.InvokeParameter[],SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 
 </summary>
 <param name="[declare]"></param>
 <param name="env"></param>
 <param name="params">
 ```
 (a,b,c = xxx, ...)
 ```
 
 1. (1,c =2, b=33, d=5,cc=66)
 2. (1,2,3, d=5, cc=66)
 </param>
 <returns></returns>
 <remarks>
 处理参数在最后或者倒数第二个的情况
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Interop.RArgumentList.CreateObjectListArguments(SMRUCC.Rsharp.Runtime.Interop.RMethodInfo,SMRUCC.Rsharp.Runtime.Environment,SMRUCC.Rsharp.Runtime.Components.InvokeParameter[])">
 <summary>
 Create argument value for <see cref="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])"/>
 </summary>
 <param name="params">
 required of replace dot(.) to underline(_)?
 </param>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Interop.RMethodArgument">
 <summary>
 The R# method argument wrapper
 </summary>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Interop.RMethodArgument.name">
 <summary>
 The argument name
 </summary>
 <returns></returns>
 <remarks>
 is a reference of <see cref="P:System.Reflection.MemberInfo.Name"/>
 </remarks>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Interop.RMethodArgument.type">
 <summary>
 the type of this parameter that required
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Interop.RMethodArgument.default">
 <summary>
 default value 
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Interop.RMethodArgument.isOptional">
 <summary>
 is an optional parameter?
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Interop.RMethodArgument.isObjectList">
 <summary>
 is a ``...`` list argument?
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Interop.RMethodArgument.isByrefValueParameter">
 <summary>
 is a parameter that accept the byref value to this function?
 </summary>
 <returns></returns>
 <remarks>
 byref call: 
 func(...) &lt;- value;
 
 call in normal function invoke style:
 func(value, ...);
 
 if this property is TRUE, then it meansthe byref assign of the value will
 passing to this parameter.
 </remarks>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Interop.RMethodArgument.isRequireRawVector">
 <summary>
 Do not apply the <see cref="M:SMRUCC.Rsharp.Runtime.RVectorExtensions.getFirst(System.Object,System.Boolean)"/> operation
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Interop.RMethodArgument.GetRawVectorElementType">
 <summary>
 Get element type of the target raw vector
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Interop.RMethodArgument.ToString">
 <summary>
 show markdown document of this parameter
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Interop.RMethodArgument.getDefaultValue(SMRUCC.Rsharp.Runtime.Interop.RRawVectorArgumentAttribute,SMRUCC.Rsharp.Runtime.Interop.RDefaultValueAttribute,System.Type,System.Boolean,System.Object)">
 <summary>
 get the default value of this parameter
 </summary>
 <param name="rawVector"></param>
 <param name="defaultScript"></param>
 <param name="paramType"></param>
 <param name="hasExpression"></param>
 <param name="[default]"></param>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Interop.RMethodInfo">
 <summary>
 Use for R# package method, a wrapper for the .NET clr function <see cref="T:System.Reflection.MethodInfo"/>.
 </summary>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Interop.RMethodInfo.name">
 <summary>
 The function name
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Interop.RMethodInfo.returns">
 <summary>
 the return type of current api method
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Interop.RMethodInfo.parameters">
 <summary>
 A list of parameters of current .NET api that imported
 from the external dll assembly file.
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Interop.RMethodInfo.invisible">
 <summary>
 Do not print the value of this function on console
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Interop.RMethodInfo.namespace">
 <summary>
 module namespace string that parsed from <see cref="T:Microsoft.VisualBasic.Scripting.MetaData.PackageAttribute"/>
 </summary>
 <returns></returns>
</member>
<member name="F:SMRUCC.Rsharp.Runtime.Interop.RMethodInfo.api">
 <summary>
 <see cref="T:System.Reflection.MethodInfo"/>
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Runtime.Interop.RMethodInfo.listObjectMargin">
 <summary>
 the location of the ``...`` list parameter
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Interop.RMethodInfo.#ctor(System.String,System.Delegate)">
 <summary>
 wrap the .net clr lambda expression
 </summary>
 <param name="name"></param>
 <param name="closure">
 Runtime generated .NET method
 </param>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Interop.RMethodInfo.#ctor(Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedValue{System.Reflection.MethodInfo})">
 <summary>
 Static method
 </summary>
 <param name="api"></param>
 
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Interop.RMethodInfo.#ctor(System.Reflection.MethodInfo)">
 <summary>
 construct a R# runtime function from a static clr function
 </summary>
 <param name="func"></param>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Interop.RMethodInfo.#ctor(System.String,System.Reflection.MethodInfo,System.Object)">
 <summary>
 Construct a object class binding instance member function
 </summary>
 <param name="name">The symbol name of the given function</param>
 <param name="closure"><see cref="T:System.Reflection.MethodInfo"/> from parsing .NET dll module file.</param>
 <param name="target">
 for object instance method used only, nothing means static method
 </param>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Interop.RMethodInfo.GetNetCoreCLRDeclaration">
 <summary>
 Gets the <see cref="T:System.Reflection.MethodInfo"/> represented by the delegate.
 </summary>
 <returns></returns>
 
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Interop.RMethodInfo.GetRApiReturns">
 <summary>
 
 </summary>
 <returns>
 this function will returns nothing if the attribute is not found
 </returns>
 
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Interop.RMethodInfo.Invoke(System.Object[],SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 direct invoke
 </summary>
 <param name="parameters"></param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Interop.RMethodInfo.Invoke(SMRUCC.Rsharp.Runtime.Environment,SMRUCC.Rsharp.Runtime.Components.InvokeParameter[])">
 <summary>
 Invoke a R-sharp wrap .NET clr function
 </summary>
 <param name="envir"></param>
 <param name="params">no orders, the parameters will be aligned in this clr function invoke process</param>
 <returns></returns>
 <remarks>
 1. do parameter alignment in this function
 2. and then invoke clr function
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Interop.RMethodInfo.createNormalArguments(SMRUCC.Rsharp.Runtime.Environment,System.Collections.Generic.Dictionary{System.String,SMRUCC.Rsharp.Runtime.Components.InvokeParameter})">
 <summary>
 
 </summary>
 <param name="envir"></param>
 <param name="arguments">
 required of replace dot(.) to underline(_)?
 </param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Interop.RMethodInfo.getValue(SMRUCC.Rsharp.Runtime.Interop.RMethodArgument,System.Object,System.String,SMRUCC.Rsharp.Runtime.Environment@,System.Boolean)">
 <summary>
 Get type converted object value for match the parameter type. 
 </summary>
 <param name="arg"></param>
 <param name="value"></param>
 <param name="trace"></param>
 <param name="envir"></param>
 <param name="trygetListParam">
 Fix bugs for list arguments when the parameter input have no symbol name
 In such situation, then type is mismatch due to the reason of invalid 
 offset bugs
 </param>
 <returns></returns>
 <remarks>
 returns an error message when type cast error
 </remarks>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Interop.RuntimeValueLiteral">
 <summary>
 Literal of any .NET clr runtime value object
 </summary>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Interop.RuntimeValueLiteral.value">
 <summary>
 Any .NET clr runtime object
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Interop.RuntimeValueLiteral.#ctor(System.Object)">
 <summary>
 Create a new .NET clr object literal value
 </summary>
 <param name="value"></param>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Interop.Operator.BinaryIndex">
 <summary>
 execute a binary expression based on the value type selector
 </summary>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Interop.Operator.BinaryIndex.symbol">
 <summary>
 the operator symbol text
 </summary>
 <returns></returns>
</member>
<member name="F:SMRUCC.Rsharp.Runtime.Interop.Operator.BinaryIndex.hashIndexCache">
 <summary>
 key=hascode1|hashcode2
 </summary>
 <remarks>
 ### 20221110 due to the reason of run parallel, so we 
 needs to lock this cache list for avoid lock error.
 
 System.InvalidOperationException: 
 Operations that change non-concurrent collections must 
 have exclusive access. A concurrent update was performed 
 on this collection and corrupted its state. The
 collection's state is no longer correct.
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Interop.Operator.BinaryIndex.addOperator(SMRUCC.Rsharp.Runtime.Interop.RType,SMRUCC.Rsharp.Runtime.Interop.RType,SMRUCC.Rsharp.Runtime.Interop.Operator.IBinaryOperator,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 请注意，因为这个函数不会进行重复判断，所以在调用这个函数之前可以通过<see cref="M:SMRUCC.Rsharp.Runtime.Interop.Operator.BinaryIndex.hasOperator(SMRUCC.Rsharp.Runtime.Interop.RType,SMRUCC.Rsharp.Runtime.Interop.RType)"/>
 函数来判断是否重复从而决定是否对之前的操作符进行覆盖还是抛出错误信息
 </summary>
 <param name="left"></param>
 <param name="right"></param>
 <param name="[operator]"></param>
 <param name="env"></param>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Interop.Operator.BinaryIndex.rightNull(System.Object,System.String,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 execute a binary expression when the value of right is nothing
 </summary>
 <param name="left"></param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Interop.Operator.BinaryIndex.leftNull(System.Object,System.String,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 execute a binary expression when the value of left is nothing
 </summary>
 <param name="right"></param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Interop.Operator.BinaryOperator">
 <summary>
 execute a binary expression
 </summary>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Interop.Operator.BinaryOperator.operatorSymbol">
 <summary>
 the operator symbol text
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Interop.Operator.BinaryOperator.left">
 <summary>
 the required type of left
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Interop.Operator.BinaryOperator.right">
 <summary>
 the required type of right
 </summary>
 <returns></returns>
</member>
<member name="F:SMRUCC.Rsharp.Runtime.Interop.Operator.BinaryOperator.operation">
 <summary>
 the operator evaluation.
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Interop.Operator.BinaryOperator.Execute(System.Object,System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 主要是为了兼容R#语言的<see cref="T:SMRUCC.Rsharp.Runtime.Internal.Object.unit"/>特性
 </summary>
 <param name="left"></param>
 <param name="right"></param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Interop.Operator.BinaryOperatorEngine">
 <summary>
 engine of binary operator in R#
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Interop.Operator.BinaryOperatorEngine.arithmeticOperators">
 <summary>
 add arithmetic operators
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Interop.Operator.BinaryOperatorEngine.addMixedOperators(SMRUCC.Rsharp.Runtime.Interop.RType,SMRUCC.Rsharp.Runtime.Interop.RType)">
 <summary>
 left and right should be in different type
 </summary>
 <param name="left"></param>
 <param name="right"></param>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Interop.Operator.BinaryOperatorEngine.addBinary(SMRUCC.Rsharp.Runtime.Interop.RType,SMRUCC.Rsharp.Runtime.Interop.RType,System.String,SMRUCC.Rsharp.Runtime.Interop.Operator.IBinaryOperator,SMRUCC.Rsharp.Runtime.Environment,System.Boolean)">
 <summary>
 add a new operator
 </summary>
 <param name="left"></param>
 <param name="right"></param>
 <param name="symbol"></param>
 <param name="op"></param>
 <param name="env"></param>
 <param name="overrides">
 Overrides of the existed operator evaluation when the operator symbol and the binary type is matched?
 </param>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Interop.Operator.BinaryOperatorEngine.ImportsOperators(System.Type,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 imports user defined operator
 </summary>
 <param name="package"></param>
 <param name="env">
 the environment object is apply for generates the error message if the operator 
 is already existed, could be nothing to omit it.
 </param>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Interop.Operator.IBinaryOperator">
 <summary>
 Evaluate of a binary operator
 </summary>
 <param name="left"></param>
 <param name="right"></param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Interop.IRType">
 <summary>
 the common model of the .NET clr type and R# runtime type
 </summary>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Interop.IRType.className">
 <summary>
 the class name for display and inspect
 </summary>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Interop.RType">
 <summary>
 The type wrapper for .NET type to R# language runtime
 </summary>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Interop.RType.fullName">
 <summary>
 the raw CLR <see cref="P:System.Type.FullName"/>
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Interop.RType.name">
 <summary>
 the raw CLR type name
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Interop.RType.mode">
 <summary>
 The mapped R# data type
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Interop.RType.isPrimitive">
 <summary>
 is R# runtime type?
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Interop.RType.isGenericListObject">
 <summary>
 Is dictionary of string and value types?
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Interop.RType.raw">
 <summary>
 based .NET CLR type
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Interop.RType.haveDynamicsProperty">
 <summary>
 implements interface of <see cref="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.IDynamicsObject"/>?
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Interop.RType.isEnvironment">
 <summary>
 is an <see cref="T:SMRUCC.Rsharp.Runtime.Environment"/> object?
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Interop.RType.integers">
 <summary>
 include single element and array element, example as:
 
 integer, integer()
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Interop.RType.logicals">
 <summary>
 boolean and boolean()
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Interop.RType.list">
 <summary>
 R tuple list/JSON object
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Interop.RType.any">
 <summary>
 mapping to the clr <see cref="T:System.Object"/> type.
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Interop.RType.closure">
 <summary>
 R runtime function
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Interop.RType.GetRawElementType">
 <summary>
 gets the array element type from current r# type <see cref="P:SMRUCC.Rsharp.Runtime.Interop.RType.raw"/>
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Interop.RType.populateNames">
 <summary>
 <see cref="M:SMRUCC.Rsharp.Runtime.Interop.RType.getNames"/>
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Interop.RType.getNames">
 <summary>
 Get method names and property names of target type object instance
 </summary>
 <returns></returns>
 
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Interop.RType.GetRSharpType(System.Type)">
 <summary>
 Get VB.NET clr type to R# type wrapper <see cref="T:SMRUCC.Rsharp.Runtime.Interop.RType"/>
 </summary>
 <param name="type"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Interop.RType.GetType(System.TypeCode)">
 <summary>
 create <see cref="T:SMRUCC.Rsharp.Runtime.Interop.RType"/> based on the .NET clr <see cref="T:System.TypeCode"/> enumeration value
 </summary>
 <param name="code"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Interop.RType.GetType(SMRUCC.Rsharp.Runtime.Components.TypeCodes)">
 <summary>
 create <see cref="T:SMRUCC.Rsharp.Runtime.Interop.RType"/> based on the R# <see cref="T:SMRUCC.Rsharp.Runtime.Components.TypeCodes"/> enumeration value
 </summary>
 <param name="code"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Interop.RType.GetType(Microsoft.VisualBasic.Scripting.MetaData.TypeInfo,SMRUCC.Rsharp.Runtime.GlobalEnvironment)">
 <summary>
 Convert the type information model to R# type
 </summary>
 <param name="type"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Interop.RType.TypeOf(System.Object)">
 <summary>
 get R# type value of the given VB.NET object value
 </summary>
 <param name="x"></param>
 <returns>
 对于在``R#``语言之中的基础类型，例如vector,list等，这个
 函数会返回元素基础类型值：<see cref="P:SMRUCC.Rsharp.Runtime.Components.RsharpDataObject.elementType"/>.
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Interop.RType.op_Explicit(SMRUCC.Rsharp.Runtime.Interop.RType)~System.Type">
 <summary>
 Enable conversion from R# type data to CLR type information
 </summary>
 <param name="type"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Interop.RType.op_Like(SMRUCC.Rsharp.Runtime.Interop.RType,System.Type)">
 <summary>
 <see cref="P:SMRUCC.Rsharp.Runtime.Interop.RType.raw"/> type is given target <paramref name="type"/>?
 </summary>
 <param name="rtype"></param>
 <param name="type"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Interop.RType.op_Like(SMRUCC.Rsharp.Runtime.Interop.RType,SMRUCC.Rsharp.Runtime.Interop.RType)">
 <summary>
 does <paramref name="type"/> can be convert to the <paramref name="baseType"/>?
 </summary>
 <param name="type"></param>
 <param name="baseType"></param>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.RExit">
 <summary>
 A signal object for make R# exit the script executation
 </summary>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.RExit.exit_code">
 <summary>
 the program exit status code
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.MagicScriptSymbol.dir">
 <summary>
 dir path that contains the running script
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.MagicScriptSymbol.file">
 <summary>
 the file name of current running script
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.MagicScriptSymbol.fullName">
 <summary>
 the full path of the current running script
 </summary>
 <returns></returns>
</member>
<member name="F:SMRUCC.Rsharp.Runtime.RTypeExtensions.parseTypeCode">
 <summary>
 Converts the input string text to value <see cref="T:SMRUCC.Rsharp.Runtime.Components.TypeCodes"/>
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.RTypeExtensions.GetRTypeCode(System.String)">
 <summary>
 Get R type code from the type constraint expression value.
 </summary>
 <param name="type$"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.RTypeExtensions.IsPrimitive(System.Type,System.Boolean)">
 <summary>
 It is R# primitive type?
 </summary>
 <param name="type"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.RTypeExtensions.IsPrimitive(SMRUCC.Rsharp.Runtime.Components.TypeCodes,System.Boolean)">
 <summary>
 It is R# primitive type? (bool, double, int, string, list?)
 </summary>
 <param name="type"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.RTypeExtensions.IsNumeric(SMRUCC.Rsharp.Runtime.Components.TypeCodes)">
 <summary>
 Target R type is a kind of numeric type?
 </summary>
 <param name="type"></param>
 <returns>
 this function returns true if the <paramref name="type"/> is 
 <see cref="F:SMRUCC.Rsharp.Runtime.Components.TypeCodes.double"/> or <see cref="F:SMRUCC.Rsharp.Runtime.Components.TypeCodes.integer"/>
 </returns>
 
</member>
<member name="M:SMRUCC.Rsharp.Runtime.RTypeExtensions.GetRTypeCode(System.Type)">
 <summary>
 VB.NET CLR object type to R type code mapping
 </summary>
 <param name="type"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.RTypeExtensions.GetType(System.TypeCode)">
 <summary>
 Mapping CLR <see cref="T:System.TypeCode"/> to .net CLR object type
 </summary>
 <param name="type"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.RTypeExtensions.GetType(SMRUCC.Rsharp.Runtime.Components.TypeCodes,System.Boolean)">
 <summary>
 Mapping R# <see cref="T:SMRUCC.Rsharp.Runtime.Components.TypeCodes"/> to .net CLR object type
 </summary>
 <param name="type"></param>
 <returns>
 the function will returns nothing if the type mapping is not valid
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.RVectorExtensions.AllNothing(System.Array)">
 <summary>
 check all elements inside the given array is all nothing?
 </summary>
 <param name="v"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.RVectorExtensions.isVector``1(System.Object)">
 <summary>
 Object ``x`` is an array of <typeparamref name="T"/>?
 </summary>
 <typeparam name="T"></typeparam>
 <param name="x"></param>
 <returns>
 returns a logical value of this type test operation
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.RVectorExtensions.getFirst(System.Object,System.Boolean)">
 <summary>
 Get first element in the input <paramref name="value"/> sequence
 </summary>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.RVectorExtensions.single(System.Object,System.Boolean)">
 <summary>
 Try get a single element
 </summary>
 <param name="x">
 If the input object x is an array with just one element, 
 then the single value will be populate, otherwise will 
 populate the input x
 </param>
 <param name="forceSingle">
 this function returns the first element in array/vector always
 if this parameter is set to true
 </param>
 <returns></returns>
 <remarks>
 这个函数只会在确认只有一个向量元素的情况下才会返回单个元素
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.RVectorExtensions.asVector(System.Object,System.Type,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 Ensure that the input <paramref name="value"/> object is a sequence. 
 (This method will decouple the object instance value from vbObject 
 container unless the required <paramref name="type"/> is 
 <see cref="T:SMRUCC.Rsharp.Runtime.Internal.Object.vbObject"/>.)
 </summary>
 <param name="value"></param>
 <param name="type">
 should be the element type of the target vector array
 </param>
 <returns>
 如果执行出错，这个函数会返回一个错误消息
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.RVectorExtensions.UnsafeTryCastGenericArray(System.Array)">
 <summary>
 Cast a possible object array to a generic type constrained array
 </summary>
 <param name="vec"></param>
 <returns>
 propably returns an array with all element value is nothing
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.RVectorExtensions.isScalarVector(System.Object)">
 <summary>
 target value is nothing orelse is array with less than or equals to one element?
 </summary>
 <param name="xi"></param>
 <returns>
 Does the input test object <paramref name="xi"/> not contains multiple value?
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.RVectorExtensions.MeltArray(System.Array)">
 <summary>
 vector length = 0: means nothing
 vector length = 1: means scalar
 </summary>
 <param name="vec"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.RVectorExtensions.TryCastGenericArray(System.Array,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 This function make sure the return array is not a generic type array
 </summary>
 <param name="vec"></param>
 <param name="env"></param>
 <returns>
 A class variant type: error message or a generic array
 
 Andalso this function will returns nothing if the input <paramref name="vec"/>
 is nothing.
 </returns>
 <remarks>
 返回错误消息或者结果向量
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.RVectorExtensions.asVector``1(System.Object)">
 <summary>
 这个函数会确保返回的输出值都是一个数组
 </summary>
 <typeparam name="T"></typeparam>
 <param name="value">
 
 </param>
 <returns>
 this function returns an empty collection if the 
 given <paramref name="value"/> is nothing.
 </returns>
 <remarks>
 ##### 20210526 因为这个函数会涉及到转换类型的操作，所以性能损耗会非常严重
 
 所以假若仅仅只需要转换数据对象为数组的话，请避免使用这个函数
 应该手动编写代码以提升性能
 
 在进行.NET语言编写相应的包的时候，尽量使用<see cref="T:SMRUCC.Rsharp.Runtime.Vectorization.CLRVector"/>模块之中
 的类型转换函数以减少性能损失
 </remarks>
 
</member>
<member name="M:SMRUCC.Rsharp.Runtime.RVectorExtensions.castSingle``1(System.Type,System.Object)">
 <summary>
 handling some special type cast situation
 </summary>
 <typeparam name="T"></typeparam>
 <param name="typeofT"></param>
 <param name="o"></param>
 <returns></returns>
 
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Serialize.Buffer">
 <summary>
 data buffer model for run ``R#`` IPC
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Serialize.NullObject.getValue">
 <summary>
 returns nothing, due to the reason of NULL means
 no value
 </summary>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Serialize.BufferObjects">
 <summary>
 
 </summary>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Serialize.bitmapBuffer">
 <summary>
 handler for gdi+ image data.
 </summary>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Serialize.bitmapBuffer.bitmap">
 <summary>
 the gdi+ raster image
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Serialize.dataframeBuffer.Serialize(System.IO.Stream)">
 <summary>
 write dataframe value to binary file
 </summary>
 <param name="buffer"></param>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Serialize.listBuffer.getValue">
 <summary>
 a wrapper to the <see cref="M:SMRUCC.Rsharp.Runtime.Serialize.listBuffer.getList"/> function
 </summary>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Serialize.messageBuffer">
 <summary>
 the error message
 </summary>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Serialize.rawBuffer">
 <summary>
 a vector of raw bytes
 </summary>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Serialize.textBuffer">
 <summary>
 utf8 text data
 </summary>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Serialize.textBuffer.mime">
 <summary>
 the content text mime type
 </summary>
 <returns></returns>
 <remarks>used for the http service.</remarks>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Serialize.vectorBuffer">
 <summary>
 serialize handler for ``R#`` vector
 </summary>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Serialize.vectorBuffer.type">
 <summary>
 the full name of the <see cref="T:System.Type"/> for create <see cref="T:SMRUCC.Rsharp.Runtime.Interop.RType"/>
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Serialize.vectorBuffer.safeGetType">
 <summary>
 get the array element type
 </summary>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Components.Interface.RFunction">
 <summary>
 the abstract model of these:
 
 1. <see cref="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Closure.DeclareLambdaFunction"/>
 2. <see cref="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Closure.DeclareNewFunction"/>
 3. <see cref="T:SMRUCC.Rsharp.Runtime.Interop.RMethodInfo"/>
 </summary>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Components.Interface.RFunction.name">
 <summary>
 函数名
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Components.Interface.RFunction.getReturns(SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 获取这个函数可能所返回的类型，如果没有额外的信息，这个属性一般是any类型
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Components.Interface.RFunction.getArguments">
 <summary>
 get the parameter list of current function
 </summary>
 <returns>
 please note that:
 
 + if the value of the item is nothing, then it means the parameter is required!
 + if the value of the item is a literal expression of NULL, then it means the parameter is optional and the default value is NULL
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Components.Interface.RFunction.Invoke(SMRUCC.Rsharp.Runtime.Environment,SMRUCC.Rsharp.Runtime.Components.InvokeParameter[])">
 <summary>
 执行当前的这个函数对象然后获取得到结果值
 </summary>
 <param name="envir"></param>
 <param name="arguments"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Components.Interface.RFunction.Invoke(System.Object[],SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 直接传入参数进行函数的调用，这个接口一般是直接用于生成lambda函数所使用的
 </summary>
 <param name="arguments"></param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Components.Interface.IReflector">
 <summary>
 The reflection operation helper in R# language runtime
 </summary>
 <remarks>
 used this model for implements the get names:
 
 1. for vector and list, implements ``names`` function
 2. for dataframe object, implements the ``colnames`` function
 </remarks>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Components.Interface.RIndex">
 <summary>
 index start from base 1
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Components.Interface.RIndex.getByIndex(System.Int32)">
 <summary>
 get element by index(base from 1)
 </summary>
 <param name="i">index i should be start from base 1</param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Components.Interface.RIndex.getByIndex(System.Int32[])">
 <summary>
 
 </summary>
 <param name="i">index i should be start from base 1</param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Components.Interface.RIndex.setByIndex(System.Int32,System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 
 </summary>
 <param name="i">index i should be start from base 1</param>
 <param name="value"></param>
 <param name="envir"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Components.Interface.RIndex.setByIndex(System.Int32[],System.Array,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 
 </summary>
 <param name="i">index i should be start from base 1</param>
 <param name="value"></param>
 <param name="envir"></param>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Components.Interface.RNameIndex">
 <summary>
 a collection data model in R# language that indicates each element has names
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Components.Interface.RNameIndex.getByName(System.String)">
 <summary>
 get an element by name
 </summary>
 <param name="name"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Components.Interface.RNameIndex.getByName(System.String[])">
 <summary>
 get a set of data elements by name set
 </summary>
 <param name="names"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Components.Interface.RNameIndex.setByName(System.String,System.Object,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 set data element value by a given name
 </summary>
 <param name="name"></param>
 <param name="value"></param>
 <param name="envir"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Components.Interface.RNameIndex.setByName(System.String[],System.Array,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 set a data collection of values by a given name list
 </summary>
 <param name="names"></param>
 <param name="value"></param>
 <param name="envir"></param>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Components.Interface.RPipeline.isError">
 <summary>
 is an error message?
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Components.InvokeParameter.isSymbolAssign">
 <summary>
 is syntax of ``a &lt;- b``?
 
 (主要是应用于生成list的参数列表)
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Components.InvokeParameter.haveSymbolName(System.Boolean)">
 <summary>
 
 </summary>
 <param name="hasObjectList">
 If allows hasObjectList, then <see cref="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.DataSets.SymbolReference"/> will be used as list slot symbol name
 otherwise only allows get symbol name from parameter name reference pattern ``a &lt;- b``.
 </param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Components.InvokeParameter.#ctor(System.String,System.Object,System.Int32)">
 <summary>
 Create a new parameter with given symbol name
 </summary>
 <param name="name">
 the index name pattern number should be keeps the same order with the <paramref name="index"/>.
 example as: name = $1, and the index must be 1
 </param>
 <param name="runtimeValue"></param>
 <param name="index">1-based offset of the invoke arguments</param>
 <remarks>
 combine <paramref name="name"/> and <paramref name="runtimeValue"/> for 
 create an expressin of <see cref="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.Operators.ValueAssignExpression"/>.
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Components.InvokeParameter.GetLazyEvaluateExpression">
 <summary>
 Just get the value part expression, not to evaluate it
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Components.InvokeParameter.Evaluate(SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 get value part
 </summary>
 <param name="envir"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Components.InvokeParameter.Create(System.Collections.Generic.IEnumerable{SMRUCC.Rsharp.Interpreter.ExecuteEngine.Expression})">
 <summary>
 Just wrap parameter value with index
 </summary>
 <param name="expressions"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Components.InvokeParameter.CreateArguments(SMRUCC.Rsharp.Runtime.Environment,System.Collections.Generic.IEnumerable{SMRUCC.Rsharp.Runtime.Components.InvokeParameter},System.Boolean)">
 <summary>
 
 </summary>
 <param name="env"></param>
 <param name="arguments"></param>
 <param name="hasObjectList">
 If has object list argument, then use the symbol name as slot name
 </param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Components.InvokeParameter.CreateLiterals(System.Object[])">
 <summary>
 create argument by runtime literal values.
 </summary>
 <param name="args"></param>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Components.Message">
 <summary>
 The warning message and exception message
 </summary>
 <remarks>
 this runtime message object is a collection of the error message string
 </remarks>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Components.Message.message">
 <summary>
 the message content about this error or warning
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Components.Message.level">
 <summary>
 the .NET log levels of current message object, value could be warning and error 
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Components.Message.environmentStack">
 <summary>
 [R# runtime] the R# scripting environment runtime stack trace
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Components.Message.trace">
 <summary>
 [VB.NET runtime] the R# engine stack trace
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Components.Message.source">
 <summary>
 the source R# expression that cause this error or warning message
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Components.Message.ToCLRException">
 <summary>
 Convert R# error message to VB.NET clr exception object
 </summary>
 <returns></returns>
 
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Components.Message.AsWarning">
 <summary>
 convert the message level to warning level
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Components.Message.ThrowCLRError">
 <summary>
 throw the <see cref="T:System.Exception"/> data that cast from <see cref="M:SMRUCC.Rsharp.Runtime.Components.Message.ToCLRException"/>
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Components.Message.SymbolNotFound(SMRUCC.Rsharp.Runtime.Environment,System.String,SMRUCC.Rsharp.Runtime.Components.TypeCodes,System.Nullable{System.Boolean})">
 <summary>
 create a symbol not found error message
 </summary>
 <param name="envir"></param>
 <param name="symbolName$"></param>
 <param name="type"></param>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Components.Rscript">
 <summary>
 An Rscript source wrapper
 </summary>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Components.Rscript.source">
 <summary>
 If the script is load from a text file, then property value of <see cref="P:SMRUCC.Rsharp.Runtime.Components.Rscript.source"/> is the file location
 Otherwise this property is value nothing
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Components.Rscript.script">
 <summary>
 The script text
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Components.Rscript.GetTokens">
 <summary>
 Get language <see cref="T:SMRUCC.Rsharp.Language.TokenIcer.Scanner"/> tokens
 </summary>
 <returns></returns>
 
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Components.Rscript.FromFile(System.String)">
 <summary>
 R script from local file
 </summary>
 <param name="path"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Components.Rscript.AutoHandleScript(System.String)">
 <summary>
 auto handle Rscript text from:
 
 + plain text input
 + local file
 + network file on a web server
 
 </summary>
 <param name="handle"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Components.Rscript.FromText(System.String)">
 <summary>
 R script from in memory plain text input
 </summary>
 <param name="text"></param>
 <returns></returns>
 
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Components.IAttributeReflector.getAttributeNames">
 <summary>
 Get all attribute name that tagged with current symbol object.
 </summary>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Components.RsharpDataObject">
 <summary>
 the R# data object with specific element data type
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Runtime.Components.RsharpDataObject.m_attributes">
 <summary>
 holds the custom attribute data that tagged with current R# runtime object
 this dictionary object value is created in lazy mode
 </summary>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Components.RsharpDataObject.elementType">
 <summary>
 get the element type of this R# runtime object
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Components.RsharpDataObject.getAttribute(System.String,System.Object)">
 <summary>
 get attribute value by name
 </summary>
 <param name="name"></param>
 <param name="[default]"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Components.RsharpDataObject.setAttribute(System.String,System.Object)">
 <summary>
 tag a named attribute data with current R# runtime object
 </summary>
 <param name="name"></param>
 <param name="val"></param>
 <example>
 <code>
 Dim obj As New RsharpDataObject
 obj.setAttribute("name", "value")
 </code>
 </example>
 <returns>this function returns the object itself for the chaining call</returns>
 <remarks>
 this function will create a new dictionary object if the attribute data is not initialized
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Components.RsharpDataObject.getAttributeNames">
 <summary>
 Get all attribute name that tagged with current symbol object.
 </summary>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Components.Symbol">
 <summary>
 The variable model in R# language
 </summary>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Components.Symbol.stacktrace">
 <summary>
 which runtime stack that this variable symbol is created?
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Components.Symbol.value">
 <summary>
 变量值对于基础类型而言，都是以数组的形式存储的
 非基础类型则为其值本身
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Components.Symbol.constraint">
 <summary>
 当前的这个变量被约束的类型
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Components.Symbol.readonly">
 <summary>
 current symbol value is constant lock binding in the environment?
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Components.Symbol.typeId">
 <summary>
 <see cref="P:SMRUCC.Rsharp.Runtime.Interop.RType.fullName"/>, key for <see cref="P:SMRUCC.Rsharp.Runtime.GlobalEnvironment.types"/>
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Components.Symbol.typeof">
 <summary>
 Get the .net clr type of the current object <see cref="P:SMRUCC.Rsharp.Runtime.Components.Symbol.value"/>.
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Components.Symbol.typeCode">
 <summary>
 当前的这个变量的值所具有的类型代码
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Components.Symbol.length">
 <summary>
 The vector length
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Components.Symbol.isCallable">
 <summary>
 当前的这个符号值是否是一个可以被调用的函数对象？
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Components.Symbol.constraintValid">
 <summary>
 当前的变量值的类型代码是否满足类型约束条件
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Components.Symbol.#ctor(SMRUCC.Rsharp.Runtime.Components.TypeCodes)">
 <summary>
 NULL
 </summary>
 <param name="constraint"></param>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Components.Symbol.#ctor(System.Object)">
 <summary>
 just wrap the clr runtime value
 </summary>
 <param name="wrap_val"></param>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Components.Symbol.setValue(System.Object,SMRUCC.Rsharp.Runtime.Environment,System.Boolean)">
 <summary>
 
 </summary>
 <param name="x"></param>
 <param name="env"></param>
 <param name="overrides">
 set this parameter to value TRUE to apply for the 
 script symbol imports
 </param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Components.Symbol.setMutable(System.Boolean)">
 <summary>
 set current symbol its lock binding status
 </summary>
 <param name="readonly">
 + true for const and lock binding
 + false for mutable and un-lock binding
 </param>
 
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Components.TryError">
 <summary>
 try-error
 </summary>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Components.TryError.stackframe">
 <summary>
 the error location
 </summary>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Components.TypeCodes">
 <summary>
 The R# types (byte)
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Runtime.Components.TypeCodes.NA">
 <summary>
 Unknown or invalid
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Runtime.Components.TypeCodes.generic">
 <summary>
 Object type in R#, any other CLR type.(使用这个类型来表示没有类型约束)
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Runtime.Components.TypeCodes.closure">
 <summary>
 函数类型
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Runtime.Components.TypeCodes.environment">
 <summary>
 the runtime environment
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Runtime.Components.TypeCodes.clr_delegate">
 <summary>
 type code for <see cref="T:SMRUCC.Rsharp.Runtime.Interop.RMethodInfo"/> and .NET clr <see cref="T:System.Reflection.MethodInfo"/>
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Runtime.Components.TypeCodes.list">
 <summary>
 Class type in R#
 </summary>
 <remarks>
 The R# list is the Dictionary type in VB.NET
 
 R#之中的list类型就是.NET之中的字典类型，对于所有的list类型的R对象而言，
 尽管他们的属性的数量和名称不相同，但是都是list字典类型
 </remarks>
</member>
<member name="F:SMRUCC.Rsharp.Runtime.Components.TypeCodes.integer">
 <summary>
 <see cref="T:System.Int32"/> vector
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Runtime.Components.TypeCodes.double">
 <summary>
 <see cref="T:System.Double"/> numeric vector
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Runtime.Components.TypeCodes.string">
 <summary>
 <see cref="T:System.String"/> vector
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Runtime.Components.TypeCodes.boolean">
 <summary>
 <see cref="T:System.Boolean"/> vector
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Runtime.Components.TypeCodes.dataframe">
 <summary>
 A data table liked compound type
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Runtime.Components.TypeCodes.raw">
 <summary>
 <see cref="T:System.Byte"/>
 </summary>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Components.What">
 <summary>
 just enumerate the R# primitive type
 </summary>
 <remarks>
 this enum flag code used for the export functions parameters,
 example as <see cref="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.file.readBin(System.Object,System.Object,System.Int32,System.Int32,System.Boolean,SMRUCC.Rsharp.Runtime.Internal.Invokes.endianness,SMRUCC.Rsharp.Runtime.Internal.Object.list,SMRUCC.Rsharp.Runtime.Environment)"/>;
 for compose type, use <see cref="T:SMRUCC.Rsharp.Runtime.Components.TypeCodes"/>
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Components.WhatReader.ClassWhat(System.Array)">
 <summary>
 convert the function output of <see cref="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.base.numeric(System.Int32,SMRUCC.Rsharp.Runtime.Environment)"/>, 
 <see cref="M:SMRUCC.Rsharp.Runtime.Internal.Invokes.base.ints(System.Int32,SMRUCC.Rsharp.Runtime.Environment)"/> to flag <see cref="T:SMRUCC.Rsharp.Runtime.Components.What"/>
 </summary>
 <param name="a"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Components.WhatReader.LoadWhat(SMRUCC.Rsharp.Runtime.Components.What)">
 <summary>
 load what data from byte vector
 </summary>
 <param name="what"></param>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Vectorization.CLRVector">
 <summary>
 Data cast type helper for the primitive array in CLR function code
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Vectorization.CLRVector.asLong(System.Object)">
 <summary>
 cast any to int(64 bit)
 </summary>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Vectorization.CLRVector.safeCharacters(System.Object)">
 <summary>
 
 </summary>
 <param name="x"></param>
 <returns>
 the returns string array always not null
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Vectorization.CLRVector.asScalarCharacter(System.Object)">
 <summary>
 get the first element in the input vector as character
 </summary>
 <param name="x"></param>
 <returns>
 this function will returns nothing if the input data is null
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Vectorization.CLRVector.asCharacter(System.Object)">
 <summary>
 try to cast any object to .net clr character vector 
 </summary>
 <param name="x"></param>
 <returns>
 this function returns nothing if the input object <paramref name="x"/> is nothing
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Vectorization.CLRVector.asInteger(System.Object)">
 <summary>
 Try to cast any clr object as the integer vector unsafely
 </summary>
 <param name="x"></param>
 <returns>
 this function will returns nothing if the given object <paramref name="x"/> is nothing
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Vectorization.CLRVector.asNumeric(System.Object)">
 <summary>
 cast any .net clr object to a numeric vector
 </summary>
 <param name="x"></param>
 <returns>
 an empty vector will be returns if the given object <paramref name="x"/> is nothing
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Vectorization.CLRVector.asLogical(System.Object)">
 <summary>
 NULL -> false
 </summary>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Vectorization.CLRVector.asObject(System.Object)">
 <summary>
 try to cast any kind of clr data input as object array
 </summary>
 <param name="x"></param>
 <returns></returns>
 <remarks>
 a wrapper function of <see cref="M:SMRUCC.Rsharp.Runtime.RVectorExtensions.asVector``1(System.Object)"/>.
 </remarks>
 
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Vectorization.op_evaluator">
 <summary>
 
 </summary>
 <param name="x">scalar</param>
 <param name="y">scalar</param>
 <param name="env"></param>
 <returns>this function should populate a single value result or a error message</returns>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Vectorization.Core">
 <summary>
 Operator impl core
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Vectorization.Core.op_In``1(System.Object,System.Collections.Generic.IEnumerable{``0})">
 <summary>
 The ``In`` operator
 </summary>
 <typeparam name="T"></typeparam>
 <param name="x"></param>
 <param name="collection"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Vectorization.Core.UnaryCoreInternal``2(System.Object,System.Func{System.Object,System.Object})">
 <summary>
 Generic unary operator core for primitive type.
 </summary>
 <typeparam name="T"></typeparam>
 <typeparam name="TOut"></typeparam>
 <param name="x"></param>
 <param name="[do]"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Vectorization.Core.BinaryCoreInternal``3(System.Object,System.Object,SMRUCC.Rsharp.Runtime.Vectorization.op_evaluator,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 this function just apply for the custom operator
 
 [Vector core] Generic binary operator core for numeric type.
 </summary>
 <typeparam name="TX"></typeparam>
 <typeparam name="TY"></typeparam>
 <typeparam name="TOut"></typeparam>
 <param name="x"></param>
 <param name="y"></param>
 <param name="do"></param>
 <returns>
 error message or array of <typeparamref name="TOut"/>.
 </returns>
 <remarks>
 the <paramref name="do"/> delegate function should be used for measure two scalar element value:
 
 op_evaluator = function(a,b,env) {...}
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Vectorization.Core.VectorAlignment(System.Array[])">
 <summary>
 将所有的数组都转换为等长的数组
 </summary>
 <param name="a"></param>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Vectorization.GetVectorElement">
 <summary>
 helper class object for make a safe vector element visiting
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Runtime.Vectorization.GetVectorElement.single">
 <summary>
 is a scalar value
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Runtime.Vectorization.GetVectorElement.vector">
 <summary>
 is a vector data
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Runtime.Vectorization.GetVectorElement.m_get">
 <summary>
 method cache for get value by index for unify
 the <see cref="F:SMRUCC.Rsharp.Runtime.Vectorization.GetVectorElement.single"/> scalar and the 
 <see cref="F:SMRUCC.Rsharp.Runtime.Vectorization.GetVectorElement.vector"/> array.
 </summary>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Vectorization.GetVectorElement.isNullOrEmpty">
 <summary>
 does the given input vector data is nothing or a clr array with zero elements inside?
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Runtime.Vectorization.GetVectorElement.item(System.Int32)">
 <summary>
 get elements inside current vector with i index
 </summary>
 <param name="i">zero-based vector element index value</param>
 <returns>
 this property unify the array get element and scalar value getter
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Vectorization.GetVectorElement.#ctor(System.Array,System.Type)">
 <summary>
 maybe a scalar value or a array vector
 </summary>
 <param name="vec"></param>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Vectorization.GetVectorElement.#ctor(System.Object,System.Type)">
 <summary>
 
 </summary>
 <param name="scalar">
 this item should never be nothing?
 </param>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Vectorization.GetVectorElement.Getter">
 <summary>
 
 </summary>
 <returns>
 the lambda function accepts a zero-based index value for
 get element value from a clr vector <see cref="T:System.Array"/> 
 object
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Vectorization.GetVectorElement.Create``1(System.Object)">
 <summary>
 if the target input object <paramref name="x"/>is nothing, then this function
 will returns an instance of <see cref="T:SMRUCC.Rsharp.Runtime.Vectorization.GetVectorElement"/> with wrap a null
 value
 </summary>
 <typeparam name="T"></typeparam>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Vectorization.GetVectorElement.CreateAny(System.Object)">
 <summary>
 if the target input object <paramref name="x"/>is nothing, then this function
 will returns an instance of <see cref="T:SMRUCC.Rsharp.Runtime.Vectorization.GetVectorElement"/> with wrap a null
 value
 </summary>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Vectorization.GetVectorElement.IsScalar(System.Object)">
 <summary>
 test the given <paramref name="obj"/> is a single scalar value?
 </summary>
 <param name="obj"></param>
 <returns>
 this function return true if the given <paramref name="obj"/> is nothing
 orelse is primitive type
 </returns>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Vectorization.ObjectSet">
 <summary>
 data collection helper
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Vectorization.ObjectSet.GetObjectSet(System.Object,SMRUCC.Rsharp.Runtime.Environment,SMRUCC.Rsharp.Runtime.Interop.RType@)">
 <summary>
 将任意类型的序列输入转换为统一的对象枚举序列
 </summary>
 <param name="x"></param>
 <returns></returns>
 <remarks>
 for a dataframe object, the row observation data will be treated as an object and populate from this function.
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Runtime.Vectorization.ObjectSet.extractDataframe(SMRUCC.Rsharp.Runtime.Internal.Object.dataframe)">
 <summary>
 populate the row observation
 </summary>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Runtime.Vectorization.typedefine`1">
 <summary>
 Type cache module
 </summary>
 <typeparam name="T"></typeparam>
</member>
<member name="F:SMRUCC.Rsharp.Runtime.Vectorization.typedefine`1.baseType">
 <summary>
 The vector based type(type of scaler value)
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Runtime.Vectorization.typedefine`1.enumerable">
 <summary>
 The abstract vector type(array, list, collection, etc)
 </summary>
</member>
<member name="T:SMRUCC.Rsharp.Development.Components.DotMachine">
 <summary>
 ### Numerical Characteristics of the Machine
 
 .Machine is a variable holding information on the numerical 
 characteristics of the machine R is running on, such as the 
 largest double or integer and the machine's precision.
 </summary>
 <remarks>
 The algorithm is based on Cody's (1988) subroutine MACHAR. 
 As all current implementations of R use 32-bit integers and 
 use IEC 60559 floating-point (double precision) arithmetic, 
 the "integer" and "double" related values are the same for 
 almost all R builds.

 Note that On most platforms smaller positive values than 
 .Machine$Double.xmin can occur. On a typical R platform the 
 smallest positive Double Is about 5E-324.
 </remarks>
</member>
<member name="P:SMRUCC.Rsharp.Development.Components.DotMachine.double_eps">
 <summary>
 the smallest positive floating-point number x such that 1 + x != 1. 
 It equals double.base ^ ulp.digits if either double.base is 2 or 
 double.rounding is 0; otherwise, it is (double.base ^ double.ulp.digits) / 2. 
 Normally 2.220446e-16.
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Development.Components.DotMachine.double_neg_eps">
 <summary>
 a small positive floating-point number x such that 1 - x != 1. It equals 
 double.base ^ double.neg.ulp.digits if double.base is 2 or double.rounding 
 is 0; otherwise, it is (double.base ^ double.neg.ulp.digits) / 2. Normally
 1.110223e-16. As double.neg.ulp.digits is bounded below by -(double.digits + 3),
 double.neg.eps may not be the smallest number that can alter 1 by subtraction.
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Development.Components.DotMachine.integer_max">
 <summary>
 the largest integer which can be represented. Always 2^{31} - 1 = 21474836472
 </summary>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Development.Components.Encoder">
 <summary>
 helper for json/bencode serialization of the R# runtime object.
 </summary>
</member>
<member name="P:SMRUCC.Rsharp.Development.Components.Encoder.row_names">
 <summary>
 options for dataframe, a new field row.names will be generates if set this option value TRUE
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Development.Components.Encoder.full_vector">
 <summary>
 options for dataframe, make the scalar field to full size vector if set this option value TRUE
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Development.Components.Encoder.TryHandleNonVector(System.Array,System.Boolean@)">
 <summary>
 R语言为向量化语言，但是其他的大部分编程语言不是向量化的
 所以在向量对象这里可能会存在一些bug
 我们基于大部分的语言所需求的数据都不是向量化的假设
 在这里将所有只包含有一个元素的向量认为是非向量数据
 </summary>
 <param name="vec"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Development.Components.Encoder.GetObject(System.Object,System.Boolean@)">
 <summary>
 digest R# object as underlying .NET object
 </summary>
 <param name="Robj"></param>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Development.Components.FileReference.filepath">
 <summary>
 The file object reference inside the given <see cref="P:SMRUCC.Rsharp.Development.Components.FileReference.fs"/> wrapper
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Development.Components.ProfileRecord.memory_delta">
 <summary>
 memory delta size in bytes unit ``MB``.
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Development.Components.RSessionInfo.Rversion">
 <summary>
 a list, the result of calling R.Version().
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Development.Components.RSessionInfo.platform">
 <summary>
 a character string describing the platform R was 
 built under. Where sub-architectures are in use 
 this is of the form platform/sub-arch (nn-bit).
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Development.Components.RSessionInfo.locale">
 <summary>
 a character string, the result of calling Sys.getlocale().
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Development.Components.RSessionInfo.running">
 <summary>
 a character string (or possibly NULL), the same as osVersion, see below.
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Development.Components.RSessionInfo.RNGkind">
 <summary>
 a character vector, the result of calling RNGkind().
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Development.Components.RSessionInfo.basePkgs">
 <summary>
 a character vector of base packages which are attached.
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Development.Components.RSessionInfo.loadedOnly">
 <summary>
 (not always present): a named list of the results of calling 
 packageDescription on packages whose namespaces are loaded 
 but are not attached.
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Development.Components.RSessionInfo.matprod">
 <summary>
 a character string, the result of calling getOption("matprod").
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Development.Components.RSessionInfo.BLAS">
 <summary>
 a character string, the result of calling extSoftVersion()["BLAS"].
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Development.Components.RSessionInfo.LAPACK">
 <summary>
 a character string, the result of calling La_library().
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Development.Components.tqdmList.getKeys">
 <summary>
 wrap tqdm from this function
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Development.Components.tqdmList.pullData">
 <summary>
 populate of the data collection with tqdm progress bar
 </summary>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Development.Components.AggregateFunction">
 <summary>
 create via the ``aggregate`` function, example as: 
 
 ```r
 let fx = aggregate(FUN = "max");
 
 print(fx([1,2,3,4,5]));
 # [1] 5
 ```
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Development.Components.ProgressBarFunction.n">
 <summary>
 total n task number
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Development.Components.ProgressBarFunction.d">
 <summary>
 interval for print the progress
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Development.Components.ProgressBarFunction.#ctor(System.Int32,System.Int32,System.Int32)">
 <summary>
 
 </summary>
 <param name="n">total task size</param>
 <param name="interval">
 [1,100]
 </param>
</member>
<member name="T:SMRUCC.Rsharp.Development.Components.ZipFolder">
 <summary>
 open zip for read data.
 </summary>
</member>
<member name="P:SMRUCC.Rsharp.Development.Components.ZipFolder.ls">
 <summary>
 populate all files inside internal of this zip file.
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Development.Components.ZipFolder.#ctor(System.String)">
 <summary>
 
 </summary>
 <param name="zipFile"></param>
</member>
<member name="P:SMRUCC.Rsharp.Development.Configuration.ConfigFile.localConfigs">
 <summary>
 脚本执行引擎的默认配置文件路径
 </summary>
 <returns></returns>
</member>
<member name="F:SMRUCC.Rsharp.Development.Configuration.ConfigFile.GCModellerSettings">
 <summary>
 the directory path for save common config file 
 of the GCModeller products. 
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Development.Configuration.ConfigFile.GetStartupLoadingPackages">
 <summary>
 default is ``["base", "utils", "grDevices", "stats"]``
 </summary>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Development.Configuration.OptionHooks">
 <summary>
 hooks for set options
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Development.Configuration.OptionHooks.Add(System.String,System.Action{System.String})">
 <summary>
 
 </summary>
 <param name="opt">
 the option name
 </param>
 <param name="callback"></param>
 
</member>
<member name="T:SMRUCC.Rsharp.Development.Configuration.Options">
 <summary>
 Data reader of <see cref="T:SMRUCC.Rsharp.Development.Configuration.ConfigFile"/>. The operations in this module will modify 
 the environment configuration of the R# scripting engine and it also controls 
 some of the behaviour of the sciBASIC.NET framework.
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Development.Configuration.Options.configValues">
 <summary>
 The memory cache value of the configuration.
 </summary>
</member>
<member name="P:SMRUCC.Rsharp.Development.Configuration.Options.nwarnings">
 <summary>
 ``nwarnings``, config the number of warning messages to display after done of run a script program. default is 50 warning message.
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Development.Configuration.Options.lib">
 <summary>
 Package library repository file path.
 </summary>
 <returns></returns>
</member>
<member name="F:SMRUCC.Rsharp.Development.Configuration.Options.UnixLib">
 <summary>
 config folder on unix platform is a fixed directory. 
 </summary>
</member>
<member name="P:SMRUCC.Rsharp.Development.Configuration.Options.lib_loc">
 <summary>
 the folder path for save the installed R# zip packages
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Development.Configuration.Options.maxPrint">
 <summary>
 Max count number for print vector. integer, defaulting to 999. 
 print or show methods can make use of this option, to limit the 
 amount of information that is printed, to something in the 
 order of (and typically slightly less than) max.print entries.
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Development.Configuration.Options.digits">
 <summary>
 [digits]:
 
 controls the number of significant (see signif) digits to print when printing 
 numeric values. It is a suggestion only. Valid values are 1...22 with default 
 7. See the note in print.default about values greater than 15.
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Development.Configuration.Options.f64Format">
 <summary>
 [f64.format]: ``F`` or ``G``
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Development.Configuration.Options.strict">
 <summary>
 turn strict mode on?
 </summary>
 <returns>
 option(strict = TRUE/FALSE);
 </returns>
</member>
<member name="P:SMRUCC.Rsharp.Development.Configuration.Options.stdout_multipline">
 <summary>
 在R#环境之中调用命令行，输出的stdout字符串是使用多行数据返回还是整个文本返回
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Development.Configuration.Options.verbose">
 <summary>
 logical. Should R report extra information on progress? Set to TRUE by the command-line option ``--verbose``
 </summary>
 <returns></returns>
 <remarks>
 debug模式下会默认将啰嗦模式打开
 </remarks>
</member>
<member name="P:SMRUCC.Rsharp.Development.Configuration.Options.environments">
 <summary>
 get default script environments
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Development.Configuration.Options.localConfig">
 <summary>
 file path for save the config file
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Development.Configuration.Options.#ctor(System.String,System.Boolean)">
 <summary>
 
 </summary>
 <param name="configs"></param>
 <param name="saveConfig">
 为R解释器创建配置数据的时候，一般只是修改当前新创建的解释器的环境
 并不需要写入配置文件，这个参数总是会设置为FALSE
 
 当通过命令行修改默认参数配置的时候，才会将这个参数设置为TRUE
 保存通过命令行工具所配置的R环境选项
 新修改的配置文件将会作为默认配置作为后面启动的R脚本解释器的默认配置值
 </param>
</member>
<member name="M:SMRUCC.Rsharp.Development.Configuration.Options.getOption(System.String,System.String,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 Get configuration value string, if the option is not exists in current configuration, 
 then this function will create a new configuration value with use default value.
 </summary>
 <param name="opt"></param>
 <param name="default$"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Development.Configuration.Options.setOption(System.String,System.String,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 Set configuration value and update the configuration database.
 </summary>
 <param name="opt"></param>
 <param name="value"></param>
 <returns></returns>
 <remarks>
 This method will also join/update a variable into the 
 sciBASIC.NET framework runtime.
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Development.Configuration.Options.flush(System.Boolean)">
 <summary>
 Save configuration file
 </summary>
 
</member>
<member name="T:SMRUCC.Rsharp.Development.AnnotationDocs">
 <summary>
 Parser of the <see cref="T:Microsoft.VisualBasic.ApplicationServices.Development.XmlDoc.Assembly.Project"/> assembly
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Development.AnnotationDocs.GetAnnotations(System.Type)">
 <summary>
 get xml document of a given clr type
 </summary>
 <param name="package"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Development.AnnotationDocs.get_clr_xml_document(System.Reflection.Assembly)">
 <summary>
 a helper function for get the xml comment document for a given dll file
 </summary>
 <param name="assembly"></param>
 <returns>the file path to the xml document file, could be nothing if not found</returns>
</member>
<member name="M:SMRUCC.Rsharp.Development.AnnotationDocs.GetAnnotations(System.Reflection.MethodInfo,System.Boolean)">
 <summary>
 
 </summary>
 <param name="func"></param>
 <param name="requireNoneNull">
 默认当没有做注释的时候，这个函数会返回空值
 反之这个参数为TRUE的时候会返回空文档对象实例
 </param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Development.AnnotationDocs.PrintHelp(SMRUCC.Rsharp.Runtime.Interop.RMethodInfo,SMRUCC.Rsharp.Runtime.RContentOutput)">
 <summary>
 Print help information about the given R api method 
 </summary>
 <param name="api"></param>
</member>
<member name="M:SMRUCC.Rsharp.Development.CodeAnalysis.FunctionTree.GetNode(System.String)">
 <summary>
 
 </summary>
 <param name="name"></param>
 <returns>
 the return value always not null
 </returns>
</member>
<member name="T:SMRUCC.Rsharp.Development.CodeAnalysis.SymbolTypeDefine">
 <summary>
 the general definition model of the symbol or function in typescript
 </summary>
</member>
<member name="P:SMRUCC.Rsharp.Development.CodeAnalysis.SymbolTypeDefine.value">
 <summary>
 the return/symbol value type of current function
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Development.CodeAnalysis.SymbolTypeDefine.toList">
 <summary>
 as.list(args(func))
 </summary>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Development.CodeAnalysis.TypeScriptDefine">
 <summary>
 the generator module for the type script definition
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Development.CodeAnalysis.TypeScriptDefine.ExtractModule(SMRUCC.Rsharp.Runtime.GlobalEnvironment,SMRUCC.Rsharp.Development.Package.Package[])">
 <summary>
 extract the typescript module definition 
 </summary>
 <param name="pkg"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Development.CodeAnalysis.TypeScriptDefine.ExtractModule(SMRUCC.Rsharp.Development.Package.Package[],System.IO.TextWriter,SMRUCC.Rsharp.Runtime.GlobalEnvironment)">
 <summary>
 
 </summary>
 <param name="pkgs">
 modules with the same namespace reference
 </param>
 <param name="ts"></param>
</member>
<member name="M:SMRUCC.Rsharp.Development.CodeAnalysis.TypeScriptDefine.BuildNamespaceTree(System.String,SMRUCC.Rsharp.Development.Package.Package[])">
 <summary>
 due to the reason of R symbol name may contains the ``dot`` symbol
 and this may confuse the javascript/python syntax, so needs the 
 tree structure to solve this problem
 </summary>
 <param name="root"></param>
 <param name="pkg"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Development.CodeAnalysis.TypeScriptDefine.MapTypeScriptType(SMRUCC.Rsharp.Runtime.Interop.RType)">
 <summary>
 mapping R# clr type to typescript type mark string
 </summary>
 <param name="type"></param>
 <returns></returns>
</member>
<member name="F:SMRUCC.Rsharp.Development.CodeAnalysis.TypeWriter.symbol">
 <summary>
 20230610 this symbol object will be nothing if the 
 target package module contains no public export api 
 function
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Development.CodeAnalysis.TypeWriter.Flush(SMRUCC.Rsharp.Runtime.GlobalEnvironment)">
 <summary>
 start to write a comment document for a target function <see cref="F:SMRUCC.Rsharp.Development.CodeAnalysis.TypeWriter.symbol"/>
 </summary>
 <param name="context"></param>
</member>
<member name="T:SMRUCC.Rsharp.Development.CodeAnalysis.RlangTranslator">
 <summary>
 helper module for translate the R# code to R language
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Development.CodeAnalysis.RlangTranslator.filters">
 <summary>
 filtering of the parent symbols
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Development.CodeAnalysis.RlangTranslator.GetScript(SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 get R language script
 </summary>
 <param name="env">
 the runtime environment for extract the symbol values for run the script
 </param>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Development.CodeAnalysis.SymbolAnalysis">
 <summary>
 analysis of the static symbol reference
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Development.CodeAnalysis.SymbolAnalysis.Context.Create(System.String)">
 <summary>
 declare new symbol or function parameters
 </summary>
 <param name="symbol"></param>
</member>
<member name="T:SMRUCC.Rsharp.Development.Document">
 <summary>
 R comment documentation model
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Development.Document.UnixMan">
 <summary>
 convert R documentation to unix man page
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Development.FunctionDeclare.RenderValueColor(Microsoft.VisualBasic.Text.Xml.Models.NamedValue)">
 <summary>
 rendering the color for the default value
 </summary>
 <param name="a"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Development.ConsoleMarkdownPrinter.printDocs(SMRUCC.Rsharp.Interpreter.ExecuteEngine.SymbolExpression)">
 <summary>
 print highlighted markdown on console
 </summary>
 <param name="f"></param>
</member>
<member name="M:SMRUCC.Rsharp.Development.ConsoleMarkdownPrinter.getMarkdownDocs(SMRUCC.Rsharp.Interpreter.ExecuteEngine.SymbolExpression)">
 <summary>
 get help document content in markdown format
 </summary>
 <param name="f"></param>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Development.ConsoleSyntaxHighlightPrinter">
 <summary>
 Print R# code with syntax highlight on the console by use ascii escape sequence
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Development.ConsoleSyntaxHighlightPrinter.PrintCode(System.String,SMRUCC.Rsharp.Runtime.RContentOutput)">
 <summary>
 helper function for print code with syntax highlights
 </summary>
 <param name="code"></param>
 <param name="dev"></param>
</member>
<member name="M:SMRUCC.Rsharp.Development.ConsoleSyntaxHighlightPrinter.PrintCode(System.String,System.IO.TextWriter,SMRUCC.Rsharp.Runtime.OutputEnvironments)">
 <summary>
 helper function for print code with syntax highlights
 </summary>
 <param name="code"></param>
 <param name="dev"></param>
</member>
<member name="M:SMRUCC.Rsharp.Development.ConsoleSyntaxHighlightPrinter.PrintAsHtmlSpans(System.Collections.Generic.IEnumerable{SMRUCC.Rsharp.Language.TokenIcer.Token},System.IO.TextWriter)">
 <summary>
 html syntax highlights
 </summary>
 <param name="tokens"></param>
 <param name="dev"></param>
</member>
<member name="M:SMRUCC.Rsharp.Development.UnixManPagePrinter.printManPage(SMRUCC.Rsharp.Runtime.Interop.RMethodInfo,Microsoft.VisualBasic.ApplicationServices.Development.XmlDoc.Assembly.ProjectMember,SMRUCC.Rsharp.Runtime.RContentOutput)">
 <summary>
 print the help information on the console
 </summary>
 <param name="api"></param>
 <param name="docs"></param>
 <param name="markdown"></param>
</member>
<member name="M:SMRUCC.Rsharp.Development.UnixManPagePrinter.CreateManPage(SMRUCC.Rsharp.Runtime.Interop.RMethodInfo,Microsoft.VisualBasic.ApplicationServices.Development.XmlDoc.Assembly.ProjectMember)">
 <summary>
 extract the help document data from the clr xml documentation file
 </summary>
 <param name="api"></param>
 <param name="docs"></param>
 <returns></returns>
</member>
<member name="F:SMRUCC.Rsharp.Development.CommandLine.ArgumentInfo.type">
 <summary>
 argument value type in the commandline input.
 </summary>
</member>
<member name="T:SMRUCC.Rsharp.Development.CommandLine.ShellScript">
 <summary>
 the R# shell script commandline arguments helper module
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Development.CommandLine.ShellScript.AddArgumentValue(SMRUCC.Rsharp.Interpreter.ExecuteEngine.Expression,System.String,System.Boolean,SMRUCC.Rsharp.Development.CommandLine.ArgumentInfo)">
 <summary>
 add a command line argument value
 </summary>
 <param name="expr"></param>
 <param name="default$"></param>
 <param name="attrs"></param>
</member>
<member name="T:SMRUCC.Rsharp.Development.Package.CollectibleAssemblyLoadContext">
 <summary>
 https://stackoverflow.com/questions/27266907/no-appdomains-in-net-core-why
 </summary>
</member>
<member name="P:SMRUCC.Rsharp.Development.Package.LocalPackageDatabase.assemblies">
 <summary>
 .NET assembly list
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Development.Package.LocalPackageDatabase.packages">
 <summary>
 installed R# zip package
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Development.Package.LocalPackageDatabase.hasLibFile(System.String)">
 <summary>
 Check if the given dll module <paramref name="libraryFileName"/> is exists in database or not.
 </summary>
 <param name="libraryFileName"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Development.Package.LocalPackageDatabase.enumerateNugets(System.String)">
 <summary>
 enumerate all nuget zip packages that installed inside the local repository
 </summary>
 <returns></returns>
 
</member>
<member name="M:SMRUCC.Rsharp.Development.Package.LocalPackageDatabase.FindPackage(System.String,SMRUCC.Rsharp.Runtime.GlobalEnvironment,System.Exception@)">
 <summary>
 If the package is not exists or load package failure
 then this function returns nothing
 </summary>
 <param name="packageName"></param>
 <param name="exception"></param>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Development.Package.PackageInfo.namespace">
 <summary>
 Package name
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Development.Package.PackageInfo.description">
 <summary>
 Package summary information
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Development.Package.PackageInfo.url">
 <summary>
 This plugins project's home page url.
 </summary>
 <returns></returns>
 
</member>
<member name="P:SMRUCC.Rsharp.Development.Package.PackageInfo.publisher">
 <summary>
 Your name or E-Mail
 </summary>
 <returns></returns>
 
</member>
<member name="P:SMRUCC.Rsharp.Development.Package.PackageInfo.cites">
 <summary>
 这个脚本模块包的文献引用列表
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Development.Package.PackageLoaderEntry.module">
 <summary>
 The package loader clr type entry information
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Development.Package.PackageLoaderEntry.basePackage">
 <summary>
 the base package name of current dll module file
 if current .NET assembly module file is installed
 from the nuget zip package.
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Development.Package.PackageLoaderEntry.GetLoader(SMRUCC.Rsharp.Runtime.GlobalEnvironment,System.Exception@)">
 <summary>
 Get package loading entry information
 </summary>
 <param name="exception"></param>
 <returns>
 load .NET context into runtme via this object value
 </returns>
</member>
<member name="T:SMRUCC.Rsharp.Development.Package.ImportsPackage">
 <summary>
 Helper methods for add .NET function into <see cref="T:SMRUCC.Rsharp.Runtime.Environment"/> target
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Development.Package.ImportsPackage.GetAllApi(System.Type,System.Boolean,System.Boolean)">
 <summary>
 这个函数会获取得到通过<see cref="T:System.Composition.ExportAttribute"/>或者<see cref="T:Microsoft.VisualBasic.CommandLine.Reflection.ExportAPIAttribute"/>标记的函数
 </summary>
 <param name="package"></param>
 <param name="strict"></param>
 <param name="includesInternal"></param>
 <returns>
 a collection of the tuple list:
 
 [exportapi_name => function]
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Development.Package.ImportsPackage.TryParse(System.Reflection.MethodInfo,System.Boolean)">
 <summary>
 parse the clr function export api name and the function body
 </summary>
 <param name="method"></param>
 <param name="strict"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Development.Package.ImportsPackage.ImportsStatic(SMRUCC.Rsharp.Runtime.Environment,System.Type,System.Boolean)">
 <summary>
 This function returns a list of object which is masked by the new imports <paramref name="package"/>
 </summary>
 <param name="env"></param>
 <param name="package"></param>
 <param name="strict"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Development.Package.ImportsPackage.ImportsStaticInternalImpl(SMRUCC.Rsharp.Runtime.Environment,System.Type,System.Boolean)">
 <summary>
 imports all static api method in a given package module. 
 </summary>
 <param name="envir"></param>
 <param name="package"></param>
 <param name="strict"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Development.Package.ImportsPackage.ImportsInstance(SMRUCC.Rsharp.Runtime.Environment,System.Object)">
 <summary>
 imports class object instance methods.
 </summary>
 <param name="envir"></param>
 <param name="target"></param>
</member>
<member name="M:SMRUCC.Rsharp.Development.Package.LibDLL.GetDllFile(System.String,SMRUCC.Rsharp.Runtime.Environment,System.Collections.Generic.List{System.String}@)">
 <summary>
 try to get .net clr dll assembly file from app directory or attached package assembly directories
 </summary>
 <param name="libDllName"></param>
 <param name="env"></param>
 <param name="searchContext"></param>
 <returns></returns>
 <remarks>
 attach_lib_dir
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Development.Package.LibDLL.getDllFromAttachedPackages(System.String,SMRUCC.Rsharp.Runtime.GlobalEnvironment,System.Collections.Generic.List{System.String}@)">
 <summary>
 load from the assembly of attatch packages
 </summary>
 <param name="libDll"></param>
 <param name="globalEnvironment"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Development.Package.LibDLL.getDllFromAppDir(System.String,SMRUCC.Rsharp.Runtime.GlobalEnvironment,System.Collections.Generic.List{System.String}@)">
 <summary>
 
 </summary>
 <param name="libDll">
 the dll file name or full path
 </param>
 <param name="globalEnvironment"></param>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Development.Package.NuGet.metadata.nuspec">
 <summary>
 A .nuspec file is an XML manifest that contains package
 metadata. This manifest is used both to build the 
 package and to provide information to consumers. The 
 manifest is always included in a package.
 
 https://docs.microsoft.com/en-us/nuget/reference/nuspec
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Development.Package.NuGet.metadata.nuspec.createRReference(SMRUCC.Rsharp.Development.Package.File.Dependency[],System.String)">
 <summary>
 可以通过这个依赖列表从nuget上搜索所被引用的``R#``程序包列表
 </summary>
 <param name="loading"></param>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Development.Package.NuGet.metadata.nugetmeta">
 <summary>
 ### Required metadata elements
 
 Although the following elements are the minimum 
 requirements For a package, you should consider 
 adding the Optional metadata elements To improve 
 the overall experience developers have With your 
 package.
 
 These elements must appear within a &lt;metadata> 
 element.
 </summary>
</member>
<member name="P:SMRUCC.Rsharp.Development.Package.NuGet.metadata.nugetmeta.id">
 <summary>
 The case-insensitive package identifier, which 
 must be unique across nuget.org or whatever 
 gallery the package resides in. IDs may not 
 contain spaces or characters that are not valid 
 for a URL, and generally follow .NET namespace 
 rules. See Choosing a unique package identifier 
 for guidance.
 
 When uploading a package to nuget.org, the id 
 field Is limited to 128 characters.
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Development.Package.NuGet.metadata.nugetmeta.title">
 <summary>
 A human-friendly title of the package which may 
 be used in some UI displays. (nuget.org and the 
 Package Manager in Visual Studio do not show 
 title)
 
 When uploading a package to nuget.org, the title 
 field Is limited to 256 characters but Is Not used 
 for any display purposes.
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Development.Package.NuGet.metadata.nugetmeta.version">
 <summary>
 The version of the package, following the major.minor.patch 
 pattern. Version numbers may include a pre-release 
 suffix as described in Package versioning.
 
 When uploading a package to nuget.org, the version 
 field Is limited to 64 characters.
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Development.Package.NuGet.metadata.nugetmeta.authors">
 <summary>
 A comma-separated list of packages authors, matching 
 the profile names on nuget.org. These are displayed 
 in the NuGet Gallery on nuget.org and are used to 
 cross-reference packages by the same authors.
 
 When uploading a package to nuget.org, the authors field 
 Is limited to 4000 characters.
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Development.Package.NuGet.metadata.nugetmeta.requireLicenseAcceptance">
 <summary>
 A Boolean value specifying whether the client must 
 prompt the consumer to accept the package license 
 before installing the package.
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Development.Package.NuGet.metadata.nugetmeta.license">
 <summary>
 Supported with NuGet 4.9.0 and above
 
 An SPDX license expression Or path To a license file 
 within the package, often shown In UIs Like nuget.org. 
 If you're licensing the package under a common 
 license, like MIT or BSD-2-Clause, use the associated 
 SPDX license identifier. 
 
 For example:
 
 ```
 &lt;LICENSE type="expression">MIT&lt;/license>
 ```
 
 If your package is licensed under multiple common licenses, 
 you can specify a composite license using the SPDX 
 expression syntax version 2.0. 
 
 For example:
 
 ```
 &lt;LICENSE type="expression">BSD-2-Clause OR MIT&lt;/license>
 ```
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Development.Package.NuGet.metadata.nugetmeta.licenseUrl">
 <summary>
 A URL for the package's license, often shown 
 in UIs like nuget.org.
 
 When uploading a package to nuget.org, the 
 licenseUrl field Is limited to 4000 characters.
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Development.Package.NuGet.metadata.nugetmeta.icon">
 <summary>
 Supported with NuGet 5.3.0 and above
 
 It Is a path to an image file within the package, 
 often shown in UIs Like nuget.org as the package 
 icon. Image file size Is limited to 1 MB. Supported 
 file formats include JPEG And PNG. We recommend
 an image resolution of 128x128.
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Development.Package.NuGet.metadata.nugetmeta.projectUrl">
 <summary>
 A URL for the package's home page, often shown 
 in UI displays as well as nuget.org.
 
 When uploading a package to nuget.org, the 
 projectUrl field Is limited to 4000 characters.
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Development.Package.NuGet.metadata.nugetmeta.description">
 <summary>
 A description of the package for UI display.
 
 When uploading a package to nuget.org, the 
 description field Is limited to 4000 
 characters.
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Development.Package.NuGet.metadata.nugetmeta.copyright">
 <summary>
 (1.5+) Copyright details for the package.
 When uploading a package to nuget.org, the 
 copyright field Is limited to 4000 
 characters.
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Development.Package.NuGet.metadata.nugetmeta.readme">
 <summary>
 Supported with NuGet 5.10.0 preview 2 and above
 
 When packing a readme file, you need to use the 
 readme element to specify the package path, relative 
 to the root of the package. In addition to this, 
 you need to make sure that the file Is included in 
 the package. Supported file formats include only 
 Markdown (.md).
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Development.Package.NuGet.metadata.nugetmeta.tags">
 <summary>
 A space-delimited list of tags and keywords that 
 describe the package and aid discoverability of 
 packages through search and filtering.
 
 When uploading a package to nuget.org, the tags 
 field Is limited to 4000 characters.
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Development.Package.NuGet.metadata.nugetmeta.repository">
 <summary>
 Repository metadata, consisting of four optional 
 attributes: type and url (4.0+), and branch and
 commit (4.6+). These attributes allow you to map
 the .nupkg to the repository that built it, with 
 the potential to get as detailed as the individual 
 branch name and / or commit SHA-1 hash that built 
 the package. This should be a publicly available 
 url that can be invoked directly by a version 
 control software. It should not be an html page as 
 this is meant for the computer. For linking to 
 project page, use the projectUrl field, instead.
 
 When uploading a package to nuget.org, the type 
 attribute is limited to 100 characters and the url 
 attribute is limited to 4000 characters.
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Development.Package.NuGet.metadata.nugetmeta.dependencies">
 <summary>
 A collection of zero or more &lt;dependency> elements 
 specifying the dependencies for the package. Each 
 dependency has attributes of id, version, include 
 (3.x+), and exclude (3.x+). 
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Development.Package.NuGet.metadata.nugetmeta.frameworkAssemblies">
 <summary>
 (1.2+) A collection of zero or more &lt;frameworkAssembly> 
 elements identifying .NET Framework assembly references 
 that this package requires, which ensures that references 
 are added to projects consuming the package. Each 
 frameworkAssembly has assemblyName and targetFramework
 attributes.
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Development.Package.NuGet.metadata.nugetmeta.language">
 <summary>
 The locale ID for the package. 
 </summary>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Development.Package.NuGet.metadata.dependency">
 <summary>
 The &lt;dependencies> element within &lt;metadata> 
 contains any number of &lt;dependency> elements that 
 identify other packages upon which the top-level 
 package depends. 
 </summary>
</member>
<member name="P:SMRUCC.Rsharp.Development.Package.NuGet.metadata.dependency.id">
 <summary>
 (Required) The package ID of the dependency, such 
 as "EntityFramework" and "NUnit", which is the name 
 of the package nuget.org shows on a package page.
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Development.Package.NuGet.metadata.dependency.version">
 <summary>
 (Required) The range of versions acceptable as a 
 dependency. See Package versioning for exact syntax. 
 Floating versions are not supported.
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Development.Package.NuGet.metadata.dependency.exclude">
 <summary>
 A comma-delimited list of include/exclude tags (see 
 below) indicating of the dependency to exclude in the
 final package. The default value is build,analyzers 
 which can be over-written. But content/ ContentFiles 
 are also implicitly excluded in the final package 
 which can't be over-written. Tags specified with 
 exclude take precedence over those specified with 
 include. For example, include="runtime, compile" 
 exclude="compile" is the same as include="runtime".
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Development.Package.NuGet.metadata.dependency.include">
 <summary>
 A comma-delimited list of include/exclude tags (see 
 below) indicating of the dependency to include in the
 final package. The default value is all.
 </summary>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Development.Package.NuGet.metadata.frameworkAssembly">
 <summary>
 Framework assemblies are those that are part of the .NET 
 framework and should already be in the global assembly cache 
 (GAC) for any given machine. By identifying those assemblies 
 within the &lt;frameworkAssemblies> element, a package can 
 ensure that required references are added to a project in 
 the event that the project doesn't have such references 
 already. Such assemblies, of course, are not included in a 
 package directly.
 
 The &lt;frameworkAssemblies> element contains zero Or 
 more &lt;frameworkAssembly> elements
 </summary>
</member>
<member name="P:SMRUCC.Rsharp.Development.Package.NuGet.metadata.frameworkAssembly.assemblyName">
 <summary>
 (Required) The fully qualified assembly name.
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Development.Package.NuGet.metadata.frameworkAssembly.targetFramework">
 <summary>
 (Optional) Specifies the target framework to which this 
 reference applies. If omitted, indicates that the reference 
 applies to all frameworks. See Target frameworks for 
 the exact framework identifiers.
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Development.Package.NuGet.Repository.Install(System.String,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 install R# module package from nuget repository
 </summary>
 <param name="packageName"></param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Development.Package.NuGet.Repository.Install(System.String,SMRUCC.Rsharp.Runtime.Environment,System.String,System.Boolean)">
 <summary>
 install R# module package from nuget repository
 </summary>
 <param name="packageName"></param>
 <param name="env"></param>
 <param name="mirror"></param>
 <param name="include_prerelease"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Development.Package.NuGet.Repository.Search(System.String,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 search R# package from nuget repository
 </summary>
 <param name="packageName"></param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Development.Package.NuGet.web.WebRequest">
 <summary>
 use nuget package repository system as R# package repository
 </summary>
</member>
<member name="T:SMRUCC.Rsharp.Development.Package.Package">
 <summary>
 The R# package module wrapper
 </summary>
</member>
<member name="P:SMRUCC.Rsharp.Development.Package.Package.package">
 <summary>
 the package assembly module.
 </summary>
 <returns>
 the .NET context for imports methods and functions
 </returns>
</member>
<member name="P:SMRUCC.Rsharp.Development.Package.Package.isMissing">
 <summary>
 the <see cref="P:SMRUCC.Rsharp.Development.Package.Package.package"/> assembly module is nothing means 
 the current package object is missing on your filesystem.
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Development.Package.Package.ls">
 <summary>
 Get all api names in this package module
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Development.Package.Package.dllName">
 <summary>
 get the .net clr dll assembly basename without extension suffix
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Development.Package.Package.#ctor(Microsoft.VisualBasic.Scripting.MetaData.PackageAttribute,System.Type)">
 <summary>
 construct from a clr runtime type
 </summary>
 <param name="info"></param>
 <param name="package"></param>
</member>
<member name="M:SMRUCC.Rsharp.Development.Package.Package.#ctor(SMRUCC.Rsharp.Development.Package.PackageLoaderEntry)">
 <summary>
 For missing package
 </summary>
 <param name="loaderInfo"></param>
</member>
<member name="F:SMRUCC.Rsharp.Development.Package.Package.apiCache">
 <summary>
 [namespace::name -> entry_point]
 </summary>
</member>
<member name="P:SMRUCC.Rsharp.Development.Package.File.AssemblyPack.assembly">
 <summary>
 dll files, apply for md5 checksum calculation
 </summary>
 <returns>get filtered dll file modules</returns>
 <remarks>
 程序会将几乎所有的文件都打包进去: <see cref="M:SMRUCC.Rsharp.Development.Package.File.AssemblyPack.GetAllPackageContentFiles"/>
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Development.Package.File.AssemblyPack.GetAllPackageContentFiles">
 <summary>
 enumerates all package contents files, includes:
 
 1. dll modules
 2. deps.json files
 3. app config files
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Development.Package.File.AssemblyPack.GetAllPackageClrXmlDocumentFiles">
 <summary>
 enumerate all xml files for clr assembly dll documentation
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Development.Package.File.AssemblyPack.GenericEnumerator">
 <summary>
 enumerates all dll files
 </summary>
 <returns>dll file file path in full name</returns>
</member>
<member name="M:SMRUCC.Rsharp.Development.Package.File.CreatePackage.getAssemblyList(System.String,Microsoft.VisualBasic.ComponentModel.Collection.Index{System.String})">
 <summary>
 scan for all dll files from the given package source <paramref name="dir"/>
 </summary>
 <param name="dir"></param>
 <param name="assemblyFilters">
 all of the assembly file that appears in this index list will be 
 excludes from the package build 
 </param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Development.Package.File.CreatePackage.Build(SMRUCC.Rsharp.Development.Package.File.DESCRIPTION,System.String,System.IO.Stream,Microsoft.VisualBasic.ComponentModel.Collection.Index{System.String},System.Boolean)">
 <summary>
 build a R# package file
 </summary>
 <param name="target">
 the target directory that contains the necessary 
 files for create a R# package file.</param>
 <param name="outfile">the output zip file stream</param>
 <returns></returns>
 
</member>
<member name="M:SMRUCC.Rsharp.Development.Package.File.CreatePackage.getRuntimeTags">
 <summary>
 get assembly runtime folder tag
 </summary>
 <returns>net48, net6.0, net5.0</returns>
</member>
<member name="M:SMRUCC.Rsharp.Development.Package.File.CreatePackage.buildUnixMan(SMRUCC.Rsharp.Development.Package.File.PackageModel,System.String)">
 <summary>
 create unix .1 man page file and html help documents
 </summary>
 <param name="file"></param>
 <param name="package_dir"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Development.Package.File.CreatePackage.buildRscript(SMRUCC.Rsharp.Development.Package.File.PackageModel,System.String,Microsoft.VisualBasic.Language.List{SMRUCC.Rsharp.Interpreter.ExecuteEngine.Expression}@)">
 <summary>
 this function just add <see cref="P:SMRUCC.Rsharp.Development.Package.File.PackageModel.symbols"/>
 </summary>
 <param name="file"></param>
 <param name="script"></param>
 <param name="loading">
 a list of dependency expression
 </param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Development.Package.File.CreatePackage.MakeFunction(SMRUCC.Rsharp.Interpreter.ExecuteEngine.Expression)">
 <summary>
 fix for the function name
 </summary>
 <param name="line"></param>
 <returns></returns>
 <remarks>
 this function will rename the function with anomoymous name
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Development.Package.File.CreatePackage.getFileReader(System.String)">
 <summary>
 + ``%s``, means the <paramref name="path"/> parameter value
 + ``1%``, means integer value 1
 + ``1#``, means float value 1
 + ``$``, means the <see cref="T:SMRUCC.Rsharp.Runtime.Environment"/> parameter reference
 </summary>
 <param name="path"></param>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Development.Package.File.Dependency.library">
 <summary>
 assembly file name
 </summary>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Development.Package.File.DESCRIPTION">
 <summary>
 the metadata of the R# package file
 </summary>
</member>
<member name="P:SMRUCC.Rsharp.Development.Package.File.DESCRIPTION.Package">
 <summary>
 the package name
 </summary>
 <remarks>
 this package name could be used for load the package via ``require`` or ``library`` function.
 </remarks>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Development.Package.File.DESCRIPTION.Type">
 <summary>
 the type of the current R# package.
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Development.Package.File.DESCRIPTION.Title">
 <summary>
 the title display of the current package.
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Development.Package.File.DESCRIPTION.Version">
 <summary>
 the package version string
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Development.Package.File.DESCRIPTION.Date">
 <summary>
 the date time for build this package
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Development.Package.File.DESCRIPTION.Author">
 <summary>
 the author names for write this packages
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Development.Package.File.DESCRIPTION.Description">
 <summary>
 A long text for make notes about this package its function and usage.
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Development.Package.File.DESCRIPTION.License">
 <summary>
 the license name
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Development.Package.File.DESCRIPTION.meta">
 <summary>
 other additional metadata about this package
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Development.Package.File.DESCRIPTION.isEmpty">
 <summary>
 check of the content data of current package metadata is empty or not?
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Development.Package.File.DESCRIPTION.Parse(System.String)">
 <summary>
 
 </summary>
 <param name="file">the file path to the package document description file</param>
 <returns></returns>
 
</member>
<member name="T:SMRUCC.Rsharp.Development.Package.File.Expressions.RBreakControls">
 <summary>
 break/next
 </summary>
</member>
<member name="T:SMRUCC.Rsharp.Development.Package.File.Expressions.RExpression">
 <summary>
 the R expression writer/reader
 </summary>
 <remarks>
 expression: [ExpressionTypes, i32][dataSize, i32][TypeCodes, byte][expressionData, bytes]
              4                     4              1                ...
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Development.Package.File.Expressions.RExpression.saveSize(System.IO.BinaryWriter)">
 <summary>
 
 </summary>
 <param name="outfile"></param>
 <remarks>
 expression: [ExpressionTypes, i32][dataSize, i32][TypeCodes, byte][expressionData, bytes]
              4                     4              1                ...
 </remarks>
</member>
<member name="T:SMRUCC.Rsharp.Development.Package.File.Expressions.RJSON">
 <summary>
 <see cref="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.ExpressionSymbols.DataSets.JSONLiteral"/>
 </summary>
</member>
<member name="T:SMRUCC.Rsharp.Development.Package.File.Expressions.RRequire">
 <summary>
 imports语句在脚本模式下可以出现在任意语句块之中，但是
 imports语句在R#程序包之中只允许出现在脚本的最顶层，不允许出现在其他的语句块中
 require语句可以出现在程序包之中的任意语句块之中
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Development.Package.File.PatternMatch.#ctor(System.String)">
 <summary>
 create a new regular expression pattern match object
 </summary>
 <param name="pattern">
 a regular expression pattern
 </param>
 
</member>
<member name="T:SMRUCC.Rsharp.Development.Package.File.Rbuildignore">
 <summary>
 file handler of ``.Rbuildignore``
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Development.Package.File.Rbuildignore.IsFileIgnored(System.String)">
 <summary>
 
 </summary>
 <param name="relpath">
 a relative path to the directory of DESCRIPTION meta data file.
 </param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Development.Package.File.Rbuildignore.CreatePatterns(System.String)">
 <summary>
 create a file name matches pattern
 
 1. a regular expression pattern should start with symbol ``^`` and ends with the symbol ``$``
 2. a relative file path pattern just required a relative file path to a specific file
 3. comment line start with the ``#`` symbol
 </summary>
 <param name="file">
 a text file its file path or the content data text itself
 </param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Development.Package.File.RegularMatch.#ctor(System.String)">
 <summary>
 normal file path matched
 </summary>
 <param name="pattern">
 a relative file path
 </param>
</member>
<member name="M:SMRUCC.Rsharp.Development.Package.File.NuGetZip.copyAssembly">
 <summary>
 copy .NET assembly dll files
 </summary>
</member>
<member name="T:SMRUCC.Rsharp.Development.Package.File.PackageLoader2">
 <summary>
 Load R package folder
 
 20221122

 just load the R source file at here, the
 package module inside the .NET dll file its
 loading procedure is lazy, load a specific dll 
 file until the ``imports`` expression is 
 evaluated in the R script file
 </summary>
 <remarks>
 the package loading procedure between the <see cref="M:SMRUCC.Rsharp.Development.Package.File.PackageLoader2.Hotload(System.String,SMRUCC.Rsharp.Runtime.GlobalEnvironment,SMRUCC.Rsharp.Development.Package.File.DESCRIPTION@)"/> and
 <see cref="M:SMRUCC.Rsharp.Development.Package.File.PackageLoader2.LoadPackage(Microsoft.VisualBasic.ApplicationServices.IFileSystemEnvironment,System.String,System.Boolean,SMRUCC.Rsharp.Runtime.GlobalEnvironment)"/> is similar to each other, but have some significatent 
 difference between each other:
 
 1. hotload function handling the source project folder, all of the R source is the original text file
 2. loadpackage function handling the package installed folder, all of the R source is serialized as binary data file
 3. the directory folder structure is also different between the source project folder and the package library folder
 
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Development.Package.File.PackageLoader2.CheckPackage(System.String)">
 <summary>
 检查程序包的指纹是否和checksum中的结果相匹配
 </summary>
 <param name="libDir"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Development.Package.File.PackageLoader2.GetPackageDirectory(SMRUCC.Rsharp.Development.Configuration.Options,System.String)">
 <summary>
 get the root dir of the target R#(nuget/zip) package.
 </summary>
 <param name="opt"></param>
 <param name="packageName">the R# package name</param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Development.Package.File.PackageLoader2.Hotload(System.String,SMRUCC.Rsharp.Runtime.GlobalEnvironment,SMRUCC.Rsharp.Development.Package.File.DESCRIPTION@)">
 <summary>
 程序包调试，测试用api
 
 在启动的时候对未进行编译的程序包进行热加载
 </summary>
 <param name="projDir">
 the package source project directory, which is should be un-build...
 for load the package directory which is installed into the R library
 folder, use the method <see cref="M:SMRUCC.Rsharp.Development.Package.File.PackageLoader2.LoadPackage(Microsoft.VisualBasic.ApplicationServices.IFileSystemEnvironment,System.String,System.Boolean,SMRUCC.Rsharp.Runtime.GlobalEnvironment)"/>
 instead.
 </param>
 <param name="env"></param>
 <returns></returns>
 
</member>
<member name="M:SMRUCC.Rsharp.Development.Package.File.PackageLoader2.Hotload(Microsoft.VisualBasic.ApplicationServices.IFileSystemEnvironment,SMRUCC.Rsharp.Runtime.GlobalEnvironment,SMRUCC.Rsharp.Development.Package.File.DESCRIPTION@)">
 <summary>
 程序包调试，测试用api
 
 在启动的时候对未进行编译的程序包进行热加载
 </summary>
 <param name="projDir">
 the package source project directory, which is should be un-build...
 for load the package directory which is installed into the R library
 folder, use the method <see cref="M:SMRUCC.Rsharp.Development.Package.File.PackageLoader2.LoadPackage(Microsoft.VisualBasic.ApplicationServices.IFileSystemEnvironment,System.String,System.Boolean,SMRUCC.Rsharp.Runtime.GlobalEnvironment)"/>
 instead.
 </param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="F:SMRUCC.Rsharp.Development.Package.File.PackageLoader2.RsharpHelp">
 <summary>
 "r-sharp-help"
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Development.Package.File.PackageLoader2.LoadPackage(Microsoft.VisualBasic.ApplicationServices.IFileSystemEnvironment,System.String,System.Boolean,SMRUCC.Rsharp.Runtime.GlobalEnvironment)">
 <summary>
 attach installed package
 </summary>
 <param name="dir">the local physical filesystem</param>
 <param name="env"></param>
 <param name="quietly">
 options for mute the package loader banner display
 </param>
</member>
<member name="M:SMRUCC.Rsharp.Development.Package.File.PackageLoader2.loadDependency(SMRUCC.Rsharp.Runtime.PackageEnvironment,SMRUCC.Rsharp.Development.Package.File.PackageNamespace)">
 <summary>
 这个函数会加载通过``imports...from...``语句进行显示加载的依赖程序集
 </summary>
 <param name="env"></param>
 <param name="pkg"></param>
</member>
<member name="M:SMRUCC.Rsharp.Development.Package.File.PackageLoader2.callOnLoad(SMRUCC.Rsharp.Runtime.PackageEnvironment,System.Boolean,SMRUCC.Rsharp.Development.Package.File.PackageNamespace)">
 <summary>
 call package initilization loader function
 </summary>
 <param name="env"></param>
 <param name="pkg"></param>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Development.Package.File.PackageModel.symbols">
 <summary>
 only allows function and constant.
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Development.Package.File.PackageModel.dataSymbols">
 <summary>
 the file names in ``data/`` directory.
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Development.Package.File.PackageModel.clr">
 <summary>
 documents about the clr data types
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Development.Package.File.PackageModel.GetSymbols">
 <summary>
 get all <see cref="T:SMRUCC.Rsharp.Interpreter.ExecuteEngine.SymbolExpression"/> from <see cref="P:SMRUCC.Rsharp.Development.Package.File.PackageModel.symbols"/>
 </summary>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Development.Package.File.PackageModel.Flush(System.IO.Stream,System.Collections.Generic.Dictionary{System.String,System.String},System.Boolean)">
 <summary>
 generate package file from here
 </summary>
 <param name="outfile"></param>
 <param name="assets"></param>
 <remarks>
 generate nuget package format zip archive file.
 </remarks>
</member>
<member name="P:SMRUCC.Rsharp.Development.Package.File.PackageNamespace.libPath">
 <summary>
 the root directory of the package module to load
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Development.Package.File.PackageNamespace.assembly">
 <summary>
 [library.dll => md5]
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Development.Package.File.PackageNamespace.packageName">
 <summary>
 the namespace of the package library
 </summary>
 <returns></returns>
</member>
<member name="P:SMRUCC.Rsharp.Development.Package.File.PackageNamespace.inMemory">
 <summary>
 current package is load from the in-memory stream zip archive?
 </summary>
 <returns>
 return true means from a in-memory zip archive stream, false means
 from local filesystem
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Development.Package.File.PackageNamespace.#ctor(System.String,System.String)">
 <summary>
 create a new package namespace from source development directory
 </summary>
 <param name="pkgName"></param>
 <param name="libpath">the local source directory for the package development</param>
</member>
<member name="M:SMRUCC.Rsharp.Development.Package.File.PackageNamespace.#ctor(Microsoft.VisualBasic.ApplicationServices.IFileSystemEnvironment)">
 <summary>
 Create package namespace model from a local package installation location
 </summary>
 <param name="dir">
 the root directory of the package module to load, or a zip 
 stream filesystem for attach package in memory.
 </param>
</member>
<member name="M:SMRUCC.Rsharp.Development.Package.File.PackageNamespace.Check(Microsoft.VisualBasic.ApplicationServices.IFileSystemEnvironment@,System.String,SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 check of a installed package libdir location
 </summary>
 <param name="dir"></param>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Development.Package.File.PackageNamespace.CheckAssemblyExist(System.String)">
 <summary>
 try to check of the clr assembly file is existed in current package?
 </summary>
 <param name="assemblyName"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Development.Package.File.PackageNamespace.FindAssemblyPath(System.String)">
 <summary>
 try to find the clr assembly file in current library folder
 </summary>
 <param name="assemblyName">the dll assembly name</param>
 <returns>
 this function maybe returns nothing if the required assembly file 
 is not exists in the package directory.
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Development.Package.File.BlockReader.Read(System.IO.BinaryReader)">
 <summary>
 从头开始读文件使用的函数
 </summary>
 <param name="reader"></param>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Development.Package.File.ExpressionTypes">
 <summary>
 The R# expression data type
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Development.Package.File.ExpressionTypes.Literal">
 <summary>
 literal value or constant value
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Development.Package.File.ExpressionTypes.LinqQuery">
 <summary>
 A linq query epxression in R# scripting 
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Development.Package.File.ExpressionTypes.Require">
 <summary>
 expression for require load package 
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Development.Package.File.ExpressionTypes.Shell">
 <summary>
 shell a commandline string
 </summary>
</member>
<member name="T:SMRUCC.Rsharp.Development.Package.File.Writer">
 <summary>
 
 </summary>
 <remarks>
 expression: [ExpressionTypes, i32][dataSize, i32][TypeCodes, byte][expressionData, bytes]
              4                     4              1                ...
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Development.Package.File.Writer.Write(SMRUCC.Rsharp.Interpreter.ExecuteEngine.Expression)">
 <summary>
 将任意R#表达式序列化为字节流
 </summary>
 <param name="x">
 任意一个R#表达式
 </param>
 <returns>
 函数返回表达式的md5哈希值
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Development.Package.File.Writer.GetBuffer(Microsoft.VisualBasic.ApplicationServices.Debugging.Diagnostics.StackFrame)">
 <summary>
 这个函数会将传递进来的sourcemap对象加入到缓存之中
 </summary>
 <param name="sourceMap"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Development.Package.PackageLoader.ParsePackages(System.String,System.Boolean)">
 <summary>
 应该是只会加载静态方法
 </summary>
 <param name="dll">the file full path of the dll package module file</param>
 <param name="strict"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Development.Package.PackageLoader.ParsePackage(System.Type,System.Boolean)">
 <summary>
 这个函数会将包信息缓存下来
 </summary>
 <param name="type"></param>
 <param name="strict"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Development.Package.PackageLoader.ScanDllFiles(System.String,System.Boolean)">
 <summary>
 Scan the given directory and parse package from dll files.
 </summary>
 <param name="directory"></param>
 <param name="strict"></param>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Development.Package.PackageManager">
 <summary>
 这个对象可以枚举出所有已经安装的<see cref="T:SMRUCC.Rsharp.Development.Package.Package"/>对象
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Development.Package.PackageManager.hasLibFile(System.String)">
 <summary>
 Check if the given dll module <paramref name="libraryFileName"/> is exists in database or not.
 </summary>
 <param name="libraryFileName"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Development.Package.PackageManager.hasLibPackage(System.String)">
 <summary>
 check if a required zip package is installed or not?
 </summary>
 <param name="pkgName"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Development.Package.PackageManager.GetPackageDocuments(System.String,System.Boolean)">
 <summary>
 Handling the document reading for the CLR module which
 has been registered inside the local package repository
 </summary>
 <param name="pkgName"></param>
 <param name="remarks">
 get the remarks text?
 </param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Development.Package.PackageManager.FindPackage(System.String,SMRUCC.Rsharp.Runtime.GlobalEnvironment,System.Exception@)">
 <summary>
 Find a dll module package
 </summary>
 <param name="packageName"></param>
 <param name="exception"></param>
 <returns>
 If the package is not exists or load package failure
 then this function returns nothing
 </returns>
</member>
<member name="M:SMRUCC.Rsharp.Development.Package.PackageManager.InstallLocals(System.String,System.Exception@)">
 <summary>
 在调用了这个函数进行包模块的安装之后，需要调用<see cref="M:SMRUCC.Rsharp.Development.Package.PackageManager.Flush"/>函数更新数据库才可以完成安装
 </summary>
 <param name="pkgFile"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Development.Package.PackageManager.InstallLocals(System.IO.Stream,System.Exception@)">
 <summary>
 Install a compiled zip package file
 </summary>
 <param name="zip_stream"></param>
 <param name="err"></param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Development.Package.PackageManager.installZip(System.IO.Stream,System.String,System.Exception@)">
 <summary>
 
 </summary>
 <param name="zipFile">a stream of the package zip file</param>
 <returns>returns the symbol names in target zip package file.</returns>
</member>
<member name="M:SMRUCC.Rsharp.Development.Package.PackageManager.installDll(System.String)">
 <summary>
 
 </summary>
 <param name="dllFile"></param>
 <returns>returns module names in target dll assembly file</returns>
</member>
<member name="M:SMRUCC.Rsharp.Development.Package.PackageManager.Flush">
 <summary>
 将程序包数据库更新到硬盘文件之上
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Development.Package.PackageManager.GenericEnumerator">
 <summary>
 从<see cref="P:SMRUCC.Rsharp.Development.Package.LocalPackageDatabase.assemblies"/>中枚举出所有的<see cref="T:SMRUCC.Rsharp.Development.Package.PackageLoaderEntry"/>
 </summary>
 <returns></returns>
</member>
<member name="T:SMRUCC.Rsharp.Development.Package.zzz">
 <summary>
 R# ``zzz.R`` magic trick
 </summary>
</member>
<member name="M:SMRUCC.Rsharp.Development.Package.zzz.TryRunZzzOnLoad(System.Reflection.Assembly)">
 <summary>
 It's a file where one usually puts actions on load of the package. 
 It is tradition/convention that it's called zzz.R and could be 
 called anything.R
 
 You only need To include this If you want you package To Do something 
 out Of the ordinary When it loads. Keep looking at what people put 
 In there And you'll begin to get a sense of what they're used for.
 </summary>
 <param name="package">
 module named ``zzz`` andalso contains a entry method named ``onLoad``
 </param>
</member>
<member name="T:SMRUCC.Rsharp.Development.Polyglot.Platform">
 <summary>
 polyglot programming
 
 Polyglot programming is the practice of writing code in multiple 
 languages to capture additional functionality and efficiency not 
 available in a single language. The use of domain specific languages
 (DSLs) has become a standard practice for enterprise application
 development. For example, a mobile development team might employ
 Java, JavaScript and HTML5 to create a fully functional application.
 Other DSLs such as SQL (for data queries), XML (embedded configuration)
 and CSS (document formatting) are often built into enterprise 
 applications as well. One developer may be proficient in multiple 
 languages, or a team with varying language skills may work together 
 to perform polyglot programming.

 Polyglot programming Is considered necessary When a Single, 
 general-purpose language cannot offer the desired level Of functionality 
 Or speed, interact properly With the database Or the desired delivery 
 platform, Or meet End user expectations. Proponents Of polyglot 
 programming contend that Using the most effective language For Each 
 aspect Of a program enables faster development, greater comprehension
 For business stakeholders, And a more optimal End product. However,
 integrating a wide variety Of languages into a Single application may
 entail added complexity. Resource consumption may increase In terms
 Of training, testing And maintenance. Polyglot programming may also
 make code difficult To deploy If operations Is Not familiar With the
 same languages used In development.
 </summary>
</member>
<member name="F:SMRUCC.Rsharp.Development.Polyglot.Platform.interop">
 <summary>
 symbols solver for javascript/python reference to R# object
 </summary>
 <remarks>
 use this interop environment for the external function closure
 initialization
 </remarks>
</member>
<member name="M:SMRUCC.Rsharp.Development.Polyglot.Platform.Register(System.String)">
 <summary>
 
 </summary>
 <param name="dllpath">
 dll full path
 </param>
 <returns></returns>
</member>
<member name="M:SMRUCC.Rsharp.Development.RFileSystem.GetPackageDir(SMRUCC.Rsharp.Runtime.Environment)">
 <summary>
 a shortcut wrapper for function <see cref="M:SMRUCC.Rsharp.Development.Package.File.PackageLoader2.GetPackageDirectory(SMRUCC.Rsharp.Development.Configuration.Options,System.String)"/>
 </summary>
 <param name="env"></param>
 <returns></returns>
</member>
<member name="F:SMRUCC.Rsharp.Development.RuntimeError._stackTrace">
 <summary>
 the stack trace of R# script
 </summary>
</member>
</members>
</doc>
