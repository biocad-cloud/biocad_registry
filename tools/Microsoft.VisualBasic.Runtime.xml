<?xml version="1.0"?>
<doc>
<assembly>
<name>
Microsoft.VisualBasic.Runtime
</name>
</assembly>
<members>
<member name="T:Microsoft.VisualBasic.My.Resources.Resources">
<summary>
  A strongly-typed resource class, for looking up localized strings, etc.
</summary>
</member>
<member name="P:Microsoft.VisualBasic.My.Resources.Resources.ResourceManager">
<summary>
  Returns the cached ResourceManager instance used by this class.
</summary>
</member>
<member name="P:Microsoft.VisualBasic.My.Resources.Resources.Culture">
<summary>
  Overrides the current thread's CurrentUICulture property for all
  resource lookups using this strongly typed resource class.
</summary>
</member>
<member name="P:Microsoft.VisualBasic.My.Resources.Resources.bashRunner">
<summary>
  Looks up a localized resource of type System.Byte[].
</summary>
</member>
<member name="P:Microsoft.VisualBasic.My.Resources.Resources.CPOL">
<summary>
  Looks up a localized string similar to ?&lt;html&gt;
&lt;head&gt;
&lt;title&gt;The Code Project Open License (CPOL)&lt;/title&gt;
&lt;Style&gt;
BODY, P, TD { font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 10pt }
H1,H2,H3,H4,H5 { color: #ff9900; font-weight: bold; }
H1 { font-size: 14pt;color:black }
H2 { font-size: 13pt; }
H3 { font-size: 12pt; }
H4 { font-size: 10pt; color: black; }
PRE { BACKGROUND-COLOR: #FBEDBB; FONT-FAMILY: &quot;Courier New&quot;, Courier, mono; WHITE-SPACE: pre; }
CODE { COLOR: #990000; FONT-FAMILY: &quot;Courier New&quot;, Courier, mono; }
.S [rest of string was truncated]&quot;;.
</summary>
</member>
<member name="P:Microsoft.VisualBasic.My.Resources.Resources.gpl">
<summary>
  Looks up a localized string similar to                     GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. &lt;http://fsf.org/&gt;
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to [rest of string was truncated]&quot;;.
</summary>
</member>
<member name="P:Microsoft.VisualBasic.My.Resources.Resources.help">
<summary>
  Looks up a localized resource of type System.Byte[].
</summary>
</member>
<member name="P:Microsoft.VisualBasic.My.Resources.Resources.license">
<summary>
  Looks up a localized string similar to This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU  [rest of string was truncated]&quot;;.
</summary>
</member>
<member name="P:Microsoft.VisualBasic.My.Resources.Resources.List_of_MIME_types___Internet_Media_Types_">
<summary>
  Looks up a localized string similar to Name	MIME Type / Internet Media Type	File Extension	More Details
3D Crossword Plugin	application/vnd.hzn-3d-crossword	.x3d	IANA: 3D Crossword Plugin
3GP	video/3gpp	.3gp	Wikipedia: 3GP
3GP2	video/3gpp2	.3g2	Wikipedia: 3G2
3GPP MSEQ File	application/vnd.mseq	.mseq	IANA: 3GPP MSEQ File
3M Post It Notes	application/vnd.3m.post-it-notes	.pwn	IANA: 3M Post It Notes
3rd Generation Partnership Project - Pic Large	application/vnd.3gpp.pic-bw-large	.plb	3GPP
3rd Generation Partnership Project - Pic Small	appli [rest of string was truncated]&quot;;.
</summary>
</member>
<member name="P:Microsoft.VisualBasic.My.Resources.Resources.runMono">
<summary>
  Looks up a localized resource of type System.Byte[].
</summary>
</member>
<member name="P:Microsoft.VisualBasic.My.Resources.Resources.runNet5">
<summary>
  Looks up a localized resource of type System.Byte[].
</summary>
</member>
<member name="T:Microsoft.VisualBasic.My.File">
 <summary>
 A internal file handler
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.My.File.Close(System.Int32)">
 <summary>
 不存在的文件句柄会在这个函数之中被忽略掉
 </summary>
 <param name="file%"></param>
</member>
<member name="M:Microsoft.VisualBasic.My.File.OpenHandle(System.String,Microsoft.VisualBasic.Text.Encodings)">
 <summary>
 Open a file system handle
 </summary>
 <param name="file"></param>
 <param name="encoding"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.My.File.FileOpened(System.String)">
 <summary>
 Is this file opened
 </summary>
 <param name="filename"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.My.File.Wait(System.String,System.Int64)">
 <summary>
 等待文件句柄的关闭
 </summary>
 <param name="file$"></param>
 <param name="timeout">等待的时间长度，默认为100s，单位为毫秒</param>
 <returns></returns>
</member>
<member name="F:Microsoft.VisualBasic.My.FileFormats.table">
 <summary>
 tsv
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.My.FrameworkInternal.Config.environment">
 <summary>
 整个框架的环境配置项目，请注意，通过命令行进行配置是优先于这个配置文件的配置值的
 可以在命令行中使用``--config-framework``命令来配置默认数据
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.My.FrameworkInternal.DoConfiguration">
 <summary>
 Do configuration
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.My.FrameworkInternal.DoConfiguration.unix_debug_flag">
 <summary>
 --unix
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.My.FrameworkInternal.DoConfiguration.verbose_flag">
 <summary>
 --verbose
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.My.FrameworkInternal.DoConfiguration.#cctor">
 <summary>
 should be vanilla code
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.My.FrameworkInternal.FrameworkConfigAttribute.Name">
 <summary>
 The config name in ``/@set`` or ``config.ini`` file
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.My.FrameworkInternal.IOHandler">
 <summary>
 Collection IO extensions
 </summary>
 <remarks>
 在这个模块之中删除了read函数，因为read是取决于输入的文件的具体格式的，并不是取决于代码的
 所以读取操作无意义
 但是对于write而言，则是可以通过代码来控制具体的输出文件的
 </remarks>
</member>
<member name="T:Microsoft.VisualBasic.My.FrameworkInternal.MemoryLoads">
 <summary>
 config memory usage by the framework
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.My.FrameworkInternal.MemoryLoads.Light">
 <summary>
 lazy load
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.My.FrameworkInternal.MemoryLoads.Heavy">
 <summary>
 load all file data into memory when file size less than 2GB
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.My.FrameworkInternal.MemoryLoads.Max">
 <summary>
 load all data into memory even data file size is greater than 2GB
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.My.FrameworkInternal.NamespaceDoc">
 <summary>
 The sciBASIC.NET framework config module
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.My.InnerQueue">
 <summary>
 Task action Queue for terminal QUEUE SOLVER 🙉
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.My.InnerQueue.InnerThread">
 <summary>
 The internal task queue of the sciBASIC.NET framework
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.My.InnerQueue.AddToQueue(System.Action)">
 <summary>
 添加终端输出的任务到任务队列之中
 </summary>
 <param name="task"></param>
 
</member>
<member name="M:Microsoft.VisualBasic.My.InnerQueue.WaitQueue">
 <summary>
 Wait for all thread queue job done.(Needed if you are using multiThreaded queue)
 </summary>
 
</member>
<member name="F:Microsoft.VisualBasic.My.JavaScript.DataView.BIG_ENDIAN">
 <summary>
 The binary data is present in big endian.
 
 (network byte order)
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.My.JavaScript.DataView.LITTLE_ENDIAN">
 <summary>
 The binary data is present in little endian.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.My.JavaScript.DataView.byteLength">
 <summary>
 the <see cref="P:System.IO.Stream.Length"/>
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.My.JavaScript.ES6.RegExp.ParseOptions(System.String)">
 <summary>
 Parse regexp attribute flags string
 </summary>
 <param name="flags"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.My.JavaScript.IJavaScriptObjectAccessor">
 <summary>
 Interface helper for get value by name
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.My.JavaScript.IJavaScriptObjectAccessor.Accessor(System.String)">
 <summary>
 get member value by name
 </summary>
 <param name="name">
 the member name, could be property name or field name
 </param>
 <returns>
 the object member value
 </returns>
</member>
<member name="F:Microsoft.VisualBasic.My.JavaScript.MemberAccessorResult.Undefined">
 <summary>
 Member is not exists in current javascript object
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.My.JavaScript.MemberAccessorResult.ClassMemberProperty">
 <summary>
 IS a member property in this javascript object
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.My.JavaScript.MemberAccessorResult.ExtensionProperty">
 <summary>
 Is an extension property object this javascript object
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.My.JavaScript.JavaScriptObject">
 <summary>
 javascript object
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.My.JavaScript.JavaScriptObject.this">
 <summary>
 This javascript object instance
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.My.JavaScript.JavaScriptObject.length">
 <summary>
 the size of the member collection in this javascript object
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.My.JavaScript.JavaScriptObject.Item(System.String)">
 <summary>
 只针对Public的属性或者字段有效
 </summary>
 <param name="memberName"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.My.JavaScript.JavaScriptObject.#ctor">
 <summary>
 如果存在无参数的函数，则也会被归类为只读属性？
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.My.JavaScript.JavaScriptObject.GetGenericJSON">
 <summary>
 populate all members data
 </summary>
 <returns>
 Apply for create json in dynamics
 </returns>
 <remarks>
 only works for the object in primitive type
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.My.JavaScript.JavaScriptObject.CreateDynamicObject(System.String[],System.Object[])">
 <summary>
 A wrapper for <see cref="M:Microsoft.VisualBasic.DynamicType.Create(System.Collections.Generic.Dictionary{System.String,System.Object})"/>
 </summary>
 <param name="names"></param>
 <param name="values"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.My.JavaScript.JavaScriptObject.CreateDynamicObject(System.Type,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Object}})">
 <summary>
 Create runtime object and then assign the property value
 </summary>
 <param name="dynamic"></param>
 <param name="values"></param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.My.JavaScript.JavaScriptValue.Accessor">
 <summary>
 A symbol reference to the parent object
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.My.JavaScript.JavaScriptValue.Literal">
 <summary>
 The constant literal value
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.My.JavaScript.JavaScriptValue.IsConstant">
 <summary>
 is scalar constant literal value?
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.My.JavaScript.JavaScriptValue.SetValue(System.Object)">
 <summary>
 proxy of set value to slot or clr object member
 </summary>
 <param name="value"></param>
 <remarks>
 if current value proxy is literal value, then this method just update the 
 slot value, or set member value via the reflection operation.
 </remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.My.JavaScript.JavaScriptValue.CheckLiteral">
 <summary>
 Check of the literal value is primitive value?
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.My.JavaScript.Linq.reduce``2(System.Collections.Generic.IEnumerable{``0},System.Func{``1,``0,System.Int32,``1},``1)">
 <summary>
 
 </summary>
 <typeparam name="T">序列的类型</typeparam>
 <typeparam name="V">序列进行降维之后的结果类型</typeparam>
 <param name="seq"></param>
 <param name="produce"></param>
 <param name="init"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.My.JavaScript.Linq.reduce``2(System.Collections.Generic.IEnumerable{``0},System.Func{``1,``0,System.Int32,``0[],``1},``1)">
 <summary>
 
 </summary>
 <typeparam name="T">序列的类型</typeparam>
 <typeparam name="V">序列进行降维之后的结果类型</typeparam>
 <param name="seq"></param>
 <param name="produce"></param>
 <param name="init"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.My.JavaScript.Linq.reduce``1(System.Array,System.Func{``0,System.Object,System.Int32,``0},``0)">
 <summary>
 
 </summary>
 <typeparam name="V">序列进行降维之后的结果类型</typeparam>
 <param name="seq"></param>
 <param name="produce"></param>
 <param name="init"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.My.JavaScript.Linq.reduce``1(System.Array,System.Func{``0,System.Object,``0},``0)">
 <summary>
 
 </summary>
 <typeparam name="V">序列进行降维之后的结果类型</typeparam>
 <param name="seq"></param>
 <param name="produce"></param>
 <param name="init"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.My.JavaScript.Linq.reduce``2(System.Collections.Generic.IEnumerable{``0},System.Func{``1,``0,``1},``1)">
 <summary>
 
 </summary>
 <typeparam name="T">序列的类型</typeparam>
 <typeparam name="V">序列进行降维之后的结果类型</typeparam>
 <param name="seq"></param>
 <param name="produce"></param>
 <param name="init"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.My.JavaScript.Linq.pop``1(``0[]@)">
 <summary>
 用于删除并返回数组的最后一个元素。
 </summary>
 <typeparam name="T"></typeparam>
 <param name="a"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.My.JavaScript.Linq.shift``1(``0[]@)">
 <summary>
 用于把数组的第一个元素从其中删除，并返回第一个元素的值。
 </summary>
 <typeparam name="T"></typeparam>
 <param name="a"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.My.JavaScript.UnionType`1">
 <summary>
 Union type of the value and its value generator function.
 </summary>
 <typeparam name="T"></typeparam>
</member>
<member name="T:Microsoft.VisualBasic.My.Log4VB">
 <summary>
 VB.NET <see cref="T:System.Console"/> log framework.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.My.Log4VB.logs">
 <summary>
 Additional user log file drivers
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.My.Log4VB.DebuggerTagColors">
 <summary>
 ``<see cref="T:Microsoft.VisualBasic.ApplicationServices.Debugging.Logging.MSG_TYPES"/> -> <see cref="T:System.ConsoleColor"/>``
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.My.Log4VB.redirectWarning">
 <summary>
 LoggingDriver(header$, message$, level As MSG_TYPES)
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.My.Log4VB.redirectError">
 <summary>
 LoggingDriver(header$, message$, level As MSG_TYPES)
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.My.Log4VB.redirectDebug">
 <summary>
 LoggingDriver(header$, message$, level As MSG_TYPES)
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.My.Log4VB.redirectInfo">
 <summary>
 LoggingDriver(header$, message$, level As MSG_TYPES)
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.My.Log4VB.getColor(System.Int32)">
 <summary>
 Translate <see cref="T:Microsoft.VisualBasic.ApplicationServices.Debugging.Logging.MSG_TYPES"/> to <see cref="T:System.ConsoleColor"/>
 </summary>
 <param name="level"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.My.Log4VB.Print(System.String,System.String,System.ConsoleColor,System.Int32)">
 <summary>
 头部和消息字符串都是放在一个task之中进行输出的
 </summary>
 <param name="header"></param>
 <param name="msg"></param>
 <param name="msgColor"></param>
 <param name="level"><see cref="T:System.ConsoleColor"/> or <see cref="T:Microsoft.VisualBasic.ApplicationServices.Debugging.Logging.MSG_TYPES"/></param>
</member>
<member name="M:Microsoft.VisualBasic.My.Log4VB.Print(System.String,System.ConsoleColor,System.ConsoleColor)">
 <summary>
 输出的终端消息带有指定的终端颜色色彩
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.My.Log4VB.Println(System.String,System.ConsoleColor,System.ConsoleColor)">
 <summary>
 输出的终端消息带有指定的终端颜色色彩
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.My.RlangInterop.ProcessingRUniCode(System.String)">
 <summary>
 processing a unicode char like ``&lt;U+767D>`` 
 </summary>
 <param name="output"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.My.RlangInterop.ProcessingRRawUniCode(System.String,Microsoft.VisualBasic.Text.Encodings)">
 <summary>
 processing a unicode char like ``&lt;aa>``
 </summary>
 <param name="output"></param>
 <param name="encoding"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.My.SingletonHolder`1">
 <summary>
 An Interface for the SingletonHolder Class.(存储单体模式的对象实例)
 </summary>
 <typeparam name="T">泛型T必须是含有一个无参数的构造函数的</typeparam>
</member>
<member name="P:Microsoft.VisualBasic.My.SingletonHolder`1.Instance">
 <summary>
 目标类型的唯一单个实例
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.My.UNIX.LinuxRunHelper">
 <summary>
 mono shortcuts
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.My.UNIX.LinuxRunHelper.BashRun">
 <summary>
 Run from bash shell
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.My.UNIX.LinuxRunHelper.BashShell">
 <summary>
 这里比perl脚本掉调用有一个缺点，在运行前还需要使用命令修改为可执行权限
 
 ```
 'sudo chmod 777 cmd.sh'
 ```
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.My.UNIX.LinuxRunHelper.Shell(System.String,System.String,System.Boolean,System.String)">
 <summary>
 Run linux command via ``/bin/bash``
 </summary>
 <param name="command"></param>
 <param name="args"></param>
 <param name="verbose"></param>
 <returns></returns>
 <remarks>
 <see cref="M:Microsoft.VisualBasic.CommandLine.PipelineProcess.Call(Microsoft.VisualBasic.CommandLine.InteropService.InteropService,System.String,System.String,System.Boolean,System.Boolean)"/>
 </remarks>
</member>
<member name="T:Microsoft.VisualBasic.My.UNIX.PathMapper">
 <summary>
 Maps the linux path to the Windows path.(这个模块是将Linux路径映射为Windows路径的)
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.My.UNIX.PathMapper.platform">
 <summary>
 Gets a <see cref="T:System.PlatformID"/> enumeration value that identifies the operating system
 platform.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.My.UNIX.PathMapper.GetMapPath(System.String)">
 <summary>
 Map linux path on Windows:
 
 + [~ -> C:\User\&lt;user_name>]
 + [# -> <see cref="P:Microsoft.VisualBasic.App.HOME"/>]
 + [/ -> C:\]
 + [/usr/bin -> C:\Program Files\]
 + [/usr -> C:\User\]
 + [- -> <see cref="P:Microsoft.VisualBasic.App.PreviousDirectory"/>]
 
 </summary>
 <param name="path"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.My.UNIX.PathMapper.HOME">
 <summary>
 Get user home folder
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.App">
 <summary>
 Provides information about, and means to manipulate, the current environment Application information collection.
 (More easily runtime environment information provider on <see cref="F:System.PlatformID.Unix"/>/LINUX server platform for VisualBasic program.)
 (从命令行之中使用``/@set``参数赋值环境变量的时候，每一个变量之间使用分号进行分隔)
 </summary>

</member>
<member name="P:Microsoft.VisualBasic.App.RunTimeDirectory">
 <summary>
 运行时环境所安装的文件夹的位置
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.App.NanoTime">
 <summary>
 Gets the number of ticks that represent the date and time of this instance.
 
 The number of ticks that represent the date and time of this instance. The value
 is between <see cref="F:System.DateTime.MinValue"/> and <see cref="F:System.DateTime.MaxValue"/>.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.App.EnableTqdm">
 <summary>
 Enable of show tqdm progress bar? default is enable.
 </summary>
 <returns>default is true, get config from ``tqdm`` variable from the runtime framework.</returns>
 <remarks>
 There is a bug about the tqdm progressbar when processing as a slave background process on windows system.
 </remarks>
</member>
<member name="P:Microsoft.VisualBasic.App.CPUCoreNumbers">
 <summary>
 Numbers of the CPU kernels on the current machine.
 </summary>
 <returns></returns>
 <remarks>
 获取当前的系统主机的CPU逻辑核心数，当不开启超线程的时候才是返回物理核心数
 </remarks>
</member>
<member name="P:Microsoft.VisualBasic.App.IsConsoleApp">
 <summary>
 判断当前运行的程序是否为Console类型的应用和程序，由于在执行初始化的时候，
 最先被初始化的是这个模块，所以没有任何代码能够先执行<see cref="P:System.Console.IsErrorRedirected"/>了，
 在这里使用<see cref="P:System.Console.IsErrorRedirected"/>这个来进行判断是可靠的
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.App.Desktop">
 <summary>
 Gets a path name pointing to the Desktop directory.
 </summary>
 <returns>The path to the Desktop directory.</returns>
</member>
<member name="P:Microsoft.VisualBasic.App.StdOut">
 <summary>
 <see cref="M:System.Console.OpenStandardOutput"/> as default text output device. [<see cref="T:System.IO.StreamWriter"/>]
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.App.StdInput">
 <summary>
 <see cref="M:System.Console.OpenStandardInput"/>
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.App.PID">
 <summary>
 Get the <see cref="T:System.Diagnostics.Process"/> id(PID) of the current program process.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.App.Process">
 <summary>
 Gets a new <see cref="T:System.Diagnostics.Process"/> component and associates it with the currently active process.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.App.CommandLine">
 <summary>
 Gets the command-line arguments for this <see cref="P:Microsoft.VisualBasic.App.Process"/>.
 </summary>
 <returns>Gets the command-line arguments for this process.</returns>
</member>
<member name="M:Microsoft.VisualBasic.App.Argument``1(System.String)">
 <summary>
 Get argument value from <see cref="P:Microsoft.VisualBasic.App.CommandLine"/>.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="name$"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.App.Argument(System.String)">
 <summary>
 Get argument value string from <see cref="P:Microsoft.VisualBasic.App.CommandLine"/>.
 </summary>
 <param name="name$"></param>
 <returns></returns>
 
</member>
<member name="P:Microsoft.VisualBasic.App.Command">
 <summary>
 Returns the argument portion of the <see cref="T:Microsoft.VisualBasic.CommandLine.CommandLine"/> used to start Visual Basic or
 an executable program developed with Visual Basic. The My feature provides greater
 productivity and performance than the <see cref="M:Microsoft.VisualBasic.Interaction.Command"/> function. For more information,
 see <see cref="M:Microsoft.VisualBasic.CommandLine.GitBashEnvironment.GetCommandLineArgs"/>.
 </summary>
 <returns>Gets the command-line arguments for this process.</returns>
</member>
<member name="P:Microsoft.VisualBasic.App.ExecutablePath">
 <summary>
 The file path of the current running program executable file.(本应用程序的可执行文件的文件路径)
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.App.Info">
 <summary>
 Get assembly info of current running ``*.exe`` program.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.App.AssemblyName">
 <summary>
 Gets the name, without the extension, of the assembly file for the application.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.App.HOME">
 <summary>
 The program directory of the current running program.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.App.UserHOME">
 <summary>
 Getting the path of the home directory
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.App.InputFile">
 <summary>
 Gets the ``/in`` commandline value as the input file path.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.App.OutFile">
 <summary>
 Gets the ``/out`` commandline value as the output file path.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.App.GetFile(System.String)">
 <summary>
 Found the file path based on the current application context.
 
 1. 直接查找(这个查找已经包含了在当前的文件夹之中查找)
 2. 从<see cref="P:Microsoft.VisualBasic.App.InputFile"/>所在的文件夹之中查找
 3. 从<see cref="P:Microsoft.VisualBasic.App.OutFile"/>所在的文件夹之中查找
 4. 从<see cref="P:Microsoft.VisualBasic.App.HOME"/>文件夹之中查找
 5. 从<see cref="P:Microsoft.VisualBasic.App.UserHOME"/>文件夹之中查找
 6. 从<see cref="P:Microsoft.VisualBasic.App.ProductProgramData"/>文件夹之中查找
 </summary>
 <param name="fileName$"></param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.App.CurrentDirectory">
 <summary>
 The currrent working directory of this application.(应用程序的当前的工作目录)
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.App.PreviousDirectory">
 <summary>
 -
 Linux里面的前一个文件夹
 </summary>
 <remarks>
 假设你之前好不容易进入了一个很深的目录，然后不小心敲了个 ``cd /``，是不是快气晕了啊，不用着急，通过下面的指令可以轻松的回到前一个指令：

 ```bash
 cd -
 ```
 </remarks>
</member>
<member name="P:Microsoft.VisualBasic.App.StartupDirectory">
 <summary>
 Gets the path for the executable file that started the application, not including the executable name.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.App.ProductProgramData">
 <summary>
 The repository root of the product application program data.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.App.ProductSharedDIR">
 <summary>
 The shared program data directory for a group of app which have the same product series name.
 (同一產品程序集所共享的數據文件夾)
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.App.RedirectLogging(System.String)">
 <summary>
 set log file that write text to <paramref name="file"/>
 </summary>
 <param name="file"></param>
 <remarks>
 this method is usefull for debug current process run as a pipeline sub-process
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.App.JoinVariable(System.String,System.String)">
 <summary>
 add/update the environment variable in sciBASIC.NET framework.
 </summary>
 <param name="name">
 if target variable symbol name is exists in the framework, 
 then the config value of the variable will be updated.
 or this function will add a new variable into the 
 environment.
 
 (如果给定的当前这个参数名称存在于当前框架环境中，则会更新原来的值)</param>
 <param name="value"></param>
 <remarks>
 (添加参数到应用程序的环境变量之中)
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.App.JoinVariables(Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedValue{System.String}[])">
 <summary>
 添加参数集合到应用程序的环境变量之中
 </summary>
 <param name="vars"></param>
</member>
<member name="M:Microsoft.VisualBasic.App.GetVariable(System.String,System.String)">
 <summary>
 If the parameter <paramref name="name"/> is ignored, then the value from <see cref="T:System.Runtime.CompilerServices.CallerMemberNameAttribute"/> 
 will be used as variable name.
 (这个函数只是会从设置的变量之中查找，本模块之中的变量请直接从属性进行引用，对于查找失败的变量，这个函数会返回空值
 假若忽略掉<paramref name="name"/>参数的话，则这个函数会使用<see cref="T:System.Runtime.CompilerServices.CallerMemberNameAttribute"/>来获取变量
 的名称)
 </summary>
 <param name="name$">
 因为由于是从命令行之中输入进来的，所以可能有些时候大小写会影响直接字典查找，在这里需要用字符串手工查找
 </param>
 <returns>当没有查找到相对应的环境变量的时候会返回空值</returns>
</member>
<member name="M:Microsoft.VisualBasic.App.GetAppVariables">
 <summary>
 获取<see cref="T:Microsoft.VisualBasic.App"/>的可读属性值来作为环境变量
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.App.BufferSize">
 <summary>
 其他的模块可能也会依赖于这个初始化参数
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.App.SetBufferSize(System.String)">
 <summary>
 Set value of <see cref="P:Microsoft.VisualBasic.App.BufferSize"/>
 </summary>
 <param name="size">
 the size string description, could be:
 
 1. integer value string for set in bytes
 2. number value with unit suffix, example as 64MB, 1GB etc
 </param>
</member>
<member name="M:Microsoft.VisualBasic.App.DoNothing">
 <summary>
 This delegate function do nothing
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.App.DoNothing``1(``0)">
 <summary>
 This delegate function do nothing
 </summary>
 <typeparam name="T"></typeparam>
 <param name="arg">any kind of the parameter type</param>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.App.NullDevice(Microsoft.VisualBasic.Text.Encodings)">
 <summary>
 假若有些时候函数的参数要求有一个输出流，但是并不想输出任何数据的话，则可以使用这个进行输出
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.App.println(System.String,System.Object[])">
 <summary>
 java <see cref="M:Microsoft.VisualBasic.ApplicationServices.Terminal.STDIO.printf(System.String,System.Object[])"/> + <see cref="M:System.Console.WriteLine(System.String)"/>
 </summary>
 <param name="s"></param>
 <param name="args"></param>
</member>
<member name="M:Microsoft.VisualBasic.App.FlushMemory">
 <summary>
 Rabbish collection to free the junk memory.
 </summary>
 <remarks>(垃圾回收)</remarks>

</member>
<member name="M:Microsoft.VisualBasic.App.Free``1(``0@)">
 <summary>
 Free this variable pointer in the memory.
 </summary>
 <typeparam name="T">假若该对象类型实现了<see cref="T:System.IDisposable"></see>接口，则函数还会在销毁前调用该接口的销毁函数</typeparam>
 <param name="obj"></param>
 <remarks>(销毁本对象类型在内存之中的指针)</remarks>
</member>
<member name="M:Microsoft.VisualBasic.App.Pause(System.String)">
 <summary>
 Pause the console program.
 </summary>
 <param name="Prompted"></param>
 <remarks></remarks>

</member>
<member name="M:Microsoft.VisualBasic.App.Stop">
 <summary>
 Pause and then exit the application.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.App.GetProductSharedDIR(System.Type)">
 <summary>
 使用<see cref="P:Microsoft.VisualBasic.App.ProductSharedDIR"/>的位置会变化的，则使用本函数则会使用获取当前的模块的文件夹，即使其不是exe程序而是一个dll文件
 </summary>
 <param name="type"></param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.App.UnixTimeStamp">
 <summary>
 Get current time <see cref="T:System.DateTime"/> in ``xxxxx.xxxx`` unix time stamp format.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.App.StartTime">
 <summary>
 The time tag of the application started.(应用程序的启动的时间)
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.App.ElapsedMilliseconds">
 <summary>
 The distance of time that this application running from start and to current time.
 (当前距离应用程序启动所逝去的时间)
 </summary>
 <returns>ms timespan</returns>
 <remarks>
 通过<see cref="P:Microsoft.VisualBasic.App.UnixTimeStamp"/>以及<see cref="P:Microsoft.VisualBasic.App.StartTime"/>得到的时间都是带小数的秒数
 所以在这里计算出当前时间点与启动时间点之间的差值之后，还需要乘以1000才可以得到毫秒数
 </remarks>
</member>
<member name="P:Microsoft.VisualBasic.App.LocalData">
 <summary>
 The local data dir of the application in the %user%/&lt;CurrentUser>/Local/Product/App
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.App.LocalDataTemp">
 <summary>
 The temp directory in the application local data.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.App.SysTemp">
 <summary>
 The directory path of the system temp data.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.App.AppSystemTemp">
 <summary>
 Application temp data directory in the system temp root: %<see cref="P:Microsoft.VisualBasic.App.SysTemp"/>%/<see cref="P:Microsoft.VisualBasic.App.AssemblyName"/>
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.App.Version">
 <summary>
 Gets the product version associated with this application.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.App.LogException(System.Exception,System.String@)">
 <summary>
 Simply log application exception data into a log file which saves at location: %<see cref="P:Microsoft.VisualBasic.App.LocalData"/>%/.logs/err/.
 (简单日志记录，函数返回空值)
 </summary>
 <param name="ex"></param>
 <param name="trace">调用函数的位置，这个参数一般为空，编译器会自动生成Trace位点参数</param>
 <returns>这个函数总是返回空值的</returns>
 <remarks>
 this debug logging function will returns nothing always!
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.App.TraceBugs(System.Exception,System.String)">
 <summary>
 Function returns the file path of the application log file.
 (函数返回的是日志文件的文件路径)
 </summary>
 <returns></returns>

</member>
<member name="M:Microsoft.VisualBasic.App.FormatTime(System.DateTime,System.String)">
 <summary>
 MySql时间格式： ``yy-mm-dd, 00:00:00``
 </summary>
 <param name="time"></param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.App.IsMicrosoftPlatform">
 <summary>
 Is this application running on a Microsoft OS platform.
 </summary>
 <returns></returns>
 <remarks>
 (是否是运行于微软的操作系统平台？)
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.App.CheckIsMicrosoftPlatform">
 <summary>
 这个主要是判断一个和具体的操作系统平台相关的Win32 API是否能够正常的工作？
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.App.tempCode">
 <summary>
 Example: ``tmp2A10.tmp``
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.App.GetNextUniqueName(System.String)">
 <summary>
 由于可能会运行多个使用本模块的进程，单独考哈希来作为表示会产生冲突，所以这里使用应用程序的启动时间戳以及当前的哈希值来生成唯一标示
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.App.NextTempName">
 <summary>
 是名称，不是文件路径
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.App.LogErrDIR">
 <summary>
 Error default log fie location from function <see cref="M:Microsoft.VisualBasic.App.LogException(System.Exception,System.String@)"/>.
 </summary>
 <returns></returns>
 <remarks>
 (存放自动存储的错误日志的文件夹)
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.App.LogException(System.Exception,System.String,System.String)">
 <summary>
 Simply log application exception data into a log file which saves at a user defined location parameter: <paramref name="FileName"/>.
 (简单日志记录)
 </summary>
 <param name="ex"></param>
 <param name="Trace"></param>
 <param name="FileName"></param>
 <returns></returns>

</member>
<member name="M:Microsoft.VisualBasic.App.LogException(System.String,System.String)">
 <summary>
 This is the custom message of the exception, not extract from the function <see cref="M:System.Exception.ToString"/>
 </summary>
 <param name="exMsg">
 This is the custom message of the exception, not extract from the function <see cref="M:System.Exception.ToString"/>
 </param>
 <param name="trace"></param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.App.Running">
 <summary>
 当前的应用程序是否退出运行了? 当调用<see cref="M:Microsoft.VisualBasic.App.Exit(System.Int32)"/>方法的时候, 除了会终止程序的运行
 还会讲这个属性设置为False
 
 在应用程序框架中, 有一些组件的线程会需要依赖于这个属性值来自动停止运行
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.App.Exit(System.Int32)">
 <summary>
  Terminates this <see cref="T:System.Diagnostics.Process"/> and gives the underlying operating system the specified exit code.
  (这个方法还会终止本应用程序里面的自动GC线程)
 </summary>
 <param name="state">Exit code to be given to the operating system. Use 0 (zero) to indicate that the process completed successfully.</param>

</member>
<member name="M:Microsoft.VisualBasic.App.RunCLI(System.Type,System.String,System.String)">
 <summary>
 Running the <see cref="T:System.String"/> as cli command line and the specific type define as a <see cref="T:Microsoft.VisualBasic.CommandLine.Interpreter"/>.
 (请注意，在调试模式之下，命令行解释器会在运行完命令之后暂停，而Release模式之下则不会。
 假若在调试模式之下发现程序有很长一段时间处于cpu占用为零的静止状态，则很有可能已经运行完命令并且等待回车退出)
 </summary>
 <param name="args">The command line arguments value, which its value can be gets from the <see cref="P:Microsoft.VisualBasic.App.Command"/> function.</param>
 <returns>Returns the function execute result to the operating system.</returns>

</member>
<member name="M:Microsoft.VisualBasic.App.RunCLI(System.Type,Microsoft.VisualBasic.CommandLine.CommandLine,System.String)">
 <summary>
 Running the string as a cli command line, Running the string as cli command line and the specific type define as a interpreter.
 (请注意，在调试模式之下，命令行解释器会在运行完命令之后暂停，而Release模式之下则不会。
 假若在调试模式之下发现程序有很长一段时间处于cpu占用为零的静止状态，则很有可能已经运行完命令并且等待回车退出)
 </summary>
 <param name="args">The command line arguments value, which its value can be gets from the <see cref="P:Microsoft.VisualBasic.App.Command"/> function.</param>
 <returns>Returns the function execute result to the operating system.</returns>

</member>
<member name="M:Microsoft.VisualBasic.App.RunCLI(System.Type,Microsoft.VisualBasic.CommandLine.CommandLine,Microsoft.VisualBasic.CommandLine.ExecuteEmptyCLI,System.String)">
 <summary>
 Running the string as a cli command line.(请注意，在调试模式之下，命令行解释器会在运行完命令之后暂停，而Release模式之下则不会。
 假若在调试模式之下发现程序有很长一段时间处于cpu占用为零的静止状态，则很有可能已经运行完命令并且等待回车退出)
 </summary>
 <param name="args">The command line arguments value, which its value can be gets from the <see cref="P:Microsoft.VisualBasic.App.Command"/> function.</param>
 <returns>Returns the function execute result to the operating system.</returns>

</member>
<member name="M:Microsoft.VisualBasic.App.RunCLI(System.Type,System.String,Microsoft.VisualBasic.CommandLine.ExecuteEmptyCLI,System.String)">
 <summary>
 Running the string as a cli command line.(请注意，在调试模式之下，命令行解释器会在运行完命令之后暂停，而Release模式之下则不会。
 假若在调试模式之下发现程序有很长一段时间处于cpu占用为零的静止状态，则很有可能已经运行完命令并且等待回车退出)
 </summary>
 <param name="args">The command line arguments value, which its value can be gets from the <see cref="P:Microsoft.VisualBasic.App.Command"/> function.</param>
 <returns>Returns the function execute result to the operating system.</returns>

</member>
<member name="M:Microsoft.VisualBasic.App.RunCLI(System.Type,System.String,Microsoft.VisualBasic.CommandLine.ExecuteEmptyCLI,Microsoft.VisualBasic.CommandLine.ExecuteNotFound,System.String)">
 <summary>
 Running the string as a cli command line.(请注意，在调试模式之下，命令行解释器会在运行完命令之后暂停，而Release模式之下则不会。
 假若在调试模式之下发现程序有很长一段时间处于cpu占用为零的静止状态，则很有可能已经运行完命令并且等待回车退出)
 </summary>
 <param name="args">
 The command line arguments value, which its value can be gets from the <see cref="P:Microsoft.VisualBasic.App.Command"/> function.
 </param>
 <param name="executeNotFound">
 ```vbnet
 Public Delegate Function ExecuteNotFound(args As CommandLine) As Integer
 ```
 </param>
 <returns>Returns the function execute result to the operating system.</returns>

</member>
<member name="M:Microsoft.VisualBasic.App.RunCLI(System.Type,Microsoft.VisualBasic.CommandLine.CommandLine,Microsoft.VisualBasic.CommandLine.ExecuteEmptyCLI,Microsoft.VisualBasic.CommandLine.ExecuteFile,Microsoft.VisualBasic.CommandLine.ExecuteNotFound,System.String)">
 <summary>
 Running the string as a cli command line.(请注意，在调试模式之下，命令行解释器会在运行完命令之后暂停，而Release模式之下则不会。
 假若在调试模式之下发现程序有很长一段时间处于cpu占用为零的静止状态，则很有可能已经运行完命令并且等待回车退出)
 </summary>
 <param name="args">
 The command line arguments value, which its value can be gets from the <see cref="P:Microsoft.VisualBasic.App.Command"/> function.
 </param>
 <param name="executeNotFound">
 ```vbnet
 Public Delegate Function ExecuteNotFound(args As <see cref="T:Microsoft.VisualBasic.CommandLine.CommandLine"/>) As <see cref="T:System.Int32"/>
 ```
 </param>
 <returns>Returns the function execute result to the operating system.</returns>

</member>
<member name="M:Microsoft.VisualBasic.App.RunCLI(System.Type,Microsoft.VisualBasic.CommandLine.CommandLine,Microsoft.VisualBasic.CommandLine.ExecuteEmptyCLI,Microsoft.VisualBasic.CommandLine.ExecuteFile,Microsoft.VisualBasic.CommandLine.ExecuteNotFound,Microsoft.VisualBasic.CommandLine.ExecuteQuery,System.String)">
 <summary>
 Running the string as a cli command line.(请注意，在调试模式之下，命令行解释器会在运行完命令之后暂停，而Release模式之下则不会。
 假若在调试模式之下发现程序有很长一段时间处于cpu占用为零的静止状态，则很有可能已经运行完命令并且等待回车退出)
 </summary>
 <param name="args">
 The command line arguments value, which its value can be gets from the <see cref="P:Microsoft.VisualBasic.App.Command"/> function.
 </param>
 <param name="executeNotFound">
 ```vbnet
 Public Delegate Function ExecuteNotFound(args As <see cref="T:Microsoft.VisualBasic.CommandLine.CommandLine"/>) As <see cref="T:System.Int32"/>
 ```
 </param>
 <returns>Returns the function execute result to the operating system.</returns>

</member>
<member name="M:Microsoft.VisualBasic.App.RunCLI(System.Type,Microsoft.VisualBasic.CommandLine.CommandLine,Microsoft.VisualBasic.CommandLine.ExecuteEmptyCLI,Microsoft.VisualBasic.CommandLine.ExecuteNotFound,System.String)">
 <summary>
 Running the string as a cli command line.(请注意，在调试模式之下，命令行解释器会在运行完命令之后暂停，而Release模式之下则不会。
 假若在调试模式之下发现程序有很长一段时间处于cpu占用为零的静止状态，则很有可能已经运行完命令并且等待回车退出)
 </summary>
 <param name="args">
 The command line arguments value, which its value can be gets from the <see cref="P:Microsoft.VisualBasic.App.Command"/> function.
 </param>
 <param name="executeNotFound">
 ```vbnet
 Public Delegate Function ExecuteNotFound(args As <see cref="T:Microsoft.VisualBasic.CommandLine.CommandLine"/>) As <see cref="T:System.Int32"/>
 ```
 </param>
 <returns>Returns the function execute result to the operating system.</returns>

</member>
<member name="M:Microsoft.VisualBasic.App.RunCLI(System.Type,System.String,Microsoft.VisualBasic.CommandLine.ExecuteFile,System.String)">
 <summary>
 Running the string as a cli command line.(请注意，在调试模式之下，命令行解释器会在运行完命令之后暂停，而Release模式之下则不会。
 假若在调试模式之下发现程序有很长一段时间处于cpu占用为零的静止状态，则很有可能已经运行完命令并且等待回车退出)
 </summary>
 <param name="args">The command line arguments value, which its value can be gets from the <see cref="P:Microsoft.VisualBasic.App.Command"/> function.</param>
 <returns>Returns the function execute result to the operating system.</returns>

</member>
<member name="M:Microsoft.VisualBasic.App.RunCLI(System.Type,Microsoft.VisualBasic.CommandLine.CommandLine,Microsoft.VisualBasic.CommandLine.ExecuteFile,System.String)">
 <summary>
 Running the string as a cli command line.(请注意，在调试模式之下，命令行解释器会在运行完命令之后暂停，而Release模式之下则不会。
 假若在调试模式之下发现程序有很长一段时间处于cpu占用为零的静止状态，则很有可能已经运行完命令并且等待回车退出)
 </summary>
 <param name="args">The command line arguments value, which its value can be gets from the <see cref="P:Microsoft.VisualBasic.App.Command"/> function.</param>
 <returns>Returns the function execute result to the operating system.</returns>
 <param name="executeFile">
 函数指针：
 ```vbnet
 Function ExecuteFile(path As <see cref="T:System.String"/>, args As <see cref="P:Microsoft.VisualBasic.App.CommandLine"/>) As <see cref="T:System.Int32"/>
 ```
 </param>
</member>
<member name="M:Microsoft.VisualBasic.App.RunCLI(System.Type,System.String,Microsoft.VisualBasic.CommandLine.ExecuteFile,Microsoft.VisualBasic.CommandLine.ExecuteEmptyCLI,System.String)">
 <summary>
 Running the string as a cli command line.(请注意，在调试模式之下，命令行解释器会在运行完命令之后暂停，而Release模式之下则不会。
 假若在调试模式之下发现程序有很长一段时间处于cpu占用为零的静止状态，则很有可能已经运行完命令并且等待回车退出)
 </summary>
 <param name="args">The command line arguments value, which its value can be gets from the <see cref="P:Microsoft.VisualBasic.App.Command"/> function.</param>
 <returns>Returns the function execute result to the operating system.</returns>

</member>
<member name="M:Microsoft.VisualBasic.App.RunCLI(System.Type,Microsoft.VisualBasic.CommandLine.CommandLine,Microsoft.VisualBasic.CommandLine.ExecuteFile,Microsoft.VisualBasic.CommandLine.ExecuteEmptyCLI,System.String)">
 <summary>
 Running the string as a cli command line.(请注意，在调试模式之下，命令行解释器会在运行完命令之后暂停，而Release模式之下则不会。
 假若在调试模式之下发现程序有很长一段时间处于cpu占用为零的静止状态，则很有可能已经运行完命令并且等待回车退出)
 </summary>
 <param name="args">The command line arguments value, which its value can be gets from the <see cref="P:Microsoft.VisualBasic.App.Command"/> function.</param>
 <param name="executeEmpty">
 this function pointer accepts no parameter.
 </param>
 <returns>Returns the function execute result to the operating system.</returns>

</member>
<member name="M:Microsoft.VisualBasic.App.CLICode(System.Boolean,System.Int32)">
 <summary>
 IF the flag is True, that means cli API execute successfully, function returns ZERO, or a negative integer(Default -100) for failures.
 </summary>
 <param name="b"></param>
 <param name="Failed"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.App.GetTempFile">
 <summary>
 Creates a uniquely named zero-byte temporary file on disk and returns the full
 path of that file.
 </summary>
 <returns></returns>

</member>
<member name="P:Microsoft.VisualBasic.App.CurrentProcessTemp">
 <summary>
 Get temp data directory path of current app process instance
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.App.GetProductSharedTemp">
 <summary>
 Gets a temp file name which is located at directory <see cref="P:Microsoft.VisualBasic.App.ProductSharedDIR"/>.
 (获取位于共享文件夹<see cref="P:Microsoft.VisualBasic.App.ProductSharedDIR"/>里面的临时文件)
 </summary>
 <returns></returns>

</member>
<member name="P:Microsoft.VisualBasic.App.Platform">
 <summary>
 Gets a <see cref="T:System.PlatformID"/> enumeration value that identifies the operating system
 platform.
 </summary>
 <remarks>One of the <see cref="T:System.PlatformID"/> values. this property value may affected 
 by the ``--unix`` commandline debug options when do application startup.</remarks>
</member>
<member name="M:Microsoft.VisualBasic.App.SelfFolk(System.String)">
 <summary>
 Self call this program itself for batch parallel task calculation.
 (调用自身程序，这个通常是应用于批量的数据的计算任务的实现)
 </summary>
 <param name="CLI"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.App.Shell(System.String,System.String,System.Boolean,System.String,System.Boolean,System.Boolean)">
 <summary>
 Folk helper for running the other .NET application.
 (请注意，这个函数只能够运行.NET程序, 假若是在Linux系统之上，还需要安装mono运行时环境)
 </summary>
 <param name="app">External application file full path</param>
 <param name="CLI">Commandline string that running the application <paramref name="app$"/></param>
 <param name="CLR">Is the calling external application is a .NET application?
 (是否为.NET程序?)
 </param>
 <returns></returns>
 <remarks><see cref="T:Microsoft.VisualBasic.CommandLine.IORedirectFile"/>这个建议在进行外部调用的时候才使用</remarks>
</member>
<member name="F:Microsoft.VisualBasic.App.__GCThread">
 <summary>
 自动垃圾回收线程
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.App.AddExitCleanHook(System.Action)">
 <summary>
 这里添加在应用程序退出执行的时候所需要完成的任务
 </summary>
 <param name="hook"></param>
 
</member>
<member name="M:Microsoft.VisualBasic.App.finalizeCLI(System.Int32)">
 <summary>
 自动停止GC当前程序的线程
 </summary>
 <param name="state"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.App.StartGC(System.Boolean)">
 <summary>
 Start the automatic garbage collection threads.
 (这条线程只会自动清理*.tmp临时文件，因为假若不清理临时文件的话，有时候临时文件比较多的时候，会严重影响性能，甚至无法运行应用程序框架里面的IO重定向操作)
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.App.__GCThreadInvoke">
 <summary>
 自动垃圾回收线程
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.App.__removesTEMP(System.String)">
 <summary>
 The Windows file system have a limit of the numbers in a folder, so the long time running application 
 required a thread to make the temp directory cleanup, or the application will no able to create temp 
 file when the temp folder reach its file number upbound(This may caused the application crashed).
 </summary>
 <param name="TEMP"></param>
</member>
<member name="M:Microsoft.VisualBasic.App.StopGC">
 <summary>
 Stop the automatic garbage collection threads.
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.Application">
 <summary>
 Application information
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Application.#cctor">
 <summary>
 try to fix for the winform visual designer error
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Application.StartupPath">
 <summary>
 Gets the path for the executable file that started the application, 
 not including the executable name.
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.Debugging.DebuggerArgs">
 <summary>
 调试器设置参数模块
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Debugging.DebuggerArgs.ErrLogs">
 <summary>
 错误日志的文件存储位置，默认是在AppData里面
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Debugging.DebuggerArgs.SaveErrorLog(System.String)">
 <summary>
 
 </summary>
 <param name="log">日志文本</param>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Debugging.DebuggerArgs.__logShell(Microsoft.VisualBasic.CommandLine.CommandLine)">
 <summary>
 Logging command shell history.
 </summary>
 <param name="args"></param>
</member>
<member name="F:Microsoft.VisualBasic.ApplicationServices.Debugging.DebuggerArgs.DebuggerHelps">
 <summary>
 Some optional VisualBasic debugger parameter help information.(VisualBasic调试器的一些额外的开关参数的帮助信息)
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Debugging.DebuggerArgs.InitDebuggerEnvir(Microsoft.VisualBasic.CommandLine.CommandLine,System.String)">
 <summary>
 Initialize the global environment variables in this App process.
 </summary>
 <param name="args">--echo on/off/all/warn/error --err &lt;path.log></param>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.Debugging.DebuggerLevels">
 <summary>
 默认的参数值是<see cref="F:Microsoft.VisualBasic.ApplicationServices.Debugging.DebuggerLevels.On"/>
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ApplicationServices.Debugging.DebuggerLevels.On">
 <summary>
 是否输出调试信息有程序代码来控制，这个是默认的参数
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ApplicationServices.Debugging.DebuggerLevels.Off">
 <summary>
 不会输出任务调试信息
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ApplicationServices.Debugging.DebuggerLevels.All">
 <summary>
 强制覆盖掉<see cref="F:Microsoft.VisualBasic.ApplicationServices.Debugging.DebuggerLevels.On"/>的设置，输出所有类型的信息
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ApplicationServices.Debugging.DebuggerLevels.Warning">
 <summary>
 只会输出警告或者错误类型的信息
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ApplicationServices.Debugging.DebuggerLevels.Error">
 <summary>
 只会输出错误类型的信息
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Debugging.Diagnostics.ExceptionData.Source">
 <summary>
 the source expression which trigger this error
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Debugging.Diagnostics.ExceptionData.Exception">
 <summary>
 Create exception object for throw exception expression
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Debugging.Diagnostics.ExceptionData.GetCurrentStackTrace">
 <summary>
 Parsing <see cref="P:System.Environment.StackTrace"/>, gets current stack trace information.
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.Debugging.Diagnostics.StackFrame">
 <summary>
 Contains the necessary function calls information, source
 file location information for traceback the runtime error
 </summary>
 
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Debugging.Diagnostics.StackFrame.Method">
 <summary>
 Method call
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Debugging.Diagnostics.StackFrame.File">
 <summary>
 The file path of the source file
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Debugging.Diagnostics.StackFrame.Line">
 <summary>
 The line number in current source <see cref="P:Microsoft.VisualBasic.ApplicationServices.Debugging.Diagnostics.StackFrame.File"/>.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Debugging.Diagnostics.StackFrame.#ctor(Microsoft.VisualBasic.ApplicationServices.Debugging.Diagnostics.StackFrame)">
 <summary>
 make value copy
 </summary>
 <param name="clone"></param>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.Debugging.ExceptionHandler">
 <summary>
 处理错误的工作逻辑的抽象接口
 </summary>
 <param name="ex">Socket的内部错误信息</param>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Debugging.ExceptionExtensions.Fail(System.String,System.String)">
 <summary>
 Just throw exception, but the exception contains more details information for the debugging
 </summary>
 <param name="msg$"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.Debugging.VisualBasicAppException">
 <summary>
 VisualBasic application exception wrapper
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Debugging.VisualBasicAppException.args">
 <summary>
 The CLI arguments string
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Debugging.VisualBasicAppException.Environment">
 <summary>
 The internal App environment variables
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Debugging.VisualBasicAppException.System">
 <summary>
 The system version information
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Debugging.VisualBasicAppException.#ctor(System.Exception,System.String)">
 <summary>
 <see cref="T:System.Exception"/> inner wrapper
 </summary>
 <param name="ex">The exception details</param>
 <param name="calls">Method name where occurs this exception.</param>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.Debugging.HeapSizeOf">
 <summary>
 How to get object size in memory
 </summary>
 <remarks>
 sizeof operator - determine the memory needs for a given type
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Debugging.HeapSizeOf.MeasureSize(System.Object)">
 <summary>
 Find out the size of a .net object
 </summary>
 <param name="obj"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Debugging.HeapSizeOf.StringByteSize(System.String)">
 <summary>
 Returns the actual byte size of current string
 string in VisualBasic.NET is in unicode encoding
 </summary>
 <param name="str"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Debugging.Logging.ErrorLog.BugsFormatter(System.Exception,System.String)">
 <summary>
 Generates the formatted error log file content.(生成简单的日志板块的内容)
 </summary>
 <param name="ex"></param>
 <param name="trace"></param>
 <returns></returns>

</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.Debugging.Logging.LogEntry">
 <summary>
 一条记录日志对象
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Debugging.Logging.LogEntry.ToString">
 <summary>
 生成日志文档之中的一行记录数据
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.Debugging.Logging.LogFile">
 <summary>
 日志文件记录模块。因为在Linux平台上面，Windows的日志记录API可能不会正常工作，
 所以需要这个日志模块来接替Windows的日志模块的工作
 </summary>
 <remarks>
 这个类模块将输入的信息格式化保存到文本文件之中，记录的信息包括信息头，消息文本，以及消息等级
 </remarks>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Debugging.Logging.LogFile.fileName">
 <summary>
 没有路径名称和拓展名，仅包含有单独的文件名
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Debugging.Logging.LogFile.NowTimeNormalizedString">
 <summary>
 将时间字符串里面的":"符号去除之后，剩余的字符串可以用于作为路径来使用
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Debugging.Logging.LogFile.#ctor(System.String,System.Boolean,System.Int32,System.Boolean,System.Boolean,Microsoft.VisualBasic.VBDebugger.LoggingDriver)">
 <summary>
 
 </summary>
 <param name="path">This logfile will saved to.</param>
 <remarks></remarks>
 <param name="bufferSize">当日志的记录数目达到这个数目的时候就会将日志数据写入到文件之中</param>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Debugging.Logging.LogFile.WriteLine(System.String,System.String,Microsoft.VisualBasic.ApplicationServices.Debugging.Logging.MSG_TYPES)">
 <summary>
 向日志文件之中写入数据
 </summary>
 <param name="msg"></param>
 <param name="obj"></param>
 <param name="type"></param>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Debugging.Logging.LogFile.WriteLine(System.String,System.String[])">
 <summary>
 
 </summary>
 <param name="s"></param>
 <param name="args">{[Object] As String, Optional Type As MsgType = MsgType.INF, Optional WriteToScreen As Boolean = True}</param>
 <remarks></remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Debugging.Logging.LogFile.SystemInfo">
 <summary>
 给出用于调试的系统的信息摘要
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Debugging.Logging.LogFile.SaveLog">
 <summary>
 会自动拓展已经存在的日志数据
 </summary>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.Debugging.Logging.LogReader">
 <summary>
 分析服务器的问题原因所需要的日志分析工具
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Debugging.Logging.LogReader.Parse(System.String)">
 <summary>
 a file parser for the document text of <see cref="T:Microsoft.VisualBasic.ApplicationServices.Debugging.Logging.LogFile"/>
 </summary>
 <param name="logFile"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.Debugging.Logging.MSG_TYPES">
 <summary>
 Logging levels, the types enumeration of the log file message.
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.VisualBasic.ApplicationServices.Debugging.Logging.MSG_TYPES.INF">
 <summary>
 The normal information message.[WHITE]
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.VisualBasic.ApplicationServices.Debugging.Logging.MSG_TYPES.ERR">
 <summary>
 The program error information message.[RED]
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.VisualBasic.ApplicationServices.Debugging.Logging.MSG_TYPES.WRN">
 <summary>
 Warnning message from the program.[YELLOW]
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.VisualBasic.ApplicationServices.Debugging.Logging.MSG_TYPES.DEBUG">
 <summary>
 The program debug information message.[BLUE]
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.VisualBasic.ApplicationServices.Debugging.Logging.MSG_TYPES.FINEST">
 <summary>
 Specialized Developer Info
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.DynamicInterop.IDynamicLibraryLoader">
 <summary>
 An interface definition to hide the platform specific aspects of library loading
 </summary>
 <remarks>There are probably projects 'out there' doing this already, but nothing 
 is obvious from a quick search. Re-consider again if you need more features.</remarks>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.DynamicInterop.IDynamicLibraryLoader.LoadLibrary(System.String)">
 <summary>
 Load a native library (DLL on windows, shared libraries on Linux and MacOS)
 </summary>
 <param name="filename">The file name (short file name) of the library to load, e.g. R.dll on Windows</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.DynamicInterop.IDynamicLibraryLoader.GetLastError">
 <summary>
 Gets the last error message from the native API used to load the library.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.DynamicInterop.IDynamicLibraryLoader.FreeLibrary(System.IntPtr)">
 <summary>
 Unloads a library
 </summary>
 <param name="handle">The pointer to the entry point of the library</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.DynamicInterop.IDynamicLibraryLoader.GetFunctionAddress(System.IntPtr,System.String)">
 <summary>
 Gets a pointer to the address of a native function in the specified loaded library
 </summary>
 <param name="hModule">Handle of the module(library)</param>
 <param name="lpProcName">The name of the function sought</param>
 <returns>Handle to the native function</returns>
 <remarks>
 GetProcAddress
 </remarks>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.DynamicInterop.INativeHandle">
 <summary> Interface for native handle.</summary>
 <remarks>This is similar in intent to the BCL SafeHandle, but with release 
          behaviors that are more desirable in particular circumstances.
          </remarks>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.DynamicInterop.INativeHandle.GetHandle">
 <summary> Returns the value of the handle.</summary>

 <returns> The handle.</returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.DynamicInterop.INativeHandle.AddRef">
 <summary>Manually increments the reference counter</summary>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.DynamicInterop.INativeHandle.Release">
 <summary>Manually decrements the reference counter. Triggers disposal if count reaches is zero.</summary>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.DynamicInterop.MarshalExtra">
 <summary> 
 Extra methods on top of System.Runtime.InteropServices.Marshal for allocating unmanaged memory, copying unmanaged
 memory blocks, and converting managed to unmanaged types</summary>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.DynamicInterop.MarshalExtra.AllocHGlobal``1">
 <summary> Allocates memory from the unmanaged memory of the process for a given type</summary>

 <typeparam name="T"> A type that has an equivalent in the unmanaged world e.g. int or a struct Point </typeparam>

 <returns> A pointer to the newly allocated memory. This memory must be released using the FreeHGlobal(IntPtr) method, or related.</returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.DynamicInterop.MarshalExtra.PtrToStructure``1(System.IntPtr,System.Boolean)">
 <summary> Marshals data from an unmanaged block of memory to a newly allocated managed object of the type specified by a generic type parameter. 
           Note it is almost superseded in .NET Framework 4.5.1 and later versions; consider your needs</summary>

 <exception cref="T:System.ArgumentException"> Thrown when one or more arguments have unsupported or
                                      illegal values.</exception>

 <typeparam name="T"> The type of the object to which the data is to be copied. This must be a structure.</typeparam>
 <param name="ptr">   A pointer to an unmanaged block of memory.</param>
 <param name="cleanup"> (Optional) If true, free the native memory block pointed to by ptr. This feature is handy in generated marshalling code.</param>

 <returns> A managed object that contains the data that the ptr parameter points to</returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.DynamicInterop.MarshalExtra.StructureToPtr``1(``0)">
 <summary>Marshals data from a managed object of a specified type to an unmanaged block of memory.
           Note it is almost superseded in .NET Framework 4.5.1 and later versions; consider your needs</summary>

 <typeparam name="T"> The type of the managed object.</typeparam>
 <param name="structure"> A managed object that holds the data to be marshaled. The object must be a structure.</param>

 <returns> A pointer to a newly allocated unmanaged block of memory.</returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.DynamicInterop.MarshalExtra.FreeNativeStruct``1(System.IntPtr,``0@,System.Boolean)">
 <summary> Frees all substructures of a specified type that the specified unmanaged memory block points to.</summary>

 <typeparam name="T"> The type of the managed object.</typeparam>
 <param name="ptr">           A pointer to an unmanaged block of memory.</param>
 <param name="managedObject"> [in,out] The managed object.</param>
 <param name="copy">          (Optional) True to copy.</param>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.DynamicInterop.NativeHandle">
 <summary> A stub implementation for the INativeHandle interface </summary>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.DynamicInterop.NativeHandle.#ctor(System.IntPtr,System.Int32)">
 <summary> Specialised constructor for use only by derived class.</summary>

 <param name="pointer">         The handle, value of the pointer to the native object</param>
 <param name="currentRefCount"> (Optional) Number of pre-existing references for the native object</param>
 <remarks>If a native object was created prior to its use by .NET, its lifetime may need to extend its use 
          from .NET. In practice the scenario is unlikely</remarks>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.DynamicInterop.NativeHandle.#ctor">
 <summary> Specialised default constructor for use only by derived class. 
           Defers setting the handle to the derived class</summary>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.DynamicInterop.NativeHandle.SetHandle(System.IntPtr,System.Int32)">
 <summary> Sets a handle.</summary>

 <exception cref="T:System.ArgumentException"> Thrown when a pointer is a Zero pointer
                                      .</exception>

 <param name="pointer">         The handle, value of the pointer to the native object</param>
 <param name="currentRefCount"> (Optional) Number of pre-existing references for the native object</param>
 <remarks>If a native object was created prior to its use by .NET, its lifetime may need to extend its use 
          from .NET. In practice the scenario is unlikely</remarks>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.DynamicInterop.NativeHandle.Finalize">
 <summary> Finaliser. Triggers the disposal of this object if not manually done.</summary>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.DynamicInterop.NativeHandle.ReleaseHandle">
 <summary> Releases the native resource for this handle.</summary>

 <returns> True if it succeeds, false if it fails.</returns>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.DynamicInterop.NativeHandle.ReferenceCount">
 <summary> 
 Gets the number of references to the native resource for this handle.
 </summary>
 <value> The number of references.</value>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.DynamicInterop.NativeHandle.Disposed">
 <summary> Gets a value indicating whether this handle has been disposed of already</summary>

 <value> True if disposed, false if not.</value>
</member>
<member name="F:Microsoft.VisualBasic.ApplicationServices.DynamicInterop.NativeHandle.handle">
 <summary> The handle to the native resource.</summary>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.DynamicInterop.NativeHandle.IsInvalid">
 <summary> Gets a value indicating whether this handle is invalid.</summary>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.DynamicInterop.NativeHandle.Dispose">
 <summary> If the reference counts allows it, release the resource refered to by this handle.</summary>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.DynamicInterop.NativeHandle.GetHandle">
 <summary> Returns the value of the handle.</summary>

 <returns> The handle.</returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.DynamicInterop.NativeHandle.AddRef">
 <summary> Manually increments the reference counter.</summary>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.DynamicInterop.NativeHandle.Release">
 <summary> Manually decrements the reference counter. Triggers disposal if count reaches is zero.</summary>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.DynamicInterop.PlatformUtility">
 <summary>
 Helper class with functions whose behavior may be depending on the platform 
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.DynamicInterop.PlatformUtility.IsUnix">
 <summary>
 Is the platform unix-like (Unix or MacOX)
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.DynamicInterop.PlatformUtility.GetPlatform">
 <summary>
 Gets the platform on which the current process runs.
 </summary>
 <remarks>
 <see cref="P:System.Environment.OSVersion"/>'s platform is not <see cref="F:System.PlatformID.MacOSX"/> even on Mac OS X.
 This method returns <see cref="F:System.PlatformID.MacOSX"/> when the current process runs on Mac OS X.
 This method uses UNIX's uname command to check the operating system,
 so this method cannot check the OS correctly if the PATH environment variable is changed (will returns <see cref="F:System.PlatformID.Unix"/>).
 </remarks>
 <returns>The current platform.</returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.DynamicInterop.PlatformUtility.ExecCommand(System.String,System.String)">
 <summary>
 Execute a command in a new process
 </summary>
 <param name="processName">Process name e.g. "uname"</param>
 <param name="arguments">Arguments e.g. "-s"</param>
 <returns>The output of the command to the standard output stream</returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.DynamicInterop.PlatformUtility.GetPlatformNotSupportedMsg">
 <summary>
 Gets a message saying the current platform is not supported
 </summary>
 <returns>The platform not supported message.</returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.DynamicInterop.PlatformUtility.FindFullPathEnvVar(System.String,System.String)">
 <summary>
 Given a DLL short file name, find all the matching occurences in directories as stored in an environment variable such as the PATH.
 </summary>
 <returns>One or more full file names found to exist</returns>
 <param name="dllName">short file name.</param>
 <param name="envVarName">Environment variable name - default PATH</param>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.DynamicInterop.PlatformUtility.FindFullPath(System.String,System.String[])">
 <summary>
 Given a DLL short file name, find all the matching occurences in directories.
 </summary>
 <returns>One or more full file names found to exist</returns>
 <param name="dllName">short file name.</param>
 <param name="directories">Directories in which to search for matching file names</param>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.DynamicInterop.PlatformUtility.FindFirstFullPath(System.String,System.String,System.String)">
 <summary> Given a DLL short file name, short or otherwise, searches for the first full path.</summary>

 <exception cref="T:System.DllNotFoundException"> Thrown when a DLL Not Found error condition occurs.</exception>

 <param name="nativeLibFilename"> Filename of the native library file.</param>
 <param name="libname">           (Optional) human-readable name of the library.</param>
 <param name="envVarName">        (Optional)
                                  Environment variable to use for search path(s) - 
                                  defaults according to platform to PATH or LD_LIBRARY_PATH if empty.</param>
 <returns> The found full path.</returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.DynamicInterop.PlatformUtility.CreateLibraryFileName(System.String)">
 <summary> Given the stub name for a library get the likely platform specific file name</summary>

 <exception cref="T:System.ArgumentNullException"> Thrown when one or more required arguments are null.</exception>

 <param name="libraryName"> Name of the library.</param>

 <returns> The likely file name for the shared library.</returns>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.DynamicInterop.SafeHandleUnmanagedDll.LibraryHandle">
 <summary>
 get the library handle which is load via the ``LoadLibrary`` function.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.DynamicInterop.SafeHandleUnmanagedDll.ReleaseHandle">
 <summary>
 Frees the native library this objects represents
 </summary>
 <returns>The result of the call to FreeLibrary</returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.DynamicInterop.SafeHandleUnmanagedDll.Dispose(System.Boolean)">
 <summary>
 Frees the native library this objects represents
 </summary>
 <param name="disposing"></param>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.DynamicInterop.UnixLibraryLoader.GetLastError">
 <summary>
 Gets the last error. NOTE: according to http://tldp.org/HOWTO/Program-Library-HOWTO/dl-libraries.html, returns NULL if called more than once after dlopen.
 </summary>
 <returns>The last error.</returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.DynamicInterop.UnixLibraryLoader.FreeLibrary(System.IntPtr)">
 <summary>
 Unloads a library
 </summary>
 <param name="handle">The pointer resulting from loading the library</param>
 <returns>True if the function dlclose returned 0</returns>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.DynamicInterop.UnmanagedDll">
 <summary>
 A proxy for unmanaged dynamic link library (DLL).
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.DynamicInterop.UnmanagedDll.FileName">
 <summary>
 Gets the Dll file name used for this native Dll wrapper.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.DynamicInterop.UnmanagedDll.LibraryHandle">
 <summary>
 get the library handle which is load via the ``LoadLibrary`` function.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.DynamicInterop.UnmanagedDll.#ctor(System.String,System.Int32)">
 <summary>
 Creates a proxy for the specified dll.
 </summary>
 <param name="dllName">The DLL's name.</param>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.DynamicInterop.UnmanagedDll.CheckHandleInvalid">
 <summary>
 Gets whether the current handle is equal to the invalid handle
 </summary>
 <returns></returns>
 <remarks>
 public override bool IsInvalid
 </remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.DynamicInterop.UnmanagedDll.GetFunction``1">
 <summary>
 Creates the delegate function for the specified function defined in the DLL.
 </summary>
 <typeparam name="TDelegate">The type of delegate. The name of the native 
 function is assumed to be the same as the delegate type name.</typeparam>
 <returns>The delegate.</returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.DynamicInterop.UnmanagedDll.GetFunction``1(System.String)">
 <summary>
 Creates the delegate function for the specified function defined in the DLL.
 </summary>
 <typeparam name="TDelegate">The type of delegate.</typeparam>
 <param name="entryPoint">The name of the function exported by the DLL</param>
 <returns>The delegate.</returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.DynamicInterop.UnmanagedDll.GetFunction(System.String,System.Type)">
 <summary>
 
 </summary>
 <param name="entryPoint"></param>
 <param name="type">
 should be a delegate type
 </param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.DynamicInterop.UnmanagedDll.GetFunctionAddress(System.String)">
 <summary>
 Gets the address of a native function entry point.
 </summary>
 <returns>The function address.</returns>
 <param name="lpProcName">name of the function in the native library</param>
 
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.DynamicInterop.UnmanagedDll.DangerousGetHandle(System.String)">
 <summary>
 Gets the handle of the specified entry.
 </summary>
 <param name="entryPoint">The name of function.</param>
 <returns>The handle.</returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.DynamicInterop.UnmanagedDll.Dispose(System.Boolean)">
 <summary>
 Frees the native library this objects represents
 </summary>
 <param name="disposing"></param>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.DynamicInterop.UnmanagedDll.Dispose">
 <summary>
 Dispose of this library.
 </summary>
 <remarks>Call <see cref="M:Microsoft.VisualBasic.ApplicationServices.DynamicInterop.UnmanagedDll.Dispose"/> when you are finished using the <see cref="T:Microsoft.VisualBasic.ApplicationServices.DynamicInterop.UnmanagedDll"/>. The
 <see cref="M:Microsoft.VisualBasic.ApplicationServices.DynamicInterop.UnmanagedDll.Dispose"/> method leaves the <see cref="T:Microsoft.VisualBasic.ApplicationServices.DynamicInterop.UnmanagedDll"/> in an unusable state.
 After calling <see cref="M:Microsoft.VisualBasic.ApplicationServices.DynamicInterop.UnmanagedDll.Dispose"/>, you must release all references to the
 <see cref="T:Microsoft.VisualBasic.ApplicationServices.DynamicInterop.UnmanagedDll"/> so the garbage collector can reclaim the memory that the
 <see cref="T:Microsoft.VisualBasic.ApplicationServices.DynamicInterop.UnmanagedDll"/> was occupying.</remarks>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.DynamicInterop.UnmanagedDll.WriteInt32(System.String,System.Int32)">
 <summary>
 Writes an int32 value to the address of a symbol in the library. 
 </summary>
 <param name="symbolName">Symbol name.</param>
 <param name="value">Value.</param>
 <remarks>Throws an <exception cref="T:System.ArgumentException">ArgumentException</exception> if the symbol is not exported by the library</remarks>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.DynamicInterop.UnmanagedDll.GetInt32(System.String)">
 <summary>
 Reads an int32 value from the address of a symbol in the library. 
 </summary>
 <returns>The value for this symbol, read as an int32</returns>
 <param name="symbolName">Symbol name.</param>
 <remarks>Throws an <exception cref="T:System.ArgumentException">ArgumentException</exception> if the symbol is not exported by the library</remarks>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.DynamicInterop.UnmanagedDll.WriteInt64(System.String,System.Int64)">
 <summary>
 Writes an int64 value to the address of a symbol in the library. 
 </summary>
 <param name="symbolName">Symbol name.</param>
 <param name="value">Value.</param>
 <remarks>Throws an <exception cref="T:System.ArgumentException">ArgumentException</exception> if the symbol is not exported by the library</remarks>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.DynamicInterop.UnmanagedDll.GetInt64(System.String)">
 <summary>
 Reads an int64 value from the address of a symbol in the library. 
 </summary>
 <returns>The value for this symbol, read as an int64</returns>
 <param name="symbolName">Symbol name.</param>
 <remarks>Throws an <exception cref="T:System.ArgumentException">ArgumentException</exception> if the symbol is not exported by the library</remarks>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.DynamicInterop.UnmanagedDll.WriteIntPtr(System.String,System.IntPtr)">
 <summary>
 Writes an IntPtr value to the address of a symbol in the library. 
 </summary>
 <param name="symbolName">Symbol name.</param>
 <param name="value">Value.</param>
 <remarks>Throws an <exception cref="T:System.ArgumentException">ArgumentException</exception> if the symbol is not exported by the library</remarks>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.DynamicInterop.UnmanagedDll.GetIntPtr(System.String)">
 <summary>
 Reads an IntPtr value from the address of a symbol in the library. 
 </summary>
 <returns>The value for this symbol, read as an IntPtr</returns>
 <param name="symbolName">Symbol name.</param>
 <remarks>Throws an <exception cref="T:System.ArgumentException">ArgumentException</exception> if the symbol is not exported by the library</remarks>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.DynamicInterop.UnmanagedDll.WriteByte(System.String,System.Byte)">
 <summary>
 Writes a Byte value to the address of a symbol in the library. 
 </summary>
 <param name="symbolName">Symbol name.</param>
 <param name="value">Value.</param>
 <remarks>Throws an <exception cref="T:System.ArgumentException">ArgumentException</exception> if the symbol is not exported by the library</remarks>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.DynamicInterop.UnmanagedDll.GetByte(System.String)">
 <summary>
 Reads a byte value from the address of a symbol in the library. 
 </summary>
 <returns>The value for this symbol, read as a byte</returns>
 <param name="symbolName">Symbol name.</param>
 <remarks>Throws an <exception cref="T:System.ArgumentException">ArgumentException</exception> if the symbol is not exported by the library</remarks>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.DynamicInterop.UnmanagedDll.GetAnsiString(System.String)">
 <summary>
 Reads a string value from the address of a symbol in the library. 
 </summary>
 <returns>The value for this symbol, read as an ANSI string</returns>
 <param name="symbolName">Symbol name.</param>
 <remarks>Throws an <exception cref="T:System.ArgumentException">ArgumentException</exception> if the symbol is not exported by the library</remarks>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.DynamicInterop.WindowsLibraryLoader.GetFunctionAddress(System.IntPtr,System.String)">
 <summary>
 GetProcAddress
 </summary>
 <param name="hModule"></param>
 <param name="lpProcName"></param>
 <returns></returns>
</member>
<member name="F:Microsoft.VisualBasic.ApplicationServices.DynamicInterop.Win32.MaxPathLength">
 <summary>
 MaxPath is 248. 
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.FileSystemTree">
 <summary>
 A virtual filesystem tree
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.FileSystemTree.Name">
 <summary>
 the filename/folder name of this filesystem tree node
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.FileSystemTree.Parent">
 <summary>
 the parent folder
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.FileSystemTree.data">
 <summary>
 the tagged data that associated with this file node
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.FileSystemTree.FullName">
 <summary>
 absolute full path
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.FileSystemTree.GetFile(System.String)">
 <summary>
 Get a node by its key name in current tree node
 </summary>
 <param name="name">the file node name in current tree node</param>
 <returns>
 returns nothing if the file with given <paramref name="name"/> was could not be found
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.FileSystemTree.AddFile(System.String)">
 <summary>
 add a new filesystem node and then returns the new node object.
 </summary>
 <param name="name"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.FileSystemTree.ToString">
 <summary>
 absolute full path
 </summary>
 <returns>the value of <see cref="P:Microsoft.VisualBasic.ApplicationServices.FileSystemTree.FullName"/> property data</returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.FileSystemTree.GetFile(Microsoft.VisualBasic.ApplicationServices.FileSystemTree,System.String)">
 <summary>
 common shared method for get node by path
 </summary>
 <param name="fs"></param>
 <param name="path"></param>
 <returns>
 this function returns nothing if the <paramref name="path"/> not found.
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.FileSystemTree.DeleteFile(Microsoft.VisualBasic.ApplicationServices.FileSystemTree,System.String)">
 <summary>
 
 </summary>
 <param name="fs"></param>
 <param name="path"></param>
 <returns>
 this function returns nothing if the required node has not been found, and returns the node which has been deleted.
 </returns>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.IFileSystemEnvironment">
 <summary>
 an abstract interface for union filesystem:
 
 1. local filesystem: <see cref="T:Microsoft.VisualBasic.FileIO.Directory"/>
 2. zip archive: <see cref="T:Microsoft.VisualBasic.ApplicationServices.Zip.ZipStream"/>
 3. HDS streampack filesystem
 
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.IFileSystemEnvironment.readonly">
 <summary>
 the file system environment is readonly?
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.IFileSystemEnvironment.OpenFile(System.String,System.IO.FileMode,System.IO.FileAccess)">
 <summary>
 open a specific file for read and write
 </summary>
 <param name="path"></param>
 <param name="mode"></param>
 <param name="access"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.IFileSystemEnvironment.DeleteFile(System.String)">
 <summary>
 delete target file which is specific by path
 </summary>
 <param name="path"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.IFileSystemEnvironment.FileExists(System.String,System.Boolean)">
 <summary>
 check the specific file is exists on current filesystem or not?
 </summary>
 <param name="path"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.IFileSystemEnvironment.FileSize(System.String)">
 <summary>
 get file size
 </summary>
 <param name="path"></param>
 <returns>-1 means file is not exists on the filesystem</returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.IFileSystemEnvironment.FileModifyTime(System.String)">
 <summary>
 get file modified time, usually for the cache expired test
 </summary>
 <param name="path"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.IFileSystemEnvironment.GetFullPath(System.String)">
 <summary>
 get the full path of the given file name in current directory model
 </summary>
 <param name="filename"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.IFileSystemEnvironment.WriteText(System.String,System.String)">
 <summary>
 write text content to a specific file
 </summary>
 <param name="text"></param>
 <param name="path"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.IFileSystemEnvironment.GetFiles">
 <summary>
 get all files inside current filesystem object
 </summary>
 <returns></returns>
 <remarks>
 be careful when running this on local filesystem object!
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.IFileSystemEnvironment.GetFiles(System.String,System.String[])">
 <summary>
 get all files inside a specific subfolder recursivly
 </summary>
 <param name="subdir">relative path of the subfolder in current workspace</param>
 <param name="exts">file extension type wildcard filters for the files, default is ``*.*``</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.IFileSystemEnvironment.EnumerateFiles(System.String,System.String[])">
 <summary>
 get all files inside a specific subfolder, not recursivly
 </summary>
 <param name="subdir">relative path of the subfolder in current workspace</param>
 <param name="exts">file extension type wildcard filters for the files, default is ``*.*``</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.IFileSystemEnvironment.Close">
 <summary>
 close current filesystem session
 </summary>
 <remarks>
 apply for the zip archive/HDS streampack
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.IFileSystemEnvironment.Flush">
 <summary>
 save stream data
 </summary>
 <remarks>
 apply for the zip archive/HDS streampack
 </remarks>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.IWorkspace">
 <summary>
 A abstract reference to a workdir
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.IWorkspace.Workspace">
 <summary>
 the workdir path of current workspace object
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.FileSystemView">
 <summary>
 A data view wrapper that used a specific subdir as workfolder
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.FileSystemView.#ctor(Microsoft.VisualBasic.ApplicationServices.IFileSystemEnvironment,System.String)">
 <summary>
 
 </summary>
 <param name="fs">the root workspace model</param>
 <param name="subdir">a specific sub-dir for create a wrapper view of the workspace</param>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.MemoryStreamPool">
 <summary>
 
 </summary>
 <remarks>
 just recommended apply this object for fast binary data read
 </remarks>
</member>
<member name="F:Microsoft.VisualBasic.ApplicationServices.MemoryStreamPool.buffer_size">
 <summary>
 size of each stream object in pool
 </summary>
 <remarks>
 20221101 data type should be int64, or math overflow 
 maybe happends if the offset value is greater than 
 2GB.
 </remarks>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.MemoryStreamPool.Length">
 <summary>
 the total size in bytes of the stream pool
 </summary>
 <returns></returns>
</member>
<member name="F:Microsoft.VisualBasic.ApplicationServices.MemoryStreamPool.block">
 <summary>
 the block index of <see cref="F:Microsoft.VisualBasic.ApplicationServices.MemoryStreamPool.pool"/>.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.MemoryStreamPool.FromFile(System.String,System.Int32)">
 <summary>
 
 </summary>
 <param name="path"></param>
 <param name="buffer_size">
 default buffer size is 1GB
 </param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.ProgramPathSearchTool">
 <summary>
 Program helper for search dir like ``C:\Program Files`` or ``C:\Program Files(x86)``
 </summary>
 <remarks>
 Works on windows, have not test on Linux/Mac yet.
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.ProgramPathSearchTool.#ctor(System.String[])">
 <summary>
 
 </summary>
 <param name="ENV$">
 环境变量名称列表，如果不赋值这个参数，则会默认使用Program Files和Program Files(x86)这两个文件夹
 </param>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.ProgramPathSearchTool.FindProgram(System.String,System.Boolean)">
 <summary>
 
 </summary>
 <param name="keyword$">常规的文件名称之类的，不可以包含有通配符</param>
 <param name="includeDll"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.ProgramPathSearchTool.BranchRule(System.String,System.String)">
 <summary>
 商标搜索规则
 </summary>
 <param name="ProgramFiles"></param>
 <param name="Keyword"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.ProgramPathSearchTool.SearchScriptFile(System.String,System.String,System.String)">
 <summary>
 Search for the path of a script file with a specific extension name.
 </summary>
 <param name="DIR"></param>
 <param name="Keyword"></param>
 <param name="withExtension">脚本文件的文件拓展名</param>
 <returns></returns>
 <remarks></remarks>

</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.ProgramPathSearchTool.SearchDirectory(System.String,System.String)">
 <summary>
 Search for the directories which its name was matched the keyword pattern.
 </summary>
 <param name="SpecificDrive">所指定进行搜索的驱动器，假若希望搜索整个硬盘，请留空字符串</param>
 <returns></returns>
 <remarks></remarks>

</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.ProgramPathSearchTool.SearchProgram(System.String,System.String,System.Boolean)">
 <summary>
 Invoke the search session for the program file using a specific keyword string value.
 (使用某个关键词来搜索目标应用程序)
 </summary>
 <param name="DIR"></param>
 <param name="Keyword"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="F:Microsoft.VisualBasic.ApplicationServices.SubStream.offset">
 <summary>
 [scan0] the position offset in the base stream, base address of this substream 
 object in base stream object <see cref="F:Microsoft.VisualBasic.ApplicationServices.SubStream.s"/>
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ApplicationServices.SubStream.m_position">
 <summary>
 the position offset in the base stream
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.SubStream.#ctor(System.IO.Stream,System.Int64,System.Int64)">
 <summary>
 Construct a new stream data view window
 </summary>
 <param name="s"></param>
 <param name="offset"></param>
 <param name="length"></param>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.SubStream.Flush">
 <summary>
 commit data to the base stream
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.SubStream.SetLength(System.Int64)">
 <inheritdoc />
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.TempFileSystem">
 <summary>
 return name and handle of a temporary file safely
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.TempFileSystem.GetAppSysTempFile(System.String,System.String,System.String)">
 <summary>
 Get temp file name in app system temp directory.
 </summary>
 <param name="ext"></param>
 <param name="sessionID">It is recommended that use <see cref="P:Microsoft.VisualBasic.App.PID"/> for this parameter.</param>
 <returns></returns>

</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.TempFileSystem.GenerateTemp(System.String,System.String)">
 <summary>
 create temp file path
 </summary>
 <param name="sysTemp">临时文件路径</param>
 <returns></returns>

</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.TempFileSystem.__sysTEMP">
 <summary>
 <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetParentPath(System.String)"/>(<see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetTempFileName"/>)
 当临时文件夹被删除掉了的时候，会出现崩溃。。。。所以弃用改用读取环境变量
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Globalization.LanguageAttribute.#ctor(System.Int32,System.String,System.Type)">
 <summary>
 
 </summary>
 <param name="Language">The language of the target object.</param>
 <param name="Context"></param>
 <param name="langEnum">This type define should be a enum type.</param>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.Globalization.LanguageHelper`1">
 <summary>
 
 </summary>
 <typeparam name="TLanguage">必须是枚举类型</typeparam>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Globalization.LanguageHelper`1.Text(`0,System.String)">
 <summary>
 Get the string that store as specific language.
 (获取指定语言的字符串)
 </summary>
 <param name="Language">字符串的语言</param>
 <value></value>
 <param name="res">请使用 NameOf 操作符来获取</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Globalization.LanguageHelper`1.#ctor(System.Type)">
 <summary>
 解析出所有属性，域上面的语言定义
 </summary>
 <param name="type">必须是模块类型或者属性或者域是共享类型的</param>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Globalization.LanguageHelper`1.__init(System.Collections.Generic.IEnumerable{System.Reflection.MemberInfo})">
 <summary>
 
 </summary>
 <param name="members"></param>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Globalization.StringResources`1.Default">
 <summary>
 从属性或者域上面解析出来的默认的语言值
 </summary>
 <returns></returns>
</member>
<member name="F:Microsoft.VisualBasic.ApplicationServices.Terminal.HistoryStacks.p">
 <summary>
 指向<see cref="F:Microsoft.VisualBasic.ApplicationServices.Terminal.HistoryStacks._historyList"></see>
 </summary>
 <remarks></remarks>
</member>
<member name="E:Microsoft.VisualBasic.ApplicationServices.Terminal.InteractiveDevice.NewOutputMessage">
 <summary>
 
 </summary>
 <param name="s"></param>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.InteractiveDevice.#ctor(System.String)">
 <summary>
 
 </summary>
 <param name="HistoryFile">历史数据文件的存放位置，假若为空，则使用默认文件路径</param>
 <remarks></remarks>
</member>
<member name="F:Microsoft.VisualBasic.ApplicationServices.Terminal.InteractiveDevice.HistoryCallerStack">
 <summary>
 ReadLine函数的递归返回值
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.InteractiveDevice.Save(System.String,System.Text.Encoding)">
 <summary>
 保存历史数据
 </summary>
 <param name="Path"></param>
 <param name="encoding"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.Terminal.LineEdit.Completion">
 <summary>
 Completion results returned by the completion handler.
 </summary>
 <remarks>
 You create an instance of this class to return the completion
 results for the text at the specific position.   The prefix parameter
 indicates the common prefix in the results, and the results contain the
 results without the prefix.   For example, when completing "ToString" and "ToDate"
 prefix would be "To" and the completions would be "String" and "Date".
 </remarks>
</member>
<member name="F:Microsoft.VisualBasic.ApplicationServices.Terminal.LineEdit.Completion.Result">
 <summary>
 Array of results, with the stem removed.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ApplicationServices.Terminal.LineEdit.Completion.Prefix">
 <summary>
 Shared prefix for the completion results.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.LineEdit.Completion.#ctor(System.String,System.String[])">
 <summary>
 Initializes a new instance of the <see cref="T:Microsoft.VisualBasic.ApplicationServices.Terminal.LineEdit.Completion"/> class.
 </summary>
 <param name="prefix">Common prefix for all results, an be null.</param>
 <param name="result">Array of possible completions.</param>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.Terminal.LineEdit.LineEditor">
 <summary>
 Interactive line editor.
 </summary>
 <remarks>
 Interactive line editor.
 
 > https://github.com/mono/LineEditor
 
   <para>
     LineEditor is an interative line editor for .NET applications that provides
     editing capabilities for an input line with common editing capabilities and
     navigation expected in modern application as well as history, incremental
     search over the history, completion (both textual or visual) and various 
     Emacs-like commands.
   </para>
   <para>
     When you create your line editor, you can pass the name of your application, 
     which will be used to load and save the history of commands entered by the user
     for this particular application.    
   </para>
   <para>
     
   </para>
   <example>
     The following example shows how you can instantiate a line editor that
     can provide code completion for some words when the user presses TAB
     and how the user can edit them. 
     <code>
 LineEditor le = new LineEditor ("myshell") { HeuristicsMode = "csharp" };
 le.AutoCompleteEvent += delegate (string line, int point){
     string prefix = "";
     var completions = new string [] { 
         "One", "Two", "Three", "Four", "Five", 
          "Six", "Seven", "Eight", "Nine", "Ten" 
     };
     return new Mono.Terminal.LineEditor.Completion(prefix, completions);
 };
 		
 string s;
 		
 while ((s = le.Edit("shell> ", "")) != null)
    Console.WriteLine("You typed: [{0}]", s);			}
     </code>
   </example>
   <para>
      Users can use the cursor keys to navigate both the text on the current
      line, or move back and forward through the history of commands that have
      been entered.   
   </para>
   <para>
     The interactive commands and keybindings are inspired by the GNU bash and
     GNU readline capabilities and follow the same concepts found there.
   </para>
   <para>
      Copy and pasting works like bash, deleted words or regions are added to 
      the kill buffer.   Repeated invocations of the same deleting operation will
      append to the kill buffer (for example, repeatedly deleting words) and to
      paste the results you would use the Control-y command (yank).
   </para>
   <para>
      The history search capability is triggered when you press 
      Control-r to start a reverse interactive-search
      and start typing the text you are looking for, the edited line will
      be updated with matches.  Typing control-r again will go to the next
      match in history and so on.
   </para>
   <list type="table"> 
     <listheader>
       <term>Shortcut</term>
       <description>Action performed</description>
     </listheader>
     <item>
        <term>Left cursor, Control-b</term>
        <description>
          Moves the editing point left.
        </description>
     </item>
     <item>
        <term>Right cursor, Control-f</term>
        <description>
          Moves the editing point right.
        </description>
     </item>
     <item>
        <term>Alt-b</term>
        <description>
          Moves one word back.
        </description>
     </item>
     <item>
        <term>Alt-f</term>
        <description>
          Moves one word forward.
        </description>
     </item>
     <item>
        <term>Up cursor, Control-p</term>
        <description>
          Selects the previous item in the editing history.
        </description>
     </item>
     <item>
        <term>Down cursor, Control-n</term>
        <description>
          Selects the next item in the editing history.
        </description>
     </item>
     <item>
        <term>Home key, Control-a</term>
        <description>
          Moves the cursor to the beginning of the line.
        </description>
     </item>
     <item>
        <term>End key, Control-e</term>
        <description>
          Moves the cursor to the end of the line.
        </description>
     </item>
     <item>
        <term>Delete, Control-d</term>
        <description>
          Deletes the character in front of the cursor.
        </description>
     </item>
     <item>
        <term>Backspace</term>
        <description>
          Deletes the character behind the cursor.
        </description>
     </item>
     <item>
        <term>Tab</term>
        <description>
           Triggers the completion and invokes the AutoCompleteEvent which gets
           both the line contents and the position where the cursor is.
        </description>
     </item>
     <item>
        <term>Control-k</term>
        <description>
          Deletes the text until the end of the line and replaces the kill buffer
          with the deleted text.   You can paste this text in a different place by
          using Control-y.
        </description>
     </item>
     <item>
        <term>Control-l refresh</term>
        <description>
           Clears the screen and forces a refresh of the line editor, useful when
           a background process writes to the console and garbles the contents of
           the screen.
        </description>
     </item>
     <item>
        <term>Control-r</term>
        <description>
          Initiates the reverse search in history.
        </description>
     </item>
     <item>
        <term>Alt-backspace</term>
        <description>
           Deletes the word behind the cursor and adds it to the kill ring.  You 
           can paste the contents of the kill ring with Control-y.
        </description>
     </item>
     <item>
        <term>Alt-d</term>
        <description>
           Deletes the word above the cursor and adds it to the kill ring.  You 
           can paste the contents of the kill ring with Control-y.
        </description>
     </item>
     <item>
        <term>Control-y</term>
        <description>
           Pastes the content of the kill ring into the current position.
        </description>
     </item>
     <item>
        <term>Control-q</term>
        <description>
          Quotes the next input character, to prevent the normal processing of
          key handling to take place.
        </description>
     </item>
   </list>
 </remarks>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Terminal.LineEdit.LineEditor.HeuristicsMode">
 <summary>
 The heuristics mode used by code completion.
 </summary>
 <remarks>
    <para>
      This controls the heuristics style used to show the code
      completion popup as well as when to accept an entry.
    </para>
    <para>
      The default value is null which requires the user to explicitly
      use the TAB key to trigger a completion.    
    </para>
    <para>
      Another possible value is "csharp" which will trigger auto-completion when a 
      "." is entered.
    </para>
 </remarks>
</member>
<member name="F:Microsoft.VisualBasic.ApplicationServices.Terminal.LineEdit.LineEditor.prompt">
 <summary>
 The prompt specified, and the prompt shown to the user.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ApplicationServices.Terminal.LineEdit.LineEditor.max_rendered">
 <summary>
 The maximum length that has been displayed on the screen
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ApplicationServices.Terminal.LineEdit.LineEditor.AutoCompleteEvent">
 <summary>
   Invoked when the user requests auto-completion using the tab character
 </summary>
 <remarks>
    The result is null for no values found, an array with a single
    string, in that case the string should be the text to be inserted
    for example if the word at pos is "T", the result for a completion
    of "ToString" should be "oString", not "ToString".

    When there are multiple results, the result should be the full
    text
 </remarks>
</member>
<member name="F:Microsoft.VisualBasic.ApplicationServices.Terminal.LineEdit.LineEditor.MaxWidth">
 <summary>
 max width of the auto-complete form window width in chars
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.LineEdit.LineEditor.#ctor(System.String)">
 <summary>
 Initializes a new instance of the LineEditor, using the specified name for 
 retrieving and storing the history.   The history will default to 10 entries.
 </summary>
 <param name="name">Prefix for storing the editing history.</param>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.LineEdit.LineEditor.#ctor(System.String,System.Int32)">
 <summary>
 Initializes a new instance of the LineEditor, using the specified name for 
 retrieving and storing the history.   
 </summary>
 <param name="name">Prefix for storing the editing history.</param>
 <param name="histsize">Number of entries to store in the history file.</param>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.LineEdit.LineEditor.Edit(System.String,System.String)">
 <summary>
 Edit a line, and provides both a prompt and the initial contents to edit
 </summary>
 <returns>The edit.</returns>
 <param name="prompt">Prompt shown to edit the line.</param>
 <param name="initial">Initial contents, can be null.</param>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.LineEdit.LineEditor.SaveHistory">
 <summary>
 Triggers the history to be written at this point, usually not necessary, history is saved on each line edited.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Terminal.LineEdit.LineEditor.TabAtStartCompletes">
 <summary>
 Gets or sets a value indicating whether hitting the TAB key before any text exists triggers completion or inserts a "tab" character into the buffer.  This is useful to allow users to copy/paste code that might contain whitespace at the start and you want to preserve it.
 </summary>
 <value><c>true</c> if tab at start completes; otherwise, <c>false</c>.</value>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.Terminal.LineEdit.HistoryType">
 <summary>
 Emulates the bash-like behavior, where edits done to the
 history are recorded
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.Terminal.Shell">
 <summary>
 Shell model for console.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Terminal.Shell.shell">
 <summary>
 engine for execute the command, example as execute script text in ``R#``.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Terminal.Shell.Quite">
 <summary>
 Command text for exit the shell loop 
 
 (默认的退出文本为vim的 ``:q`` 命令)
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.Shell.#ctor(Microsoft.VisualBasic.Language.UnixBash.PS1,System.Action{System.String},Microsoft.VisualBasic.ApplicationServices.Terminal.IShellDevice)">
 <summary>
 
 </summary>
 <param name="ps1">The commandline prompt prefix headers.</param>
 <param name="exec">How to execute the command line input.</param>
 <param name="dev">
 <see cref="T:Microsoft.VisualBasic.ApplicationServices.Terminal.LineEdit.LineReader"/>
 </param>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.Shell.Run">
 <summary>
 执行一个配置好的命令行模型, 代码会被一直阻塞在这里
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.Terminal.Terminal">
 <summary>
 Represents the standard input, output, and error streams for console applications. 
 (交互式的命令行终端)
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.Terminal.Clear">
 <summary>
 Clears the console buffer and corresponding console window of display information.
 </summary>
 <remarks></remarks>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.Terminal.ResetColor">
 <summary>
 Sets the foreground and background console colors to their defaults.
 </summary>
 <remarks></remarks>
 <exception cref="T:System.Security.SecurityException">The user does not have permission to perform this action.</exception>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.Terminal.SetCursorPosition(System.Int32,System.Int32)">
 <summary>
 Sets the position of the cursor.
 </summary>
 <param name="left">The column position of the cursor.</param>
 <param name="top">The row position of the cursor.</param>
 <remarks></remarks>
 <exception cref="T:System.ArgumentOutOfRangeException">left or top is less than zero.-or- left is greater than or equal to System.Console.BufferWidth.-or- top is greater than or equal to System.Console.BufferHeight.</exception>
 <exception cref="T:System.Security.SecurityException">The user does not have permission to perform this action.</exception>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.Terminal.SetError(System.IO.TextWriter)">
 <summary>
 Sets the System.Console.Error property to the specified System.IO.TextWriter object.
 </summary>
 <param name="newError">A stream that is the new standard error output.</param>
 <remarks></remarks>
 <exception cref="T:System.ArgumentNullException">newError is null.</exception>
 <exception cref="T:System.Security.SecurityException">The caller does not have the required permission.</exception>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.Terminal.SetIn(System.IO.TextReader)">
 <summary>
 Sets the System.Console.In property to the specified System.IO.TextReader object.
 </summary>
 <param name="newIn">A stream that is the new standard input.</param>
 <remarks></remarks>
 <exception cref="T:System.ArgumentNullException">newIn is null.</exception>
 <exception cref="T:System.Security.SecurityException">The caller does not have the required permission.</exception>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.Terminal.SetOut(System.IO.TextWriter)">
 <summary>
 Sets the System.Console.Out property to the specified System.IO.TextWriter object.
 </summary>
 <param name="newOut">A stream that is the new standard output.</param>
 <remarks></remarks>
 <exception cref="T:System.ArgumentNullException">newOut is null.</exception>
 <exception cref="T:System.Security.SecurityException">The caller does not have the required permission.</exception>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.Terminal.SetWindowSize(System.Int32,System.Int32)">
 <summary>
 Sets the height and width of the console window to the specified values.
 </summary>
 <param name="width">The width of the console window measured in columns.</param>
 <param name="height">The height of the console window measured in rows.</param>
 <remarks></remarks>
 <exception cref="T:System.ArgumentOutOfRangeException">width or height is less than or equal to zero.-or- width plus System.Console.WindowLeft or height plus System.Console.WindowTop is greater than or equal to System.Int16.MaxValue. -or-width or height is greater than the largest possible window width or height for the current screen resolution and console font.</exception>
 <exception cref="T:System.Security.SecurityException">The user does not have permission to perform this action.</exception>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.Terminal.Write(System.Boolean)">
 <summary>
 Writes the text representation of the specified Boolean value to the standard output stream.
 </summary>
 <param name="value">The value to write.</param>
 <remarks></remarks>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.Terminal.Write(System.Char[])">
 <summary>
 Writes the specified array of Unicode characters to the standard output stream.
 </summary>
 <param name="buffer">A Unicode character array.</param>
 <remarks></remarks>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.Terminal.Write(System.Char[],System.Int32,System.Int32)">
 <summary>
 Writes the specified subarray of Unicode characters to the standard output stream.
 </summary>
 <param name="buffer">An array of Unicode characters.</param>
 <param name="index">The starting position in buffer.</param>
 <param name="count">The number of characters to write.</param>
 <remarks></remarks>
 <exception cref="T:System.ArgumentNullException">buffer is null.</exception>
 <exception cref="T:System.ArgumentOutOfRangeException">index or count is less than zero.</exception>
 <exception cref="T:System.ArgumentException">index plus count specify a position that is not within buffer.</exception>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.Terminal.Write(System.Char)">
 <summary>
 Writes the specified Unicode character value to the standard output stream.
 </summary>
 <param name="value">The value to write.</param>
 <remarks></remarks>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.Terminal.Write(System.Decimal)">
 <summary>
 Writes the text representation of the specified System.Decimal value to the standard output stream.
 </summary>
 <param name="value">The value to write.</param>
 <remarks></remarks>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.Terminal.Write(System.Double)">
 <summary>
 Writes the text representation of the specified double-precision floating-point value to the standard output stream.
 </summary>
 <param name="value">The value to write.</param>
 <remarks></remarks>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.Terminal.Write(System.Int32)">
 <summary>
 Writes the text representation of the specified 32-bit signed integer value to the standard output stream.
 </summary>
 <param name="value">The value to write.</param>
 <remarks></remarks>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.Terminal.Write(System.Int64)">
 <summary>
 Writes the text representation of the specified 64-bit signed integer value to the standard output stream.
 </summary>
 <param name="value">The value to write.</param>
 <remarks></remarks>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.Terminal.Write(System.Object)">
 <summary>
 Writes the text representation of the specified object to the standard output stream.
 </summary>
 <param name="value">The value to write, or null.</param>
 <remarks></remarks>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.Terminal.Write(System.Single)">
 <summary>
 Writes the text representation of the specified single-precision floating-point value to the standard output stream.
 </summary>
 <param name="value">The value to write.</param>
 <remarks></remarks>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.Terminal.Write(System.String)">
 <summary>
 Writes the specified string value to the standard output stream.
 </summary>
 <param name="value">The value to write.</param>
 <remarks></remarks>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.Terminal.Write(System.String,System.Object)">
 <summary>
 Writes the text representation of the specified object to the standard output stream using the specified format information.
 </summary>
 <param name="format">A composite format string (see Remarks).</param>
 <param name="arg0">An object to write using format.</param>
 <remarks></remarks>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
 <exception cref="T:System.ArgumentNullException">format is null.</exception>
 <exception cref="T:System.FormatException">The format specification in format is invalid.</exception>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.Terminal.Write(System.String,System.Object,System.Object)">
 <summary>
 Writes the text representation of the specified objects to the standard output stream using the specified format information.
 </summary>
 <param name="format">A composite format string (see Remarks).</param>
 <param name="arg0">The first object to write using format.</param>
 <param name="arg1">The second object to write using format.</param>
 <remarks></remarks>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
 <exception cref="T:System.ArgumentNullException">format is null.</exception>
 <exception cref="T:System.FormatException">The format specification in format is invalid.</exception>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.Terminal.Write(System.String,System.Object,System.Object,System.Object)">
 <summary>
 Writes the text representation of the specified objects to the standard output stream using the specified format information.
 </summary>
 <param name="format">A composite format string (see Remarks).</param>
 <param name="arg0">The first object to write using format.</param>
 <param name="arg1">The second object to write using format.</param>
 <param name="arg2">The third object to write using format.</param>
 <remarks></remarks>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
 <exception cref="T:System.ArgumentNullException">format is null.</exception>
 <exception cref="T:System.FormatException">The format specification in format is invalid.</exception>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.Terminal.Write(System.String,System.Object[])">
 <summary>
 Writes the text representation of the specified array of objects to the standard output stream using the specified format information.
 </summary>
 <param name="format">A composite format string (see Remarks).</param>
 <param name="args">An array of objects to write using format.</param>
 <remarks></remarks>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
 <exception cref="T:System.ArgumentNullException">format or arg is null.</exception>
 <exception cref="T:System.FormatException">The format specification in format is invalid.</exception>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.Terminal.Write(System.UInt32)">
 <summary>
 Writes the text representation of the specified 32-bit unsigned integer value to the standard output stream.
 </summary>
 <param name="value">The value to write.</param>
 <remarks></remarks>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.Terminal.Write(System.UInt64)">
 <summary>
 Writes the text representation of the specified 64-bit unsigned integer value to the standard output stream.
 </summary>
 <param name="value">The value to write.</param>
 <remarks></remarks>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.Terminal.WriteLine(System.String)">
 <summary>
 Writes the current line terminator to the standard output stream.
 </summary>
 <remarks></remarks>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.Terminal.WriteLine(System.Boolean)">
 <summary>
 Writes the text representation of the specified Boolean value, followed by the current line terminator, to the standard output stream.
 </summary>
 <param name="value">The value to write.</param>
 <remarks></remarks>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.Terminal.WriteLine(System.Char[])">
 <summary>
 Writes the specified array of Unicode characters, followed by the current line terminator, to the standard output stream.
 </summary>
 <param name="buffer">A Unicode character array.</param>
 <remarks></remarks>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.Terminal.WriteLine(System.Char[],System.Int32,System.Int32)">
 <summary>
 Writes the specified subarray of Unicode characters, followed by the current line terminator, to the standard output stream.
 </summary>
 <param name="buffer">An array of Unicode characters.</param>
 <param name="index">The starting position in buffer.</param>
 <param name="count">The number of characters to write.</param>
 <remarks></remarks>
 <exception cref="T:System.ArgumentNullException">buffer is null.</exception>
 <exception cref="T:System.ArgumentOutOfRangeException">index or count is less than zero.</exception>
 <exception cref="T:System.ArgumentException">index plus count specify a position that is not within buffer.</exception>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.Terminal.WriteLine(System.Char)">
 <summary>
 Writes the specified Unicode character, followed by the current line terminator, value to the standard output stream.
 </summary>
 <param name="value">The value to write.</param>
 <remarks></remarks>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.Terminal.WriteLine(System.Decimal)">
 <summary>
 Writes the text representation of the specified System.Decimal value, followed by the current line terminator, to the standard output stream.
 </summary>
 <param name="value">The value to write.</param>
 <remarks></remarks>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.Terminal.WriteLine(System.Double)">
 <summary>
 Writes the text representation of the specified double-precision floating-point value, followed by the current line terminator, to the standard output stream.
 </summary>
 <param name="value">The value to write.</param>
 <remarks></remarks>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.Terminal.WriteLine(System.Int32)">
 <summary>
 Writes the text representation of the specified 32-bit signed integer value, followed by the current line terminator, to the standard output stream.
 </summary>
 <param name="value">The value to write.</param>
 <remarks></remarks>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.Terminal.WriteLine(System.Int64)">
 <summary>
 Writes the text representation of the specified 64-bit signed integer value, followed by the current line terminator, to the standard output stream.
 </summary>
 <param name="value">The value to write.</param>
 <remarks></remarks>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.Terminal.WriteLine(System.Object)">
 <summary>
 Writes the text representation of the specified object, followed by the current line terminator, to the standard output stream.
 </summary>
 <param name="value">The value to write.</param>
 <remarks></remarks>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.Terminal.WriteLine(System.Single)">
 <summary>
 Writes the text representation of the specified single-precision floating-point value, followed by the current line terminator, to the standard output stream.
 </summary>
 <param name="value">The value to write.</param>
 <remarks></remarks>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.Terminal.WriteLine">
 <summary>
 Writes the specified string value, followed by the current line terminator, to the standard output stream.
 </summary>
 <remarks></remarks>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.Terminal.WriteLine(System.String,System.Object)">
 <summary>
 Writes the text representation of the specified object, followed by the current line terminator, to the standard output stream using the specified format information.
 </summary>
 <param name="format">A composite format string (see Remarks).</param>
 <param name="arg0">An object to write using format.</param>
 <remarks></remarks>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
 <exception cref="T:System.ArgumentNullException">format is null.</exception>
 <exception cref="T:System.FormatException">The format specification in format is invalid.</exception>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.Terminal.WriteLine(System.String,System.Object,System.Object)">
 <summary>
 Writes the text representation of the specified objects, followed by the current line terminator, to the standard output stream using the specified format information.
 </summary>
 <param name="format">A composite format string (see Remarks).</param>
 <param name="arg0">The first object to write using format.</param>
 <param name="arg1">The second object to write using format.</param>
 <remarks></remarks>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
 <exception cref="T:System.ArgumentNullException">format is null.</exception>
 <exception cref="T:System.FormatException">The format specification in format is invalid.</exception>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.Terminal.WriteLine(System.String,System.Object,System.Object,System.Object)">
 <summary>
 Writes the text representation of the specified objects, followed by the current line terminator, to the standard output stream using the specified format information.
 </summary>
 <param name="format">A composite format string (see Remarks).</param>
 <param name="arg0">The first object to write using format.</param>
 <param name="arg1">The second object to write using format.</param>
 <param name="arg2">The third object to write using format.</param>
 <remarks></remarks>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
 <exception cref="T:System.ArgumentNullException">format is null.</exception>
 <exception cref="T:System.FormatException">The format specification in format is invalid.</exception>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.Terminal.WriteLine(System.String,System.Object[])">
 <summary>
 Writes the text representation of the specified array of objects, followed by the current line terminator, to the standard output stream using the specified format information.
 </summary>
 <param name="format">A composite format string (see Remarks).</param>
 <param name="arg">An array of objects to write using format.</param>
 <remarks></remarks>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
 <exception cref="T:System.ArgumentNullException">format or arg is null.</exception>
 <exception cref="T:System.FormatException">The format specification in format is invalid.</exception>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.Terminal.WriteLine(System.UInt32)">
 <summary>
 Writes the text representation of the specified 32-bit unsigned integer value, followed by the current line terminator, to the standard output stream.
 </summary>
 <param name="value">The value to write.</param>
 <remarks></remarks>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.Terminal.WriteLine(System.UInt64)">
 <summary>
 Writes the text representation of the specified 64-bit unsigned integer value, followed by the current line terminator, to the standard output stream.
 </summary>
 <param name="value">The value to write.</param>
 <remarks></remarks>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.Terminal.OpenStandardError">
 <summary>
 Acquires the standard error stream.
 </summary>
 <returns>The standard error stream.</returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.Terminal.OpenStandardError(System.Int32)">
 <summary>
 Acquires the standard error stream, which is set to a specified buffer size.
 </summary>
 <param name="bufferSize">The internal stream buffer size.</param>
 <returns>The standard error stream.</returns>
 <remarks></remarks>
 <exception cref="T:System.ArgumentOutOfRangeException">bufferSize is less than or equal to zero.</exception>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.Terminal.OpenStandardInput">
 <summary>
 Acquires the standard input stream.
 </summary>
 <returns>The standard input stream.</returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.Terminal.OpenStandardInput(System.Int32)">
 <summary>
 Acquires the standard input stream, which is set to a specified buffer size.
 </summary>
 <param name="bufferSize">The internal stream buffer size.</param>
 <returns>The standard input stream.</returns>
 <remarks></remarks>
 <exception cref="T:System.ArgumentOutOfRangeException">bufferSize is less than or equal to zero.</exception>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.Terminal.OpenStandardOutput">
 <summary>
 Acquires the standard output stream.
 </summary>
 <returns>The standard output stream.</returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.Terminal.OpenStandardOutput(System.Int32)">
 <summary>
 Acquires the standard output stream, which is set to a specified buffer size.
 </summary>
 <param name="bufferSize">The internal stream buffer size.</param>
 <returns>The standard output stream.</returns>
 <remarks></remarks>
 <exception cref="T:System.ArgumentOutOfRangeException">bufferSize is less than or equal to zero.</exception>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.Terminal.Read">
 <summary>
 Reads the next character from the standard input stream.
 </summary>
 <returns>The next character from the input stream, or negative one (-1) if there are currently no more characters to be read.</returns>
 <remarks></remarks>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.Terminal.ReadKey">
 <summary>
 Obtains the next character or function key pressed by the user. The pressed key is displayed in the console window.
 </summary>
 <returns>A System.ConsoleKeyInfo object that describes the System.ConsoleKey constant and Unicode character, if any, that correspond to the pressed console key. The System.ConsoleKeyInfo object also describes, in a bitwise combination of System.ConsoleModifiers values, whether one or more Shift, Alt, or Ctrl modifier keys was pressed simultaneously with the console key.</returns>
 <remarks></remarks>
 <exception cref="T:System.InvalidOperationException">The System.Console.In property is redirected from some stream other than the console.</exception>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.Terminal.ReadKey(System.Boolean)">
 <summary>
 Obtains the next character or function key pressed by the user. The pressed key is optionally displayed in the console window.
 </summary>
 <param name="intercept">Determines whether to display the pressed key in the console window. true to not display the pressed key; otherwise, false.</param>
 <returns>A System.ConsoleKeyInfo object that describes the System.ConsoleKey constant and Unicode character, if any, that correspond to the pressed console key. The System.ConsoleKeyInfo object also describes, in a bitwise combination of System.ConsoleModifiers values, whether one or more Shift, Alt, or Ctrl modifier keys was pressed simultaneously with the console key.</returns>
 <remarks></remarks>
 <exception cref="T:System.InvalidOperationException">The System.Console.In property is redirected from some stream other than the console.</exception>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.Terminal.ReadLine">
 <summary>
 Reads the next line of characters from the standard input stream.
 </summary>
 <returns>The next line of characters from the input stream, or null if no more lines are available.</returns>
 <remarks></remarks>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
 <exception cref="T:System.OutOfMemoryException">There is insufficient memory to allocate a buffer for the returned string.</exception>
 <exception cref="T:System.ArgumentOutOfRangeException">The number of characters in the next line of characters is greater than System.Int32.MaxValue.</exception>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Terminal.Terminal.BackgroundColor">
 <summary>
 Gets or sets the background color of the console.
 </summary>
 <value></value>
 <returns>A System.ConsoleColor that specifies the background color of the console; that is, the color that appears behind each character. The default is black.</returns>
 <remarks></remarks>
 <exception cref="T:System.ArgumentException">The color specified in a set operation is not a valid Color.</exception>
 <exception cref="T:System.Security.SecurityException">The user does not have permission to perform this action.</exception>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Terminal.Terminal.CursorLeft">
 <summary>
 Gets or sets the column position of the cursor within the buffer area.
 </summary>
 <value></value>
 <returns>The current position, in columns, of the cursor.</returns>
 <remarks></remarks>
 <exception cref="T:System.ArgumentOutOfRangeException">The value in a set operation is less than zero.-or- The value in a set operation is greater than or equal to System.Console.BufferWidth.</exception>
 <exception cref="T:System.Security.SecurityException">The user does not have permission to perform this action.</exception>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Terminal.Terminal.CursorTop">
 <summary>
 Gets or sets the row position of the cursor within the buffer area.
 </summary>
 <value></value>
 <returns>The current position, in rows, of the cursor.</returns>
 <remarks></remarks>
 <exception cref="T:System.ArgumentOutOfRangeException">The value in a set operation is less than zero.-or- The value in a set operation is greater than or equal to System.Console.BufferHeight.</exception>
 <exception cref="T:System.Security.SecurityException">The user does not have permission to perform this action.</exception>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Terminal.Terminal.Error">
 <summary>
 Gets the standard error output stream.
 </summary>
 <value></value>
 <returns>A System.IO.TextWriter that represents the standard error output stream.</returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Terminal.Terminal.ForegroundColor">
 <summary>
 Gets or sets the foreground color of the console.
 </summary>
 <value></value>
 <returns>A System.ConsoleColor that specifies the foreground color of the console; that is, the color of each character that is displayed. The default is gray.</returns>
 <remarks></remarks>
 <exception cref="T:System.ArgumentException">The color specified in a set operation is not a valid Color.</exception>
 <exception cref="T:System.Security.SecurityException">The user does not have permission to perform this action.</exception>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Terminal.Terminal.In">
 <summary>
 Gets the standard input stream.
 </summary>
 <value></value>
 <returns>A System.IO.TextReader that represents the standard input stream.</returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Terminal.Terminal.InputEncoding">
 <summary>
 Gets or sets the encoding the console uses to read input.
 </summary>
 <value></value>
 <returns>The encoding used to read console input.</returns>
 <remarks></remarks>
 <exception cref="T:System.ArgumentNullException">The property value in a set operation is null.</exception>
 <exception cref="T:System.IO.IOException">An error occurred during the execution of this operation.</exception>
 <exception cref="T:System.Security.SecurityException">Your application does not have permission to perform this operation.</exception>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Terminal.Terminal.IsErrorRedirected">
 <summary>
 Gets a value that indicates whether the error output stream has been redirected from the standard error stream.
 </summary>
 <value></value>
 <returns>true if error output is redirected; otherwise, false.</returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Terminal.Terminal.IsInputRedirected">
 <summary>
 Gets a value that indicates whether input has been redirected from the standard input stream.
 </summary>
 <value></value>
 <returns>true if input is redirected; otherwise, false.</returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Terminal.Terminal.IsOutputRedirected">
 <summary>
 Gets a value that indicates whether output has been redirected from the standard output stream.
 </summary>
 <value></value>
 <returns>true if output is redirected; otherwise, false.</returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Terminal.Terminal.KeyAvailable">
 <summary>
 Gets a value indicating whether a key press is available in the input stream.
 </summary>
 <value></value>
 <returns>true if a key press is available; otherwise, false.</returns>
 <remarks></remarks>
 <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
 <exception cref="T:System.InvalidOperationException">Standard input is redirected to a file instead of the keyboard.</exception>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Terminal.Terminal.LargestWindowHeight">
 <summary>
 Gets the largest possible number of console window rows, based on the current font and screen resolution.
 </summary>
 <value></value>
 <returns>The height of the largest possible console window measured in rows.</returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Terminal.Terminal.LargestWindowWidth">
 <summary>
 Gets the largest possible number of console window columns, based on the current font and screen resolution.
 </summary>
 <value></value>
 <returns>The width of the largest possible console window measured in columns.</returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Terminal.Terminal.Out">
 <summary>
 Gets the standard output stream.
 </summary>
 <value></value>
 <returns>A System.IO.TextWriter that represents the standard output stream.</returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Terminal.Terminal.OutputEncoding">
 <summary>
 Gets or sets the encoding the console uses to write output.
 </summary>
 <value></value>
 <returns>The encoding used to write console output.</returns>
 <remarks></remarks>
 <exception cref="T:System.ArgumentNullException">The property value in a set operation is null.</exception>
 <exception cref="T:System.IO.IOException">An error occurred during the execution of this operation.</exception>
 <exception cref="T:System.Security.SecurityException">Your application does not have permission to perform this operation.</exception>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Terminal.Terminal.TreatControlCAsInput">
 <summary>
 Gets or sets a value indicating whether the combination of the System.ConsoleModifiers.Control modifier key and System.ConsoleKey.C console key (Ctrl+C) is treated as ordinary input or as an interruption that is handled by the operating system.
 </summary>
 <value></value>
 <returns>true if Ctrl+C is treated as ordinary input; otherwise, false.</returns>
 <remarks></remarks>
 <exception cref="T:System.IO.IOException">Unable to get or set the input mode of the console input buffer.</exception>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Terminal.Terminal.WindowHeight">
 <summary>
 Gets or sets the height of the console window area.
 </summary>
 <value></value>
 <returns>The height of the console window measured in rows.</returns>
 <remarks></remarks>
 <exception cref="T:System.ArgumentOutOfRangeException">The value of the System.Console.WindowWidth property or the value of the System.Console.WindowHeight property is less than or equal to 0.-or-The value of the System.Console.WindowHeight property plus the value of the System.Console.WindowTop property is greater than or equal to System.Int16.MaxValue.-or-The value of the System.Console.WindowWidth property or the value of the System.Console.WindowHeight property is greater than the largest possible window width or height for the current screen resolution and console font.</exception>
 <exception cref="T:System.IO.IOException">Error reading or writing information.</exception>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Terminal.Terminal.WindowWidth">
 <summary>
 Gets or sets the width of the console window.
 </summary>
 <value></value>
 <returns>The width of the console window measured in columns.</returns>
 <remarks></remarks>
 <exception cref="T:System.ArgumentOutOfRangeException">The value of the System.Console.WindowWidth property or the value of the System.Console.WindowHeight property is less than or equal to 0.-or-The value of the System.Console.WindowHeight property plus the value of the System.Console.WindowTop property is greater than or equal to System.Int16.MaxValue.-or-The value of the System.Console.WindowWidth property or the value of the System.Console.WindowHeight property is greater than the largest possible window width or height for the current screen resolution and console font.</exception>
 <exception cref="T:System.IO.IOException">Error reading or writing information.</exception>
</member>
<member name="E:Microsoft.VisualBasic.ApplicationServices.Terminal.Terminal.CancelKeyPress">
 <summary>
 Occurs when the System.ConsoleModifiers.Control modifier key (Ctrl) and either the System.ConsoleKey.C console key (C) or the Break key are pressed simultaneously (Ctrl+C or Ctrl+Break).
 </summary>
 <param name="sender"></param>
 <param name="e"></param>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.Terminal.TerminalEvents">
 <summary>
 这个终端事件会依赖于<see cref="P:Microsoft.VisualBasic.App.Running"/>属性值来自动退出的
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.Terminal.TerminalEvents.AutoCompleteHandler">
 <summary>
 Method signature for auto completion handlers.
 </summary>
 <remarks>
 The completion handler receives the text as it is being edited as
 well as the position of the cursor in that line.   The method
 must return an instance of Completion with the possible completions.
 </remarks>
</member>
<member name="E:Microsoft.VisualBasic.ApplicationServices.Terminal.TerminalEvents.Resize">
 <summary>
 Terminal resize event for [<see cref="P:System.Console.WindowWidth"/>, <see cref="P:System.Console.WindowHeight"/>]
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.Terminal.AnsiColor">
 <summary>
 ANSI color definitions for the terminal.
 Each color has a different code depending on if it's applied as a foreground or 
 background color.
 </summary>
 <remarks>https://en.wikipedia.org/wiki/ANSI_escape_code#Colors</remarks>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.Terminal.AnsiEscapeCodes">
 <summary>
 https://en.wikipedia.org/wiki/ANSI_escape_code
 
 ANSI escape sequences are a standard for in-band signaling to control 
 cursor location, color, font styling, and other options on video text 
 terminals and terminal emulators. Certain sequences of bytes, most 
 starting with an ASCII escape character and a bracket character, are
 embedded into text. The terminal interprets these sequences as commands,
 rather than text to display verbatim.
 
 ANSI sequences were introduced In the 1970S To replace vendor-specific 
 sequences And became widespread In the computer equipment market by 
 the early 1980S. They are used In development, scientific, commercial 
 text-based applications As well As bulletin board systems To offer 
 standardized functionality.
 
 Although hardware text terminals have become increasingly rare In the 
 21St century, the relevance Of the ANSI standard persists because a great
 majority Of terminal emulators And command consoles interpret at least
 a portion Of the ANSI standard.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ApplicationServices.Terminal.AnsiEscapeCodes.Escape">
 <summary>
 ANSI 转义字符
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.AnsiEscapeCodes.GetMoveCursorToColumn(System.Int32)">
 <param name="index">Index starts at 1.</param>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.AnsiEscapeCodes.AppendMoveCursorToColumn(System.Text.StringBuilder,System.Int32)">
 <param name="sb">Target StringBUilder.</param>
 <param name="index">Index starts at 1.</param>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.AnsiEscapeCodes.ToAnsiEscapeSequenceSlow(Microsoft.VisualBasic.ApplicationServices.Terminal.ConsoleFormat)">
 <summary>
 convert the console print style as the ANSI escape sequence string
 </summary>
 <param name="formatting"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.Terminal.ConsoleFormat">
 <summary>
 define the <see cref="P:Microsoft.VisualBasic.ApplicationServices.Terminal.TextSpan.style"/> for print on the console.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ConsoleFormat.ToString">
 <summary>
 <see cref="M:Microsoft.VisualBasic.ApplicationServices.Terminal.AnsiEscapeCodes.ToAnsiEscapeSequenceSlow(Microsoft.VisualBasic.ApplicationServices.Terminal.ConsoleFormat)"/>
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.Terminal.MarkdownRender">
 <summary>
 A simple markdown render on console
 </summary>
 <remarks>
 主要是渲染下面的一些元素:
 
 + code: 红色
 + url: 蓝色
 + blockquote: 灰色背景色
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.MarkdownRender.DoPrint(System.String,System.Int32)">
 <summary>
 print the given markdown text with current theme styles
 </summary>
 <param name="markdown$"></param>
 <param name="indent%"></param>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.MarkdownRender.bufferIs(System.String)">
 <summary>
 <see cref="F:Microsoft.VisualBasic.ApplicationServices.Terminal.MarkdownRender.controlBuf"/> is in given string pattern?
 </summary>
 <param name="term"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.MarkdownRender.bufferAllIs(System.Char)">
 <summary>
 All of the character value in <see cref="F:Microsoft.VisualBasic.ApplicationServices.Terminal.MarkdownRender.controlBuf"/> is equals to given character <paramref name="c"/>
 </summary>
 <param name="c"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.MarkdownRender.EndSpan(System.Boolean)">
 <summary>
 create new <see cref="T:Microsoft.VisualBasic.ApplicationServices.Terminal.TextSpan"/> and then clear the <see cref="F:Microsoft.VisualBasic.ApplicationServices.Terminal.MarkdownRender.textBuf"/> 
 for pull next text span object.
 </summary>
 <param name="byNewLine"></param>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.MarkdownRender.Print(System.String,Microsoft.VisualBasic.ApplicationServices.Terminal.MarkdownTheme,System.Int32)">
 <summary>
 do console writeline with styles
 </summary>
 <param name="markdown">the markdown text to print on the console</param>
 <param name="theme">
 the theme styles for make console print
 </param>
 <param name="indent">the prefix space indent number.</param>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.Terminal.TextSpan">
 <summary>
 console print text with a specific styles
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Terminal.TextSpan.style">
 <summary>
 print the pnain text if the style is nothing
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.Terminal.PipelineCLI">
 <summary>
 a | b - 管道命令在读写方面更加适合于文本数据，由于省去了IO的时间，故而效率较高
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.PipelineCLI.Start(System.IO.Stream,System.String,System.String)">
 <summary>
 使用管道的方法启动下游的应用程序
 </summary>
 <param name="app"></param>
 <param name="args"></param>
 <remarks>
 http://stackoverflow.com/questions/30546522/how-to-use-a-pipe-between-two-processes-in-process-start
 
 let the OS do it. ``StartInfo.FileName = "cmd"`` then prepend ``executablepath`` to params so it looks 
 the way you would enter it in a command window; 
 ``StartInfo.Arguments = params`` then start the process 
 
 – Plutonix May 30 '15 at 15:13
 </remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.PrintAsTable.Print``1(System.Collections.Generic.IEnumerable{``0},System.Boolean)">
 <summary>
 Returns a text string 
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <param name="addBorder"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.PrintAsTable.Print``1(System.Collections.Generic.IEnumerable{``0},System.IO.TextWriter,System.Boolean)">
 <summary>
 Print the object collection as table on the console 
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <param name="dev"></param>
 <param name="addBorder"></param>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.PrintAsTable.PrintTable(System.Collections.Generic.IEnumerable{System.String[]},System.IO.TextWriter,System.Char,System.String[],System.Boolean,System.Int32)">
 <summary>
 与函数<see cref="M:Microsoft.VisualBasic.ApplicationServices.Terminal.PrintAsTable.Print(System.Collections.Generic.Dictionary{System.String,System.String},System.IO.TextWriter,System.Char,System.Int32)"/>所不同的是，这个函数还会添加边框
 </summary>
 <param name="source">Each element is a row in table matrix</param>
 <param name="dev"></param>
 <param name="sep"></param>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.PrintAsTable.Print(System.Collections.Generic.IEnumerable{System.String[]},System.IO.TextWriter,System.Char,System.Int32)">
 <summary>
 Print the string matrix collection <paramref name="source"/> in table layout.
 </summary>
 <param name="source">The string matrix collection.</param>
 <param name="dev">The output device</param>
 <param name="sep"></param>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.PrintAsTable.Print(System.Collections.Generic.Dictionary{System.String,System.String},System.IO.TextWriter,System.Char,System.Int32)">
 <summary>
 Print the string dictionary as table
 </summary>
 <param name="table"></param>
 <param name="dev"></param>
 <param name="sep"></param>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.STDIO__.IReadDevice.ReadLine">
 <summary>
 Reads the next line of characters from the standard input stream.(从输入流读取下一行字符)
 </summary>
 <returns>
 The next line of characters from the input stream, or null if no more lines are available.
 </returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.STDIO__.IReadDevice.Read">
 <summary>
 Reads the next character from the standard input stream.(从输入流读取下一个字符)
 </summary>
 <returns>
 The next character from the input stream, or negative one (-1) if there are currently no more 
 characters to be read.
 </returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.STDIO__.IWriteDevice.WriteLine">
 <summary>
 Writes the specified string value, followed by the current line terminator, to the standard 
 output stream.
 (将指定的字符串值（后跟当前行终止符）写入输出流。)
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.STDIO__.IWriteDevice.WriteLine(System.String,System.Object[])">
 <summary>
 Writes the text representation of the specified array of objects, followed by the current line terminator, 
 to the standard output stream using the specified format information.
 (将指定的字符串值（后跟当前行终止符）写入输出流。)
 </summary>
 <param name="s"></param>
 <param name="args"></param>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.Terminal.STDIO__.IConsole">
 <summary>
 Represents the standard input, output, and error streams for console applications.
 (表示一个输入输出流控制台界面接口)
 </summary>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Terminal.STDIO__.IConsole.WindowWidth">
 <summary>
 控制台窗口的宽度，以列为单位。
 </summary>
 <returns></returns>
 <remarks>
 不是以像素为单位，而是以字符个数为单位
 </remarks>
</member>
<member name="E:Microsoft.VisualBasic.ApplicationServices.Terminal.STDIO__.IConsole.Tab">
 <summary>
 when &lt;TAB> is pressed
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.STDIO__.Shell.AllocConsole">
 <summary>
 You can create a console window In a Windows Forms project.  Project + properties, turn off "Enable application framework" 
 And Set Startup Object To "Sub Main". 
 
 Modify the Application.Run() statement To create the proper startup form, If necessary.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.STDIO__.Shell.ShowConsoleWindows">
 <summary>
 为WinForm应用程序分配一个终端窗口，这个函数一般是在Debug模式之下进行程序调试所使用的
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.Terminal.STDIO">
 <summary>
 A standard input/output compatibility package that makes VisualBasic console
 program easily running on the Linux server or mac osx operating system.
 (一个用于让VisualBasic应用程序更加容易的运行于Linux服务器或者MAC系统之上的标准输入输出流的系统兼容包)
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.VisualBasic.ApplicationServices.Terminal.STDIO.escapings">
 <summary>
 A dictionary list of the escape characters.(转义字符列表)
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.STDIO.printf(System.String,System.Object[])">
 <summary>
 Output the string to the console using a specific formation.
 (按照指定的格式将字符串输出到终端窗口之上，请注意，这个函数除了将数据流
 输出到标准终端之外，还会输出到调试终端)
 </summary>
 <param name="s">A string to print on the console window.(输出到终端窗口之上的字符串)</param>
 <param name="args">Formation parameters.(格式化参数)</param>
 <remarks></remarks>

</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.STDIO.cat(System.String[])">
 <summary>
 Alias for the <see cref="M:System.Console.Write(System.Boolean)"/>.(不换行)
 </summary>
 <param name="out"></param>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.STDIO.scanf(System.String@,System.ConsoleColor)">
 <summary>
 Read the string that user input on the console to the function paramenter.
 (将用户在终端窗口之上输入的数据赋值给一个字符串变量)
 </summary>
 <param name="s"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.STDIO.ZeroFill(System.String,System.Int32)">
 <summary>
 Fill the number string with specific length of ZERO sequence to generates the fixed width string.
 </summary>
 <param name="sn"></param>
 <param name="len"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.STDIO.MsgBox(System.String,Microsoft.VisualBasic.MsgBoxStyle)">
 <summary>

 </summary>
 <param name="prompt"></param>
 <param name="style">
 Value just allow:
 <see cref="F:Microsoft.VisualBasic.MsgBoxStyle.AbortRetryIgnore"/>,
 <see cref="F:Microsoft.VisualBasic.MsgBoxStyle.OkCancel"/>,
 <see cref="F:Microsoft.VisualBasic.MsgBoxStyle.OkOnly"/>,
 <see cref="F:Microsoft.VisualBasic.MsgBoxStyle.RetryCancel"/>,
 <see cref="F:Microsoft.VisualBasic.MsgBoxStyle.YesNo"/>,
 <see cref="F:Microsoft.VisualBasic.MsgBoxStyle.YesNoCancel"/></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.STDIO.charTestEquals(System.String,System.Char)">
 <summary>

 </summary>
 <param name="input"></param>
 <param name="compare">大写的</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.STDIO.Read``1(System.String,Microsoft.VisualBasic.ApplicationServices.Terminal.STDIO.TryParseDelegate{``0},System.String)">
 <summary>
 Read Method with Generics &amp; Delegate
 
 In a console application there is often the need to ask (and validate) some data from users. 
 For this reason I have created a function that make use of generics and delegates to 
 speed up programming.
 
 > http://www.codeproject.com/Tips/1108772/Read-Method-with-Generics-Delegate
 </summary>
 <typeparam name="T"></typeparam>
 <param name="msg"></param>
 <param name="parser"></param>
 <param name="_default"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.STDIO.Write(System.Object)">
 <summary>
 Writes the text representation of the specified object to the standard output
 stream.
 </summary>
 <param name="o">The value to write, or null.</param>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.STDIO.WriteLine(System.Object)">
 <summary>
 Writes the text representation of the specified object, followed by the current
 line terminator, to the standard output stream.
 </summary>
 <param name="o">The value to write.</param>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.TablePrinter.ConsoleTableBaseData.AppendLine(System.Collections.IEnumerable)">
 <summary>
 append one row data
 </summary>
 <param name="line">the row data collection, general data</param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.Terminal.TablePrinter.ConsoleTableBuilder">
 <summary>
 A fluent library to print out a nicely formatted table in a console application
 </summary>
 <remarks>
 https://github.com/minhhungit/ConsoleTableExt
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.TablePrinter.ConsoleTableBuilder.From(System.Func{Microsoft.VisualBasic.ApplicationServices.Terminal.TablePrinter.ConsoleTableBaseData})">
 <summary>
 This function allow developer implement theme self data-source
 </summary>
 <param name="func"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.TablePrinter.ConsoleTableBuilderExtensions.WithTitle(Microsoft.VisualBasic.ApplicationServices.Terminal.TablePrinter.ConsoleTableBuilder,System.String,Microsoft.VisualBasic.ApplicationServices.Terminal.TablePrinter.Flags.TextAligntment)">
 <summary>
 Add title row on top of table
 </summary>
 <param name="builder"></param>
 <param name="title"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.TablePrinter.ConsoleTableBuilderExtensions.WithTitle(Microsoft.VisualBasic.ApplicationServices.Terminal.TablePrinter.ConsoleTableBuilder,System.String,System.ConsoleColor,Microsoft.VisualBasic.ApplicationServices.Terminal.TablePrinter.Flags.TextAligntment)">
 <summary>
 Add title row on top of table
 </summary>
 <param name="builder"></param>
 <param name="title"></param>
 <param name="foregroundColor">text color</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.TablePrinter.ConsoleTableBuilderExtensions.WithTitle(Microsoft.VisualBasic.ApplicationServices.Terminal.TablePrinter.ConsoleTableBuilder,System.String,System.ConsoleColor,System.ConsoleColor,Microsoft.VisualBasic.ApplicationServices.Terminal.TablePrinter.Flags.TextAligntment)">
 <summary>
 Add title row on top of table
 </summary>
 <param name="builder"></param>
 <param name="title"></param>
 <param name="foregroundColor">text color</param>
 <param name="backgroundColor">background color</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.TablePrinter.ConsoleTableBuilderExtensions.WithTextAlignment(Microsoft.VisualBasic.ApplicationServices.Terminal.TablePrinter.ConsoleTableBuilder,System.Collections.Generic.Dictionary{System.Int32,Microsoft.VisualBasic.ApplicationServices.Terminal.TablePrinter.Flags.TextAligntment})">
 <summary>
 Text alignment definition
 </summary>
 <param name="builder"></param>
 <param name="alignmentData"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.TablePrinter.ConsoleTableBuilderExtensions.Export(Microsoft.VisualBasic.ApplicationServices.Terminal.TablePrinter.ConsoleTableBuilder)">
 <summary>
 export the table print content string
 </summary>
 <param name="builder"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.TablePrinter.ConsoleTableBuilderExtensions.ExportAndWrite(Microsoft.VisualBasic.ApplicationServices.Terminal.TablePrinter.ConsoleTableBuilder,Microsoft.VisualBasic.ApplicationServices.Terminal.TablePrinter.Flags.TableAligntment)">
 <summary>
 export the table content as string and do console write
 </summary>
 <param name="builder"></param>
 <param name="alignment"></param>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.TablePrinter.ConsoleTableBuilderExtensions.ExportAndWriteLine(Microsoft.VisualBasic.ApplicationServices.Terminal.TablePrinter.ConsoleTableBuilder,Microsoft.VisualBasic.ApplicationServices.Terminal.TablePrinter.Flags.TableAligntment)">
 <summary>
 console write line of the table data
 </summary>
 <param name="builder"></param>
 <param name="alignment"></param>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.TablePrinter.ConsoleTableBuilderExtensions.RealLength(System.String,System.Boolean)">
 <summary>
 Get the real width for do console print of a string
 </summary>
 <param name="value"></param>
 <param name="withUtf8Characters"></param>
 <returns></returns>
 <remarks>
 1 char width for ascii character, and
 2 char width for chinese character.
 </remarks>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.Terminal.TablePrinter.Flags.CharMapPositions">
 <summary>
 Check map here https://raw.githubusercontent.com/minhhungit/ConsoleTableExt/master/wiki/Images/CharMapPositions.png
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.Terminal.TablePrinter.Flags.HeaderCharMapPositions">
 <summary>
 Check map here https://raw.githubusercontent.com/minhhungit/ConsoleTableExt/master/wiki/Images/HeaderCharMapPositions.png
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.Terminal.Utility.CBusyIndicator">
 <summary>
 The console BusyIndicator
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.Utility.CBusyIndicator.Start(System.Int32)">
 <summary>
 运行进度条
 </summary>
 <param name="Ticks">The total ticking counts of the indicator, Unit is [second].</param>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.Terminal.Utility.Constants">
 <summary>
 Constants used with PInvoke methods
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.VisualBasic.ApplicationServices.Terminal.Utility.Constants.KEY_EVENT">
 <summary>
 EventType flags.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ApplicationServices.Terminal.Utility.Constants.MOUSE_EVENT">
 <summary>
 Event contains key event record
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ApplicationServices.Terminal.Utility.Constants.WINDOW_BUFFER_SIZE_EVENT">
 <summary>
 Event contains mouse event record
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ApplicationServices.Terminal.Utility.Constants.MENU_EVENT">
 <summary>
 Event contains window change event record
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ApplicationServices.Terminal.Utility.Constants.FOCUS_EVENT">
 <summary>
 Event contains menu event record
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ApplicationServices.Terminal.Utility.Constants.INVALID_HANDLE_VALUE">
 <summary>
 Event contains focus change
 Returned by GetStdHandle when an error occurs
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.Terminal.Utility.uCharUnion">
 <summary>
 ' Struct uChar is meant to support the Windows Console API's uChar union.
 ' Unions do not exist in the pure .NET world. We have to use the regular
 ' C# struct and the StructLayout and FieldOffset Attributes to preserve
 ' the memory layout of the unmanaged union.
 '
 ' We specify the "LayoutKind.Explicit" value for the StructLayout attribute
 ' to specify that every field of the struct uChar is marked with a byte offset.
 '
 ' This byte offset is specified by the FieldOffsetAttribute and it indicates
 ' the number of bytes between the beginning of the struct in memory and the
 ' beginning of the field.
 '
 ' As you can see in the struct uChar (below), the fields "UnicodeChar"
 ' and "AsciiChar" have been marked as being of offset 0. This is the only
 ' way that an unmanaged C/C++ union can be represented in C#.
 '
 </summary>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.Terminal.Utility.KEY_EVENT_RECORD">
 <summary>
 ' The struct KEY_EVENT_RECORD is used to report keyboard input events
 ' in a console INPUT_RECORD structure.
 '
 ' Internally, it uses the structure uChar which is treated as a union
 ' in the unmanaged world.
 '
 </summary>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.Terminal.Utility.ConsolePasswordInput">
 <summary>
 Summary description for ConsolePasswordInput.
 </summary>
 <remarks>
 .NET Console Password Input By Masking Keyed-In Characters
 http://www.codeproject.com/Articles/8110/NET-Console-Password-Input-By-Masking-Keyed-In-Ch
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.Utility.ConsolePasswordInput.PasswordInput(System.String@,System.Int32)">
 <summary>

 </summary>
 <param name="refPasswordToBuild"></param>
 <param name="iMaxNumberOfCharactersSet">The password max length limits.</param>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.Terminal.Utility.EventProc">
 <summary>
 Generates the task progress for the console output.(处理任务进度)
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Terminal.Utility.EventProc.Capacity">
 <summary>
 The total <see cref="M:Microsoft.VisualBasic.ApplicationServices.Terminal.Utility.EventProc.Tick"/>
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.Utility.EventProc.#ctor(System.Int32,System.String,System.IO.StreamWriter)">
 <summary>
 
 </summary>
 <param name="n"></param>
 <param name="tag"></param>
 <param name="out">Default is <see cref="T:System.Console"/></param>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.Utility.EventProc.Tick">
 <summary>
 会自动输出进度的
 </summary>
 <returns></returns>
</member>
<member name="F:Microsoft.VisualBasic.ApplicationServices.Terminal.Utility.EventProc.percentage">
 <summary>
 Current progress percentage.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ApplicationServices.Terminal.Utility.EventProc.preElapsedMilliseconds">
 <summary>
 Previous <see cref="P:System.Diagnostics.Stopwatch.ElapsedMilliseconds"/>
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.Utility.EventProc.ToString">
 <summary>
 Generates progress output
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.Terminal.Utility.IndexedManual">
 <summary>
 有显示标题的
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.Utility.IndexedManual.#ctor(System.Collections.Generic.IEnumerable{System.String},System.String)">
 <summary>
 与<see cref="T:Microsoft.VisualBasic.ApplicationServices.Terminal.Utility.ManualPages"></see>所不同的是，本对象之中的这个字符串数组表示的是一页帮助，而不是一行帮助信息
 </summary>
 <param name="Pages"></param>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.Utility.IndexedManual.ShowManual(System.Int32,System.Int32)">
 <summary>
 使用[Enter][Down_arrow][pagedown]翻下一页[Up_arrow][Pageup]翻上一页，[q]或者[esc]结束，[home]第一页[end]最后一页
 </summary>
 <param name="initLines">无用的参数</param>
 <param name="printLines">无用的参数</param>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.Utility.IndexedManual.PrintPrompted(System.Int32,System.Int32,System.Int32)">
 <summary>
 
 </summary>
 <param name="p">Current page index</param>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.Terminal.Utility.ManIndex">
 <summary>
 the document index
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.Terminal.Utility.ManParser">
 <summary>
 helper module for parse the unix man page text
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.Terminal.Utility.UnixManPage">
 <summary>
 man手册页（manual pages，“手册”），是类UNIX系统最重要的手册工具。多数类UNIX都预装了它，这也包括Arch。使用man手册页的命令是：man。
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Terminal.Utility.UnixManPage.NAME">
 <summary>
 手册叙述对象名称，及简要描述。
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Terminal.Utility.UnixManPage.SYNOPSIS">
 <summary>
 命令参数格式，或者函数调用格式等。
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Terminal.Utility.UnixManPage.DESCRIPTION">
 <summary>
 对叙述对象更加详细的描述。
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Terminal.Utility.UnixManPage.EXAMPLES">
 <summary>
 由浅入深的使用示例。
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Terminal.Utility.UnixManPage.OPTIONS">
 <summary>
 命令行或者函数调用参数的意义。
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Terminal.Utility.UnixManPage.EXIT_STATUS">
 <summary>
 不同返回（退出）代码的含义。
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Terminal.Utility.UnixManPage.FILES">
 <summary>
 与叙述对象相关的文件。
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Terminal.Utility.UnixManPage.BUGS">
 <summary>
 已知的bug。
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Terminal.Utility.UnixManPage.SEE_ALSO">
 <summary>
 相关内容列表。
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.Utility.UnixManPage.ToString">
 <summary>
 生成man page的文本内容
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.Utility.ManualPages.ShowManual(System.Int32,System.Int32)">
 <summary>
 使用回车键或者箭头下显示下一行，字母q或者ESC键退出Manual
 </summary>
 <param name="initLines">最开始显示的行数</param>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.Utility.ManualPages.FromFile(System.String)">
 <summary>
 从文本文件之中加载Manual数据
 </summary>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.Terminal.Utility.UserTaskCancelAction">
 <summary>
 A finalize action after the user cancel current task operations.(ctrl + C)
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ApplicationServices.Terminal.Utility.ConsoleUserTaskAction.userAction">
 <summary>
 用户自定义操作
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.Terminal.Utility.UserTaskSaveAction">
 <summary>
 ``ctrl + S``
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.AbstractBar.PrintMessage(System.String)">
 <summary>
 Prints a simple message 
 </summary>
 <param name="msg">Message to print</param>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.AnimatedBar.Step">
 <summary>
 prints the character found in the animation according to the current index
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Element`1">
 <summary>
 An element of a ProgressBar
 </summary>
 <typeparam name="T"></typeparam>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Element`1.#ctor">
 <summary>
 Ctor
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Element`1.#ctor(`0,System.ConsoleColor,System.ConsoleColor)">
 <summary>
 Ctor
 </summary>
 <param name="value"></param>
 <param name="foregroundColor"></param>
 <param name="backgroundColor"></param>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Element`1.SetVisible(System.Boolean)">
 <summary>
 Sets the ProgressBar element visible (or not)
 </summary>
 <param name="show"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Element`1.SetVisible(System.Func{Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.ProgressBar,System.Boolean})">
 <summary>
 Sets the ProgressBar element visible (or not)
 </summary>
 <param name="showGetter"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Element`1.GetVisible(Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.ProgressBar)">
 <summary>
 Gets the ProgressBar element visibility
 </summary>
 <param name="progressBar"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Element`1.SetValue(`0)">
 <summary>
 Sets the Value of the ProgressBar element
 </summary>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Element`1.SetValue(System.Func{Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.ProgressBar,`0})">
 <summary>
 Sets the Value of the ProgressBar element
 </summary>
 <param name="valueGetter"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Element`1.GetValue(Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.ProgressBar)">
 <summary>
 Gets the Value of the ProgressBar element
 </summary>
 <param name="progressBar"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Element`1.SetForegroundColor(System.ConsoleColor)">
 <summary>
 Sets the ForegroundColor of the ProgressBar element
 </summary>
 <param name="foregroundColor"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Element`1.SetForegroundColor(System.Func{Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.ProgressBar,System.ConsoleColor})">
 <summary>
 Sets the ForegroundColor of the ProgressBar element
 </summary>
 <param name="foregroundColorGetter"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Element`1.GetForegroundColor(Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.ProgressBar)">
 <summary>
 Gets the ForegroundColor of the ProgressBar element
 </summary>
 <param name="progressBar"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Element`1.SetBackgroundColor(System.ConsoleColor)">
 <summary>
 Sets the BackgroundColor of the ProgressBar element
 </summary>
 <param name="backgroundColor"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Element`1.SetBackgroundColor(System.Func{Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.ProgressBar,System.ConsoleColor})">
 <summary>
 Sets the BackgroundColor of the ProgressBar element
 </summary>
 <param name="backgroundColorGetter"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Element`1.GetBackgroundColor(Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.ProgressBar)">
 <summary>
 Gets the BackgroundColor of the ProgressBar element
 </summary>
 <param name="progressBar"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.ElementList`1">
 <summary>
 A list of Elements of a ProgressBar
 </summary>
 <typeparam name="T"></typeparam>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.ElementList`1.List">
 <summary>
 The List of Elements of a Progressbar
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.ElementList`1.Clear">
 <summary>
 Clears the List of elements of a ProgressBar
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.ElementList`1.AddNew">
 <summary>
 Adds new Element to the List
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Extensions.ElementExtensions">
 <summary>
 Extensions for Element
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Extensions.ElementExtensions.GetRenderActions(Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Element{System.String},Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.ProgressBar,System.Func{System.String,System.String})">
 <summary>
 Returns a list of Actions to write the element in Console
 </summary>
 <param name="element"></param>
 <param name="progressBar"></param>
 <param name="valueTransformer">Function to Transform the value before write</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Extensions.ElementExtensions.GetRenderActions(Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Element{System.Char},Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.ProgressBar,System.Int32)">
 <summary>
 Returns a list of Actions to write the element in Console
 </summary>
 <param name="element"></param>
 <param name="progressBar"></param>
 <param name="repetition"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Extensions.StringExtensions">
 <summary>
 Extensions for String
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Extensions.StringExtensions.AdaptToConsole(System.String,System.Boolean)">
 <summary>
 Returns a string that occupy all console line/s
 </summary>
 <param name="value">The string to write in console</param>
 <param name="allowMultipleLines">To allow print the string in muliple lines or only in one:
     True: The text can be represented in more than one Console line (fill spaces to the end of last line)
     False: The text must be represented in only ONE line (truncate to fit or fill spaces to the end of line)
 </param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Extensions.StringExtensions.AdaptToMaxWidth(System.String,System.Int32,System.String)">
 <summary>
 Returns a string with exactly maxChars: Truncates string value or fill with spaces to fits exact length
 </summary>
 <param name="value"></param>
 <param name="maxWidth"></param>
 <param name="append">Text appended when it is truncated. Default: "..."</param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Extensions.TimeSpanExtensions">
 <summary>
 TimeSpan extensions
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Extensions.TimeSpanExtensions.ToStringAsSumarizedRemainingText(System.Nullable{System.TimeSpan})">
 <summary>
 Gets a textual Sumarized for remaining time: X days, or Y hours, or Z minutes, etc.
 </summary>
 <param name="ts"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Extensions.TimeSpanExtensions.ToStringAsSumarizedRemainingText(System.TimeSpan)">
 <summary>
 Gets a textual Sumarized for remaining time: X days, or Y hours, or Z minutes, etc.
 </summary>
 <param name="ts"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Extensions.TimeSpanExtensions.ToStringWithAllHours(System.Nullable{System.TimeSpan},System.Boolean)">
 <summary>
 Converts a TimeSpan to String, showing all hours
 </summary>
 <param name="ts"></param>
 <param name="includeMilliseconds"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Extensions.TimeSpanExtensions.ToStringWithAllHours(System.TimeSpan,System.Boolean)">
 <summary>
 Converts a TimeSpan to String, showing all hours
 </summary>
 <param name="ts"></param>
 <param name="includeMilliseconds"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Layout">
 <summary>
 Definition of a Layout for a ProgressBar representation
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Layout.LayoutBody">
 <summary>
 Definition of the Layout used to Render the Body of the ProgressBar
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Layout.LayoutBody.Pending">
 <summary>
 Element To show in Pending Section
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Layout.LayoutBody.Progress">
 <summary>
 Element to show in Progress Section
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Layout.LayoutBody.Text">
 <summary>
 Layout for the Text 
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Layout.LayoutBody.SetValue(System.Char)">
 <summary>
 Sets the LayoutBody value for Pending and Progress elements
 </summary>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Layout.LayoutBody.SetValue(System.Func{Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.ProgressBar,System.Char})">
 <summary>
 Sets the LayoutBody value for Pending and Progress elements
 </summary>
 <param name="valueGetter"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Layout.LayoutBody.SetForegroundColor(System.ConsoleColor)">
 <summary>
 Sets the ForegroundColor for Pending and Progress elements
 </summary>
 <param name="foregroundColor"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Layout.LayoutBody.SetForegroundColor(System.Func{Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.ProgressBar,System.ConsoleColor})">
 <summary>
 Sets the ForegroundColor for Pending and Progress elements
 </summary>
 <param name="foregroundColorGetter"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Layout.LayoutBody.SetBackgroundColor(System.ConsoleColor)">
 <summary>
 Sets the BackgroundColor for Pending and Progress elements
 </summary>
 <param name="backgroundColor"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Layout.LayoutBody.SetBackgroundColor(System.Func{Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.ProgressBar,System.ConsoleColor})">
 <summary>
 Sets the BackgroundColor for Pending and Progress elements
 </summary>
 <param name="backgroundColorGetter"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Layout.LayoutBody.#ctor">
 <summary>
 Ctor
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Layout.Margins">
 <summary>
 Layout definition for Margins
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Layout.Marquee">
 <summary>
 Layout definition for Marquee (character moving around the ProgressBar)
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Layout.Body">
 <summary>
 Layout definition for Body
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Layout.ProgressBarWidth">
 <summary>
 Width of entire ProgressBar
 Default = 30
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Layout.GetInnerWidth(Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.ProgressBar)">
 <summary>
 Gets the internal Width of the ProgressBar
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Layout.GetRenderActions(Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.ProgressBar)">
 <summary>
 Returns the Actions to do in order to Render the ProgressBar with this Layout
 </summary>
 <param name="progressBar"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Layout.LayoutMargin">
 <summary>
 Definition of the Layout used to Render the Margins of the ProgressBar
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Layout.LayoutMargin.Start">
 <summary>
 Element to show at the Margin Left (Start of the ProgressBar) 
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Layout.LayoutMargin.End">
 <summary>
 Element to show at the Margin Right (End of the ProgressBar)
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Layout.LayoutMargin.SetValue(System.String)">
 <summary>
 Sets the LayoutMargin value for Start and End elements
 </summary>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Layout.LayoutMargin.SetValue(System.Func{Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.ProgressBar,System.String})">
 <summary>
 Sets the LayoutMargin value for Start and End elements
 </summary>
 <param name="valueGetter"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Layout.LayoutMargin.SetForegroundColor(System.ConsoleColor)">
 <summary>
 Sets the ForegroundColor for Start and End elements
 </summary>
 <param name="foregroundColor"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Layout.LayoutMargin.SetForegroundColor(System.Func{Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.ProgressBar,System.ConsoleColor})">
 <summary>
 Sets the ForegroundColor for Start and End elements
 </summary>
 <param name="foregroundColorGetter"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Layout.LayoutMargin.SetBackgroundColor(System.ConsoleColor)">
 <summary>
 Sets the BackgroundColor for Start and End elements
 </summary>
 <param name="backgroundColor"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Layout.LayoutMargin.SetBackgroundColor(System.Func{Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.ProgressBar,System.ConsoleColor})">
 <summary>
 Sets the BackgroundColor for Start and End elements
 </summary>
 <param name="backgroundColorGetter"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Layout.LayoutMargin.SetVisible(System.Boolean)">
 <summary>
 Sets the visibility for Start and End elements
 </summary>
 <param name="visible"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Layout.LayoutMargin.SetVisible(System.Func{Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.ProgressBar,System.Boolean})">
 <summary>
 Sets the visibility for Start and End elements
 </summary>
 <param name="showGetter"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Layout.LayoutMargin.GetLength(Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.ProgressBar)">
 <summary>
 Return the length of Margins
 </summary>
 <param name="progressBar"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Layout.LayoutMargin.#ctor">
 <summary>
 Ctor
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Layout.LayoutMarquee">
 <summary>
 Definition for the Marquee
 The Marquee is a char that moves around the ProgressBar
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Layout.LayoutMarquee.OverPending">
 <summary>
 Marquee definition when it moves over 'Pending' section
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Layout.LayoutMarquee.OverProgress">
 <summary>
 Marquee definition when it moves over 'Progress' section
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Layout.LayoutMarquee.SetValue(System.Char)">
 <summary>
 Sets the Marqee definition when it moves over 'Pending' or 'Progress' section
 </summary>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Layout.LayoutMarquee.SetValue(System.Func{Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.ProgressBar,System.Char})">
 <summary>
 Sets the Marqee definition when it moves over 'Pending' or 'Progress' section
 </summary>
 <param name="valueGetter"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Layout.LayoutMarquee.SetForegroundColor(System.ConsoleColor)">
 <summary>
 Sets the Marqee Foreground Color when it moves over 'Pending' or 'Progress' section
 </summary>
 <param name="foregroundColor"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Layout.LayoutMarquee.SetForegroundColor(System.Func{Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.ProgressBar,System.ConsoleColor})">
 <summary>
 Sets the Marqee Foreground Color when it moves over 'Pending' or 'Progress' section
 </summary>
 <param name="foregroundColorGetter"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Layout.LayoutMarquee.SetBackgroundColor(System.ConsoleColor)">
 <summary>
 Sets the Marqee Background Color when it moves over 'Pending' or 'Progress' section
 </summary>
 <param name="backgroundColor"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Layout.LayoutMarquee.SetBackgroundColor(System.Func{Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.ProgressBar,System.ConsoleColor})">
 <summary>
 Sets the Marqee Background Color when it moves over 'Pending' or 'Progress' section
 </summary>
 <param name="backgroundColorGetter"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Layout.LayoutMarquee.SetVisible(System.Boolean)">
 <summary>
 Sets the Marqee Visibility when it moves over 'Pending' or 'Progress' section
 </summary>
 <param name="visible"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Layout.LayoutMarquee.SetVisible(System.Func{Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.ProgressBar,System.Boolean})">
 <summary>
 Sets the Marqee Visibility when it moves over 'Pending' or 'Progress' section
 </summary>
 <param name="showGetter"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Layout.LayoutMarquee.#ctor">
 <summary>
 Ctor
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.ProgressBar">
 <summary>
 A ProgressBar for Console
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.ProgressBar._IsStarted">
 <summary>
 True if ProgressBar is Started
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.ProgressBar._IsPaused">
 <summary>
 True if ProgressBar is Paused
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.ProgressBar.Layout">
 <summary>
 Layout of the ProgressBar
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.ProgressBar.Text">
 <summary>
 Text definitions for the ProgressBar
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.ProgressBar.Tag">
 <summary>
 Tag object
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.ProgressBar.Maximum">
 <summary>
 The Maximum value
 Default = 100
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.ProgressBar.Value">
 <summary>
 The current Value
 If Value is greater than Maximum, then updates Maximum value
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.ProgressBar.Percentage">
 <summary>
 Percentage of progress
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.ProgressBar.HasProgress">
 <summary>
 Indicates if the ProgressBar has Progress defined (Maximum defined)
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.ProgressBar.Step">
 <summary>
 The amount by which to increment the ProgressBar with each call to the PerformStep() method.
 Default = 1
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.ProgressBar.ElementName">
 <summary>
 The Name of the Curent Element
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.ProgressBar.FixedInBottom">
 <summary>
 True to Print the ProgressBar always in last Console Line
 False to Print the ProgressBar fixed in Console (Current position at Starting)
 You can Write at Console and ProgressBar will always be below your lines
 Default = true
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.ProgressBar.Delay">
 <summary>
 Delay for repaint and recalculate all ProgressBar
 Default = 75
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.ProgressBar.IsDone">
 <summary>
 True if ProgresBar is Done: when disposing or Progress is finished
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.ProgressBar.TimeProcessing">
 <summary>
 Processing time (time paused excluded)
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.ProgressBar.TimePerElement">
 <summary>
 Processing time per element (median)
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.ProgressBar.TimeRemaining">
 <summary>
 Estimated time finish (to Value = Maximum)
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.ProgressBar.ConsoleWriterLock">
 <summary>
 A Lock for Writing to Console
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.ProgressBar.#ctor(System.Nullable{System.Int32},System.Boolean)">
 <summary>
 Creates an instance of ConsoleProgressBar
 </summary>
 <param name="initialPosition">Initial position of the ProgressBar</param>
 <param name="autoStart">True if ProgressBar starts automatically</param>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.ProgressBar.Start">
 <summary>
 Starts the ProgressBar
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.ProgressBar.Pause">
 <summary>
 Pauses the ProgressBar
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.ProgressBar.Resume">
 <summary>
 Resume the ProgresBar
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.ProgressBar.SetValue(System.Int32,System.String,System.Object)">
 <summary>
 Assigns the current Value, and optionally current ElementName and Tag
 If Value is greater than Maximum, updates Maximum as Value
 </summary>
 <param name="value"></param>
 <param name="elementName"></param>
 <param name="tag"></param>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.ProgressBar.PerformStep(System.String,System.Object)">
 <summary>
 Advances the current position of the progress bar by the amount of the Step property
 </summary>
 <param name="elementName">The name of the new Element</param>
 <param name="tag"></param>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.ProgressBar.PerformStep(System.Int32,System.String,System.Object)">
 <summary>
 Advances the current position of the progress bar by the amount of the Step property
 </summary>
 <param name="step">Step to perform</param>
 <param name="elementName">The name of the new Element</param>
 <param name="tag"></param>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.ProgressBar.WriteLine">
 <summary>
 WriteLine in Console when ProgressBar is running
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.ProgressBar.WriteLine(System.String)">
 <summary>
 WriteLine in Console when ProgressBar is running
 </summary>
 <param name="value"></param>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.ProgressBar.WriteLine(System.String,System.Boolean)">
 <summary>
 WriteLine in Console when ProgressBar is running
 </summary>
 <param name="value"></param>
 <param name="truncateToOneLine"></param>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.ProgressBar.WriteLine(System.String,System.Nullable{System.ConsoleColor},System.Nullable{System.ConsoleColor},System.Boolean)">
 <summary>
 WriteLine in Console when ProgressBar is running
 </summary>
 <param name="value"></param>
 <param name="foregroundColor"></param>
 <param name="backgroundColor"></param>
 <param name="truncateToOneLine"></param>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.ProgressBar.Render">
 <summary>
 Renders in Console the ProgressBar
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.ProgressBar.Unrender">
 <summary>
 Unrenders (remove) from Console last ProgressBar printed
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.ProgressBar.Dispose">
 <summary>
 Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Text">
 <summary>
 Definitions for Texts in a ProgressBar
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Text.TextBody">
 <summary>
 Definition for the Texts in a ProgressBar
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Text.TextBody.Processing">
 <summary>
 Text in Body definition when ProgressBar is "Processing"
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Text.TextBody.Paused">
 <summary>
 Text in Body definition when ProgressBar is "Paused"
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Text.TextBody.Done">
 <summary>
 Text in Body definition when ProgressBar is "Done"
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Text.TextBody.SetVisible(System.Boolean)">
 <summary>
 Sets the Body Text visibility
 </summary>
 <param name="show"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Text.TextBody.SetVisible(System.Func{Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.ProgressBar,System.Boolean})">
 <summary>
 Sets the Body Text visibility
 </summary>
 <param name="showGetter"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Text.TextBody.SetValue(System.String)">
 <summary>
 Sets the Body Text definition in all ProgressBar states ("Processing", "Paused", "Done")
 </summary>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Text.TextBody.SetValue(System.Func{Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.ProgressBar,System.String})">
 <summary>
 Sets the Body Text definition in all ProgressBar states ("Processing", "Paused", "Done")
 </summary>
 <param name="valueGetter"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Text.TextBody.SetForegroundColor(System.ConsoleColor)">
 <summary>
 Sets the Body Text Foreground Color
 </summary>
 <param name="foregroundColor"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Text.TextBody.SetForegroundColor(System.Func{Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.ProgressBar,System.ConsoleColor})">
 <summary>
 Sets the Body Text Foreground Color
 </summary>
 <param name="foregroundColorGetter"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Text.TextBody.SetBackgroundColor(System.ConsoleColor)">
 <summary>
 Sets the Body Text Background Color
 </summary>
 <param name="backgroundColor"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Text.TextBody.SetBackgroundColor(System.Func{Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.ProgressBar,System.ConsoleColor})">
 <summary>
 Sets the Body Text Background Color
 </summary>
 <param name="backgroundColorGetter"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Text.TextBody.#ctor">
 <summary>
 Ctor
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Text.TextBody.GetCurrentText(Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.ProgressBar)">
 <summary>
 Gets the current Text Body definition by the ProgressBar context ("Processing", "Paused" or "Done")
 </summary>
 <param name="progressBar"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Text.TextDescription">
 <summary>
 Definition for the Description lines in a ProgressBar
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Text.TextDescription.Processing">
 <summary>
 Description lines definition when ProgressBar is "Processing"
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Text.TextDescription.Paused">
 <summary>
 Description lines definition when ProgressBar is "Paused"
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Text.TextDescription.Done">
 <summary>
 Description lines definition when ProgressBar is "Done"
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Text.TextDescription.Indentation">
 <summary>
 Indentation for Description lines
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Text.TextDescription.#ctor">
 <summary>
 Ctor
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Text.TextDescription.Clear">
 <summary>
 Clears Description Lines
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Text.TextDescription.GetCurrentDefinitionList(Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.ProgressBar)">
 <summary>
 Gets the current Description Lines definition by the ProgressBar context ("Processing", "Paused" or "Done")
 </summary>
 <param name="progressBar"></param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Text.Body">
 <summary>
 Definition of the text in the same line as ProgressBar (Body)
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ConsoleProgressBar.Text.Description">
 <summary>
 Definition of the texts in the lines below a ProgressBar (Description)
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.Program.Run(Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.AbstractBar,System.Int32,System.Int32)">
 <summary>
 
 </summary>
 <param name="bar"></param>
 <param name="wait">Sleep time of the thread</param>
 <param name="[end]">Ends at this iteration</param>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.Program.ProgressText(System.Double,System.Int32,System.Char,System.Char)">
 <summary>
 
 </summary>
 <param name="p">[0,1] represents the progress percentage</param>
 <returns>
 a progress bar liked string value, example as:
 
 ```
 ####.......
 ```
 </returns>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ColorTheme">
 <summary>
 The <see cref="T:System.ConsoleColor"/> theme for the <see cref="N:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar"/>
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ColorTheme.IsEmpty">
 <summary>
 Test if all of the property value is equals to ZERO(<see cref="F:System.ConsoleColor.Black"/>).
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ColorTheme.DefaultTheme">
 <summary>
 Default value for optional parameter
 </summary>
 <returns></returns>
 <remarks>
 ###### 2017-11-5
 This property will cause bug in reflection.
 
 ###### 2017-11-6
 Change from property to function to avoid bug caused application crashed
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.ColorTheme.Default">
 <summary>
 The default color theme values
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.SwayBar">
 <summary>
 像乒乓球一样左右碰撞的进度条
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.SwayBar.#ctor(System.Int32)">
 <summary>
 
 </summary>
 <param name="length%">
 进度条的碰撞区域的字符数量宽度
 </param>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.SwayBar.buildBlankPointer">
 <summary>
 sets the atribute blankPointer with a empty string the same length that the pointer
 </summary>
 <returns>A string filled with space characters</returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.SwayBar.ClearBar">
 <summary>
 reset the bar to its original state
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.SwayBar.PlacePointer(System.Int32,System.Int32)">
 <summary>
 remove the previous pointer and place it in a new possition
 </summary>
 <param name="start">start index</param>
 <param name="end">end index</param>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.SwayBar.Step">
 <summary>
 prints the progress bar acorrding to pointers and current direction
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.Tqdm.ProgressBar">
 <summary>
 The ProgressBar class offers a customizable console progress bar for tracking and displaying the progress of iterative tasks. 
 It features various themes, real-time updates, and supports both simple and exponential moving average rate calculations.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.Tqdm.ProgressBar.#ctor(System.Boolean,System.Double,System.Int32,System.Int32,System.Int32,System.Boolean)">
 <summary>
 Initializes a new instance of the ProgressBar class.
 </summary>
 <param name="useExpMovingAvg">Whether to use exponential moving average for rate calculation.</param>
 <param name="alpha">The smoothing factor for exponential moving average.</param>
 <param name="total">The total number of iterations expected.</param>
 <param name="width">The width of the progress bar in characters.</param>
 <param name="printsPerSecond">The estimated number of updates to the progress bar per second.</param>
 <param name="useColor">Indicates whether to use colored output for the progress bar.</param>
 <remarks>The prints per second is not an absolute number, and gets constantly tuned as the process progresses.</remarks>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.Tqdm.ProgressBar.Reset">
 <summary>
 Resets the progress bar to its initial state.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.Tqdm.ProgressBar.SetLabel(System.String)">
 <summary>
 Sets a label that appears at the end of the progress bar.
 </summary>
 <param name="text">The label text.</param>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.Tqdm.ProgressBar.SetThemeBasic">
 <summary>
 Sets the progress bar theme to basic characters of spaces + '#'.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.Tqdm.ProgressBar.SetThemeAscii">
 <summary>
 Sets the progress bar theme to ASCII characters.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.Tqdm.ProgressBar.SetThemePython">
 <summary>
 Sets the progress bar theme to Python-style characters.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.Tqdm.ProgressBar.SetTheme(System.Char[])">
 <summary>
 Sets the progress bar theme using a custom array of characters.
 </summary>
 <param name="bars">An array of characters to use in the progress bar. Must be exactly 9 characters.</param>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.Tqdm.ProgressBar.Finish">
 <summary>
 Finalizes the progress bar display.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.Tqdm.ProgressBar.Progress(System.Int32,System.Int32)">
 <summary>
 Updates the progress bar with the current progress and total.
 </summary>
 <param name="current">The current progress.</param>
 <param name="total">The total number of iterations expected. This will update the internal total counter given in the constructor.</param>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.Tqdm.ProgressBar.Progress(System.Int32,System.String)">
 <summary>
 adapter interface for <see cref="T:Microsoft.VisualBasic.CommandLine.InteropService.Pipeline.RunSlavePipeline.SetProgressEventHandler"/>
 </summary>
 <param name="current"></param>
 <param name="message"></param>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.Tqdm.ProgressBar.Progress(System.Int32)">
 <summary>
 Updates the progress bar with the current progress.
 </summary>
 <param name="current">The current progress.</param>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.Tqdm.ProgressBar.Step">
 <summary>
 Advances the progress bar by one step, automatically updating the progress count internally.
 This method is useful for scenarios where the progress is incremented in a regular manner
 and eliminates the need for external progress tracking.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.Tqdm.ProgressBar.PrintLine(System.String)">
 <summary>
 Clears the previous console line and prints a new line, ensuring subsequent prints appear on the next line.
 </summary>
 <param name="text">The text to be printed on the new line.</param>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.Tqdm.TqdmWrapper">
 <summary>
 The Tqdm class offers utility functions to wrap collections and enumerables with a ProgressBar, 
 providing a simple and effective way to track and display progress in console applications for various iterative operations.
 </summary>
 <remarks>
 https://github.com/shaltielshmid/TqdmSharp
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.Tqdm.TqdmWrapper.Wrap``1(System.Collections.Generic.ICollection{``0},System.Int32,System.Int32,System.Boolean,System.Boolean)">
 <summary>
 Wraps a collection with a progress bar for iteration, providing visual feedback on progress.
 </summary>
 <param name="collection">The collection to iterate over.</param>
 <param name="width">The width of the progress bar.</param>
 <param name="printsPerSecond">The update frequency of the progress bar.</param>
 <param name="useColor">Indicates whether to use colored output for the progress bar.</param>
 <returns>An enumerable that iterates over the collection with progress tracking.</returns> 
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.Tqdm.TqdmWrapper.Wrap``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Int32,System.Int32,System.Boolean,System.Boolean)">
 <summary>
 Wraps an enumerable with a specified total count with a progress bar for iteration, providing visual feedback on progress.
 </summary>
 <param name="enumerable">The enumerable to iterate over.</param>
 <param name="total">The total number of expected items in the enumerable.</param>
 <param name="width">The width of the progress bar.</param>
 <param name="printsPerSecond">The update frequency of the progress bar.</param>
 <param name="useColor">Indicates whether to use colored output for the progress bar.</param>
 <returns>An enumerable that iterates over the collection with progress tracking.</returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.Tqdm.TqdmWrapper.Wrap``1(System.Collections.Generic.ICollection{``0},Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.Tqdm.ProgressBar@,System.Int32,System.Int32,System.Boolean,System.Boolean)">
 <summary>
 Wraps a collection with a progress bar for iteration and provides the progress bar instance for external control (like custom labels).
 </summary>
 <param name="collection">The collection to iterate over.</param>
 <param name="bar">The progress bar instance used for tracking.</param>
 <param name="width">The width of the progress bar.</param>
 <param name="printsPerSecond">The update frequency of the progress bar.</param>
 <param name="useColor">Indicates whether to use colored output for the progress bar.</param>
 <returns>An enumerable that iterates over the collection with progress tracking.</returns>
 
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.Tqdm.TqdmWrapper.Wrap``1(System.Collections.Generic.IEnumerable{``0},System.Int32,Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.Tqdm.ProgressBar@,System.Int32,System.Int32,System.Boolean,System.Boolean)">
 <summary>
 Wraps an enumerable with a specified total count with a progress bar for iteration and provides the progress bar instance for external control (like custom labels).
 </summary>
 <param name="enumerable">The enumerable to iterate over.</param>
 <param name="total">The total number of items in the enumerable.</param>
 <param name="bar">The progress bar instance used for tracking.</param>
 <param name="width">The width of the progress bar.</param>
 <param name="printsPerSecond">The update frequency of the progress bar.</param>
 <param name="useColor">Indicates whether to use colored output for the progress bar.</param>
 <returns>An enumerable that iterates over the collection with progress tracking.</returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.Tqdm.TqdmWrapper.Range(System.Int32,System.Int32,Microsoft.VisualBasic.ApplicationServices.Terminal.ProgressBar.Tqdm.ProgressBar@,System.Int32,System.Int32,System.Boolean,System.Boolean)">
 <summary>
 Generates a sequence of integral numbers within a specified range.
 </summary>
 <param name="start">The value of the first integer in the sequence.</param>
 <param name="count">The number of sequential integers to generate.</param>
 <param name="bar"></param>
 <param name="width"></param>
 <param name="printsPerSecond"></param>
 <param name="useColor"></param>
 <returns>a range of sequential integral numbers.</returns>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.OSVersionInfo">
 <summary>
 Provides detailed information about the host operating system.(用于判断操作系统的具体版本信息的工具)
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.OSVersionInfo.ProgramBits">
 <summary>
 Determines if the current application is 32 or 64-bit.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.OSVersionInfo.ProcessorBits">
 <summary>
 Determines if the current processor is 32 or 64-bit.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.OSVersionInfo.Edition">
 <summary>
 Gets the edition of the operating system running on this computer.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ApplicationServices.OSVersionInfo.WindowsNameList.null">
 <summary>
 Linux/MAC
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ApplicationServices.OSVersionInfo.WindowsNameList.Windows3_1">
 <summary>
 Windows 3.1
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ApplicationServices.OSVersionInfo.WindowsNameList.WindowsCE">
 <summary>
 Windows CE
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ApplicationServices.OSVersionInfo.WindowsNameList.Windows95OSR2">
 <summary>
 Windows 95 OSR2
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ApplicationServices.OSVersionInfo.WindowsNameList.Windows95">
 <summary>
 Windows 95
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ApplicationServices.OSVersionInfo.WindowsNameList.Windows98SecondEdition">
 <summary>
 Windows 98 Second Edition
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ApplicationServices.OSVersionInfo.WindowsNameList.Windows98">
 <summary>
 Windows 98
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ApplicationServices.OSVersionInfo.WindowsNameList.WindowsMe">
 <summary>
 Windows Me
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ApplicationServices.OSVersionInfo.WindowsNameList.WindowsNT3_51">
 <summary>
 Windows NT 3.51
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ApplicationServices.OSVersionInfo.WindowsNameList.WindowsNT4_0">
 <summary>
 Windows NT 4.0
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ApplicationServices.OSVersionInfo.WindowsNameList.WindowsNT4_0Server">
 <summary>
 Windows NT 4.0 Server
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ApplicationServices.OSVersionInfo.WindowsNameList.Windows2000">
 <summary>
 Windows 2000
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ApplicationServices.OSVersionInfo.WindowsNameList.WindowsXP">
 <summary>
 Windows XP
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ApplicationServices.OSVersionInfo.WindowsNameList.WindowsServer2003">
 <summary>
 Windows Server 2003
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ApplicationServices.OSVersionInfo.WindowsNameList.WindowsVista">
 <summary>
 Windows Vista
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ApplicationServices.OSVersionInfo.WindowsNameList.WindowsServer2008">
 <summary>
 Windows Server 2008
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ApplicationServices.OSVersionInfo.WindowsNameList.Windows7">
 <summary>
 Windows 7
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ApplicationServices.OSVersionInfo.WindowsNameList.WindowsServer2008R2">
 <summary>
 Windows Server 2008 R2
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ApplicationServices.OSVersionInfo.WindowsNameList.Windows8">
 <summary>
 Windows 8
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ApplicationServices.OSVersionInfo.WindowsNameList.WindowsServer2012">
 <summary>
 Windows Server 2012
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.OSVersionInfo.WindowsName">
 <summary>
 Gets the name of the operating system running on this computer.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.OSVersionInfo.GetVersionEx(Microsoft.VisualBasic.ApplicationServices.OSVersionInfo.OSVERSIONINFOEX@)">
 <summary>
 ##### GetVersionEx Function
 
 _GetVersionEx may be altered Or unavailable for releases after Windows 8.1. Instead, use the Version Helper functions_
 
 With the release Of Windows 8.1, the behavior Of the GetVersionEx API has changed In the value it will Return For the 
 operating system version. The value returned by the GetVersionEx Function now depends On how the application Is 
 manifested.
 Applications Not manifested for Windows 8.1 Or Windows 10 will return the Windows 8 OS version value (6.2). Once an 
 application Is manifested for a given operating system version, GetVersionEx will always return the version that the 
 application Is manifested for in future releases. To manifest your applications for Windows 8.1 Or Windows 10, refer 
 to Targeting your application for Windows.
 
 **Syntax**
 
 ```C
 BOOL WINAPI GetVersionEx(
   _Inout_ LPOSVERSIONINFO lpVersionInfo
 );
 ```
 
 </summary>
 <param name="osVersionInfo">An OSVersionInfo Or OSVERSIONINFOEX structure that receives the operating system information.
 Before calling the GetVersionEx Function, set the dwOSVersionInfoSize member of the structure as appropriate to indicate 
 which data structure Is being passed to this function.
 </param>
 <returns>If the Then Function succeeds, the Return value Is a nonzero value.
 If the Then Function fails, the Return value Is zero. To Get extended Error information, Call GetLastError. 
 The Function fails If you specify an invalid value For the dwOSVersionInfoSize member Of the OSVERSIONINFO 
 Or OSVERSIONINFOEX Structure.
 </returns>
 <remarks>
 Identifying the current operating system Is usually Not the best way To determine whether a particular operating system 
 feature Is present. This Is because the operating system may have had New features added In a redistributable DLL. Rather 
 than Using GetVersionEx To determine the operating system platform Or version number, test For the presence Of the feature 
 itself. For more information, see Operating System Version.
 The GetSystemMetrics function provides additional information about the current operating system.
 
 |Product|Setting|
 |-------|-------|
 |Windows XP Media Center Edition|SM_MEDIACENTER|
 |Windows XP Starter Edition|SM_STARTER|
 |Windows XP Tablet PC Edition|SM_TABLETPC|
 |Windows Server 2003 R2|SM_SERVERR2|

 To check for specific operating systems Or operating system features, use the IsOS function. The GetProductInfo function retrieves the product type.
 To retrieve information for the operating system on a remote computer, use the NetWkstaGetInfo function, the Win32_OperatingSystem WMI class, Or the OperatingSystem property of the IADsComputer interface.
 To compare the current system version to a required version, use the VerifyVersionInfo function instead of using GetVersionEx to perform the comparison yourself.
 
 If compatibility Then mode Is In effect, the GetVersionEx Function reports the operating system As it identifies itself, which may Not 
 be the operating system that Is installed. For example, If compatibility mode Is In effect, GetVersionEx reports the operating system 
 that Is selected For application compatibility.
 
 **Examples**

 When using the GetVersionEx function to determine whether your application Is running on a particular version of the operating system, 
 check for version numbers that are greater than Or equal to the desired version numbers. This ensures that the test succeeds for later 
 versions of the operating system. For example, if your application requires Windows XP Or later, use the following test.
 
 ```C
 #include &lt;windows.h>
 #include &lt;stdio.h>

 Void main()
 {
     OSVersionInfo osvi;
     BOOL bIsWindowsXPorLater;

     ZeroMemory(&amp;osvi, SizeOf(OSVersionInfo));
     osvi.dwOSVersionInfoSize = SizeOf(OSVersionInfo);

     GetVersionEx(&amp;osvi);

     bIsWindowsXPorLater =
        ((osvi.dwMajorVersion > 5) ||
        ((osvi.dwMajorVersion == 5) &amp;&amp; (osvi.dwMinorVersion >= 1) ));
 
     if(bIsWindowsXPorLater) 
         printf("The system meets the requirements.\n");
     else printf("The system does not meet the requirements.\n");
 }
 ```

 For an example that identifies the current operating system, see Getting the System Version.
 
 **Requirements**

 | | |
 |-|-|
 |Minimum supported client|Windows 2000 Professional [desktop apps only]|
 |Minimum supported server|Windows 2000 Server [desktop apps only]|
 |Header|Winbase.h(include Windows.h)|
 |Library|Kernel32.lib|
 |DLL|Kernel32.dll|
 |Unicode And ANSI names|GetVersionExW(Unicode) And GetVersionExA (ANSI)|
 </remarks>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.OSVersionInfo.ServicePack">
 <summary>
 Gets the service pack information of the operating system running on this computer.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.OSVersionInfo.BuildVersion">
 <summary>
 Gets the build version number of the operating system running on this computer.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.OSVersionInfo.VersionString">
 <summary>
 Gets the full version string of the operating system running on this computer.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.OSVersionInfo.Version">
 <summary>
 Gets the full version of the operating system running on this computer.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.OSVersionInfo.MajorVersion">
 <summary>
 Gets the major version number of the operating system running on this computer.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.OSVersionInfo.MinorVersion">
 <summary>
 Gets the minor version number of the operating system running on this computer.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.OSVersionInfo.RevisionVersion">
 <summary>
 Gets the revision version number of the operating system running on this computer.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.PerformanceCounter.LastCheckPoint">
 <summary>
 get last marked checkpoint
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.PerformanceCounter.Set">
 <summary>
 reset the counter
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.PerformanceCounter.Mark(System.String)">
 <summary>
 create a checkpoint
 </summary>
 <param name="title"></param>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.PerformanceCounter.Mark">
 <summary>
 reset the checkpoint to current 
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.TimeCounter.span0">
 <summary>
 time interval span from the begining
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.TimeCounter.span1">
 <summary>
 time interval span since from the last checkpoint
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Plugin.Loader.GetPluginMethod(System.String,System.String)">
 <summary>
 只会查找静态方法
 </summary>
 <param name="assembly$"></param>
 <param name="guid"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.Plugin.FormattedDoubleConverter">
 <summary>
 
 </summary>
 <remarks>
 https://stackoverflow.com/questions/16541264/property-grid-number-formatting
 </remarks>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.ResourcesSatellite">
 <summary>
 Represents a resource manager that provides convenient access to culture-specific
 resources at run time.Security Note: Calling methods in this class with untrusted
 data is a security risk. Call the methods in the class only with trusted data.
 For more information, see Untrusted Data Security Risks.
 (资源卫星程序集)
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.ResourcesSatellite.FileName">
 <summary>
 The file path of the resources satellite assembly.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.ResourcesSatellite.Resources">
 <summary>
 <see cref="T:System.Resources.ResourceManager"/> object in the satellite assembly.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.ResourcesSatellite.GetObject(System.String)">
 <summary>
 Returns the value of the specified non-string resource.
 </summary>
 <param name="name">The name of the resource to get.</param>
 <returns>The value of the resource localized for the caller's current culture settings.
 If an appropriate resource set exists but name cannot be found, the method returns
 null.</returns>
 
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.ResourcesSatellite.GetObject(System.String,System.Globalization.CultureInfo)">
 <summary>
 Gets the value of the specified non-string resource localized for the specified
 culture.
 </summary>
 <param name="name">The name of the resource to get.</param>
 <param name="culture">The culture for which the resource is localized. If the resource is not localized
 for this culture, the resource manager uses fallback rules to locate an appropriate
 resource.If this value is null, the System.Globalization.CultureInfo object is
 obtained by using the System.Globalization.CultureInfo.CurrentUICulture property.</param>
 <returns>The value of the resource, localized for the specified culture. If an appropriate
 resource set exists but name cannot be found, the method returns null.</returns>
 
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.ResourcesSatellite.GetStream(System.String)">
 <summary>
 Returns an unmanaged memory stream object from the specified resource.
 </summary>
 <param name="name">The name of a resource.</param>
 <returns>An unmanaged memory stream object that represents a resource .</returns>
 
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.ResourcesSatellite.GetStream(System.String,System.Globalization.CultureInfo)">
 <summary>
 Returns an unmanaged memory stream object from the specified resource, using
 the specified culture.
 </summary>
 <param name="name">The name of a resource.</param>
 <param name="culture">An object that specifies the culture to use for the resource lookup. If culture
 is null, the culture for the current thread is used.</param>
 <returns>An unmanaged memory stream object that represents a resource.</returns>
 
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.ResourcesSatellite.GetString(System.String)">
 <summary>
 Returns the value of the specified string resource.
 </summary>
 <param name="name">The name of the resource to retrieve.</param>
 <returns>The value of the resource localized for the caller's current UI culture, or null
 if name cannot be found in a resource set.</returns>
 
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.ResourcesSatellite.GetString(System.String,System.Globalization.CultureInfo)">
 <summary>
 Returns the value of the string resource localized for the specified culture.
 </summary>
 <param name="name">The name of the resource to retrieve.</param>
 <param name="culture">An object that represents the culture for which the resource is localized.</param>
 <returns>The value of the resource localized for the specified culture, or null if name
 cannot be found in a resource set.</returns>
 
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.ResourcesSatellite.#ctor(System.Type)">
 <summary>
 Load external resource data from current module's satellite assembly.
 </summary>
 <param name="type"></param>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.ResourcesSatellite.#ctor(System.Reflection.Assembly)">
 <summary>
 默认是<see cref="P:Microsoft.VisualBasic.App.HOME"/>/Resources/assmFile
 </summary>
 <param name="assm"></param>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.ResourcesSatellite.#ctor(System.Type,System.Reflection.Assembly)">
 <summary>
 
 </summary>
 <param name="my">null</param>
 <param name="assm"></param>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.ResourcesSatellite.LoadMy">
 <summary>
 从自身的程序集之中加载数据
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.ResourcesSatellite.MyResource">
 <summary>
 Returns the cached ResourceManager instance used by this class.
 </summary>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.TarGzFileSystem.GetFullPath(System.String)">
 <summary>
 
 </summary>
 <param name="filename">the relative file path of the target file/folder</param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.Zip.Overwrite">
 <summary>
 Used to specify what our overwrite policy
 is for files we are extracting.
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.Zip.ArchiveAction">
 <summary>
 Used to identify what we will do if we are
 trying to create a zip file and it already
 exists.
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.Zip.ZipStreamReader">
 <summary>
 zip file stream helper
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Zip.ZipStreamReader.LoadZipArchive(System.String,System.Collections.Generic.IEnumerable{System.String})">
 <summary>
 将zip文件中的所有数据包一次性的返回给上层调用代码
 </summary>
 <param name="zipFile"></param>
 <param name="takes"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Zip.ZipStreamReader.GetZipSubStream(System.String,System.String)">
 <summary>
 如果这个函数返回的是空值，说明zip压缩文件中没有该目标
 </summary>
 <param name="zipFile$"></param>
 <param name="name$"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Zip.UnZip.ImprovedExtractToFile(System.IO.Compression.ZipArchiveEntry,System.String,Microsoft.VisualBasic.ApplicationServices.Zip.Overwrite)">
 <summary>
 Safely extracts a single file from a zip file
 </summary>
 <param name="file">
 The zip entry we are pulling the file from
 </param>
 <param name="destinationPath">
 The root of where the file is going
 </param>
 <param name="overwriteMethod">
 Specifies how we are going to handle an existing file.
 The default is Overwrite.IfNewer.
 </param>
 
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Zip.UnZip.ImprovedExtractToDirectory(System.String,System.String,Microsoft.VisualBasic.ApplicationServices.Zip.Overwrite,System.Boolean)">
 <summary>
 Unzips the specified file to the given folder in a safe
 manner.  This plans for missing paths and existing files
 and handles them gracefully.
 </summary>
 <param name="sourceArchiveFileName">
 The name of the zip file to be extracted
 </param>
 <param name="destinationDirectoryName">
 The directory to extract the zip file to
 </param>
 <param name="overwriteMethod">
 Specifies how we are going to handle an existing file.
 The default is IfNewer.
 </param>
 <returns>
 this function returns the parameter value of <paramref name="destinationDirectoryName"/>
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Zip.UnZip.ImprovedExtractToDirectory(Microsoft.VisualBasic.Net.Http.DataURI,System.String,Microsoft.VisualBasic.ApplicationServices.Zip.Overwrite,System.Boolean,System.String)">
 <summary>
 Unzips the specified file to the given folder in a safe
 manner.  This plans for missing paths and existing files
 and handles them gracefully.
 </summary>
 <param name="zip">
 The file contant data of the zip file to be extracted
 </param>
 <param name="destinationDirectoryName">
 The directory to extract the zip file to
 </param>
 <param name="overwriteMethod">
 Specifies how we are going to handle an existing file.
 The default is IfNewer.
 </param>
 
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Zip.UnZip.ImprovedExtractToDirectory(System.IO.Stream,System.String,Microsoft.VisualBasic.ApplicationServices.Zip.Overwrite,System.Boolean,System.String)">
 <summary>
 Unzips the specified file to the given folder in a safe
 manner.  This plans for missing paths and existing files
 and handles them gracefully.
 </summary>
 <param name="zip">
 The file contant data of the zip file to be extracted
 </param>
 <param name="destinationDirectoryName">
 The directory to extract the zip file to
 </param>
 <param name="overwriteMethod">
 Specifies how we are going to handle an existing file.
 The default is IfNewer.
 </param>
 
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.Zip.ZipLib">
 <summary>
 Creating Zip Files Easily in .NET 4.5
 Tim Corey, 11 May 2012
 
 http://www.codeproject.com/Articles/381661/Creating-Zip-Files-Easily-in-NET
 </summary>
 <remarks></remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Zip.ZipLib.CheckValidZipFile(System.String)">
 <summary>
 Check if the given <paramref name="zip"/> file contains any data. 
 </summary>
 <param name="zip"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Zip.ZipLib.IsSourceFolderZip(System.String,System.String@)">
 <summary>
 判断目标zip文件是否是直接将文件夹进行压缩的
 如果是直接将文件夹压缩的，那么肯定会在每一个entry的起始存在一个共同的文件夹名
 例如：
 
 ```
 95-1.D/
 95-1.D/AcqData/
 95-1.D/AcqData/Contents.xml
 95-1.D/AcqData/Devices.xml
 ```
 </summary>
 <param name="zip"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Zip.ZipLib.IsSourceFolderZip(System.IO.Stream,System.String@,System.Boolean)">
 <summary>
 判断目标zip文件是否是直接将文件夹进行压缩的
 如果是直接将文件夹压缩的，那么肯定会在每一个entry的起始存在一个共同的文件夹名
 例如：
 
 ```
 95-1.D/
 95-1.D/AcqData/
 95-1.D/AcqData/Contents.xml
 95-1.D/AcqData/Devices.xml
 ```
 </summary>
 <param name="zip"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Zip.ZipLib.DirectoryArchive(System.String,System.String,Microsoft.VisualBasic.ApplicationServices.Zip.ArchiveAction,Microsoft.VisualBasic.ApplicationServices.Zip.Overwrite,System.IO.Compression.CompressionLevel,System.Boolean)">
 <summary>
 
 </summary>
 <param name="directory$"></param>
 <param name="saveZip$"></param>
 <param name="action"></param>
 <param name="fileOverwrite"></param>
 <param name="compression"></param>
 <param name="flatDirectory">
 当这个参数为FALSE的时候，zip文件之中会保留有原来的文件夹的树形结构，
 反之，则zip文件之中不会存在任何文件夹结构，所有的文件都会被保存在zip文件里面的根目录之中
 
 这个参数默认为False，即保留有原来的文件夹树形结构
 </param>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Zip.ZipLib.AddToArchive(System.Collections.Generic.IEnumerable{System.String},System.String,Microsoft.VisualBasic.ApplicationServices.Zip.ArchiveAction,Microsoft.VisualBasic.ApplicationServices.Zip.Overwrite,System.IO.Compression.CompressionLevel,System.String)">
 <summary>
 Allows you to add files to an archive, whether the archive
 already exists or not
 </summary>
 <param name="archiveFullName">
 The name of the archive to you want to add your files to
 </param>
 <param name="files">
 A set of file names that are to be added
 </param>
 <param name="action">
 Specifies how we are going to handle an existing archive
 </param>
 <param name="compression">
 Specifies what type of compression to use - defaults to Optimal
 </param>
 
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Zip.ZipLib.WriteFiles(System.IO.Compression.ZipArchive,System.String[],System.IO.Compression.ZipArchiveMode,Microsoft.VisualBasic.ApplicationServices.Zip.Overwrite,System.IO.Compression.CompressionLevel,System.String,System.String)">
 <summary>
 add files into the zip file archive object
 </summary>
 <param name="zipFile"></param>
 <param name="files">
 a file path list to save into the zip package file, should be full path!
 </param>
 <param name="mode"></param>
 <param name="fileOverwrite"></param>
 <param name="compression"></param>
 <param name="relativeDir"></param>
 <param name="parent$"></param>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.Zip.ZipStream">
 <summary>
 using a zip archive file as a virtual filesystem
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Zip.ZipStream.filepath">
 <summary>
 Gets the absolute path of the file opened in the FileStream.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Zip.ZipStream.#ctor(System.IO.Stream,System.Boolean)">
 <summary>
 
 </summary>
 <param name="file"></param>
 <param name="is_readonly">
 readonly mode just allows for read data from the zip archive file, and 
 set this parameter value to FALSE will enable for create entry inside 
 the file.
 </param>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Zip.ZipStream.ToString">
 <summary>
 debug view of the stream source
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Zip.ZipStream.GetFileEntry(System.String,System.Boolean)">
 <summary>
 
 </summary>
 <param name="path"></param>
 <returns>
 return nothing if the required archive entry could not be found
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Zip.ZipStream.OpenFile(System.String,System.IO.FileMode,System.IO.FileAccess)">
 <summary>
 
 </summary>
 <param name="path"></param>
 <param name="mode"></param>
 <param name="access"></param>
 <returns></returns>
 <remarks>
 due to the reason of zip deflate stream object does not supports the seek operation,
 so this function convert the zip deflate stream to a memory stream at first in this
 function for avoid the downstream operation error when call the stream seek method.
 </remarks>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.Utils">
 <summary>
 App utils
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Utils.Shell(System.String,System.Diagnostics.ProcessWindowStyle,System.Boolean)">
 <summary>
 
 </summary>
 <param name="commandLine"></param>
 <param name="windowStyle"></param>
 <param name="waitForExit">
 If NOT, then the function returns the associated process id value,
 else returns the process exit code.
 </param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Utils.TryRun(System.Action,System.String)">
 <summary>
 Call target <see cref="T:System.Action"/> delegate, if exception occurs in the action, 
 then this function will logs the exception and exit without thorw an exception. 
 </summary>
 <param name="task"></param>
 <param name="stack$"></param>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Utils.TaskRun(System.Action,System.String)">
 <summary>
 Run background task, if the <see cref="M:Microsoft.VisualBasic.Parallel.Tasks.AsyncHandle`1.GetValue"/> returns nothing, 
 then means the task run no errors.
 </summary>
 <param name="task"></param>
 <param name="stack">进行调用堆栈的上一层的栈名称</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Utils.Time(System.Action)">
 <summary>
 Returns the total executation time of the target <paramref name="work"/>.
 (性能测试工具，函数之中会自动输出整个任务所经历的处理时长)
 </summary>
 <param name="work">
 Function pointer of the task work that needs to be tested.(需要测试性能的工作对象)
 </param>
 <returns>Returns the total executation time of the target <paramref name="work"/>. ms</returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Utils.Wait(System.Func{System.Boolean})">
 <summary>
 假若条件判断<paramref name="handle"/>不为真的话，函数会一直阻塞线程，直到条件判断<paramref name="handle"/>为真
 </summary>
 <param name="handle"></param>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Utils.Wait(Microsoft.VisualBasic.ApplicationServices.Utils.TaskWaitHandle)">
 <summary>
 假若条件判断<paramref name="handle"/>不为真的话，函数会一直阻塞线程，直到条件判断<paramref name="handle"/>为真
 </summary>
 <param name="handle"></param>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Utils.CLIPath(System.String)">
 <summary>
 If the path string value is already wrappered by quot, then this function will returns the original string (DO_NOTHING).
 (假若命令行之中的文件名参数之中含有空格的话，则可能会造成错误，需要添加一个双引号来消除歧义)
 </summary>
 <param name="path"></param>
 <returns>
 A unix system compatible file path
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Utils.CLIToken(System.String)">
 <summary>
 <see cref="M:Microsoft.VisualBasic.ApplicationServices.Utils.CLIPath(System.String)"/>函数为了保持对Linux系统的兼容性会自动替换\为/符号，这个函数则不会执行这个替换
 </summary>
 <param name="token"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Utils.GetMIMEDescrib(System.String,System.Boolean)">
 <summary>
 ``*.txt -> text``，这个函数是作用于文件的拓展名之上的
 </summary>
 <param name="ext"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Utils.FileMimeType(System.String,System.Boolean)">
 <summary>
 与<see cref="M:Microsoft.VisualBasic.ApplicationServices.Utils.GetMIMEDescrib(System.String,System.Boolean)"/>所不同的是，这个函数是直接作用于文件路径之上的。
 </summary>
 <param name="path"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.Development.ApplicationInfoUtils">
 <summary>
 Parsing product assembly meta data
 </summary>
 <remarks>
 http://www.c-sharpcorner.com/uploadfile/ravesoft/access-assemblyinfo-file-and-get-product-informations/
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Development.ApplicationInfoUtils.RetrieveLinkerTimestamp(System.Reflection.Assembly)">
 <summary>
 Linker Timestamp
 </summary>
 
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Development.ApplicationInfoUtils.CalculateCompileTime(System.Reflection.Assembly)">
 <summary>
 计算出模块文件的编译时间.(在编译项目之前应该手动修改vbproj文件中的``Deterministic``配置项的值为False来允许自动递增版本号的特性)
 </summary>
 <param name="assm"></param>
 <returns></returns>
 <remarks>
 ### Get Compile date and time in application 
 
 > https://social.msdn.microsoft.com/forums/en-US/172201e0-c47b-40a8-a5d7-0a052cb42532/get-compile-date-and-time-in-application
 
 Set up your Build and MinorRevision numbers to auto-increment, pull out the date created for 
 by using the Version numbers from the version on the class. 
 
 1. Open ``AssemblyInfo.vb``.  You'll find it under the Properties folder in your solution.  
 Find the two lines that say "AssemblyVersion" and "AssemblyFileVersion" in them.  
 Change them to:

 ```vbnet
 &lt;assembly AssemblyVersion("1.0.*")>
 &lt;assembly AssemblyFileVersion("1.0.*")>
 ```

 Once you Do this, Visual Studio will automatically increment the last two values In the version.  
 
 2. The creation date can be found at runtime using the following algorithm:

 ```vbnet
 Dim version = Assembly.GetExecutingAssembly().GetName().Version
 Dim creationDate = New DateTime(2000, 1, 1).AddDays(version.Build).AddSeconds(version.MinorRevision * 2)
 ```
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Development.ApplicationInfoUtils.VBCore">
 <summary>
 获取对当前运行时环境的描述
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Development.ApplicationInfoUtils.CurrentExe">
 <summary>
 获取当前进程的exe文件的程序描述信息，直接使用New申明得到的只是运行时核心模块dll文件的信息
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Development.ApplicationInfoUtils.GetCompanyName(System.Reflection.Assembly)">
 <summary>
 Get the name of the system provider name from the assembly
 </summary>
 <param name="assm"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Development.ApplicationInfoUtils.GetProductVersion(System.Reflection.Assembly)">
 <summary>
 Get System version from the assembly
 </summary>
 <param name="assembly"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Development.ApplicationInfoUtils.GetProductName(System.Reflection.Assembly)">
 <summary>
 Get the name of the System from the assembly
 </summary>
 <param name="assembly"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Development.ApplicationInfoUtils.GetCopyRightsDetail(System.Reflection.Assembly)">
 <summary>
 Get the copyRights details from the assembly
 </summary>
 <param name="assembly"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Development.ApplicationInfoUtils.GetProductTitle(System.Reflection.Assembly)">
 <summary>
 Get the Product tile from the assembly
 </summary>
 <param name="assembly"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Development.ApplicationInfoUtils.GetProductDescription(System.Reflection.Assembly)">
 <summary>
 Get the description of the product from the assembly
 </summary>
 <param name="assembly"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.Development.AssemblyInfo">
 <summary>
 ``My Project\AssemblyInfo.vb``
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Development.AssemblyInfo.Guid">
 <summary>
 The following GUID is for the ID of the typelib if this project is exposed to COM
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Development.AssemblyInfo.BuiltTime">
 <summary>
 The compile date and time of the assembly file.
 </summary>
 <returns></returns>
 <remarks>
 ##### 20210715
 
 当这个值为空值的时候，JSON序列化会出错；
 所以假若需要进行JSON序列化，请及时赋值一个时间值，或者直接使用<see cref="P:Microsoft.VisualBasic.DateAndTime.Now"/>进行初始化
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Development.AssemblyInfo.GetType(System.String)">
 <summary>
 Gets the <see cref="T:System.Type"/> object with the specified name in the assembly instance.
 </summary>
 <param name="fullName">The full name of the type.</param>
 <returns>An object that represents the specified class, or null if the class is not found.</returns>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.Development.NamespaceDoc">
 <summary>
 The VisualBasic source code file related extension api module.
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.Development.NetCoreApp.deps">
 <summary>
 read deps.json for .net 5 assembly
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Development.NetCoreApp.deps.runtimeTarget">
 <summary>
 ".NETCoreApp,Version=v5.0"
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Development.NetCoreApp.deps.GetReferenceProject">
 <summary>
 get list of project reference name
 </summary>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Development.NetCoreApp.deps.RetriveLoadedAssembly">
 <summary>
 returns a list of file path loaded assembly files
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Development.NetCoreApp.deps.LoadAssemblyOrCache(System.String,System.Boolean)">
 <summary>
 load assembly from a given file path
 </summary>
 <param name="dllFile">full path</param>
 <returns>this function maybe returns nothing if the error happends
 andalso parameter value of <paramref name="strict"/> set to FALSE.</returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Development.NetCoreApp.deps.TryHandleNetCore5AssemblyBugs(System.Type,System.String[])">
 <summary>
 handling of the bugs on .NET 5 runtime
 missing assembly when load reference type module
 </summary>
 <param name="package"></param>
 
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Development.NetCoreApp.deps.TryHandleNetCore5AssemblyBugs(System.Reflection.Assembly,System.String[])">
 <summary>
 handling of the bugs on .NET 5 runtime
 missing assembly when load reference type module
 </summary>
 <param name="package"></param>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.Development.NetCoreApp.MSBuild">
 <summary>
 .NET core msbuild command wrapper
 
 ```
 dotnet msbuild
 ```
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Development.NetCoreApp.MSBuild.version">
 <summary>
 get dotnet version value
 </summary>
 <returns>
 nothing means dotnet msbuild is not installed
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Development.NetCoreApp.MSBuild.dotnetShell(System.String,System.Boolean)">
 <summary>
 shell dotnet commandline and then returns the standard output of the dotnet command.
 </summary>
 <param name="arguments"></param>
 <returns></returns>
</member>
<member name="F:Microsoft.VisualBasic.ApplicationServices.Development.XmlDoc.Serialization.APIExtensions.NamespaceDoc">
 <summary>
 NDoc supports this by recognising a special NamespaceDoc class located in each namespace
 
 > https://stackoverflow.com/questions/793210/xml-documentation-for-a-namespace
 
 这个名字的对象类型主要是被用来标记命名空间的注释信息使用的
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Development.XmlDoc.Serialization.APIExtensions.__trans(System.String)">
 <summary>
 这里会将双引号替换成为markdown里面的inline code形式
 </summary>
 <param name="cref"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.Development.XmlDoc.Serialization.Doc">
 <summary>
 .NET assembly generated XML comments documents file.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ApplicationServices.Development.XmlDoc.Serialization.memberTypes.Type">
 <summary>
 T
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ApplicationServices.Development.XmlDoc.Serialization.memberTypes.Filed">
 <summary>
 F
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ApplicationServices.Development.XmlDoc.Serialization.memberTypes.Method">
 <summary>
 M
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ApplicationServices.Development.XmlDoc.Serialization.memberTypes.Property">
 <summary>
 P
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ApplicationServices.Development.XmlDoc.Serialization.memberTypes.Event">
 <summary>
 E
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Development.XmlDoc.Serialization.param.name">
 <summary>
 the parameter name
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Development.XmlDoc.Serialization.param.text">
 <summary>
 the parameter description text
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Development.XmlDoc.Serialization.NamespaceDocExtensions.ScanAnnotations(Microsoft.VisualBasic.ApplicationServices.Development.XmlDoc.Assembly.ProjectSpace)">
 <summary>
 一般而言，一个命名空间之下只需要有一个注释类型即可，如果存在多个注释类型的话
 注释信息字符串会被合并在一起
 </summary>
 <param name="project"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.Development.XmlDoc.Assembly.Project">
 <summary>
 Describes a Project, a collection of related types and namespaces.  In this case, one Project = one DLL.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Development.XmlDoc.Assembly.Project.GetType(System.String)">
 <summary>
 当目标对象没有xml注释的时候，这个函数返回的是空值
 </summary>
 <param name="fullName"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.Development.XmlDoc.Assembly.ProjectMember">
 <summary>
 Base class for a method or property.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Development.XmlDoc.Assembly.ProjectMember.Params">
 <summary>
 the xml document text for the function/property parameters
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Development.XmlDoc.Assembly.ProjectMember.Declare">
 <summary>
 申明的原型
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Development.XmlDoc.Assembly.ProjectMember.example">
 <summary>
 example code for use this method
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.Development.XmlDoc.Assembly.ProjectNamespace">
 <summary>
 A namespace within a project -- typically a collection of related types.  Equates to a .net Namespace.
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.Development.XmlDoc.Assembly.ProjectSpace">
 <summary>
 A collection of one or more projects put together, and their attendant namespaces.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Development.XmlDoc.Assembly.ProjectSpace.ImportFromXmlDocFolder(System.String)">
 <summary>
 Batch imports of <see cref="M:Microsoft.VisualBasic.ApplicationServices.Development.XmlDoc.Assembly.ProjectSpace.ImportFromXmlDocFile(System.String)"/>
 </summary>
 <param name="path"></param>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Development.XmlDoc.Assembly.ProjectSpace.ImportFromXmlDocFile(System.String)">
 <summary>
 Imports xdoc document data from a specific xml file.
 </summary>
 <param name="path"></param>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Development.XmlDoc.Assembly.XmlDocs.Name">
 <summary>
 the member name
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Development.XmlDoc.Assembly.XmlDocs.Summary">
 <summary>
 Specifies the summary of the member. Use the &lt;summary> tag to describe a type or 
 a type member. Use &lt;remarks> to add supplemental information to a type description.
 
 The text For the &lt;summary> tag Is the only source Of information about the type 
 In IntelliSense, And Is also displayed In the Object Browser. 
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Development.XmlDoc.Assembly.XmlDocs.Remarks">
 <summary>
 Use the &lt;remarks> tag to add information about a type, supplementing the information specified with &lt;summary>.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ApplicationServices.Development.XmlDoc.Assembly.XmlDocs.LoadFromNode(System.Xml.XmlNode)">
 <summary>
 a unify method for read content data from xml
 </summary>
 <param name="xn"></param>
 <remarks>
 summary, remarks, keywords
 </remarks>
</member>
<member name="T:Microsoft.VisualBasic.ApplicationServices.Development.XmlDoc.Assembly.ProjectType">
 <summary>
 A type within a project namespace.
 </summary>
 <remarks>
 Fields和Events都不允许重载，但是属性和函数都可以重载
 </remarks>
</member>
<member name="F:Microsoft.VisualBasic.ApplicationServices.Development.XmlDoc.Assembly.ProjectType.properties">
 <summary>
 因为属性存在参数，所以可能会出现重载的情况
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ApplicationServices.Development.XmlDoc.Assembly.ProjectType.methods">
 <summary>
 会出现重载函数，所以这里也应该是一个list
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ApplicationServices.Development.XmlDoc.Assembly.ProjectType.Namespace">
 <summary>
 The namespace container of this type
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.VBDebugger">
 <summary>
 Debugger helper module for VisualBasic Enterprises System.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.VBDebugger.debugMode">
 <summary>
 if in the debug profile(which means ``DEBUG`` constant is defined for the compiler)
 then this function will always returns value ``true``;
 otherwise, return value by command line config argument ``--debug``
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.VBDebugger.die(System.String,System.Predicate{System.Object},System.String)">
 <summary>
 Assert that the expression value is correctly or not?
 </summary>
 <param name="message$">The exception message</param>
 <param name="failure">If this expression test is True, then die expression will raise an exception</param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.VBDebugger.LinqProc``1(System.Collections.Generic.IEnumerable{``0},System.String)">
 <summary>
 当在执行大型的数据集合的时候怀疑linq里面的某一个任务进入了死循环状态，可以使用这个方法来检查是否如此
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <param name="tag"></param>
 <returns></returns>
 
</member>
<member name="F:Microsoft.VisualBasic.VBDebugger.m_level">
 <summary>
 当前的调试器的信息输出登记，默认是输出所有的信息
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.VBDebugger.m_mute">
 <summary>
 是否静默掉所有的调试器输出信息？默认不是
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.VBDebugger.LoggingDriver">
 <summary>
 对外部开放的调试日志的获取接口类型的申明
 </summary>
 <param name="header">消息的类型的头部标签</param>
 <param name="message">消息文本内容，一般为一行文本</param>
 <param name="level">日志消息的错误等级</param>
</member>
<member name="P:Microsoft.VisualBasic.VBDebugger.Mute">
 <summary>
 Disable the debugger information outputs on the console if this <see cref="P:Microsoft.VisualBasic.VBDebugger.Mute"/> property is set to 
 <see cref="T:System.Boolean"/>, and enable the output if this property is set to <see cref="T:System.Boolean"/>. 
 NOTE: this debugger option property can be overrides by the debugger parameter from the CLI parameter 
 named ``--echo``
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.VBDebugger.ForceSTDError">
 <summary>
 Force the app debugging output redirect into the std_error device.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.VBDebugger.benchmark(System.Action,System.String)">
 <summary>
 Test how long this <paramref name="test"/> will takes.
 </summary>
 <param name="test"></param>
 <param name="trace$"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.VBDebugger.warning(System.String,System.Boolean)">
 <summary>
 Display the wraning level(YELLOW color) message on the console.
 </summary>
 <param name="msg"></param>
 <param name="mute"></param>
</member>
<member name="M:Microsoft.VisualBasic.VBDebugger.AttachLoggingDriver(Microsoft.VisualBasic.VBDebugger.LoggingDriver)">
 <summary>
 Add additional user logging driver
 </summary>
 <param name="driver"></param>
</member>
<member name="M:Microsoft.VisualBasic.VBDebugger.PrintException``1(``0,System.String,System.Boolean)">
 <summary>
 The function will print the exception details information on the standard <see cref="T:System.Console"/>, <see cref="M:Microsoft.VisualBasic.VBDebugger.debug(System.String,System.Boolean)"/> console, and system <see cref="T:System.Diagnostics.Trace"/> console.
 (分别在标准终端，调试终端，系统调试终端之中打印出错误信息，请注意，函数会直接返回False可以用于指定调用者函数的执行状态，这个函数仅仅是在终端上面打印出错误，不会保存为日志文件)
 </summary>
 <typeparam name="ex"></typeparam>
 <param name="exception"></param>
 
</member>
<member name="M:Microsoft.VisualBasic.VBDebugger.PrintException(System.String,System.String,System.Boolean)">
 <summary>
 可以使用这个方法<see cref="M:System.Reflection.MethodBase.GetCurrentMethod"/>.<see cref="M:Microsoft.VisualBasic.EmitReflection.GetFullName(System.Reflection.MethodBase,System.Boolean)"/>获取得到<paramref name="memberName"/>所需要的参数信息
 </summary>
 <param name="msg"></param>
 <param name="memberName"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.VBDebugger.WaitOutput">
 <summary>
 等待调试器输出工作线程将内部的消息队列输出完毕
 </summary>
 <remarks>
 ### 20230308
 
 Do not combine of this method with the echo method
 in this <see cref="T:Microsoft.VisualBasic.VBDebugger"/> module! Or a thread
 lock will be created and block the program running!
 
 So i make this function access level from public to 
 friend.
 </remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.VBDebugger.WriteLine(System.String,System.ConsoleColor)">
 <summary>
 输出的终端消息带有指定的终端颜色色彩
 </summary>
 <param name="msg"></param>
 <param name="color"></param>
 <remarks>
 works based on <see cref="F:Microsoft.VisualBasic.My.Log4VB.redirectInfo"/>
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.VBDebugger.Assertion(System.Boolean,System.String,Microsoft.VisualBasic.ApplicationServices.Debugging.Logging.MSG_TYPES,System.String)">
 <summary>
 If <paramref name="test"/> boolean value is False, then the assertion test failure. If the test is failure the specific message will be output on the console.
 </summary>
 <param name="test"></param>
 <param name="fails"></param>
 <param name="level"></param>
 <param name="calls"></param>
</member>
<member name="M:Microsoft.VisualBasic.VBDebugger.Assertion(System.String,Microsoft.VisualBasic.ApplicationServices.Debugging.Logging.MSG_TYPES,System.String)">
 <summary>
 If the <paramref name="test"/> message is not null or empty string, then the console will output the message.
 </summary>
 <param name="test"></param>
 <param name="level"></param>
 <param name="calls"></param>
</member>
<member name="M:Microsoft.VisualBasic.VBDebugger.Assertion(System.Boolean,System.String,System.String)">
 <summary>
 Use an assert statement to disrupt normal execution if a boolean condition is false.
 If <paramref name="test"/> is false(means this assertion test failure), then throw exception.
 </summary>
 <param name="test"></param>
 <param name="msg"></param>
</member>
<member name="M:Microsoft.VisualBasic.VBDebugger.debug(System.Text.StringBuilder,System.Int32)">
 <summary>
 Output the full debug information while the project is debugging in debug mode.
 (向标准终端和调试终端输出一些带有时间戳的调试信息)
 </summary>
 <param name="msg">The message fro output to the debugger console, this function will add a time stamp automaticly To the leading position Of the message.</param>
 <param name="Indent"></param>
</member>
<member name="M:Microsoft.VisualBasic.VBDebugger.EchoLine(System.String)">
 <summary>
 Alias for <see cref="M:System.Console.WriteLine"/>
 </summary>
 <param name="s">the text content for write line</param>
 <remarks>
 works based on <see cref="F:Microsoft.VisualBasic.My.Log4VB.redirectInfo"/>
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.VBDebugger.echo(System.Char)">
 <summary>
 Alias for <see cref="M:System.Console.Write(System.Boolean)"/>
 </summary>
 <param name="c"></param>
</member>
<member name="M:Microsoft.VisualBasic.VBDebugger.cat(System.String[])">
 <summary>
 print message, alias for <see cref="M:System.Console.Write(System.String)"/>.(支持``sprintf``之中的转义字符)
 </summary>
 <param name="s$"></param>
</member>
<member name="T:Microsoft.VisualBasic.Parallel.BufferPipe">
 <summary>
 the abstract base type of the package data
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Parallel.DataPipe">
 <summary>
 a <see cref="T:System.IO.MemoryStream"/> liked in-memory data
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Parallel.DataPipe.data">
 <summary>
 the in-memory data
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.DataPipe.#ctor(System.IO.MemoryStream)">
 <summary>
 extract all bytes data from the input <see cref="T:System.IO.MemoryStream"/> for construct a new data package
 </summary>
 <param name="data"></param>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.DataPipe.GetBlocks">
 <summary>
 get data in block formats
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.DataPipe.Read">
 <summary>
 get all data
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Parallel.ZipDataPipe">
 <summary>
 compress the in-memory buffer data
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.ZipDataPipe.#ctor(System.IO.MemoryStream)">
 <summary>
 extract all bytes data from the input <see cref="T:System.IO.MemoryStream"/> for construct a new data package
 </summary>
 <param name="data"></param>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.ZipDataPipe.GetBlocks">
 <summary>
 get data in zip-compressed stream
 </summary>
 <returns></returns>
 <remarks>
 just returns one block of the data, this function works based on the <see cref="M:Microsoft.VisualBasic.Parallel.ZipDataPipe.Read"/> function.
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.ZipDataPipe.Read">
 <summary>
 get data in zip-compressed stream
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.ZipDataPipe.UncompressBuffer(System.Byte[])">
 <summary>
 
 </summary>
 <param name="wrap">the zip data should has the magic header</param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Parallel.VectorTask">
 <summary>
 the parallel task helper
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Parallel.VectorTask.workLen">
 <summary>
 the input pending task sequence size
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Parallel.VectorTask.sequenceMode">
 <summary>
 set this flag value to value TRUE for run algorithm debug
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Parallel.VectorTask.cpu_count">
 <summary>
 <see cref="F:Microsoft.VisualBasic.Parallel.VectorTask.n_threads"/>
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Parallel.VectorTask.n_threads">
 <summary>
 set number of cpu threads for run current <see cref="T:Microsoft.VisualBasic.Parallel.VectorTask"/> parallel. 
 this thread value MUST BE configured before construct of the task object.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.VectorTask.#ctor(System.Int32,System.Boolean,System.Nullable{System.Int32})">
 <summary>
 construct a new parallel task executator
 </summary>
 <param name="nsize"></param>
 <remarks>
 the thread count for run the parallel task is configed
 via the <see cref="F:Microsoft.VisualBasic.Parallel.VectorTask.n_threads"/> by default.
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.VectorTask.Solve(System.Int32,System.Int32,System.Int32)">
 <summary>
 solve a sub task
 </summary>
 <param name="start">index offset start from zero</param>
 <param name="ends"></param>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.VectorTask.Solve">
 <summary>
 Run in sequence
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.VectorTask.Run">
 <summary>
 Run in parallel
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.VectorTask.Allocate``1(System.Boolean)">
 <summary>
 allocate a block of result output memory data for one thread task
 </summary>
 <typeparam name="TOut"></typeparam>
 <param name="all">
 allocate all result(len=<see cref="F:Microsoft.VisualBasic.Parallel.VectorTask.workLen"/>) when set this parameter value TRUE or 
 just for cpu worker thread(len=<see cref="F:Microsoft.VisualBasic.Parallel.VectorTask.cpu_count"/>) if set this parameter value 
 FALSE?
 </param>
 <returns></returns>
 <remarks>
 element count problem see the dev comments about the 
 parameter ``thread_id`` from function 
 <see cref="M:Microsoft.VisualBasic.Parallel.VectorTask.ParallelFor(System.Int32,System.Int32)"/>
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.VectorTask.ParallelFor(System.Int32,System.Int32)">
 <summary>
 implements the parallel for use the thread pool
 </summary>
 <param name="span_size"></param>
 <param name="thread_id">
 the thread id is start from based ZERO, but the upper index of 
 the thread id is equals to the <see cref="F:Microsoft.VisualBasic.Parallel.VectorTask.cpu_count"/>, so 
 group result vector should has value with ``<see cref="F:Microsoft.VisualBasic.Parallel.VectorTask.cpu_count"/> + 1`` elements.
 </param>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.VectorTask.CopyMemory``1(``0[],``0[],System.Int32)">
 <summary>
 copy all data of <paramref name="span"/> to the target region inside <paramref name="v"/>
 </summary>
 <typeparam name="T"></typeparam>
 <param name="v"></param>
 <param name="span">may be a part of region inside <paramref name="v"/></param>
 <param name="start"></param>
</member>
<member name="F:Microsoft.VisualBasic.Parallel.MMFProtocol.MapStream.MSIOReader._udtBadge">
 <summary>
 内存映射文件的更新标识符
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.MMFProtocol.MapStream.MSIOReader.#ctor(System.String,Microsoft.VisualBasic.Parallel.MMFProtocol.DataArrival,System.Int64)">
 <summary>
 
 </summary>
 <param name="uri"></param>
 <param name="callback"></param>
 <param name="ChunkSize">内存映射文件的数据块的预分配大小</param>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.MMFProtocol.MapStream.MSIOReader.ReadBadge">
 <summary>
 由于考虑到可能会传递很大的数据块，所以在这里检测数据更新的话只读取头部的8个字节的数据
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Parallel.MMFProtocol.MapStream.MSWriter">
 <summary>
 Memory stream writer
 </summary>
 <remarks>
 mmfServer的主要功能是创建并维护一个内存映射文件
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.MMFProtocol.MapStream.MSWriter.#ctor(System.String,System.Int64)">
 <summary>
 
 </summary>
 <param name="uri"></param>
 <remarks>对象实例会首先尝试以服务器的角色建立连接，当不成功的时候会以客户端的形式建立连接</remarks>
</member>
<member name="P:Microsoft.VisualBasic.Parallel.MMFProtocol.MapStream.MMFStream.udtBadge">
 <summary>
 Stamp; Update Badge
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Parallel.MMFProtocol.MapStream.MMFStream.byteData">
 <summary>
 内存映射文件中所存储的将要进行进程间交换的数据
 </summary>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.Parallel.MMFProtocol.DataArrival">
 <summary>
 客户端接受到的数据需要经过反序列化解码方能读取
 </summary>
 <param name="data"></param>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.Parallel.MMFProtocol.ReadNewMessage">
 <summary>
 
 </summary>
 <param name="message">UTF8 string</param>
</member>
<member name="T:Microsoft.VisualBasic.Parallel.MMFProtocol.MMFSocket">
 <summary>
 MMFProtocol socket object for the inter-process communication on the localhost, this can be using for the data exchange between two process.
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.MMFProtocol.MMFSocket.#ctor(System.String,System.Int64)">
 <summary>
 
 </summary>
 <param name="uri"></param>
 <param name="chunkSize">默认的区块大小为100KB，这个对于一般的小文本传输已经足够了</param>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.MMFProtocol.MMFSocket.#ctor(System.String,Microsoft.VisualBasic.Parallel.MMFProtocol.DataArrival)">
 <summary>
 
 </summary>
 <param name="uri"></param>
 <param name="dataArrivals">
 Public Delegate Sub <see cref="M:Microsoft.VisualBasic.Parallel.MMFProtocol.MMFSocket.__dataArrival(System.Byte[])"/>(byteData As <see cref="T:System.Byte"/>())
 会优先于事件<see cref="M:Microsoft.VisualBasic.Parallel.MMFProtocol.MMFSocket.__dataArrival(System.Byte[])"></see>的发生</param>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.MMFProtocol.MMFSocket.ReadData">
 <summary>
 直接从映射文件之中读取数据
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.MMFProtocol.MMFSocket.SendMessage(System.String)">
 <summary>
 
 </summary>
 <param name="s"><see cref="P:System.Text.Encoding.UTF8"/></param>
</member>
<member name="T:Microsoft.VisualBasic.Parallel.MMFProtocol.ProcessLock">
 <summary>
 进程排斥锁
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.VisualBasic.Parallel.MMFProtocol.ProcessLock._ProcessLock">
 <summary>
 进程排斥锁
 </summary>
 <remarks>
 程序中采用一个进程排斥锁是由于待日后Mono运行时环境在Linux平台中的WinForm GTK成熟后，向Linux平台迁移，
 由于Visual Baisc/C#所编写的应用程序需要保持单个进程，则需要启用应用程序框架，而很多情况下为了优化的需求应用程序
 无法使用应用程序框架，为了实现一次编译到处运行的目的，程序的代码不会再平台间进行修改，
 由于Linux平台之上不能使用Win32API来保持单进程，为了保持程序对Windows/Linux/MAC三大操作系统的兼容性，故而在这里使用了一个进程排斥锁
 </remarks>
</member>
<member name="F:Microsoft.VisualBasic.Parallel.MMFProtocol.ProcessLock.f_ProcessLock">
 <summary>
 进程锁的排斥情况
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.MMFProtocol.ProcessLock.#ctor(System.String)">
 <summary>
 
 </summary>
 <param name="strHost">进程排斥锁的锁名</param>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.Parallel.MMFProtocol.ProcessLock.Locked">
 <summary>
 返回当前的进程是否被加锁
 </summary>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.MMFProtocol.WorkFlow.FolkProc``2(System.String,System.String,``0,System.Func{``0,System.Byte[]},System.Func{System.Byte[],``1})">
 <summary>
 创建出一个子进程，然后按照命令行参数<paramref name="CLI"/>执行制定的命令，同时通过内存映射传递复杂参数，最后结束后通过内存映射传递回数据
 主要是通过内存映射减少数据IO的时间，加快计算流程
 </summary>
 <typeparam name="TIn"></typeparam>
 <typeparam name="TOut"></typeparam>
 <param name="exe"></param>
 <param name="CLI"></param>
 <param name="[in]"></param>
 <param name="writer"></param>
 <param name="reader"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.TimeOutAPI.OperationTimeOut``2(System.Func{``0,``1},``0,``1@,System.Double)">
 <summary>
 The returns value of TRUE represent of the target operation has been time out.(返回真，表示操作超时)
 </summary>
 <typeparam name="T"></typeparam>
 <typeparam name="TOut"></typeparam>
 <param name="handle"></param>
 <param name="out"></param>
 <param name="timeOut">The time unit of this parameter is second.(单位为秒)</param>
 <returns></returns>
 <remarks></remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.Parallel.TimeOutAPI.OperationTimeOut``1(System.Func{``0},``0@,System.Double)">
 <summary>
 
 </summary>
 <typeparam name="T"></typeparam>
 <param name="handle"></param>
 <param name="Out"></param>
 <param name="TimeOut">The time unit of this parameter is second.(单位为秒)</param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Parallel.TimeOutAPI.OperationTimeOut(System.Action,System.Double)">
 <summary>
 
 </summary>
 <param name="handle"></param>
 <param name="TimeOut">The time unit of this parameter is second.(单位为秒)</param>
 <returns></returns>
 
</member>
<member name="T:Microsoft.VisualBasic.Parallel.DataRequestHandler">
 <summary>
 
 </summary>
 <param name="request"></param>
 <param name="RemoteAddress"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Parallel.RequestStream">
 <summary>
 Socket user client => Socket server data request &amp;
 Socket server => Socket user client data response package.
 (Socket客户端 => Socket服务器所发送的数据请求以及从
 Socket服务器 => Socket客户端所返回数据的数据响应包)
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Parallel.RequestStream.ProtocolCategory">
 <summary>
 This property indicates the protocol processor module for the server object.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Parallel.RequestStream.Protocol">
 <summary>
 This property indicates which the specifics protocol processor will be 
 used for the incoming client request.
 (协议的头部)
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Parallel.RequestStream.BufferLength">
 <summary>
 Buffer length of the protocol request raw stream data <see cref="P:Microsoft.VisualBasic.Parallel.RequestStream.ChunkBuffer"/>.
 (协议数据的长度)
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Parallel.RequestStream.ChunkBuffer">
 <summary>
 The raw stream data of the details data request or the server response data.
 </summary>
 <returns></returns>
 <remarks>
 (协议的具体数据请求)
 </remarks>
</member>
<member name="P:Microsoft.VisualBasic.Parallel.RequestStream.FullRead">
 <summary>
 verify that the stream data in <see cref="P:Microsoft.VisualBasic.Parallel.RequestStream.ChunkBuffer"/> is recieve complete?
 (<see cref="P:Microsoft.VisualBasic.Parallel.RequestStream.ChunkBuffer"/>部分的数据是否完整？)
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.RequestStream.#ctor(System.Int64,System.Int64,System.Byte[])">
 <summary>
 
 </summary>
 <param name="protocolCategory"></param>
 <param name="protocol"></param>
 <param name="buffer"><see cref="P:Microsoft.VisualBasic.Parallel.RequestStream.ChunkBuffer"/></param>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.RequestStream.#ctor(System.Int64,System.Int64)">
 <summary>
 构建一个无参数的网络协议对象
 </summary>
 <param name="ProtocolCategory"></param>
 <param name="Protocol"></param>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.RequestStream.#ctor(System.Int64,System.Int64,System.String)">
 <summary>
 The default text encoding is <see cref="P:System.Text.Encoding.UTF8"/>
 </summary>
 <param name="protocolCategory"></param>
 <param name="protocol"></param>
 <param name="strData">Protocol request argument parameters</param>
 
</member>
<member name="M:Microsoft.VisualBasic.Parallel.RequestStream.#ctor(System.String)">
 <summary>
 其余的协议参数都是值 <see cref="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_OK"/>
 </summary>
 <param name="data"></param>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.RequestStream.#ctor(System.Byte[])">
 <summary>
 Deserialize (当还有剩余数据的时候会将数据进行剪裁)
 </summary>
 <param name="rawStream"></param>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.RequestStream.GetUTF8String">
 <summary>
 默认是使用UTF8编码来编码字符串的
 </summary>
 <returns>
 这个函数总是返回一个不为空值的字符串
 </returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Parallel.RequestStream.GetString(System.Text.Encoding)">
 <summary>
 按照指定的编码构建出一个字符串值
 </summary>
 <param name="encoding"></param>
 <returns>
 这个函数总是返回一个不为空值的字符串
 </returns>
 <remarks>
 20240620
 
 the string may contains may zero byte after the string data,
 so we needs to trim such zero bytes for avoid the possible 
 string parser error.
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.RequestStream.LoadObject``1(Microsoft.VisualBasic.Scripting.Abstract.LoadObject{``0})">
 <summary>
 将数据首先生成字符串，然后根据函数指针<paramref name="handler"/>句柄的描述从字符串之中反序列化加载对象
 </summary>
 <typeparam name="T"></typeparam>
 <param name="handler"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Parallel.RequestStream.LoadObject``1">
 <summary>
 json
 </summary>
 <typeparam name="T"></typeparam>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Parallel.RequestStream.GetRawStream``1">
 <summary>
 从原始数据流<see cref="P:Microsoft.VisualBasic.Parallel.RequestStream.ChunkBuffer"/>之中进行反序列化得到一个嵌套的数据串流对象
 </summary>
 <typeparam name="TStream"></typeparam>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.RequestStream.CreateProtocol``1(System.Int64,System.Int64,``0)">
 <summary>
 这个函数是使用json序列化参数信息的
 </summary>
 <typeparam name="T"></typeparam>
 <param name="category"></param>
 <param name="protocol"></param>
 <param name="params"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.RequestStream.CreatePackage``1(``0)">
 <summary>
 服务器端返回数据所使用的，默认使用json序列化，所有的标签为<see cref="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_OK"/>
 </summary>
 <typeparam name="T"></typeparam>
 <param name="obj"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.RequestStream.CreatePackage(System.Byte[])">
 <summary>
 服务器端返回数据所使用的，所有的标签为<see cref="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_OK"/>
 </summary>
 <param name="pack"></param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Parallel.RequestStream.TotalBytes">
 <summary>
 注意：在协议头部之间还存在着一个字节的offset，这个字节的值为255
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.RequestStream.Serialize(System.IO.Stream)">
 <summary>
 执行序列化进行网络之间的数据传输
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Parallel.RequestStream.SYS_PROTOCOL">
 <summary>
 系统里面最基本的基本数据协议
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Parallel.RequestStream.Protocols">
 <summary>
 最基本的Socket数据串流协议
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Parallel.RequestStream.Protocols.SSL">
 <summary>
 私有密匙加密
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Parallel.RequestStream.Protocols.SSL_PublicToken">
 <summary>
 公共密匙加密
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Parallel.RequestStream.Protocols.InvalidCertificates">
 <summary>
 无效的数字证书
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Parallel.RequestStream.IsSSLProtocol">
 <summary>
 这个请求数据是一个SSL加密数据（使用用户的私有密匙）
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Parallel.RequestStream.IsSSL_PublicToken">
 <summary>
 使用公共密匙
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Parallel.RequestStream.IsPlantText">
 <summary>
 这个数据仅仅是一个文本，没有包含有任何协议头数据
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Parallel.RequestStream.IsSSLHandshaking">
 <summary>
 这个请求数据是否为握手协议
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.RequestStream.op_Equality(Microsoft.VisualBasic.Parallel.RequestStream,Microsoft.VisualBasic.Parallel.RequestStream)">
 <summary>
 简单的字符串等价
 </summary>
 <param name="a"></param>
 <param name="b"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Parallel.Tasks.Actor`2">
 <summary>
 This Actor class can be used to call a function which has one 
 parameter, object (T) and returns the result, object (V). The 
 result is returned in a delegate.
 </summary>
 <typeparam name="T">Input type</typeparam>
 <typeparam name="V">Output type</typeparam>
</member>
<member name="P:Microsoft.VisualBasic.Parallel.Tasks.Actor`2.State.parameter">
 <summary>
 This is the parameter which is passed to the function
 defined as job.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Parallel.Tasks.Actor`2.State.result">
 <summary>
 This will be the response and will be sent back to the 
 calling thread using the delegate (a).
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Parallel.Tasks.Actor`2.State.job">
 <summary>
 Actual method to run.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Parallel.Tasks.Actor`2.State.error">
 <summary>
 Capture any errors and send back to the calling thread.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.Tasks.Actor`2.State.Run">
 <summary>
  Set as an internal types void so only the Actor class can  
  invoke this method.
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Parallel.Tasks.AsyncHandle`1">
 <summary>
 Represents the status of an asynchronous operation.(背景线程加载数据)
 </summary>
 <typeparam name="TOut"></typeparam>
 <remarks>
 这个后台任务模块是为了更加方便的构建出匿名方法的调用过程，因为这个对象的
 工作原理是基于匿名方法的``BeginInvoke``函数来工作的。
 </remarks>
</member>
<member name="P:Microsoft.VisualBasic.Parallel.Tasks.AsyncHandle`1.Task">
 <summary>
 封装一个方法，该方法不具有参数，且返回由<typeparamref name="TOut"></typeparamref>参数指定的类型的值。
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Parallel.Tasks.AsyncHandle`1.IsCompleted">
 <summary>
 Gets a value that indicates whether the asynchronous operation has completed.
 (获取一个值，该值指示异步操作是否已完成。)
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.Tasks.AsyncHandle`1.#ctor(System.Func{`0})">
 <summary>
 Creates a new background task from a function handle.
 </summary>
 <param name="Task"></param>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.Tasks.AsyncHandle`1.Run">
 <summary>
 Start the background task thread.(启动后台背景线程)
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.Tasks.AsyncHandle`1.GetValue">
 <summary>
 Current thread will be blocked at here if the background task not finished.
 (没有完成的时候会一直在这里阻塞当前的线程)
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Parallel.Tasks.IBackgroundTask`1">
 <summary>
 背景线程的任务抽象
 </summary>
 <typeparam name="T"></typeparam>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Parallel.Tasks.BackgroundTask`1.Value">
 <summary>
 获取得到任务线程执行的输出结果
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.Tasks.BackgroundTask`1.Abort">
 <summary>
 取消当前的任务的执行，在线程内部产生的异常可以在<see cref="P:Microsoft.VisualBasic.Parallel.Tasks.BackgroundTask`1.ExecuteException"/>获取得到
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Parallel.Tasks.RevokableTaskLoop">
 <summary>
 可以被取消的循环对象
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Parallel.Tasks.RevokableTaskLoop`1">
 <summary>
 可以被取消的循环对象
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Parallel.Tasks.CallbackTask">
 <summary>
 When the task job complete, then the program will notify user code through callback function.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.Tasks.IParallelTask.WaitForExit">
 <summary>
 这个函数会检查<see cref="P:Microsoft.VisualBasic.Parallel.Tasks.IParallelTask.TaskComplete"/>属性来判断任务是否执行完毕
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Parallel.Tasks.Task`2">
 <summary>
 更加底层的线程模式，和LINQ相比不会受到CPU核心数目的限制
 </summary>
 <typeparam name="T">后台任务的执行参数</typeparam>
 <typeparam name="TOut">后台任务的执行结果</typeparam>
</member>
<member name="P:Microsoft.VisualBasic.Parallel.Tasks.Task`2.Value">
 <summary>
 假若任务已经完成，则会返回计算值，假若没有完成，则只会返回空值，
 假若想要在任何情况之下都会得到后台任务所执行的计算结果，
 请使用<see cref="M:Microsoft.VisualBasic.Parallel.Tasks.Task`2.GetValue"/>方法
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.Tasks.Task`2.GetValue">
 <summary>
 假若后台任务还没有完成，则函数会一直阻塞在这里直到任务执行完毕，
 假若任务早已完成，则函数会立即返回数据
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Parallel.Tasks.TaskQueue`1">
 <summary>
 这个只有一条线程来执行
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Parallel.Tasks.TaskQueue`1.__tasks">
 <summary>
 ###### 2018-1-27
 
 如果直接在这里使用<see cref="P:Microsoft.VisualBasic.App.BufferSize"/>的话，极端的情况下会导致服务器的内存直接被耗尽
 所以在这里使用一个较小的常数值
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Parallel.Tasks.TaskQueue`1.Tasks">
 <summary>
 返回当前的任务池之中的任务数量
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Parallel.Tasks.TaskQueue`1.RunningTask">
 <summary>
 当这个属性为False的时候说明没有任务在执行，此时为空闲状态
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Parallel.Tasks.TaskQueue`1.uid">
 <summary>
 the unique name of current task
 </summary>
 <returns></returns>
</member>
<member name="F:Microsoft.VisualBasic.Parallel.Tasks.TaskQueue`1.task_name">
 <summary>
 the name of the task is running
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.Tasks.TaskQueue`1.#ctor(System.String,System.Int32,System.Action{System.String,System.Exception})">
 <summary>
 会单独启动一条新的线程来用来执行任务队列
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.Tasks.TaskQueue`1.Join(System.Func{Microsoft.VisualBasic.Parallel.Tasks.TaskQueue{`0}.TaskWorker,`0})">
 <summary>
 函数会被插入一个队列之中，之后线程会被阻塞在这里直到函数执行完毕，这个主要是用来控制服务器上面的任务并发的
 一般情况下不会使用这个方法，这个方法主要是控制服务器资源的利用程序的，当线程处于忙碌的状态的时候，
 当前线程会被一直阻塞，直到线程空闲
 </summary>
 <param name="handle"></param>
 <returns>假若本对象已经开始Dispose了，则为完成的任务都会返回Nothing</returns>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.Tasks.TaskQueue`1.Enqueue(System.Func{Microsoft.VisualBasic.Parallel.Tasks.TaskQueue{`0}.TaskWorker,`0},System.Action{`0},System.String)">
 <summary>
 这个函数只会任务添加到队列之中，而不会阻塞线程
 </summary>
 <param name="handle"></param>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.Tasks.TaskQueue`1.__taskQueueEXEC">
 <summary>
 有一条线程单独执行这个任务队列
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Parallel.Tasks.TaskQueue`1.TaskWorker">
 <summary>
 A task
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Parallel.Tasks.TaskQueue`1.TaskWorker.progress">
 <summary>
 [0,100]
 </summary>
 <remarks>
 negative value means no progress report
 </remarks>
</member>
<member name="T:Microsoft.VisualBasic.Parallel.Tasks.UpdateThread">
 <summary>
 Running a specific <see cref="T:System.Action"/> in the background periodically.
 (比较适合用于在服务器上面执行周期性的计划任务)
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Parallel.Tasks.UpdateThread.Periods">
 <summary>
 The timer interval, sleeps n **ms** interval
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Parallel.Tasks.UpdateThread.ErrHandle">
 <summary>
 If this exception handler is null, then when the unhandled exception occurring,
 this thread object will throw the exception and then stop working.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Parallel.Tasks.UpdateThread.Running">
 <summary>
 指示当前的这个任务处理对象是否处于运行状态
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Parallel.Tasks.UpdateThread.Caller">
 <summary>
 The caller stack name
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.Tasks.UpdateThread.#ctor(System.Int32,System.Action,System.String)">
 <summary>
 Running a specific action in the background periodically. The time unit of the parameter <paramref name="Periods"/> is ms or Ticks.
 </summary>
 <param name="periods">ms for update thread sleeps</param>
 <param name="updates"></param>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.Tasks.UpdateThread.Start">
 <summary>
 运行这条线程，假若更新线程已经在运行了，则会自动忽略这次调用
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.Tasks.UpdateThread.Stop">
 <summary>
 停止更新线程的运行
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.Tasks.UpdateThread.GetTicks(System.Int32,System.Int32,System.Int32)">
 <summary>
 获取得到总的毫秒数
 </summary>
 <param name="hh"></param>
 <param name="mm"></param>
 <param name="ss%"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Parallel.GroupResult`2">
 <summary>
 分组操作的结果
 </summary>
 <typeparam name="T">Group的元素的类型</typeparam>
 <typeparam name="Itag">Group的Key的类型</typeparam>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.GroupAPI.ParallelGroup``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
 <summary>
 貌似使用LINQ进行Group操作的时候是没有并行化的，灰非常慢，则可以使用这个拓展函数来获取较好的性能
 </summary>
 <typeparam name="T"></typeparam>
 <typeparam name="T_TAG"></typeparam>
 <param name="source"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Parallel.Linq.LQuerySchedule">
 <summary>
 Parallel Linq query library for VisualBasic.
 (用于高效率执行批量查询操作和用于检测操作超时的工具对象，请注意，为了提高查询的工作效率，请尽量避免在查询操作之中生成新的临时对象
 并行版本的LINQ查询和原始的线程操作相比具有一些性能上面的局限性)
 </summary>
 <remarks>
 在使用``Parallel LINQ``的时候，请务必要注意不能够使用Let语句操作共享变量，因为排除死锁的开销比较大
 
 在设计并行任务的时候应该遵循的一些原则:
 
 1. 假若每一个任务之间都是相互独立的话，则才可以进行并行化调用
 2. 在当前程序域之中只能够通过线程的方式进行并行化，对于时间较短的任务而言，非并行化会比并行化更加有效率
 3. 但是对于这些短时间的任务，仍然可以将序列进行分区合并为一个大型的长时间任务来产生并行化
 4. 对于长时间的任务，可以直接使用并行化Linq拓展执行并行化
 
 这个模块主要是针对大量的短时间的任务序列的并行化的，用户可以在这里配置线程的数量自由的控制并行化的程度
 </remarks>
</member>
<member name="P:Microsoft.VisualBasic.Parallel.Linq.LQuerySchedule.CPU_NUMBER">
 <summary>
 Get the number of processors on the current machine.
 </summary>
 <value></value>
 <returns>
 A reference to the <see cref="P:System.Environment.ProcessorCount"/>
 </returns>
 <remarks>(获取当前的系统主机的CPU核心数)</remarks>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.Linq.LQuerySchedule.AutoConfig(System.Int32)">
 <summary>
 假如小于0，则认为是自动配置，0被认为是单线程，反之直接返回
 </summary>
 <param name="n"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.Linq.LQuerySchedule.LQuery``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Int32)">
 <summary>
 将大量的短时间的任务进行分区，合并，然后再执行并行化，请注意，<paramref name="task"/>参数不能够使lambda表达式，否则会出现EntryNotFound的错误
 </summary>
 <typeparam name="T"></typeparam>
 <typeparam name="TOut"></typeparam>
 <param name="inputs"></param>
 <param name="task"></param>
 <param name="parTokens">函数参数是每一个分区里面的元素的数量</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.Linq.LQuerySchedule.LQuery``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,System.Boolean},System.Int32)">
 <summary>
 将大量的短时间的任务进行分区，合并，然后再执行并行化
 </summary>
 <typeparam name="T"></typeparam>
 <typeparam name="TOut"></typeparam>
 <param name="inputs"></param>
 <param name="task"></param>
 <param name="where">Processing where test on the inputs</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.Linq.LQuerySchedule.LQuery``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``1,System.Boolean},System.Int32)">
 <summary>
 将大量的短时间的任务进行分区，合并，然后再执行并行化
 </summary>
 <typeparam name="T"></typeparam>
 <typeparam name="TOut"></typeparam>
 <param name="inputs"></param>
 <param name="task"></param>
 <param name="outWhere">Processing where test on the output</param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Parallel.Linq.TaskPartitions">
 <summary>
 对大量的短时间的任务进行分区的操作是在这里完成的
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.Linq.TaskPartitions.PartTokens(System.Int32,System.Int32)">
 <summary>
 根据任务总量计算出所需要的线程的数量
 </summary>
 <param name="source"></param>
 <param name="num_threads"></param>
 <returns></returns>
 <remarks>假设所有的任务都被平均的分配到每一个线程之上</remarks>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.Linq.TaskPartitions.SplitIterator``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Boolean)">
 <summary>
 Performance the partitioning operation on the input sequence.
 (请注意，这个函数适用于数量非常多的序列。对所输入的序列进行分区操作，<paramref name="parTokens"/>函数参数是每一个分区里面的元素的数量)
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <param name="parTokens">每一个分区之中的元素数量</param>
 <returns></returns>
 <remarks>对于数量较少的序列，可以使用<see cref="M:Microsoft.VisualBasic.Parallel.Linq.TaskPartitions.SplitIterator``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Boolean)"/>进行分区操作，
 该函数使用数组的<see cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)"/>方法进行分区复制，效率较高
 
 由于本函数需要处理大量的数据，使用Array的方法会内存占用较厉害，所以在这里更改为List操作以降低内存的占用
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.Linq.TaskPartitions.Partitioning``2(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Func{``0,``1})">
 <summary>
 进行分区之后返回一个长时间的任务组合
 </summary>
 <typeparam name="T"></typeparam>
 <param name="parts">函数参数是每一个分区里面的元素的数量</param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Parallel.Linq.TaskPartitions.Partitioning``2(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Func{``0,``1},System.Func{``0,System.Boolean})">
 <summary>
 进行分区之后返回一个长时间的任务组合
 </summary>
 <typeparam name="T"></typeparam>
 <returns></returns>
 
</member>
<member name="T:Microsoft.VisualBasic.Parallel.Linq.TaskPartitions.__taskHelper`2">
 <summary>
 因为在上一层调用之中使用了并行化，所以在这里不能够使用并行化拓展了
 </summary>
 <typeparam name="T"></typeparam>
 <typeparam name="out"></typeparam>
</member>
<member name="T:Microsoft.VisualBasic.Parallel.ParallelExtension">
 <summary>
 Parallel based on the threading
 </summary>
 
</member>
<member name="M:Microsoft.VisualBasic.Parallel.ParallelExtension.DoEvents``1(System.Func{``0})">
 <summary>
 execute the given <paramref name="func"/>, and hen do events
 </summary>
 <typeparam name="T"></typeparam>
 <param name="func"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.ParallelExtension.RunTask(System.Threading.ThreadStart,System.String)">
 <summary>
 Start a new thread and then returns the background thread task handle.
 </summary>
 <param name="start"></param>
 <returns>
 the thread method <see cref="M:System.Threading.Thread.Start"/> is already be called
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.ParallelExtension.AsyncTask(System.Threading.ThreadStart)">
 <summary>
 运行一个后台任务
 </summary>
 <param name="start"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Parallel.Threads.ThreadPool">
 <summary>
 使用多条线程来执行任务队列，推荐在编写Web服务器的时候使用这个模块来执行任务
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Parallel.Threads.ThreadPool.pendings">
 <summary>
 临时的句柄缓存
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Parallel.Threads.ThreadPool.NumOfThreads">
 <summary>
 线程池之中的线程数量
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Parallel.Threads.ThreadPool.WorkingThreads">
 <summary>
 返回当前正在处于工作状态的线程数量
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Parallel.Threads.ThreadPool.FullCapacity">
 <summary>
 是否所有的线程都是处于工作状态的
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.Threads.ThreadPool.Start">
 <summary>
 Start the background task, and stop until the <see cref="M:Microsoft.VisualBasic.Parallel.Threads.ThreadPool.Dispose"/> method has been called
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.Threads.ThreadPool.GetStatus">
 <summary>
 获取当前的这个线程池对象的状态的摘要信息
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.Threads.ThreadPool.RunTask(System.Action{Microsoft.VisualBasic.Parallel.Tasks.TaskQueue{System.Int64}.TaskWorker},System.Action{System.Int64},System.String)">
 <summary>
 Push a new task into the parallel task queue.
 (使用线程池里面的空闲线程来执行任务)
 </summary>
 <param name="task"></param>
 <param name="callback">回调函数里面的参数是任务的执行的时间长度</param>
 <param name="name">the name of current task</param>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.Threads.ThreadPool.RunTask(System.Action,System.Action{System.Int64},System.String)">
 <summary>
 Push a new task into the parallel task queue.
 (使用线程池里面的空闲线程来执行任务)
 </summary>
 <param name="task"></param>
 <param name="callback">回调函数里面的参数是任务的执行的时间长度</param>
 <param name="name">the name of current task</param>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.Threads.ThreadPool.OperationTimeOut(System.Action,System.Int32)">
 <summary>
 Run a speicifc task with assert of operation 
 is time out or not.
 </summary>
 <param name="task">
 A specific task to run
 </param>
 <param name="timeout">
 wait timeout in unit milliseconds
 </param>
 <returns>
 + true means timeout, the task has not been finished;
 + false means the task has been execute success without timeout
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.Threads.ThreadPool.allocate">
 <summary>
 allocate the task into the task thread pool
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.Threads.ThreadPool.__taskInvoke.Run(Microsoft.VisualBasic.Parallel.Tasks.TaskQueue{System.Int64}.TaskWorker)">
 <summary>
 不清楚是不是因为lambda有问题，所以导致计时器没有正常的工作，所以在这里使用内部类来工作
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.Threads.ThreadPool.GetAvaliableThread">
 <summary>
 这个函数总是会返回一个线程对象的
 
 + 当有空闲的线程，会返回第一个空闲的线程
 + 当没有空闲的线程，则会返回任务队列最短的线程
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.Threads.ThreadStart.Execute(System.Collections.Generic.IEnumerable{Microsoft.VisualBasic.Parallel.Threads.ThreadStart})">
 <summary>
 Run parallel task
 </summary>
 <param name="tasks"></param>
 <remarks>
 run tasks in batch mode based on the <see cref="M:System.Threading.Tasks.Task.Run(System.Action)"/>
 </remarks>
</member>
<member name="T:Microsoft.VisualBasic.Parallel.ThreadQueue">
 <summary>
 任务线程队列
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Parallel.ThreadQueue.MultiThreadSupport">
 <summary>
 If TRUE, the Writing process will be separated from the main thread.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Parallel.ThreadQueue.queue">
 <summary>
 Just my queue
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Parallel.ThreadQueue.dummy">
 <summary>
 lock
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Parallel.ThreadQueue.xThread">
 <summary>
 Writer Thread ☺
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Parallel.ThreadQueue.QSolverRunning">
 <summary>
 Is thread running?
 hum
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Parallel.ThreadQueue.Sleep">
 <summary>
 任务队列是否是处于休眠状态?(任务队列的内容是空的)
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Parallel.ThreadQueue.RunningTask">
 <summary>
 get the task that is running now.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.ThreadQueue.AddToQueue(System.Action)">
 <summary>
 Add an Action to the queue.
 </summary>
 <param name="A">``() => { .. }``, 任务的执行内容</param>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.ThreadQueue.WaitQueue">
 <summary>
 Wait for all thread queue job done.(Needed if you are using multiThreaded queue)
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.ThreadQueue.ExecQueue">
 <summary>
 Execute the queue list
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Parallel.ThreadQueue.ThreadLoop">
 <summary>
 running all task inside current <see cref="F:Microsoft.VisualBasic.Parallel.ThreadQueue.queue"/>
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.CommandLine.CLIMapper">
 <summary>
 从可写属性之中赋值
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CLIMapper.Maps``1(Microsoft.VisualBasic.CommandLine.CommandLine,System.Boolean)">
 <summary>
 Assign the argument value in the commandline into the target argument container object.
 The properties in the container class type needs decorating with attribute
 
 (这个拓展函数是将命令行对象反序列化为参数对象)
 <see cref="T:Microsoft.VisualBasic.CommandLine.Reflection.Argv"/>
 </summary>
 <typeparam name="T"></typeparam>
 <param name="args"></param>
 <param name="strict"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CLIMapper.GetName(System.Reflection.PropertyInfo)">
 <summary>
 If the property <paramref name="prop"/> have the custom attribute <see cref="T:Microsoft.VisualBasic.CommandLine.Reflection.Argv"/>
 then the name value in <see cref="T:Microsoft.VisualBasic.CommandLine.Reflection.Argv"/> will be used, otherwise, 
 <see cref="P:System.Reflection.MemberInfo.Name"/> will be used. 
 </summary>
 <param name="prop"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.CommandLine.CliResCommon">
 <summary>
 CLI resources manager
 
 (将程序内部自身的资源数据释放到文件的帮助对象)
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CliResCommon.#ctor(System.String,System.Type)">
 <summary>
 内部资源为一个可执行文件，其将会被释放到<paramref name="EXPORT"/>文件夹之中
 </summary>
 <param name="EXPORT">资源文件的数据缓存文件夹</param>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CliResCommon.TryRelease(System.String,System.String)">
 <summary>
 
 </summary>
 <param name="Name">使用 NameOf 操作符来获取资源</param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.CommandLine.CLITools">
 <summary>
 CLI parser and <see cref="T:Microsoft.VisualBasic.CommandLine.CommandLine"/> object creates.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CLITools.GetFileList(System.String)">
 <summary>
 在命令行之中使用逗号作为分隔符分隔多个文件
 </summary>
 <param name="input"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CLITools.AppSummary(Microsoft.VisualBasic.ApplicationServices.Development.AssemblyInfo,System.String,System.String,System.IO.TextWriter)">
 <summary>
 
 </summary>
 <param name="assem"></param>
 <param name="description">命令行的使用功能描述信息文本</param>
 <param name="SYNOPSIS">命令行的使用语法</param>
 <param name="write"></param>
 
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CLITools.Args">
 <summary>
 Gets the commandline object for the current program.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CLITools.Join(System.Collections.Generic.IEnumerable{System.String})">
 <summary>
 ReGenerate the cli command line argument string text.(重新生成命令行字符串)
 </summary>
 <param name="tokens">
 If the token value have a space character, then this function 
 will be wrap that token with quot character automatically.
 </param>
 <returns></returns>
 <remarks></remarks>
 
</member>
<member name="F:Microsoft.VisualBasic.CommandLine.CLITools.SPLIT_REGX_EXPRESSION">
 <summary>
 A regex expression string that use for split the commandline text.
 (用于分析命令行字符串的正则表达式)
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CLITools.GetTokens(System.String)">
 <summary>
 Try parse the argument tokens which comes from the user input commandline string. 
 (尝试从用户输入的命令行字符串之中解析出所有的参数)
 </summary>
 <param name="CLI"></param>
 <returns></returns>
 <remarks></remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CLITools.tupleParser(System.String,Microsoft.VisualBasic.Language.List{System.String}@)">
 <summary>
 只取第一个=符号出现的位置，结果会被添加进入<paramref name="argv"/>列表之中
 </summary>
 <param name="s$"></param>
 <param name="argv"></param>
</member>
<member name="F:Microsoft.VisualBasic.CommandLine.CLITools.TokenSplitRegex">
 <summary>
 会对%进行替换的
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CLITools.TryParse(System.String,System.String,System.Char)">
 <summary>
 尝试从输入的语句之中解析出词法单元，注意，这个函数不是处理从操作系统所传递进入的命令行语句
 </summary>
 <param name="CommandLine"></param>
 <returns></returns>
 <remarks></remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CLITools.CreateObject(System.String,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}},System.Collections.Generic.IEnumerable{System.String})">
 <summary>
 Creates command line object from a set obj <see cref="T:System.Collections.Generic.KeyValuePair`2"/>
 </summary>
 <param name="name"></param>
 <param name="args"></param>
 <param name="bFlags"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CLITools.TrimParamPrefix(System.String)">
 <summary>
 Trim the CLI argument name its prefix symbols.
 (修剪命令行参数名称的前置符号)
 </summary>
 <param name="argName"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CLITools.Equals(Microsoft.VisualBasic.CommandLine.CommandLine,Microsoft.VisualBasic.CommandLine.CommandLine)">
 <summary>
 请注意，这个是有方向性的，由于是依照参数1来进行比较的，
 假若args2里面的参数要多于第一个参数，但是第一个参数里
 面的所有参数值都可以被参数2完全比对得上的话，就认为二
 者是相等的
 </summary>
 <param name="args1"></param>
 <param name="args2"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CLITools.GetCommandsOverview(Microsoft.VisualBasic.CommandLine.CommandLine)">
 <summary>
 Gets the brief summary information of current cli command line object.
 (获取当前的命令行对象的参数摘要信息)
 </summary>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="E:Microsoft.VisualBasic.CommandLine.IIORedirectAbstract.ProcessExit">
 <summary>
 The target invoked process event has been exit with a specific return code.(目标派生子进程已经结束了运行并且返回了一个错误值)
 </summary>
 <param name="exitCode"></param>
 <param name="exitTime"></param>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.IIORedirectAbstract.StandardOutput">
 <summary>
 Gets the standard output for the target invoke process.
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.IIORedirectAbstract.Start(System.Boolean)">
 <summary>
 Start the target process. If the target invoked process is currently on the running state, 
 then this function will returns the -100 value as error code and print the warning 
 information on the system console.(启动目标进程)
 </summary>
 <param name="WaitForExit">Indicate that the program code wait for the target process exit or not?(参数指示应用程序代码是否等待目标进程的结束)</param>
 <returns>当发生错误的时候会返回错误代码，当当前的进程任然处于运行的状态的时候，程序会返回-100错误代码并在终端之上打印出警告信息</returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.IIORedirectAbstract.Run">
 <summary>
 启动目标子进程，然后等待执行完毕并返回退出代码(请注意，在进程未执行完毕之前，整个线程会阻塞在这里)
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.CommandLine.ProcessExitCallback">
 <summary>
 A function pointer for process the events when the target invoked child process was terminated and exit.
 (当目标进程退出的时候所调用的过程)
 </summary>
 <param name="exitCode">The exit code for the target sub invoke process.进程的退出代码</param>
 <param name="exitTime">The exit time for the target sub invoke process.(进程的退出时间)</param>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.CommandLine.IORedirect">
 <summary>
 A communication fundation class type for the commandline program interop.
 (一个简单的用于从当前进程派生子进程的Wrapper对象，假若需要folk出来的子进程对象
 不需要终端交互功能，则更加推荐使用<see cref="T:Microsoft.VisualBasic.CommandLine.IORedirectFile"/>对象来进行调用)
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.VisualBasic.CommandLine.IORedirect.processIsRunning">
 <summary>
 当前的这个进程实例是否处于运行的状态
 </summary>
 <remarks></remarks>
</member>
<member name="E:Microsoft.VisualBasic.CommandLine.IORedirect.ProcessExit">
 <summary>
 The target invoked process event has been exit with a specific return code.
 (目标派生子进程已经结束了运行并且返回了一个错误值)
 </summary>
 <param name="exitCode"></param>
 <param name="exitTime"></param>
 <remarks></remarks>
</member>
<member name="F:Microsoft.VisualBasic.CommandLine.IORedirect._processInfo">
 <summary>
 The process invoke interface of current I/O redirect operation.
 </summary>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.IORedirect.StandardOutput">
 <summary>
 Gets the standard output for the target invoke process.
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.IORedirect.#ctor(System.String,System.String,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}},System.Boolean,System.Boolean)">
 <summary>
 Creates a <see cref="T:System.Diagnostics.Process"/> wrapper for the CLI program operations.
 (在服务器上面可能会有一些线程方面的兼容性BUG的问题，不太清楚为什么会导致这样)
 </summary>
 <param name="Exe">The file path of the executable file.</param>
 <param name="args">
 The CLI arguments for the folked program.
 
 (程序会自动将这个参数之中的换行符替换为空格.)
 </param>
 <param name="ENV">Set up the environment variable for the target invoked child process.</param>
 <param name="hide">是否显示目标被调用的外部程序的标准输出</param>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.IORedirect.GetError">
 <summary>
 Gets a <see cref="T:System.String"/> used to read the error output of the application.
 </summary>
 <returns>A <see cref="T:System.String"/> text value that read from the std_error of <see cref="T:System.IO.StreamReader"/> 
 that can be used to read the standard error stream of the application.</returns>
 
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.IORedirect.Start(System.Boolean,System.String[],System.Boolean)">
 <summary>
 Start the target process. If the target invoked process is currently on the running state, 
 then this function will returns the -100 value as error code and print the warning 
 information on the system console.(启动目标进程)
 </summary>
 <param name="WaitForExit">
 Indicate that the program code wait for the target process exit or not?
 (参数指示应用程序代码是否等待目标进程的结束)
 </param>
 <returns>
 当发生错误的时候会返回错误代码，当当前的进程任然处于运行的状态的时候，程序会返回-100错误代码并在终端之上打印出警告信息
 </returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.IORedirect.waitForExit(System.Int32)">
 <summary>
 With a given timeout in milliseconds unit
 </summary>
 <param name="timeout"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.IORedirect.Start(Microsoft.VisualBasic.CommandLine.ProcessExitCallback,System.String[],System.Boolean)">
 <summary>
 Start the target process.(启动目标进程)
 </summary>
 <returns>当发生错误的时候会返回错误代码</returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.IORedirect.Start(System.Boolean)">
 <summary>
 Gets the value that the associated process specified when it terminated.
 </summary>
 <param name="WaitForExit"></param>
 <returns>The code that the associated process specified when it terminated.</returns>
 
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.IORedirect.Run">
 <summary>
 线程会被阻塞在这里，直到外部应用程序执行完毕
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.IORedirect.op_Implicit(System.String)~Microsoft.VisualBasic.CommandLine.IORedirect">
 <summary>
 在进行隐士转换的时候，假若可执行文件的文件路径之中含有空格，则这个时候应该要特别的小心
 </summary>
 <param name="CLI"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.CommandLine.IORedirectFile">
 <summary>
 Using this class object rather than <see cref="T:Microsoft.VisualBasic.CommandLine.IORedirect"/> is more encouraged.
 (假若所建立的子进程并不需要进行终端交互，相较于<see cref="T:Microsoft.VisualBasic.CommandLine.IORedirect"/>对象，更加推荐使用本对象类型来执行。
 似乎<see cref="T:Microsoft.VisualBasic.CommandLine.IORedirect"/>对象在创建一个子进程的时候的对象IO重定向的句柄的处理有问题，所以在这里构建一个更加简单的类型对象，
 这个IO重定向对象不具备终端交互功能)
 </summary>
 <remarks>先重定向到一个临时文件之中，然后再返回临时文件给用户代码</remarks>
</member>
<member name="F:Microsoft.VisualBasic.CommandLine.IORedirectFile._TempRedirect">
 <summary>
 重定向的临时文件
 </summary>
 <remarks>当使用.tmp拓展名的时候会由于APP框架里面的GC线程里面的自动临时文件清理而产生冲突，所以这里需要其他的文件拓展名来避免这个冲突</remarks>
</member>
<member name="F:Microsoft.VisualBasic.CommandLine.IORedirectFile.shellScript">
 <summary>
 shell文件接口
 </summary>
</member>
<member name="E:Microsoft.VisualBasic.CommandLine.IORedirectFile.ProcessExit">
 <summary>
 The target invoked process event has been exit with a specific return code.(目标派生子进程已经结束了运行并且返回了一个错误值)
 </summary>
 <param name="exitCode"></param>
 <param name="exitTime"></param>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.IORedirectFile.StandardOutput">
 <summary>
 目标子进程的终端标准输出
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.IORedirectFile.CopyRedirect(System.String)">
 <summary>
 将目标子进程的标准终端输出文件复制到一个新的文本文件之中
 </summary>
 <param name="CopyToPath"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.IORedirectFile.#ctor(System.String,System.String,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}},System.Boolean,System.String,System.String,System.Boolean,System.Boolean,System.Nullable{System.Boolean})">
 <summary>
 Using this class object rather than <see cref="T:Microsoft.VisualBasic.CommandLine.IORedirect"/> is more 
 encouraged if there is no console interactive with your folked 
 process.
 </summary>
 <param name="file">
 The program file.
 (请注意检查路径参数，假若路径之中包含有%这个符号的话，在调用cmd的时候会失败)
 </param>
 <param name="argv">
 The program commandline arguments.
 (请注意检查路径参数，假若路径之中包含有%这个符号的话，在调用cmd的时候会失败)
 </param>
 <param name="environment">Temporary environment variable</param>
 <param name="folkNew">Folk the process on a new console window if this parameter value is TRUE</param>
 <param name="stdRedirect">If not want to redirect the std out to your file, just leave this value blank.</param>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.IORedirectFile.Run">
 <summary>
 Start target child process and then wait for the child process exits. 
 So that the thread will be stuck at here until the sub process is 
 job done!
 (启动目标子进程，然后等待执行完毕并返回退出代码(请注意，在进程未执行完毕
 之前，整个线程会阻塞在这里))
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.IORedirectFile.Start(System.Action)">
 <summary>
 启动子进程，但是不等待执行完毕，当目标子进程退出的时候，回调<paramref name="procExitCallback"/>函数句柄
 </summary>
 <param name="procExitCallback"></param>
 
</member>
<member name="T:Microsoft.VisualBasic.CommandLine.PipelineProcess">
 <summary>
 How to found the process by CLI
 </summary>
 
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.PipelineProcess.GetProc(System.Int32)">
 <summary>
 <see cref="M:System.Diagnostics.Process.GetProcessById(System.Int32)"/>
 </summary>
 <param name="pid"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.PipelineProcess.GetProc(System.String)">
 <summary>
 Get process by command line parameter.(按照命令行参数来获取进程实例)
 </summary>
 <param name="cli"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.PipelineProcess.FindProc(Microsoft.VisualBasic.CommandLine.IIORedirectAbstract)">
 <summary>
 这个主要是为了<see cref="T:Microsoft.VisualBasic.CommandLine.IORedirectFile"/>对象进行相关进程的查找而设置的，
 对于<see cref="T:Microsoft.VisualBasic.CommandLine.IORedirect"/>而言则直接可以从其属性<see cref="P:Microsoft.VisualBasic.CommandLine.IORedirect.processInfo"/>之中获取相关的进程信息
 </summary>
 <param name="IO"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.PipelineProcess.ExecSub(System.String,System.String,System.Action{System.String},System.String,System.String@,System.String,System.Boolean,System.Action{System.Diagnostics.Process})">
 <summary>
 执行CMD命令
 
 Example:
 
 ```vbnet
 Call excuteCommand("ipconfig", "/all", AddressOf PrintMessage)
 ```
 </summary>
 <param name="app">命令</param>
 <param name="args">参数</param>
 <param name="onReadLine">行信息（委托）</param>
 <remarks>https://github.com/lishewen/LSWFramework/blob/master/LSWClassLib/CMD/CMDHelper.vb</remarks>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.PipelineProcess.handleRunStream(System.Diagnostics.Process,System.String,System.Action{System.String},System.Boolean)">
 <summary>
 
 </summary>
 <param name="p"></param>
 <param name="in">
 the standard input
 </param>
 <param name="onReadLine">
 populate the standard output lines
 </param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.PipelineProcess.CheckProcessStreamOpen(System.Diagnostics.Process@,System.IO.StreamReader@)">
 <summary>
 A common wrapper for check of the sub-process stdout stream is avaiable?
 </summary>
 <param name="p"></param>
 <param name="reader"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.PipelineProcess.CreatePipeline(System.String,System.String,System.Boolean,System.String)">
 <summary>
 Create a new process
 </summary>
 <param name="appPath"></param>
 <param name="args"></param>
 <param name="it">
 this option will affects the UseShellExecute:
 
 ```
 docker run -it XXX
 ```
 
 parameter value set to TRUE means not UseShellExecute
 </param>
 <returns>
 the target process object is already has been 
 started in this function.
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.PipelineProcess.ExecSub(System.String,System.String,System.String)">
 <summary>
 
 </summary>
 <param name="app$"></param>
 <param name="args$"></param>
 <param name="in$"></param>
 <returns>The standard output of the target <paramref name="app"/>, the 
 data inside this stream object may contains text or image or other
 binary data.</returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.PipelineProcess.CallDotNetCorePipeline(Microsoft.VisualBasic.CommandLine.InteropService.InteropService,System.String,System.String)">
 <summary>
 
 </summary>
 <param name="app">
 the ``*.dll/*.exe`` program file path, which is going to running under the ``dotnet`` command.
 </param>
 <param name="args"></param>
 <param name="[in]"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.PipelineProcess.Call(System.String,System.String,System.String,System.Boolean,System.String@,System.Int32@)">
 <summary>
 Run process and then gets the ``std_out`` of the child process
 </summary>
 <param name="app">The file path of the application to be called by its parent process.</param>
 <param name="args">CLI arguments</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.PipelineProcess.Call(Microsoft.VisualBasic.CommandLine.InteropService.InteropService,System.String,System.String,System.Boolean,System.Boolean)">
 <summary>
 Run process and then gets the ``std_out`` of the child process
 </summary>
 <param name="app">The file path of the application to be called by its parent process.</param>
 <param name="args">CLI arguments</param>
 <param name="dotnet">
 Run a .NET core console application?
 </param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.CommandLine.CommandLine">
 <summary>
 A command line object that parse from the user input commandline string.
 (从用户所输入的命令行字符串之中解析出来的命令行对象，标准的命令行格式为：
 <example>&lt;EXE> &lt;CLI_Name> ["Parameter" "Value"]</example>)
 </summary>
 <remarks></remarks>

</member>
<member name="F:Microsoft.VisualBasic.CommandLine.CommandLine.cliCommandArgvs">
 <summary>
 原始的命令行字符串
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.CommandLine.Name">
 <summary>
 The command name that parse from the input command line.
 </summary>
 <value></value>
 <returns></returns>
 <remarks>
 (从输入的命令行中所解析出来的命令的名称)
 </remarks>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.CommandLine.Tokens">
 <summary>
 The command tokens that were parsed from the input commandline.
 </summary>
 <value></value>
 <returns></returns>
 <remarks>
 (从所输入的命令行之中所解析出来的命令参数单元)
 </remarks>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.CommandLine.ParameterList">
 <summary>
 Listing all of the parameter value collection that parsed from the commandline string.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.CommandLine.Keys">
 <summary>
 得到当前的命令行对象之中的所有的参数的名称的列表
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.CommandLine.Parameters">
 <summary>
 The parameters in the commandline without the first token of the command name.
 </summary>
 <value></value>
 <returns></returns>
 <remarks>
 (将命令行解析为词元之后去掉命令的名称之后所剩下的所有的字符串列表)
 </remarks>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.CommandLine.BoolFlags">
 <summary>
 对于参数而言，都是--或者-或者/或者\开头的，下一个单词为单引号或者非上面的字符开头的，例如/o &lt;path>
 对于开关而言，与参数相同的其实符号，但是后面不跟参数而是其他的开关，通常开关用来进行简要表述一个逻辑值
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.CommandLine.EnvironmentVariables">
 <summary>
 获取得到通过``/@set``参数所传入的环境变量(键值对之间使用分号分隔)
 </summary>
 <returns>
 this readonly property ensure that the result dictionary is always not null, but may be empty.
 </returns>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.CommandLine.cli">
 <summary>
 Get the original command line string.
 </summary>
 <value></value>
 <returns></returns>
 <remarks>
 (获取所输入的命令行对象的原始的字符串)
 </remarks>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.CommandLine.Item(System.String)">
 <summary>
 The parameter name is not case sensitive.
 </summary>
 <param name="paramName">
 The argument name in the commandline.
 
 ##### 2018-09-10 
 为了兼容VB的!字典取值语法，这个属性是会自动处理开关参数的前缀的
 即会自动的将开关参数的/\--等前缀删除尝试进行取值
 这个自动转换不会应用于逻辑开关参数上面
 </param>
 <value></value>
 <returns></returns>
 <remarks>
 (开关的名称是不区分大小写的，进行字符串插值脚本化处理的时候，是使用的<see cref="M:Microsoft.VisualBasic.App.GetVariable(System.String,System.String)"/>函数来获取环境变量值)
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CommandLine.HavebFlag(System.String)">
 <summary>
 See if the target logical flag argument is exists in the commandline?
 </summary>
 <param name="name"></param>
 <returns>(查看命令行之中是否存在某一个逻辑开关)</returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CommandLine.ToString">
 <summary>
 Returns the original cli command line argument string.
 </summary>
 <returns></returns>
 <remarks>
 (返回所传入的命令行的原始字符串)
 </remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CommandLine.GetFullDIRPath(System.String)">
 <summary>
 Get specific argument value as full directory path.
 </summary>
 <param name="name">parameter name</param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CommandLine.GetFullFilePath(System.String)">
 <summary>
 Get specific argument value as full file path.
 </summary>
 <param name="name">parameter name</param>
 <returns></returns>
 <remarks>
 (这个函数还会同时修正file://协议的头部)
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CommandLine.CheckMissingRequiredParameters(System.Collections.Generic.IEnumerable{System.String})">
 <summary>
 Checking for the missing required parameter, this function will returns the missing parameter
 in the current cli command line object using a specific parameter name list.
 </summary>
 <param name="list"></param>
 <returns></returns>
 <remarks>
 (检查<paramref name="list"></paramref>之中的所有参数是否存在，函数会返回不存在的参数名)
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CommandLine.CheckMissingRequiredArguments(System.String[])">
 <summary>
 Gets a list of missing required argument name.
 </summary>
 <param name="args"></param>
 <returns></returns>
 
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.CommandLine.IsNullOrEmpty">
 <summary>
 Does this cli command line object contains any parameter argument information.
 </summary>
 <value></value>
 <returns></returns>
 <remarks>
 (查看本命令行参数对象之中是否存在有参数信息)
 </remarks>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.CommandLine.IsNothing">
 <summary>
 <see cref="T:System.String"/> of <see cref="P:Microsoft.VisualBasic.CommandLine.CommandLine.Name"/> AndAlso <see cref="P:Microsoft.VisualBasic.CommandLine.CommandLine.IsNullOrEmpty"/>
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CommandLine.ContainsParameter(System.String,System.Boolean)">
 <summary>
 Does the specific argument exists in this commandline? argument name is not case sensitity.
 </summary>
 <param name="parameterName"></param>
 <returns></returns>
 <remarks>
 (参数名称字符串大小写不敏感)
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CommandLine.op_Implicit(System.String)~Microsoft.VisualBasic.CommandLine.CommandLine">
 <summary>
 Parsing the commandline string as object model
 </summary>
 <param name="CommandLine"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CommandLine.Assert(System.String,System.String)">
 <summary>
 Determined that the specific Boolean flag is exists or not? 
 if not then returns <paramref name="failure"/>, if exists such flag, then returns the <paramref name="name"/>.
 </summary>
 <param name="name">Boolean flag name</param>
 <param name="failure"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CommandLine.GetDictionary(System.String,System.String)">
 <summary>
 If the target parameter is not presents in the CLI, then this function will returns nothing.
 </summary>
 <param name="name"></param>
 <returns></returns>
 <remarks>
 (键值对之间使用分号分隔)
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CommandLine.IsTrue(System.String)">
 <summary>
 Gets the value Of the specified column As a Boolean.
 </summary>
 <param name="parameter">可以包含有开关参数</param>
 <returns></returns>
 <remarks>
 (这个函数也同时包含有开关参数的，开关参数默认为逻辑值类型，当包含有开关参数的时候，其逻辑值为True，反之函数会检查参数列表，参数不存在则为空值字符串，则也为False)
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CommandLine.OpenStreamInput(System.String,System.String@)">
 <summary>About <paramref name="s"/>:
 
 + If the file path is not a value path, then is the value is not null, the argument value will be returned from this parameter. 
 + If the value is nothing, then this function will open the standard input as input.
 + If the file path is valid as input file, then a local file system pointer will be returned.
 
 [管道函数] 假若参数名存在并且所指向的文件也存在，则返回本地文件的文件指针，否则返回标准输入的指针
 </summary>
 <param name="param"></param>
 <param name="s">
 + If the file path is not a value path, then is the value is not null, the argument value will be returned from this parameter. 
 + If the value is nothing, then this function will open the standard input as input.
 + If the file path is valid as input file, then a local file system pointer will be returned.
 </param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CommandLine.OpenStreamOutput(System.String,Microsoft.VisualBasic.Text.Encodings,System.Int64)">
 <summary>
 If the <see cref="P:System.IO.StreamWriter.BaseStream"/> is <see cref="T:System.IO.FileStream"/>, then it means not a ``std_out`` pointer.
 ([管道函数] 假若参数名存在，则返回本地文件的文件指针，否则返回标准输出的指针)
 </summary>
 <param name="param"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CommandLine.ReadInput(System.String)">
 <summary>
 Read all of the text input from the file or ``std_in``
 </summary>
 <remarks>
 这个函数会首先尝试使用<see cref="M:Microsoft.VisualBasic.CommandLine.CommandLine.OpenStreamInput(System.String,System.String@)"/>打开本地文件和标准输出流
 如果失败的话<see cref="M:Microsoft.VisualBasic.CommandLine.CommandLine.OpenStreamInput(System.String,System.String@)"/>函数会返回空值，这个时候参数字符串将会直接被
 返回作为结果，如果打开成功的话，会将得到的输入流之中的所有字符串读出来返回
 </remarks>
 <param name="param"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CommandLine.GetOrdinal(System.String)">
 <summary>
 Return the index Of the named field. If the name is not exists in the parameter list, then a -1 value will be return.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CommandLine.GetString(System.String)">
 <summary>
 Gets the String value Of the specified field.
 </summary>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CommandLine.GetObject``1(System.String,System.Func{System.String,``0})">
 <summary>

 </summary>
 <typeparam name="T"></typeparam>
 <param name="parameter">Command parameter name in the command line inputs.</param>
 <param name="__getObject"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CommandLine.GetValue``1(System.String,``0,System.Func{System.String,``0})">
 <summary>
 If the given parameter is not exists in the user input arguments, then a developer specific default value will be return.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="name">The optional argument parameter name</param>
 <param name="[default]">The default value for returns when the parameter is not exists in the user input.</param>
 <param name="cast">The custom string parser for the CLI argument value</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CommandLine.OpenHandle(System.String,System.String,Microsoft.VisualBasic.Text.Encodings)">
 <summary>
 Open a file handle by using the parameter value
 </summary>
 <param name="name">The parameter name, and its argument value should be a valid file path</param>
 <param name="[default]">Default file path if the argument value is not exists</param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CommandLine.GetEnumerator">
 <summary>
 这个枚举函数也会将开关给包含进来，与<see cref="M:Microsoft.VisualBasic.CommandLine.CommandLine.ToArgumentVector"/>方法所不同的是，这个函数里面的逻辑值开关的名称没有被修饰剪裁
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CommandLine.Add(Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedValue{System.String})">
 <summary>
 Adds an item to the System.Collections.Generic.ICollection`1.
 </summary>
 <param name="item"></param>
 
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CommandLine.Add(System.String,System.String,System.Boolean,System.String)">
 <summary>
 Add a parameter with name and its value.
 </summary>
 <param name="key"></param>
 <param name="value"></param>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CommandLine.Clear">
 <summary>
 Clear the inner list buffer
 </summary>
 
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CommandLine.Contains(Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedValue{System.String})">
 <summary>
 只是通过比较名称来判断是否存在，值没有进行比较
 </summary>
 <param name="item"></param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.CommandLine.Count">
 <summary>
 Get the switch counts in this commandline object.(获取本命令行对象中的所定义的开关的数目)
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CommandLine.Remove(System.String)">
 <summary>
 Removes a parameter by name
 </summary>
 <param name="paramName"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CommandLine.Remove(Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedValue{System.String})">
 <summary>
 Removes a parameter by <see cref="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedValue`1.Name"/>
 </summary>
 <param name="item"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CommandLine.ToArgumentVector">
 <summary>
 将当前的这个命令行对象之中的所有的参数值都合并到一个向量之中返回.
 (``ToArray``拓展好像是有BUG的，所以请使用这个函数来获取所有的参数信息。
 请注意，逻辑值开关的名称会被去掉前缀)
 </summary>
 <returns></returns>
 <remarks>
 the description value in the populated vector is indicates the argument value type.
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CommandLine.op_Addition(Microsoft.VisualBasic.CommandLine.CommandLine,System.String)">
 <summary>
 Open a handle for a file system object.
 </summary>
 <param name="args"></param>
 <param name="fs"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CommandLine.op_LessThanOrEqual(Microsoft.VisualBasic.CommandLine.CommandLine,System.String)">
 <summary>
 Gets the CLI parameter value.
 </summary>
 <param name="args"></param>
 <param name="name"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CommandLine.op_Subtraction(Microsoft.VisualBasic.CommandLine.CommandLine,System.String)">
 <summary>
 Try get parameter value.
 </summary>
 <param name="args"></param>
 <param name="name"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.CommandLine.op_Subtraction(Microsoft.VisualBasic.CommandLine.CommandLine,Microsoft.VisualBasic.CommandLine.CommandLine)">
 <summary>
 Try get parameter value.
 </summary>
 <param name="args"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.CommandLine.GitBashEnvironment">
 <summary>
 Git bash environment helper module
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.CommandLine.GitBashEnvironment.gitBash">
 <summary>
 Enable .NET application running from git bash terminal
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.GitBashEnvironment.GetCommandLineArgs">
 <summary>
 Makes compatibility with git bash: <see cref="F:Microsoft.VisualBasic.CommandLine.GitBashEnvironment.gitBash"/> = ``C:/Program Files/Git``
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.GitBashEnvironment.isRunningOnGitBash">
 <summary>
 Is current application running in gitbash environment on windows?
 </summary>
 <returns></returns>
</member>
<member name="F:Microsoft.VisualBasic.CommandLine.GitBashEnvironment.BrokenWindowsNetworkDirectoryPattern">
 <summary>
 (\\)192.168.1.239\blablabla
 前面的两个斜杠可能被预处理的时候被清除掉了
 所以在这里只匹配IP地址和后面的路径部分
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.CommandLine.InteropService.InteropService">
 <summary>
 The class object which can interact with the target commandline program.
 (与目标命令行程序进行命令行交互的编程接口，本类型的对象的作用主要是生成命令行参数)
 </summary>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.InteropService.InteropService.Path">
 <summary>
 App path
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.InteropService.InteropService.IsAvailable">
 <summary>
 这个只读属性返回目标可执行文件是否有效
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.InteropService.InteropService.IORedirect">
 <summary>
 默认是不做IO重定向的
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.InteropService.InteropService.#ctor(System.String)">
 <summary>
 通过应用程序的可执行文件路径来构建命令行的交互对象
 </summary>
 <param name="app">the target exe file path</param>
 <remarks>
 this module build dotnet call for clr on unix system automatically.
 </remarks>
</member>
<member name="F:Microsoft.VisualBasic.CommandLine.InteropService.InteropService._executableAssembly">
 <summary>
 Assembly path for the target invoked program.
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.VisualBasic.CommandLine.InteropService.InteropService._executableDll">
 <summary>
 .NET Core dll corresponding to run <see cref="F:Microsoft.VisualBasic.CommandLine.InteropService.InteropService._executableAssembly"/>.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.InteropService.InteropService.GetLastCLRException">
 <summary>
 线程不安全
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.InteropService.InteropService.RunProgram(System.String,System.String)">
 <summary>
 运行非.NET应用程序
 请注意，这个函数只是生成了具体的进程调用对象，还需要手动调用
 <see cref="M:Microsoft.VisualBasic.CommandLine.IIORedirectAbstract.Run"/>或者
 <see cref="M:Microsoft.VisualBasic.CommandLine.IIORedirectAbstract.Start(System.Boolean)"/>
 方法才会启动目标进程
 </summary>
 <param name="args$"></param>
 <returns></returns>
 
</member>
<member name="T:Microsoft.VisualBasic.CommandLine.InteropService.AppDriver">
 <summary>
应用程序的执行驱动抽象接口, 这个抽象接口是为了兼容命令行应用和Docker环境下的命令行应用而设置的
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.InteropService.AppDriver.App">
 <summary>
 命令行命令或者可执行文件的路径
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.CommandLine.InteropService.CLIAbstractor">
 <summary>
 将函数的定义抽象为一个命令行，从而能够提供更好的命令行编写服务
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.InteropService.CLIAbstractor.CLIUsage(System.Reflection.MethodInfo,System.String)">
 <summary>
 Abstract the function declare as a CLI usage declare. This tool not support the generic function method.
 (不支持泛型函数)
 </summary>
 <param name="api"></param>
 <param name="prefix$"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.InteropService.CLIBuildMethod.GetCLI``1(``0,System.String)">
 <summary>
 Generates the command line string value for the invoked target cli program using this interop services object instance.
 (生成命令行参数)
 </summary>
 <typeparam name="TInteropService">
 A class type object for interaction with a commandline program.
 (与命令行程序进行交互的模块对象类型)
 </typeparam>
 <param name="app">目标交互对象的实例</param>
 <returns></returns>
 <remarks>
 依照类型<see cref="T:Microsoft.VisualBasic.CommandLine.Reflection.CLITypes"/>来生成参数字符串
 
 <see cref="F:Microsoft.VisualBasic.CommandLine.Reflection.CLITypes.Boolean"/>, True => 参数名；
 <see cref="F:Microsoft.VisualBasic.CommandLine.Reflection.CLITypes.Double"/>, <see cref="F:Microsoft.VisualBasic.CommandLine.Reflection.CLITypes.Integer"/>, <see cref="F:Microsoft.VisualBasic.CommandLine.Reflection.CLITypes.String"/>, => 参数名 + 参数值，假若字符串为空则不添加；
 （假若是枚举值类型，可能还需要再枚举值之中添加<see cref="T:System.ComponentModel.DescriptionAttribute"/>属性）
 <see cref="F:Microsoft.VisualBasic.CommandLine.Reflection.CLITypes.File"/>, 假若字符串为空则不添加，有空格自动添加双引号，相对路径会自动转换为全路径。
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.InteropService.CLIBuildMethod.SimpleBuilder(System.String,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}})">
 <summary>
 Creates a command line string by using simply fills the name and parameter values
 </summary>
 <param name="name"></param>
 <param name="args"></param>
 <returns></returns>
</member>
<member name="F:Microsoft.VisualBasic.CommandLine.InteropService.CLIBuildMethod.convertMethods">
 <summary>
 Converts the property value to a CLI token
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.CommandLine.InteropService.CLIBuildMethod.getValue">
 <summary>
 Convert property to cli parameter value string
 </summary>
 <param name="value"></param>
 <param name="attr"></param>
 <param name="prop"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.InteropService.CLIBuildMethod.pathRule(System.Object,Microsoft.VisualBasic.CommandLine.Reflection.Argv,System.Reflection.PropertyInfo)">
 <summary>
 The different between the String and Path is that applying <see cref="T:Microsoft.VisualBasic.CommandLine.Reflection.CLIToken"/> or <see cref="M:Microsoft.VisualBasic.ApplicationServices.Utils.CLIPath(System.String)"/>.
 </summary>
 <param name="value">只能是<see cref="T:System.String"/>类型的</param>
 <param name="attr"></param>
 <param name="prop"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.InteropService.CLIBuildMethod.formatToken(Microsoft.VisualBasic.CommandLine.Reflection.Argv,System.String)">
 <summary>
 这个方法不会影响逻辑值类型
 </summary>
 <param name="attr"></param>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.InteropService.CLIBuildMethod.stringRule(System.Object,Microsoft.VisualBasic.CommandLine.Reflection.Argv,System.Reflection.PropertyInfo)">
 <summary>
 可能包含有枚举值
 </summary>
 <param name="value"></param>
 <param name="attr"></param>
 <param name="prop"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.InteropService.CLIBuildMethod.stringEnumRule(System.Object,Microsoft.VisualBasic.CommandLine.Reflection.Argv,System.Reflection.PropertyInfo)">
 <summary>
 将枚举类型的属性值转换为命令行的参数值，这个转换过程与<see cref="P:Microsoft.VisualBasic.CommandLine.Reflection.Argv.Type"/>的值相关
 
 + <see cref="F:Microsoft.VisualBasic.CommandLine.Reflection.CLITypes.String"/>的时候，会直接调用ToString生成参数值
 + <see cref="F:Microsoft.VisualBasic.CommandLine.Reflection.CLITypes.Integer"/>的时候，会将枚举值的数值作为命令行参数值
 
 </summary>
 <param name="value"></param>
 <param name="attr"></param>
 <param name="prop"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.InteropService.CLIBuildMethod.booleanRule(System.Object,Microsoft.VisualBasic.CommandLine.Reflection.Argv,System.Reflection.PropertyInfo)">
 <summary>
 Property value to boolean flag in the CLI
 </summary>
 <param name="value"></param>
 <param name="attr"></param>
 <param name="prop"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.InteropService.CLIBuildMethod.ClearParameters``1(``0)">
 <summary>
 Reset the CLI parameters property in the target class object.
 </summary>
 <typeparam name="TInteropService"></typeparam>
 <param name="inst"></param>
 <returns>返回所重置的参数的个数</returns>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.CommandLine.InteropService.InCompatibleAttribute">
 <summary>
 这个CLI方法是和.NET的<see cref="T:System.Diagnostics.Process"/>调用不兼容的
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.InteropService.InCompatibleAttribute.CLRProcessCompatible(System.Reflection.MethodInfo)">
 <summary>
 判断目标方法是否是和CLR调用兼容？
 </summary>
 <param name="CLI"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.CommandLine.InteropService.Pipeline.RunSlavePipeline">
 <summary>
 wrapper for run a background task process
 </summary>
</member>
<member name="E:Microsoft.VisualBasic.CommandLine.InteropService.Pipeline.RunSlavePipeline.SetMessage">
 <summary>
 action of the string message
 </summary>
 <param name="message"></param>
 <remarks><see cref="T:System.Action`1"/></remarks>
</member>
<member name="F:Microsoft.VisualBasic.CommandLine.InteropService.Pipeline.RunSlavePipeline.app">
 <summary>
 the file full path to the target executable application file
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.InteropService.Pipeline.RunSlavePipeline.Arguments">
 <summary>
 the commandline argument of the target background task
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.InteropService.Pipeline.RunSlavePipeline.#ctor(System.String,System.String,System.String)">
 <summary>
 create a new commandline pipeline task
 </summary>
 <param name="app">the commandline application</param>
 <param name="arguments">
 the commandline argument string, value of this string
 parameter could be in multiple line
 </param>
 <param name="workdir"></param>
 <remarks>
 the commandline <paramref name="arguments"/> could be in multiple lines
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.InteropService.Pipeline.RunSlavePipeline.ToString">
 <summary>
 get commandline of current background task, in string format like 
 example as: /path/to/exe cli_arguments
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.InteropService.Pipeline.RunSlavePipeline.SendMessage(System.String)">
 <summary>
 pop out a taged message that tells the parent process to capture this message and echo to the text logger
 </summary>
 <param name="message"></param>
 
</member>
<member name="T:Microsoft.VisualBasic.CommandLine.InteropService.SharedORM.API">
 <summary>
 CommandLine source code mapper API
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.InteropService.SharedORM.API.CommandLineModel(System.String)">
 <summary>
 从<see cref="P:Microsoft.VisualBasic.CommandLine.Reflection.ExportAPIAttribute.Usage"/>之中解析出命令行的模型
 </summary>
 <param name="usage$">
 + 由于习惯于在命令行的usage说明之中使用``&lt;>``括号对来包裹参数值，所以usage字符串数据还不能直接使用普通的命令行函数进行解析
 + ``[]``方括号所包裹的参数对象都是可选参数
 + 对于可选参数的默认值，默认值的解析形式为``default=...``，如果没有这个表达式，则默认为Nothing空值为默认值
 </param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.InteropService.SharedORM.API.BuildArguments(System.String[],System.String[],System.String[]@)">
 <summary>
 
 </summary>
 <param name="args$">因为逻辑变量只存在于可选参数之中，所以在这里必须参数直接split2即可</param>
 <param name="optionals$"></param>
 <param name="booleans$"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.InteropService.SharedORM.API.Tokenize(System.String)">
 <summary>
 使用空格分隔，但是需要对value额外注意
 
 + 在这里面分隔符为空格
 + 可以使用双引号包裹值，则双引号之中的字符串在可选参数之中都被看作为可选参数值
 + 可以使用尖括号包裹值，则尖括号之中的default=表达式则是可选参数之中的默认参数值
 </summary>
 <param name="s$"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.CommandLine.InteropService.SharedORM.CLIAttribute">
 <summary>
 创建一个自定义标记来表示这个模块是一个CLI命令接口模块
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.CommandLine.InteropService.SharedORM.CodeGenerator.exe">
 <summary>
 目标应用程序模块的文件名，不包含有文件拓展名
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.CommandLine.InteropService.SharedORM.Perl">
 <summary>
 为了构建GCModeller的脚本自动化而构建的源代码生成器，生成``perl module(*.pm)``
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.CommandLine.InteropService.SharedORM.RLanguage">
 <summary>
 
 </summary>
 <remarks>因为会和Unix bash之中的``ls``命令之中的``-r``参数冲突，所以在这里命名为``Rlanguage``</remarks>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.InteropService.SharedORM.VisualBasic.addXmlComments(System.String)">
 <summary>
 
 </summary>
 <param name="description$"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.InteropService.SharedORM.VisualBasic.cliCallsInternal(System.Text.StringBuilder,Microsoft.VisualBasic.CommandLine.InteropService.SharedORM.APITuple,System.Boolean)">
 <summary>
 生成一个命令行API的调用代码
 </summary>
 <param name="vb"></param>
 <param name="cli"></param>
 <remarks>
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.InteropService.SharedORM.VisualBasic.vbParameters(Microsoft.VisualBasic.CommandLine.CommandLine,System.Boolean)">
 <summary>
 在这个函数之中会生成函数的参数列表
 </summary>
 <param name="API"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.InteropService.SharedORM.VisualBasic.optionalDefaultValue(System.String)">
 <summary>
 必须是以``default=``来作为前缀的，否则默认使用空字符串
 </summary>
 <param name="value$"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.InteropService.SharedORM.VisualBasic.createCliCalls(Microsoft.VisualBasic.CommandLine.CommandLine)">
 <summary>
 创建命令行调用字符串
 </summary>
 <param name="api"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.InteropService.SharedORM.VisualBasic.normAsVisualBasicName(System.String)">
 <summary>
 将命令行参数的名称转义为VB之中有效的对象标识符
 </summary>
 <param name="arg$"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.CommandLine.ExecuteFile">
 <summary>
 假若所传入的命令行的name是文件路径，解释器就会执行这个函数指针
 </summary>
 <param name="path"></param>
 <param name="args"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.CommandLine.ExecuteEmptyCLI">
 <summary>
 假若所传入的命令行是空的，就会执行这个函数指针
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.CommandLine.ExecuteNotFound">
 <summary>
 假若查找不到命令的话，执行这个函数
 </summary>
 <param name="args"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.CommandLine.ExecuteQuery">
 <summary>
 Run query in syntax like: ? xxx
 </summary>
 <param name="args"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.CommandLine.ExecuteImpl">
 <summary>
 Executive implementation of <see cref="T:Microsoft.VisualBasic.CommandLine.Interpreter"/>
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.CommandLine.InteractiveConsole">
 <summary>
 interactive console in ``/i`` mode, example:
 
 ```bash
 # This command will makes your CLI program enter 
 # the interactive console mode.
 # 
 # type quit() for exit.
 #
 App /i
 ```
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.InteractiveConsole.RunAppInternal(Microsoft.VisualBasic.CommandLine.CommandLine)">
 <summary>
 Contains sevral build in command about file system operation and the program CLI interpreter commands
 </summary>
 <param name="cmd"></param>
</member>
<member name="T:Microsoft.VisualBasic.CommandLine.Interpreter">
 <summary>
 Command line interpreter for your **CLI** program.
 (命令行解释器，请注意，在调试模式之下，命令行解释器会在运行完命令之后暂停，而Release模式之下则不会。
 假若在调试模式之下发现程序有很长一段时间处于cpu占用为零的静止状态，则很有可能已经运行完命令并且等待
 回车退出)
 </summary>
 <remarks></remarks>

</member>
<member name="F:Microsoft.VisualBasic.CommandLine.Interpreter.apiTable">
 <summary>
 在添加之前请确保键名是小写的字符串
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.Interpreter.ExecuteFile">
 <summary>
 Public Delegate Function __ExecuteFile(path As String, args As String()) As Integer,
 (<seealso cref="T:Microsoft.VisualBasic.CommandLine.ExecuteFile"/>: 假若所传入的命令行的name是文件路径，解释器就会执行这个函数指针)
 这个函数指针一般是用作于执行脚本程序的
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.Interpreter.ExecuteEmptyCli">
 <summary>
 Public Delegate Function __ExecuteEmptyCli() As Integer,
 (<seealso cref="T:Microsoft.VisualBasic.CommandLine.ExecuteEmptyCLI"/>: 假若所传入的命令行是空的，就会执行这个函数指针)
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Interpreter.ToDictionary">
 <summary>
 Gets the dictionary data which contains all of the available command information in this assembly module.
 (获取从本模块之中获取得到的所有的命令行信息)
 </summary>
 <returns></returns>
 <remarks></remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Interpreter.Execute(Microsoft.VisualBasic.CommandLine.CommandLine)">
 <summary>
 Execute the specific command line using this interpreter.
 </summary>
 <param name="args">The user input command line string.</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Interpreter.doExecuteNonCLIInput">
 <summary>
 命令行是空的话，假若<see cref="P:Microsoft.VisualBasic.CommandLine.Interpreter.ExecuteEmptyCli"/>不是空值的话，会优先执行<see cref="P:Microsoft.VisualBasic.CommandLine.Interpreter.ExecuteEmptyCli"/>函数指针
 否则打印出所有的命令名称信息
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Interpreter.apiInvoke(Microsoft.VisualBasic.CommandLine.CommandLine,System.String[])">
 <summary>
 The interpreter runs all of the command from here.(所有的命令行都从这里开始执行)
 </summary>
 <param name="args">就只有一个命令行对象</param>
 <param name="help_argvs"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Interpreter.exec_shell_script_internal(System.String,Microsoft.VisualBasic.CommandLine.CommandLine,System.Boolean)">
 <summary>
 Some magic tweaks will be made in this function call
 </summary>
 <param name="filename"></param>
 <param name="argv"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Interpreter.SDKdocs">
 <summary>
 Generate the sdk document for the target program assembly.(生成目标应用程序的命令行帮助文档，markdown格式的)
 </summary>
 <returns></returns>
 <remarks></remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Interpreter.Execute(System.String[])">
 <summary>
 Process the command option arguments of the main function:
 <code>Public Function Main(argvs As String()) As Integer
 </code>
 </summary>
 <param name="CommandLineArgs">The cli command line parameter string value collection.</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Interpreter.AddCommand(Microsoft.VisualBasic.CommandLine.Reflection.EntryPoints.APIEntryPoint)">
 <summary>
 Add a command in current cli interpreter.(x向当前的这个CLI命令行解释器之中添加一个命令)
 </summary>
 <param name="Command"></param>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Interpreter.Help(System.String)">
 <summary>
 Gets the help information of a specific command using its name property value.(获取某一个命令的帮助信息)
 </summary>
 <param name="CommandName">If the paramteer command name value is a empty string then this function
 will list all of the commands' help information.(假若本参数为空则函数会列出所有的命令的帮助信息)</param>
 <returns>Error code, ZERO for no error</returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.Interpreter.ListCommandInfo">
 <summary>
 Returns the command entry info list array.
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Interpreter.#ctor(System.Type,System.String)">
 <summary>

 </summary>
 <param name="type">A module or a class which contains some shared method for the command entry.
 (包含有若干使用<see cref="T:Microsoft.VisualBasic.CommandLine.Reflection.ExportAPIAttribute"></see>进行标记的命令行执行入口点的Module或者Class对象类型，
 可以使用 Object.GetType/GetType 关键词操作来获取所需要的类型信息)</param>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.Interpreter.Type">
 <summary>
 The CLI API container Module/Class type information.(申明这个解释器的命令行API容器类型)
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Interpreter.__getsAllCommands(System.Type,System.Boolean)">
 <summary>
 导出所有符合条件的静态方法
 </summary>
 <param name="Type"></param>
 <param name="[Throw]"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Interpreter.GetAllCommands(System.Type,System.Boolean)">
 <summary>
 导出所有符合条件的静态方法，请注意，在这里已经将外部的属性标记和所属的函数的入口点进行连接了
 </summary>
 <param name="type"></param>
 <param name="[Throw]"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Interpreter.getAPI(System.Reflection.MethodInfo,System.Type,System.Boolean)">
 <summary>
 从方法定义<see cref="T:System.Reflection.MethodInfo"/>之中解析出命令行的定义
 </summary>
 <param name="methodInfo"></param>
 <param name="commandAttribute"></param>
 <param name="[throw]"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Interpreter.doLoadApiInternal(Microsoft.VisualBasic.CommandLine.Reflection.ExportAPIAttribute,System.Reflection.MethodInfo,System.Boolean)">
 <summary>
 在这里将外部的属性标记和所属的函数的入口点进行连接
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Interpreter.CreateEmptyCLIObject">
 <summary>
 Create an empty cli command line interpreter object which contains no commands entry.
 (创建一个没有包含有任何命令入口点的空的CLI命令行解释器)
 </summary>
 <returns></returns>
 <remarks></remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Interpreter.CreateInstance(System.Type)">
 <summary>
 Create a new interpreter instance from a specific type information.
 (从目标类型之中构造出一个命令行解释器)
 </summary>
 <param name="Type"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Interpreter.CreateInstance``1">
 <summary>
 Create a new interpreter instance using the specific type information.
 (使用所制定的目标类型信息构造出一个CLI命令行解释器)
 </summary>
 <typeparam name="T"></typeparam>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Interpreter.CreateInstance(System.String)">
 <summary>
 Create a new interpreter instance from a specific dll/exe path, this program assembly file should be a standard .NET assembly.
 (从一个标准的.NET程序文件之中构建出一个命令行解释器)
 </summary>
 <param name="assmPath">DLL/EXE file path.(标准的.NET程序集文件的文件路径)</param>
 <returns></returns>
 <remarks></remarks>

</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Interpreter.Clear">
 <summary>
 Clear the hash table of the cli command line interpreter command entry points.(清除本CLI解释器之中的所有的命令行执行入口点的哈希数据信息)
 </summary>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.Interpreter.Count">
 <summary>
 Gets the command counts in current cli interpreter.(返回本CLI命令行解释器之中所包含有的命令的数目)
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Interpreter.ExistsCommand(System.String)">
 <summary>
 The target command line command is exists in this cli interpreter using it name property?(判断目标命令行命令是否存在于本CLI命令行解释器之中)
 </summary>
 <param name="CommandName">The command name value is not case sensitive.(命令的名称对大小写不敏感的)</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.Interpreter.Item(System.String)">
 <summary>

 </summary>
 <param name="key">调用前需要转换为小写字母的形式</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Interpreter.ListingRelated(System.String)">
 <summary>
 列举出所有可能的命令
 </summary>
 <param name="query">模糊匹配</param>
 <returns></returns>
 
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.Interpreter.APINameList">
 <summary>
 List all of the command line entry point name which were contains in this cli interpreter.
 (列举出本CLI命令行解释器之中的所有的命令行执行入口点的名称)
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.Interpreter.APIList">
 <summary>
 当前的解释器内所容纳的所有的CLI API列表
 </summary>
 <returns></returns>
</member>
<member name="F:Microsoft.VisualBasic.CommandLine.ManView.CommandHelpExtensions.BAD_COMMAND_LISTING_COMMANDS">
 <summary>
 Bad command, no such a command named ""{0}"", but you probably want to using one of these commands:
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.CommandLine.ManView.ExceptionHelp">
 <summary>
 Defines the url or e-mail information for the exceptions.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.ManView.ExceptionHelp.Documentation">
 <summary>
 CLI tools' docs url
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.ManView.ExceptionHelp.EMailLink">
 <summary>
 The author e-mail
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.CommandLine.ManView.ManualBuilder">
 <summary>
 用来生成帮助信息
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.ManView.ManualBuilder.PrintHelp(Microsoft.VisualBasic.CommandLine.Reflection.EntryPoints.APIEntryPoint)">
 <summary>
 Prints the formatted help information on the console.
 (用于生成打印在终端上面的命令行帮助信息)
 </summary>
 <param name="api"></param>
 <returns></returns>
</member>
<member name="F:Microsoft.VisualBasic.CommandLine.ManView.ManualBuilder.boolFlag">
 <summary>
 (boolean flag does not require of argument value)
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.CommandLine.ManView.SDKManual">
 <summary>
 Generates the help document in markdown format.
 (生成markdown格式的帮助文件)
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.ManView.SDKManual.LaunchManual(Microsoft.VisualBasic.CommandLine.Interpreter)">
 <summary>
 这个是用于在终端上面显示的无格式的文本输出
 </summary>
 <param name="CLI"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.ManView.SDKManual.MarkdownDoc(Microsoft.VisualBasic.CommandLine.Interpreter)">
 <summary>
 这个是用于保存于文件之中的markdown格式的有格式标记的文本输出
 </summary>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.ManView.SDKManual.AppSummary(Microsoft.VisualBasic.ApplicationServices.Development.AssemblyInfo,System.String,System.String,System.IO.TextWriter)">
 <summary>
 
 </summary>
 <param name="assem"></param>
 <param name="description">命令行的使用功能描述信息文本</param>
 <param name="SYNOPSIS">命令行的使用语法</param>
 <param name="write"></param>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.ManView.SDKManual.HelpSummary(Microsoft.VisualBasic.CommandLine.Interpreter,System.Boolean)">
 <summary>
 Returns the summary brief help information of all of the commands in current cli interpreter.
 (枚举出本CLI解释器之中的所有的命令的帮助的摘要信息)
 </summary>
 <returns></returns>
 <remarks></remarks>
 <param name="markdown">Output in markdown format?</param>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Parsers.CliArgumentParsers.CreateParameterValues(System.String[],System.Boolean,System.String)">
 <summary>
 Parsing parameters from a specific tokens.
 (从给定的词组之中解析出参数的结构)
 </summary>
 <param name="tokens">个数为偶数的，但是假若含有开关的时候，则可能为奇数了</param>
 <param name="includeLogicals">返回来的列表之中是否包含有逻辑开关</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Parsers.CliArgumentParsers.GetLogicalFlags(System.Collections.Generic.IEnumerable{System.String},System.String@)">
 <summary>
 Get all of the logical parameters from the input tokens.
 (这个函数所生成的逻辑参数的名称全部都是小写形式的)
 </summary>
 <param name="args">要求第一个对象不能够是命令的名称</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Parsers.CliArgumentParsers.IsPossibleLogicFlag(System.String)">
 <summary>
 Is this string tokens is a possible <see cref="T:System.Boolean"/> value flag
 </summary>
 <param name="obj"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.CommandLine.Parsers.CLIParser">
 <summary>
 命令行单词解析器
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Parsers.CLIParser.extract(System.Collections.Generic.IEnumerable{System.String})">
 <summary>
 split the key=value tuple insdie the commandline argument token string
 </summary>
 <param name="tokens">
 a set of the commandline argument token list
 </param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Parsers.CLIParser.TryParse(System.Collections.Generic.IEnumerable{System.String},System.Boolean,System.String)">
 <summary>
 Try parsing the cli command string from the string value.
 </summary>
 <param name="args">The commandline arguments which is user inputs from the terminal.</param>
 <param name="duplicatedAllows">Allow the duplicated command parameter argument name in the input, 
 default is not allowed the duplication.(是否允许有重复名称的参数名出现，默认是不允许的)</param>
 <returns></returns>
 <remarks>(尝试着从文本行之中解析出命令行参数信息)</remarks>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Parsers.CLIParser.TryParse(System.String,System.Boolean)">
 <summary>
 Try parsing the cli command string from the string value.
 (尝试着从文本行之中解析出命令行参数信息，假若value里面有空格，则必须要将value添加双引号)
 </summary>
 <param name="CLI">The commandline arguments which is user inputs from the terminal.</param>
 <param name="duplicateAllowed">Allow the duplicated command parameter argument name in the input, 
 default is not allowed the duplication.(是否允许有重复名称的参数名出现，默认是不允许的)</param>
 <returns></returns>
 <remarks></remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Parsers.DictionaryParser.TryParse(System.String)">
 <summary>
 键值对之间使用分号分隔
 </summary>
 <param name="str$"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.CommandLine.Reflection.ArgumentCollection">
 <summary>
 The help information for a specific command line parameter switch.(某一个指定的命令的开关的帮助信息)
 </summary>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.Reflection.ArgumentCollection.Count">
 <summary>
 本命令行对象中的包含有帮助信息的开关参数的数目
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.Reflection.ArgumentCollection.Parameter(System.String)">
 <summary>
 Returns the parameter switch help information with the specific name value.(显示某一个指定名称的开关信息)
 </summary>
 <param name="Name"></param>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.Reflection.ArgumentCollection.GetExample">
 <summary>
 Gets the usage example of this parameter switch.(获取本参数开关的帮助信息)
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Reflection.ArgumentCollection.ToString">
 <summary>
 显示所有的开关信息
 </summary>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.Reflection.ActiveViewsAttribute.type">
 <summary>
 Code type name in the markdown, default is ``json``
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.CommandLine.Reflection.ArgumentAttribute">
 <summary>
 Use for the detail description for a specific commandline switch.(用于对某一个命令的开关参数的具体描述帮助信息)
 </summary>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.Reflection.ArgumentAttribute.Name">
 <summary>
 The name of this command line parameter switch.(该命令开关的名称)
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.Reflection.ArgumentAttribute.BriefName">
 <summary>
 POSIX short name
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.Reflection.ArgumentAttribute.Description">
 <summary>
 The description and brief help information about this parameter switch, 
 you can using the ``\n`` escape string to gets a ``VbCrLf`` value.
 (对这个开关参数的具体的描述以及帮助信息，可以使用``\n``转义字符进行换行)
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.Reflection.ArgumentAttribute.Example">
 <summary>
 The usage example of this parameter switch.(该开关的值的示例)
 
 ```
 name example
 ```
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.Reflection.ArgumentAttribute.Usage">
 <summary>
 The usage syntax information about this parameter switch.(本开关参数的使用语法)
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.Reflection.ArgumentAttribute.Optional">
 <summary>
 Is this parameter switch is an optional value.(本开关是否为可选的参数)
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.Reflection.ArgumentAttribute.Out">
 <summary>
 Is this parameter is using for the output
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.Reflection.ArgumentAttribute.AcceptTypes">
 <summary>
 Accept these types as input or output data in this types if <see cref="P:Microsoft.VisualBasic.CommandLine.Reflection.ArgumentAttribute.Out"/> is true.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.Reflection.ArgumentAttribute.Extensions">
 <summary>
 Example:
 
 ```
 csv, json, txt
 ```
 
 Extension for the document format <see cref="P:Microsoft.VisualBasic.CommandLine.Reflection.ArgumentAttribute.AcceptTypes"/> if this argument its <see cref="P:Microsoft.VisualBasic.CommandLine.Reflection.ArgumentAttribute.TokenType"/> is a <see cref="F:Microsoft.VisualBasic.CommandLine.Reflection.CLITypes.File"/>
 If supports multiple extension, delimiter using ``,`` comma symbol.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Reflection.ArgumentAttribute.#ctor(System.String,System.Boolean,Microsoft.VisualBasic.CommandLine.Reflection.CLITypes,Microsoft.VisualBasic.CommandLine.Reflection.PipelineTypes)">
 <summary>
 对命令行之中的某一个参数进行描述性信息的创建，包括用法和含义
 </summary>
 <param name="Name">The full name of this command line parameter switch.(该命令开关的名称)</param>
 <param name="optional">Is this parameter switch is an optional value.(本开关是否为可选的参数)</param>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.CommandLine.Reflection.ExportAPIAttribute">
 <summary>
 A command object that with a specific name.
 </summary>
 <remarks>(一个具有特定名称命令执行对象)</remarks>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.Reflection.ExportAPIAttribute.Name">
 <summary>
 The name of the commandline object.
 </summary>
 <value></value>
 <returns></returns>
 <remarks>(这个命令的名称)</remarks>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.Reflection.ExportAPIAttribute.Info">
 <summary>
 Something detail of help information.
 </summary>
 <value></value>
 <returns></returns>
 <remarks>(详细的帮助信息)</remarks>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.Reflection.ExportAPIAttribute.Usage">
 <summary>
 The usage of this command.
 </summary>
 <value></value>
 <returns></returns>
 <remarks>(这个命令的用法，本属性仅仅是一个助记符，当用户没有编写任何的使用方法信息的时候才会使用本属性的值)</remarks>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.Reflection.ExportAPIAttribute.Example">
 <summary>
 A example that to useing this command.
 </summary>
 <value></value>
 <returns></returns>
 <remarks>(对这个命令的使用示例，本属性仅仅是一个助记符，当用户没有编写任何示例信息的时候才会使用本属性的值，
 在编写帮助示例的时候，需要编写出包括命令开关名称的完整的例子)</remarks>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Reflection.ExportAPIAttribute.#ctor(System.String)">
 <summary>
 You are going to define a available export api 
 for you application to another language or 
 scripting program environment.
 
 </summary>
 <param name="Name">
 The name of the commandline object or you define 
 the exported API name here.
 </param>
 <remarks>(定义一个命令行程序之中可以使用的命令)</remarks>
 
</member>
<member name="F:Microsoft.VisualBasic.CommandLine.Reflection.PipelineTypes.std_in">
 <summary>
 This argument can accept the std_out from upstream app as input
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.CommandLine.Reflection.PipelineTypes.std_out">
 <summary>
 This argument can output data to std_out
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.CommandLine.Reflection.GroupAttribute">
 <summary>
 应用于方法之上的，标注当前的这个方法的功能分组
 </summary>
 
</member>
<member name="T:Microsoft.VisualBasic.CommandLine.Reflection.GroupingDefineAttribute">
 <summary>
 应用于命令行类型容器之上的，用于功能分组的详细描述信息
 </summary>
 
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.Reflection.GroupingDefineAttribute.Description">
 <summary>
 当前的这一功能分组的详细描述信息
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.Reflection.IExportAPI.Name">
 <summary>
 The name of the commandline object.(这个命令的名称)
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.Reflection.IExportAPI.Info">
 <summary>
 Something detail of help information.(详细的帮助信息)
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.Reflection.IExportAPI.Usage">
 <summary>
 The usage of this command.(这个命令的用法，本属性仅仅是一个助记符，当用户没有编写任何的使用方法信息的时候才会使用本属性的值)
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.Reflection.IExportAPI.Example">
 <summary>
 A example that to useing this command.(对这个命令的使用示例，本属性仅仅是一个助记符，当用户没有编写任何示例信息的时候才会使用本属性的值)
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.CommandLine.Reflection.LastUpdatedAttribute">
 <summary>
 主要是用于帮助标记命令行命令的更新时间,了解哪些命令可能是已经过时了的
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.CommandLine.Reflection.Namespace">
 <summary>
 (<see cref="T:Microsoft.VisualBasic.CommandLine.Interpreter">CommandLine interpreter</see> executation Entry and the ShellScript software packages namespace.)这是一个命令行解释器所使用的执行入口点的集合
 </summary>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.Reflection.Namespace.Description">
 <summary>
 A brief description text about the function of this namespace.(关于本模块之中的描述性的摘要文本)
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.Reflection.Namespace.Namespace">
 <summary>
 The name value of this namespace module.(本命名空间模块的名称值)
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.Reflection.Namespace.AutoExtract">
 <summary>
 Readonly
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Reflection.Namespace.#ctor(System.String,System.String)">
 <summary>
 The name value of this namespace module.(本命名空间模块的名称值)
 </summary>
 <param name="Namespace">The name value of this namespace module.(本命名空间模块的名称值)</param>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.Reflection.Namespace.TypeInfo">
 <summary>
 Constant of type information for the reflection
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Reflection.Namespace.CreateInstance(System.Type)">
 <summary>
 从目标类型之中构造出一个命令行解释器
 </summary>
 <param name="Type"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.CommandLine.Reflection.NoteAttribute">
 <summary>
 这个自定义属性与<see cref="T:System.ComponentModel.DescriptionAttribute"/>的使用类似
 只不过<see cref="T:System.ComponentModel.DescriptionAttribute"/>是针对命令的简单说明
 以及描述
 
 这个自定义属性是针对命令内的某些注意事项的更加详细的描述，默认是不显示的
 会在man模式下被显示出来
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.Reflection.OutputAttribute.extension">
 <summary>
 The file extension name, like ``*.csv``
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.CommandLine.Reflection.CLIToken">
 <summary>
 A very basically type in the <see cref="T:Microsoft.VisualBasic.CommandLine.CommandLine"/>
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.Reflection.CLIToken.Name">
 <summary>
 Name of this token object, this can be parameter name or api name.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Reflection.CLIToken.#ctor(System.String)">
 <summary>
 Init this token by using <see cref="P:Microsoft.VisualBasic.CommandLine.Reflection.CLIToken.Name"/> value.
 </summary>
 <param name="name">Token name</param>
</member>
<member name="T:Microsoft.VisualBasic.CommandLine.Reflection.Argv">
 <summary>
 可以将这个自定义属性添加到类型的属性上面，添加额外的命名以及类型之类的标记
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.Reflection.Argv.Type">
 <summary>
 对于<see cref="F:Microsoft.VisualBasic.CommandLine.Reflection.CLITypes.String"/>和<see cref="F:Microsoft.VisualBasic.CommandLine.Reflection.CLITypes.File"/>
 程序会有不同的处理操作，虽然二者的值都是字符串输入
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.Reflection.Argv.IsOptional">
 <summary>
 Optional commandline arguments.(本属性标记一个命令行字符串之中的可选参数)
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Reflection.Argv.#ctor(System.String,Microsoft.VisualBasic.CommandLine.Reflection.CLITypes,System.Boolean)">
 <summary>
 默认为参数字符串通用类型
 </summary>
 <param name="name$"></param>
 <param name="type"></param>
 <param name="optional">
 Optional commandline arguments.(本属性标记一个命令行字符串之中的可选参数)
 </param>
</member>
<member name="T:Microsoft.VisualBasic.CommandLine.Reflection.Prefix">
 <summary>
 这个自定义属性添加在Class申明上表示该class类的命令行参数的名称都会添加这个prefix
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.CommandLine.Reflection.CLITypes">
 <summary>
 The data type enumeration of the target optional parameter switch.
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.VisualBasic.CommandLine.Reflection.CLITypes.Undefined">
 <summary>
 其他未知的未定义类型
 (如果是未定义的类型，则在自动生成命令行参数值的时候会被忽略掉，这个时候会需要你自己进行
 手动处理这些未定义类型的参数值)
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.CommandLine.Reflection.CLITypes.File">
 <summary>
 File/directory path, is equals most string.
 (对于指定为路径类型的参数值，在生成命令行的时候会自动调用<see cref="M:Microsoft.VisualBasic.ApplicationServices.Utils.CLIPath(System.String)"/>函数，
 在Linux系统之中，文件夹也是一种文件)
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.CommandLine.Reflection.CLITypes.String">
 <summary>
 ``String``.(对于指定为字符串类型的参数，在调用的时候回自动调用
 <see cref="M:Microsoft.VisualBasic.ApplicationServices.Utils.CLIToken(System.String)"/>函数)
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.VisualBasic.CommandLine.Reflection.CLITypes.Integer">
 <summary>
 Int
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.VisualBasic.CommandLine.Reflection.CLITypes.Double">
 <summary>
 Real
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.VisualBasic.CommandLine.Reflection.CLITypes.Boolean">
 <summary>
 This is a flag value, if this flag presents in the CLI, then this named Boolean 
 value is ``TRUE``, otherwise is ``FALSE``.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.CommandLine.Reflection.CLITypes.Base64">
 <summary>
 This cli argument parameter value is kind of binary value, 
 we can decode this value into binary data chunks.
 
 (这个命令行参数值是base64字符串，可以看作为一个二进制输入参数)
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.CommandLine.Reflection.EntryPoints.APIEntryPoint">
 <summary>
 The entry point data of the commands in the command line which was original loaded 
 from the source meta data in the compiled target.
 (命令行命令的执行入口点)
 </summary>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.Reflection.EntryPoints.APIEntryPoint.Arguments">
 <summary>
 当前的这个命令对象的参数帮助信息列表
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.Reflection.EntryPoints.APIEntryPoint.EntryPoint">
 <summary>
 The reflection entry point in the assembly for the target method object.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.Reflection.EntryPoints.APIEntryPoint.target">
 <summary>
 If the target invoked <see cref="P:Microsoft.VisualBasic.CommandLine.Reflection.EntryPoints.APIEntryPoint.EntryPoint">method delegate</see> is a instance method, 
 then this property value should be the target object instance which has the method delegate.
 (假若目标方法不是共享的方法，则必须要使用本对象来进行Invoke的调用)
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.Reflection.EntryPoints.APIEntryPoint.IsInstanceMethod">
 <summary>
 The shared method did not requires of the object instance.(这个方法是否为实例方法)
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Reflection.EntryPoints.APIEntryPoint.EntryPointFullName(System.Boolean)">
 <summary>
 The full name path of the target invoked method delegate in the namespace library.
 </summary>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Reflection.EntryPoints.APIEntryPoint.#ctor(System.Object)">
 <summary>
 这个构造函数只设置目标实例对象，其他的数据从属性进行设置
 </summary>
 <param name="invokeOn"></param>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Reflection.EntryPoints.APIEntryPoint.#ctor(Microsoft.VisualBasic.CommandLine.Reflection.ExportAPIAttribute,System.Reflection.MethodInfo,System.Boolean)">
 <summary>
 Instance method can be initialize from this constructor.
 (假若目标方法为实例方法，请使用本方法进行初始化)
 </summary>
 <param name="attribute"></param>
 <param name="Invoke"></param>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Reflection.EntryPoints.APIEntryPoint.HelpInformation(System.Boolean)">
 <summary>
 Returns the help information details for this command line entry object.(获取本命令行执行入口点的详细帮助信息)
 </summary>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Reflection.EntryPoints.APIEntryPoint.Invoke(System.Object[],System.Boolean)">
 <summary>
 Invoke this command line and returns the function value.(函数会补齐可选参数)
 </summary>
 <param name="parameters">The function parameter for the target invoked method, the optional value will be filled 
 using the paramter default value if you are not specific the optional paramter value is the element position of 
 this paramter value.</param>
 <param name="Throw">If throw then if the exception happened from delegate invocation then the program will throw an 
 exception and terminated, if not then the program will save the exception information into a log file and then 
 returns a failure status.</param>
 <returns></returns>
 <remarks></remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Reflection.EntryPoints.APIEntryPoint.DirectInvoke(System.Object[],System.Boolean)">
 <summary>
 不会自动调整补齐参数
 </summary>
 <param name="callParameters"></param>
 <param name="[Throw]"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Reflection.EntryPoints.APIEntryPoint.tryInvoke(System.Object[],System.Object,System.Boolean)">
 <summary>
 记录错误信息的最上层的堆栈
 </summary>
 <param name="callParameters"></param>
 <param name="target"></param>
 <param name="[throw]"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Reflection.EntryPoints.APIEntryPoint.Invoke(System.Object[],System.Object,System.Boolean)">
 <summary>
 Invoke this command line and returns the function value.
 (函数会补齐可选参数)
 </summary>
 <param name="parameters">The function parameter for the target invoked method, the optional value will be filled 
 using the parameter default value if you are not specific the optional parameter value is the element position of 
 this parameter value.</param>
 <param name="target">Target entry pointer of this function method delegate.</param>
 <param name="Throw">If throw then if the exception happened from delegate invocation then the program will throw an 
 exception and terminated, if not then the program will save the exception information into a log file and then 
 returns a failure status.</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Reflection.EntryPoints.APIEntryPoint.InvokeCLI(System.Object[],System.Object,System.Boolean)">
 <summary>
 Invoke this command line but returns the function execute success, Zero for success and -1 for failure.
 (函数会补齐可选参数)
 </summary>
 <param name="parameters"></param>
 <param name="target"></param>
 <param name="Throw"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.Reflection.EntryPoints.APIDelegate.Name">
 <summary>
 The usage name of this command line entry point.(本命令行对象的调用命令名称)
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Reflection.EntryPoints.APIDelegate.#ctor(Microsoft.VisualBasic.ComponentModel.Binding{Microsoft.VisualBasic.CommandLine.Reflection.ExportAPIAttribute,System.Reflection.MethodInfo},System.Func{System.Object[],System.Int32})">
 <summary>
 不可以使用本方法初始化目标对象为实例方法的类型
 </summary>
 <param name="attribute"></param>
 <param name="Invoke"></param>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Reflection.EntryPoints.APIDelegate.Execute(Microsoft.VisualBasic.CommandLine.CommandLine)">
 <summary>
 + 如果目标方法是一个Function函数,则退出代码为目标函数返回值
 + 如果目标方法是一个无返回的Sub,则退出代码永远都是零
 </summary>
 <param name="args">数组的长度必须与目标函数的参数的数目一致，否则短于目标函数的参数的数目的数组会使用Nothing来填充缺少的部分，而多于目标函数的参数会被截断</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Reflection.EntryPoints.APIDelegate.MatchArgumentName(Microsoft.VisualBasic.CommandLine.CommandLine,System.String,Microsoft.VisualBasic.Scripting.MetaData.Parameter)">
 <summary>
 convert the clr function parameter name as the commandline argument name
 </summary>
 <param name="args"></param>
 <param name="name"></param>
 <param name="[alias]"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.CommandLine.Reflection.ExportApiInformation">
 <summary>
 Data reader and view for <see cref="T:Microsoft.VisualBasic.CommandLine.Reflection.ExportAPIAttribute"/>
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.CommandLine.Reflection.RunDllEntryPoint">
 <summary>
 
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Reflection.RunDllEntryPoint.#ctor(System.String)">
 <summary>
 rundll namespace::api
 </summary>
 <param name="Name"></param>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Reflection.RunDllEntryPoint.GetPoint(System.String)">
 <summary>
 
 </summary>
 <param name="entrypoint"></param>
 <returns>
 假若没有api的名称的话，是默认使用一个名字为``Main``的主函数来运行的
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Reflection.RunDllEntryPoint.GetDllMethod(System.Reflection.Assembly,System.String)">
 <summary>
 大小写不敏感
 </summary>
 <param name="assembly"></param>
 <param name="entryPoint">
 namespace::funcName
 </param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Reflection.RunDllEntryPoint.GetDllMainFunc(System.Type,System.String)">
 <summary>
 
 </summary>
 <param name="dll"></param>
 <param name="entry"></param>
 <returns>
 this function returns nothing if the method is not found
 </returns>
</member>
<member name="P:Microsoft.VisualBasic.CommandLine.Grouping.Groups.Data">
 <summary>
 这个分组之中的API列表
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.Grouping.#ctor(Microsoft.VisualBasic.CommandLine.Interpreter)">
 <summary>
 
 </summary>
 <param name="CLI">
 主要是需要从这个类型定义之中得到<see cref="T:Microsoft.VisualBasic.CommandLine.Reflection.GroupingDefineAttribute"/>数据
 </param>
</member>
<member name="T:Microsoft.VisualBasic.CommandLine.StreamExtensions">
 <summary>
 + file path: C://path/to/file
 + standard input: std_in://
 + standard output: std_out://
 + memory mapping file: memory://file/uri
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.StreamExtensions.OpenForRead(System.String)">
 <summary>
 一个用于通用化的打开数据流读取对象的函数
 </summary>
 <param name="reference"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CommandLine.StreamExtensions.OpenForWrite(System.String,System.Int64)">
 <summary>
 请注意,这个函数在创建内存映射文件的时候,默认是0.5GB大小的
 </summary>
 <param name="reference"></param>
 <param name="size"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Algorithm.base.Comb`1">
 <summary>
 对象类型的组合输出工具，即目标类型的集合之中的元素两两组合配对
 </summary>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Algorithm.base.Comb`1.EOL">
 <summary>
 对象列表是否已经完全组合输出
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Algorithm.base.Comb`1.NewLine">
 <summary>
 是否已经开始读取新的一行数据
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Algorithm.base.Comb`1.CreateCompleteObjectPairs(System.Collections.Generic.IEnumerable{`0})">
 <summary>
 Creates the completely combination of the elements in the target input collection source.
 (创建完完全全的两两配对)
 </summary>
 <param name="source"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Algorithm.base.Combination`1">
 <summary>
 https://github.com/coderespawn/permutations
 </summary>
 <typeparam name="T"></typeparam>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Algorithm.base.CombinationExtensions">
 <summary>
 任意多个集合之间的对象之间相互组成组合输出
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Algorithm.base.CombinationExtensions.CreateCombos``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
 <summary>
 生成两个序列的两两组合 ``{<paramref name="seq_1"/> -> <paramref name="seq_2"/>}()``
 </summary>
 <typeparam name="TA"></typeparam>
 <typeparam name="TB"></typeparam>
 <param name="seq_1"></param>
 <param name="seq_2"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Algorithm.base.CombinationExtensions.Iteration``1(``0[][])">
 <summary>
 create a vs b vs c ...
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Algorithm.base.DistanceMap`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Func{`0,`0,System.Double})">
 <summary>
 NxN distance matrix
 </summary>
 <param name="points"></param>
 <param name="metric">
 具有对称性的距离计算公式，通常为欧几里得距离
 </param>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Algorithm.base.DistanceMap`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`0},System.Func{`0,`0,System.Double})">
 <summary>
 MxN distance matrix
 </summary>
 <param name="pts1"></param>
 <param name="pts2"></param>
 <param name="metric">具有对称性的距离计算公式，通常为欧几里得距离</param>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Algorithm.base.SlideWindowExtensions">
 <summary>
 Create a collection of slide Windows data for the target collection object.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Algorithm.base.SlideWindowExtensions.CreateSlideWindows``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Int32,System.Boolean)">
 <summary>
 Create a collection of slide Windows data for the target collection object.(创建一个滑窗集合)
 </summary>
 <typeparam name="T"></typeparam>
 <param name="data"></param>
 <param name="winSize">The windows size of the created slide window.(窗口的大小)</param>
 <param name="offset">在序列之上移动的步长</param>
 <returns></returns>
 <param name="extTails">引用类型不建议打开这个参数</param>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Algorithm.base.SlideWindowExtensions.SlideWindows``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Int32,System.Boolean)">
 <summary>
 Create a collection of slide Windows data for the target collection object.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="data"></param>
 <param name="winSize">The windows size of the created slide window.(窗口的大小)</param>
 <param name="offset">在序列之上移动的步长</param>
 <returns></returns>
 <param name="extTails">引用类型不建议打开这个参数</param>
 <remarks>(创建一个滑窗集合)</remarks>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Algorithm.base.SlideWindow`1">
 <summary>
 A slide window data model.(滑窗操作的数据模型)
 </summary>
 <typeparam name="T"></typeparam>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Algorithm.base.SlideWindow`1.Index">
 <summary>
 The position of the current Windows in the Windows list.(在创建的滑窗的队列之中当前的窗口对象的位置)
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Algorithm.base.SlideWindow`1.Items">
 <summary>
 The elements in this slide window.(这个划窗之中的元素的列表)
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Algorithm.base.SlideWindow`1.left">
 <summary>
 The left start position of the current slide Windows segment on the original sequence.
 (当前窗口在原始的序列之中的左端起始位点)
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Algorithm.base.SlideWindow`1.Length">
 <summary>
 The length of the slide window.(窗口长度)
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Algorithm.BinarySearchFunction`2">
 <summary>
 精确查找某一个对象
 </summary>
 <typeparam name="K"></typeparam>
 <typeparam name="T"></typeparam>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Algorithm.BinarySearchFunction`2.Item(System.Int32)">
 <summary>
 negative index value means read from reverse seqeucne
 </summary>
 <param name="i"></param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Algorithm.BinarySearchFunction`2.size">
 <summary>
 the length of the input sequence data
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Algorithm.BinarySearchFunction`2.BinarySearch(`0)">
 <summary>
 should be reorder in asc
 </summary>
 <param name="target"></param>
 <returns>Returns ``-1`` means no search result</returns>
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.Algorithm.BinaryTree.DelegateTreeInsertCallback`2.m_duplicated">
 <summary>
 usually for add cluster member into cluster
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Algorithm.BinaryTree.DelegateTreeInsertCallback`2.#ctor">
 <summary>
 default is do nothing
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Algorithm.BinaryTree.AVLClusterTree`1">
 <summary>
 A binary tree model for do data clustering
 </summary>
 <typeparam name="K">
 the key data type andalso the cluster value type
 </typeparam>
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.Algorithm.BinaryTree.AVLClusterTree`1.addClusterMember">
 <summary>
 thread unsafe
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Algorithm.BinaryTree.AVLClusterTree`1.Search(`0)">
 <summary>
 Make key search and then populate all hits cluster member
 </summary>
 <param name="key"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Algorithm.BinaryTree.AVLSupports">
 <summary>
 Binary tree balance helper
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Algorithm.BinaryTree.AVLTree`2">
 <summary>
 The AVL binary tree operator. the binbox key is <typeparamref name="K"/> and 
 value data type is <typeparamref name="V"/>.
 </summary>
 <typeparam name="K"></typeparam>
 <typeparam name="V"></typeparam>
 <remarks>
 http://www.cnblogs.com/huangxincheng/archive/2012/07/22/2603956.html
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Algorithm.BinaryTree.AVLTree`2.#ctor(System.Comparison{`0},System.Func{`0,System.String})">
 <summary>
 Create an instance of the AVL binary tree.
 </summary>
 <param name="compares">
 ``compares(newKey, treeKey)``:
 
 Compare between two keys. This comparison function should returns: 
 
 + 0, means two keys are equals.
 + 1, means a is greater than b.
 + -1, means a is smaller than b.
 </param>
 <param name="views">Display the key as string</param>
 <remarks>
 the binbox key is <typeparamref name="K"/> and 
 value data type is <typeparamref name="V"/>.
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Algorithm.BinaryTree.AVLTree`2.Add(`0,`1,System.Boolean)">
 <summary>
 add key related value into current tree
 </summary>
 <param name="key"></param>
 <param name="value"></param>
 <param name="valueReplace"></param>
 <remarks>
 get cluster value collection via the tree node ``values`` data
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Algorithm.BinaryTree.AVLTree`2.Find(`0)">
 <summary>
 This function will returns nothing if <paramref name="term"/> not found in current tree.
 </summary>
 <param name="term"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Algorithm.BinaryTree.ClusterKey`1">
 <summary>
 wrapper for the cluster data
 </summary>
 <typeparam name="K"></typeparam>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Algorithm.BinaryTree.ClusterKey`1.Root">
 <summary>
 use the first element in current cluster member set as the root element
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Algorithm.BinaryTree.ClusterKey`1.Add(`0)">
 <summary>
 get all cluster data from this cluster data object, the first element is the root seed of current tree node
 </summary>
 <param name="newMember"></param>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Algorithm.BinaryTree.ClusterKey`1.DoComparison(System.Comparison{`0},Microsoft.VisualBasic.ComponentModel.Algorithm.BinaryTree.ComparisonDirectionPrefers,System.Boolean)">
 <summary>
 在这里应该是多个key比较一个query
 </summary>
 <param name="compares"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Algorithm.BinaryTree.Extensions">
 <summary>
 Help methods for the binary tree operations
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Algorithm.BinaryTree.Extensions.Find``2(Microsoft.VisualBasic.ComponentModel.Algorithm.BinaryTree.BinaryTree{``0,``1},``0,System.Comparison{``0})">
 <summary>
 查找失败会返回空值
 </summary>
 <typeparam name="K"></typeparam>
 <typeparam name="V"></typeparam>
 <param name="tree"></param>
 <param name="key"></param>
 <param name="compares"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Algorithm.BinaryTree.Enumerable.PopulateSequence``2(Microsoft.VisualBasic.ComponentModel.Algorithm.BinaryTree.BinaryTree{``0,``1})">
 <summary>
 Populate an ASC sortted sequence from this binary tree 
 
 ```
 left -> me -> right
 ```
 </summary>
 <typeparam name="K"></typeparam>
 <typeparam name="V"></typeparam>
 <param name="tree"></param>
 <returns></returns>
 <remarks>
 这个函数是直接将键名和对应的值取出来，如果是需要取出聚类的簇成员，
 应该使用<see cref="M:Microsoft.VisualBasic.ComponentModel.Algorithm.BinaryTree.Enumerable.PopulateNodes``2(Microsoft.VisualBasic.ComponentModel.Algorithm.BinaryTree.BinaryTree{``0,``1})"/>方法
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Algorithm.BinaryTree.Enumerable.PopulateNodes``2(Microsoft.VisualBasic.ComponentModel.Algorithm.BinaryTree.BinaryTree{``0,``1})">
 <summary>
 将一个给定的二叉树对象转换为一个数组序列
 </summary>
 <typeparam name="K"></typeparam>
 <typeparam name="V"></typeparam>
 <param name="tree"></param>
 <returns>
 current -> right -> left
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Algorithm.BinaryTree.Enumerable.Values``2(Microsoft.VisualBasic.ComponentModel.Algorithm.BinaryTree.BinaryTree{``0,``1})">
 <summary>
 Get all value property from the childs in this given node
 </summary>
 <typeparam name="K"></typeparam>
 <typeparam name="V"></typeparam>
 <param name="tree"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Algorithm.BinaryTree.NaiveBinaryTree`2">
 <summary>
 The Binary tree itself. 朴素二叉树
 
 A very basic Binary Search Tree. Not generalized, stores
 name/value pairs in the tree nodes. name is the node key.
 The advantage of a binary tree is its fast insert and lookup
 characteristics. This version does not deal with tree balancing.
 (二叉搜索树，用于建立对repository的索引文件)
 </summary>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Algorithm.BinaryTree.NaiveBinaryTree`2.Length">
 <summary>
 Returns the number of nodes in the tree
 </summary>
 <returns>Number of nodes in the tree</returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Algorithm.BinaryTree.NaiveBinaryTree`2.KillTree(Microsoft.VisualBasic.ComponentModel.Algorithm.BinaryTree.BinaryTree{`0,`1}@)">
 <summary>
 Recursive destruction of binary search tree, called by method clear
 and destroy. Can be used to kill a sub-tree of a larger tree.
 This is a hanger on from its Delphi origins, it might be dispensable
 given the garbage collection abilities of .NET
 </summary>
 <param name="p"></param>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Algorithm.BinaryTree.NaiveBinaryTree`2.Clear">
 <summary>
 Clear the binary tree.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Algorithm.BinaryTree.NaiveBinaryTree`2.FindSymbol(`0,Microsoft.VisualBasic.ComponentModel.Algorithm.BinaryTree.BinaryTree{`0,`1}@)">
 <summary>
 Find name in tree. Return a reference to the node
 if symbol found else return null to indicate failure.
 </summary>
 <param name="key">Name of node to locate</param>
 <returns>Returns null if it fails to find the node, else returns reference to node</returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Algorithm.BinaryTree.NaiveBinaryTree`2.add(Microsoft.VisualBasic.ComponentModel.Algorithm.BinaryTree.BinaryTree{`0,`1},Microsoft.VisualBasic.ComponentModel.Algorithm.BinaryTree.BinaryTree{`0,`1}@,System.Boolean)">
 <summary>
 Recursively locates an empty slot in the binary tree and inserts the node
 </summary>
 <param name="node"></param>
 <param name="tree"></param>
 <returns>
 当处于append模式下，append值的时候不会返回节点，而是返回nothing
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Algorithm.BinaryTree.NaiveBinaryTree`2.insert(`0,`1,System.Boolean)">
 <summary>
 Add a symbol to the tree if it's a new one. Returns reference to the new
 node if a new node inserted, else returns null to indicate node already present.
 </summary>
 <param name="append">
 If this argument value is set to ``TRUE``, then it means do value key clustering. 
 </param>
 <returns> Returns reference to the new node is the node was inserted.
 If a duplicate node (same name was located then returns null</returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Algorithm.BinaryTree.NaiveBinaryTree`2.findSuccessor(Microsoft.VisualBasic.ComponentModel.Algorithm.BinaryTree.BinaryTree{`0,`1},Microsoft.VisualBasic.ComponentModel.Algorithm.BinaryTree.BinaryTree{`0,`1}@)">
 <summary>
 Find the next ordinal node starting at node startNode.
 Due to the structure of a binary search tree, the
 successor node is simply the left most node on the right branch.
 </summary>
 <param name="startNode">Name key to use for searching</param>
 <param name="parent">Returns the parent node if search successful</param>
 <returns>Returns a reference to the node if successful, else null</returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Algorithm.BinaryTree.NaiveBinaryTree`2.delete(`0)">
 <summary>
 Delete a given node. This is the more complex method in the binary search
 class. The method considers three senarios, 
 
 + 1) the deleted node has no children; 
 + 2) the deleted node as one child; 
 + 3) the deleted node has two children. 
 
 Case one and two are relatively simple to handle, the only unusual considerations 
 are when the node is the root node. Case ``3)`` is much more complicated. It 
 requires the location of the successor node.
 
 The node to be deleted is then replaced by the sucessor node and the
 successor node itself deleted. Throws an exception if the method fails
 to locate the node for deletion.
 </summary>
 <param name="key">Name key of node to delete</param>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Algorithm.BinaryTree.NaiveBinaryTree`2.drawNode(Microsoft.VisualBasic.ComponentModel.Algorithm.BinaryTree.BinaryTree{`0,`1})">
 <summary>
 Simple 'drawing' routines
 </summary>
 <param name="node"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Algorithm.BinaryTree.NaiveBinaryTree`2.ToString">
 <summary>
 Return the tree depicted as a simple string, useful for debugging, eg
 50(40(30(20, 35), 45(44, 46)), 60)
 </summary>
 <returns>Returns the tree</returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Algorithm.BinaryTree.Iterator`2.next">
 <summary>
 if null-iterator, returns first node
 otherwise, returns next node
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Algorithm.BinaryTree.Iterator`2.prev">
 <summary>
 if null-iterator, returns last node
 otherwise, returns previous node
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Algorithm.BinaryTree.RBNode`2">
 <summary>
 与键名所对应的数据是存储在<see cref="P:Microsoft.VisualBasic.ComponentModel.Algorithm.BinaryTree.BinaryTree`2.Value"/>之中的
 </summary>
 <typeparam name="K"></typeparam>
 <typeparam name="V"></typeparam>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Algorithm.BinaryTree.RBTree`2.Iterator">
 <summary>
 returns a null iterator call <see cref="M:Microsoft.VisualBasic.ComponentModel.Algorithm.BinaryTree.Iterator`2.next"/> or 
 <see cref="M:Microsoft.VisualBasic.ComponentModel.Algorithm.BinaryTree.Iterator`2.prev"/> to point to an element
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Algorithm.BinaryTree.RBTree`2.min">
 <summary>
 returns null if tree is empty
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Algorithm.BinaryTree.RBTree`2.max">
 <summary>
 returns null if tree is empty
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Algorithm.BinaryTree.RBTree`2.Insert(`0,`1)">
 <summary>
 returns true if inserted, false if duplicate
 </summary>
 <param name="key"></param>
 <param name="data"></param>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Algorithm.BinaryTree.RBTree`2.Remove(`0)">
 <summary>
 returns true if removed, false if not found
 </summary>
 <param name="key"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Algorithm.BinaryTree.RBTree`2.find(`0)">
 <summary>
 returns node data if found, null otherwise
 </summary>
 <param name="key"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Algorithm.BinaryTree.RBTree`2.findIter(`0)">
 <summary>
 returns iterator to node if found, null otherwise
 </summary>
 <param name="key"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Algorithm.BinaryTree.RBTree`2.lowerBound(`0)">
 <summary>
 Returns an interator to the tree node immediately before (or at) the element
 </summary>
 <param name="data"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Algorithm.BinaryTree.RBTree`2.upperBound(System.Object)">
 <summary>
 Returns an interator to the tree node immediately after (or at) the element
 </summary>
 <param name="data"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Algorithm.BinaryTree.RBTree`2.each(System.Action{`1})">
 <summary>
 calls cb on each node's data, in order
 </summary>
 <param name="cb"></param>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Algorithm.BinaryTree.RBTree`2.reach(System.Action{`1})">
 <summary>
 calls cb on each node's data, in reverse order
 </summary>
 <param name="cb"></param>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Algorithm.BinaryTree.RBTree`2._bound(`0,System.Comparison{`0})">
 <summary>
 used for lowerBound and upperBound
 </summary>
 <param name="data"></param>
 <param name="cmp"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Algorithm.BinaryTree.TreeBase`2">
 <summary>
 二叉树对象的通用模板
 </summary>
 <typeparam name="K"></typeparam>
 <typeparam name="V"></typeparam>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Algorithm.BinaryTree.TreeBase`2.root">
 <summary>
 The root node of this binary tree
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Algorithm.BinaryTree.TreeBase`2.#ctor(System.Comparison{`0},System.Func{`0,System.String})">
 <summary>
 Create an instance of the AVL binary tree.
 </summary>
 <param name="compares">Compare between two keys.</param>
 <param name="views">Display the key as string</param>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Algorithm.BinaryTree.TreeBase`2.Clear">
 <summary>
 将整棵树销毁
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Algorithm.BinaryTree.TreeBase`2.GetAllNodes">
 <summary>
 这个函数是直接返回stack list对象中的元素值
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Algorithm.BinaryTree.BinaryTree`2">
 <summary>
 The binary tree node.
 
 (如果执行的是聚类操作的话，可以通过!values字典属性来获取簇的结果)
 
 在这里只是二叉树的节点实现，具体的二叉树构建可以通过使用下面的算法来完成：
 
 + <see cref="T:Microsoft.VisualBasic.ComponentModel.Algorithm.BinaryTree.AVLTree`2"/> 
 
 </summary>
 <typeparam name="K"></typeparam>
 <typeparam name="V"></typeparam>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Algorithm.BinaryTree.BinaryTree`2.Key">
 <summary>
 键名是唯一的，赋值之后就不可以改变了
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Algorithm.BinaryTree.BinaryTree`2.Value">
 <summary>
 与当前的这个键名相对应的键值可以根据需求发生改变，即可以被任意赋值
 
 如果是进行聚类操作的话，可以通过``!values`` as <see cref="T:Microsoft.VisualBasic.Language.List`1"/>
 来添加簇成员
 </summary>
 <returns></returns>
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.Algorithm.BinaryTree.BinaryTree`2.additionals">
 <summary>
 Additional values that using for the binary tree algorithm.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Algorithm.BinaryTree.BinaryTree`2.QualifiedName">
 <summary>
 Full name of current node
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Algorithm.BinaryTree.BinaryTree`2.Members">
 <summary>
 Get cluster members
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Algorithm.BinaryTree.BinaryTree`2.#ctor(`0,`1,Microsoft.VisualBasic.ComponentModel.Algorithm.BinaryTree.BinaryTree{`0,`1},System.Func{`0,System.String})">
 <summary>
 the given <paramref name="value"/> will be added 
 into the member list by default in this constructor 
 function.
 </summary>
 <param name="key"></param>
 <param name="value"></param>
 <param name="parent"></param>
 <param name="toString">Default debug view is <see cref="M:Microsoft.VisualBasic.Scripting.InputHandler.ToString(System.Object,System.String,System.Boolean)"/></param>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Algorithm.BinaryTree.BinaryTree`2.SetValue(System.String,System.Object)">
 <summary>
 Set <see cref="F:Microsoft.VisualBasic.ComponentModel.Algorithm.BinaryTree.BinaryTree`2.additionals"/> value by using a key value tuple.
 </summary>
 <param name="key$"></param>
 <param name="value"></param>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Algorithm.BinaryTree.BinaryTree`2.ToString">
 <summary>
 Display debug view as: ``[key, value]``
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Algorithm.Block`1">
 <summary>
 a data index block with boundary range for matches
 </summary>
 <typeparam name="T"></typeparam>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Algorithm.Block`1.GetComparision(System.Double)">
 <summary>
 test two elements theirs comparision relationship
 </summary>
 <param name="fuzzy">
 the tolerance error for matches the index node is equals to the given query value.
 this options should only works when the target index node contains only one elements
 and the boundary interval length is zero.
 </param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Algorithm.BlockSearchFunction`1.size">
 <summary>
 the input element pool count
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Algorithm.BlockSearchFunction`1.raw">
 <summary>
 the raw input sequence data, element order keeps the same with the input sequence.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Algorithm.BlockSearchFunction`1.Keys">
 <summary>
 get all keys which are evaluated from the input object
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Algorithm.BlockSearchFunction`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Func{`0,System.Double},System.Double,System.Double,System.Boolean)">
 <summary>
 
 </summary>
 <param name="data"></param>
 <param name="eval"></param>
 <param name="tolerance"></param>
 <param name="factor"></param>
 <param name="fuzzy">
 20221101       
 works for the continues numeric sequence
 </param>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Algorithm.BlockSearchFunction`1.BuildIndex(Microsoft.VisualBasic.ComponentModel.Algorithm.SequenceTag{`0}[],System.Double,System.Double,System.Boolean)">
 <summary>
 Create the binary search index
 </summary>
 <param name="input"></param>
 <param name="tolerance"></param>
 <param name="factor"></param>
 <param name="fuzzy"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Algorithm.BlockSearchFunction`1.GetOffset(`0)">
 <summary>
 get index offset by target matches
 </summary>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Algorithm.BlockSearchFunction`1.Search(`0,System.Nullable{System.Double})">
 <summary>
 query data with a given tolerance value
 </summary>
 <param name="x"></param>
 <returns>
 this function returns an empty collection if no hits result
 </returns>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Algorithm.DynamicProgramming.LongestCommonSubsequenceExtension">
 <summary>
 Longest Common Subsequence
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Algorithm.DynamicProgramming.LongestCommonSubsequenceExtension.MaxLengthSubString(System.String,System.String)">
 <summary>
 比较两个字符串之间的最长的子串
 </summary>
 <param name="a"></param>
 <param name="b"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Algorithm.DynamicProgramming.Levenshtein.LevenshteinDistance">
 <summary>
 Levenshtein Edit Distance Algorithm for measure string distance
 </summary>
 <remarks>
 http://www.codeproject.com/Tips/697588/Levenshtein-Edit-Distance-Algorithm
 </remarks>

</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Algorithm.DynamicProgramming.Levenshtein.LevenshteinDistance.CreateTable``1(``0[],``0[],Microsoft.VisualBasic.ComponentModel.Algorithm.DynamicProgramming.Cost{``0},Microsoft.VisualBasic.ComponentModel.DataStructures.GenericLambda{``0}.IEquals)">
 <summary>
 用于泛型的序列相似度比较
 </summary>
 <typeparam name="T"></typeparam>
 <param name="reference"></param>
 <param name="hypotheses"></param>
 <param name="cost"></param>
 <param name="equals">泛型化的元素等价性的比较方法</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Algorithm.DynamicProgramming.Levenshtein.LevenshteinDistance.ComputeDistance``1(``0[],``0[],Microsoft.VisualBasic.ComponentModel.DataStructures.GenericLambda{``0}.IEquals,System.Double)">
 <summary>
 泛型序列的相似度的比较计算方法，这个函数返回的是距离
 </summary>
 <typeparam name="T"></typeparam>
 <param name="reference"></param>
 <param name="hypotheses"></param>
 <param name="equals"></param>
 <param name="cost"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Algorithm.DynamicProgramming.Levenshtein.LevenshteinDistance.ComputeDistance``1(``0[],``0[],Microsoft.VisualBasic.ComponentModel.DataStructures.GenericLambda{``0}.IEquals,Microsoft.VisualBasic.ComponentModel.Algorithm.DynamicProgramming.Levenshtein.LevenshteinDistance.ToChar{``0},System.Double)">
 <summary>
 泛型序列的相似度的比较计算方法，这个会返回所有的数据
 </summary>
 <typeparam name="T"></typeparam>
 <param name="reference"></param>
 <param name="hypotheses"></param>
 <param name="equals"></param>
 <param name="asChar">这个只是用于进行显示输出的</param>
 <param name="cost"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Algorithm.DynamicProgramming.Levenshtein.LevenshteinDistance.ComputeDistance(System.Int32[],System.String,System.Double,Microsoft.VisualBasic.ComponentModel.DataStructures.GenericLambda{System.Int32}.IEquals)">
 <summary>
 Implement the Levenshtein Edit Distance algorithm between string.
 </summary>
 <param name="reference">The reference string ASCII cache.</param>
 <param name="hypotheses"></param>
 <param name="cost"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Algorithm.DynamicProgramming.Levenshtein.LevenshteinDistance.computeRouteImpl(System.String,Microsoft.VisualBasic.ComponentModel.Algorithm.DynamicProgramming.Levenshtein.DistResult,System.Int32,System.Int32,System.Double[0:,0:])">
 <summary>
 计算lev编辑的变化路径
 </summary>
 <param name="hypotheses"></param>
 <param name="result"></param>
 <param name="i"></param>
 <param name="j"></param>
 <param name="distTable"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Algorithm.DynamicProgramming.Levenshtein.LevenshteinDistance.ComputeDistance(System.String,System.String,System.Double,Microsoft.VisualBasic.ComponentModel.DataStructures.GenericLambda{System.Char}.IEquals)">
 <summary>
 The edit distance between two strings is defined as the minimum number of
 edit operations required to transform one string into another.
 </summary>
 <param name="reference"></param>
 <param name="hypotheses"></param>
 <param name="cost"></param>
 <returns></returns>
 <remarks>
 (请注意，这函数是大小写敏感的。如果需要大小写不敏感，在使用前，请先将函数的两个字符串参数都转换为小写形式)
 </remarks>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Algorithm.DynamicProgramming.Levenshtein.DistResult.DistEdits">
 <summary>
 How doest the <see cref="P:Microsoft.VisualBasic.ComponentModel.Algorithm.DynamicProgramming.Levenshtein.DistResult.Hypotheses"/> evolve from <see cref="P:Microsoft.VisualBasic.ComponentModel.Algorithm.DynamicProgramming.Levenshtein.DistResult.Reference"/>.(这个结果描述了subject是如何变化成为Query的)
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Algorithm.DynamicProgramming.Levenshtein.DistResult.Distance">
 <summary>
 the edit distance
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Algorithm.DynamicProgramming.Levenshtein.DistResult.Score">
 <summary>
 可以简单地使用这个数值来表述所比较的两个对象之间的相似度
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Algorithm.DynamicProgramming.Levenshtein.DistResult.MatchSimilarity">
 <summary>
 ``m+`` scores.(0-1之间)
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Algorithm.DynamicProgramming.Levenshtein.DistResult.NumMatches">
 <summary>
 比对上的对象的数目
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Algorithm.DynamicProgramming.Levenshtein.ResultVisualize.HTMLVisualize(Microsoft.VisualBasic.ComponentModel.Algorithm.DynamicProgramming.Levenshtein.DistResult)">
 <summary>
 Output HTML result for visualization
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Algorithm.DynamicProgramming.LongestCommonSubsequence`1">
 <summary>
 Longest Common Subsequence
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Algorithm.DynamicProgramming.LongestCommonSubsequence`1.findMatch(`0[],`0[],Microsoft.VisualBasic.ComponentModel.Algorithm.DynamicProgramming.IEquals{`0})">
 <summary>
 
 </summary>
 <param name="s"></param>
 <param name="t"></param>
 <param name="equals"></param>
 <returns>``{length, si, ti}``</returns>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Algorithm.DynamicProgramming.SCS">
 <summary>
 shortest_common_superstring
 </summary>
 <remarks>
 https://github.com/aakash01/codebase/blob/60394bf92eb09410c07eec1c4d3c81cf0fc72a70/src/com/aakash/practice/interviewbit_may2017/dynamic_programming/ShortestCommonSuperString.java
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Algorithm.DynamicProgramming.SCS.Coverage(System.Collections.Generic.IEnumerable{System.String},System.Char)">
 <summary>
 使用重叠程度最高的片段作为统计的标准
 </summary>
 <param name="table"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Algorithm.DynamicProgramming.SCS.ShortestCommonSuperString(System.Collections.Generic.IEnumerable{System.String})">
 <summary>
 Solve using Greedy. For all string find the max common prefix/suffix. Merge those two strings
 and continue it.
 </summary>
 <remarks>
 当这个函数遇到完全没有重叠的序列片段的时候，是会直接将这个不重叠的片段接到SCS的最末尾的
 </remarks>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Algorithm.QuickSortFunction`2">
 <summary>
 快速排序基本上被认为是相同数量级的所有排序算法中，平均性能最好的。
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Counter">
 <summary>
 The object counter
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Counter.#ctor">
 <summary>
 Create a new integer counter start from ZERO.(新建一个计数器)
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Counter.Hit">
 <summary>
 ``++i``
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Counter.op_Equality(Microsoft.VisualBasic.ComponentModel.Counter,Microsoft.VisualBasic.ComponentModel.Counter)">
 <summary>
 the count hit value is equals to each other?
 </summary>
 <param name="a"></param>
 <param name="b"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Counter.op_Inequality(Microsoft.VisualBasic.ComponentModel.Counter,Microsoft.VisualBasic.ComponentModel.Counter)">
 <summary>
 the count hit value is not equals to each other?
 </summary>
 <param name="a"></param>
 <param name="b"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.CounterExtensions.Pop``1(System.Collections.Generic.Stack{``0},Microsoft.VisualBasic.ComponentModel.Counter)">
 <summary>
 populate n elements from current stack
 </summary>
 <typeparam name="T"></typeparam>
 <param name="stack"></param>
 <param name="n"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Iterator`1">
 <summary>
 在<see cref="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Iterator"/>的基础之上所构建出来的一个泛型化的迭代器对象.
 </summary>
 <typeparam name="T"></typeparam>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Iterator">
 <summary>
 Implements for the <see cref="T:System.Collections.Generic.IEnumerable`1"/>, Supports a simple iteration over a non-generic collection.
 (这个迭代器对象主要是用在远程数据源之中的，对于本地的数据源而言，使用这个迭代器的效率太低了，但是对于远程数据源而言，由于存在网络延迟，所以这个迭代器的效率影响将可以被忽略不计)
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Iterator.Current">
 <summary>
 Gets the current element in the collection.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Iterator.ReadDone">
 <summary>
 Indicates that there are no more characters in the string and tokenizer is finished.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Iterator.GetEnumerator">
 <summary>
 Exposes an enumerator, which supports a simple iteration over a non-generic collection.To
 browse the .NET Framework source code for this type, see the Reference Source.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Iterator.Read">
 <summary>
 Returns current and then automatically move to next position
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Iterator.Reset">
 <summary>
 Sets the enumerator to its initial position, which is before the first element in the collection.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Iterator.MoveNext">
 <summary>
 Advances the enumerator to the next element of the collection.
 </summary>
 <returns>
 true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.
 </returns>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.DynamicPropertyBase`1">
 <summary>
 This abstract object has a <see cref="F:Microsoft.VisualBasic.ComponentModel.DataSourceModel.DynamicPropertyBase`1.propertyTable"/> dictionary keeps as 
 a dynamics property source.
 </summary>
 <typeparam name="T"></typeparam>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.DynamicPropertyBase`1.Properties">
 <summary>
 The dynamics property object with specific type of value.
 </summary>
 <returns></returns>
 <remarks>Can not serialize the dictionary object in to xml document. **and this property ensure that the value always not null!**</remarks>
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.DataSourceModel.DynamicPropertyBase`1.propertyTable">
 <summary>
 动态属性表
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.DynamicPropertyBase`1.ItemValue(System.String)">
 <summary>
 Gets/sets item value by using property name.
 </summary>
 <param name="name"></param>
 <returns></returns>
 <remarks>
 (这个函数为安全的函数，当目标属性不存在的时候，会返回空值)
 </remarks>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.DynamicPropertyBase`1.ItemValue(System.Collections.Generic.IEnumerable{System.String})">
 <summary>
 Get a value package at once using a key collection, 
 if the key is not exists in the property, then its 
 correspoding value is nothing.
 </summary>
 <param name="keys"></param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.DynamicPropertyBase`1.ItemValue(System.Collections.Generic.IEnumerable{Microsoft.VisualBasic.ComponentModel.Collection.Generic.INamedValue})">
 <summary>
 Get a value package at once using a key collection, 
 if the key is not exists in the property, then its 
 correspoding value is nothing.
 </summary>
 <param name="keys"></param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.DynamicPropertyBase`1.ItemValue(System.Collections.Generic.IEnumerable{Microsoft.VisualBasic.ComponentModel.Collection.Generic.IReadOnlyId})">
 <summary>
 Get a value package at once using a key collection, 
 if the key is not exists in the property, then its 
 correspoding value is nothing.
 </summary>
 <param name="keys"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.DynamicPropertyBase`1.Add(System.String,`0)">
 <summary>
 Add a property into the property table
 </summary>
 <param name="propertyName$"></param>
 <param name="value"></param>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.DynamicPropertyBase`1.HasProperty(System.String)">
 <summary>
 Determines whether the Dictionary contains the specified key.
 </summary>
 <param name="name">The key to locate in the Dictionary.</param>
 <returns>
 true if the Dictionary contains an element with the specified key; 
 otherwise, false.
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.DynamicPropertyBase`1.GetNames">
 <summary>
 Get all keys in <see cref="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.DynamicPropertyBase`1.Properties"/>
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.DynamicPropertyBase`1.EnumerateKeys(System.Boolean)">
 <summary>
 枚举这个动态字典类型之中的所有的键名，这个函数是默认不包含有类型自有的属性名称的
 </summary>
 <param name="joinProperties">是否包括属性名称，默认不包含</param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.DynamicPropertyBase`1.MyHashCode">
 <summary>
 Using for debugger view, this property is usually usefull for the dictionary view 
 to see if any duplicated was existed? 
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Property`1">
 <summary>
 Dictionary for [<see cref="T:System.String"/>, <typeparamref name="T"/>]
 </summary>
 <typeparam name="T"></typeparam>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Property`1.#ctor(System.String,`0)">
 <summary>
 New with a init property value
 </summary>
 <param name="initKey"></param>
 <param name="initValue"></param>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Property`1.src">
 <summary>
 
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.IProperty.GetValue(System.Object)">
 <summary>
 Gets property value from <paramref name="target"/> object.
 </summary>
 <param name="target"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.IProperty.SetValue(System.Object@,System.Object)">
 <summary>
 Set <paramref name="value"/> to the property of <paramref name="target"/> object.
 </summary>
 <param name="target"></param>
 <param name="value"></param>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.IDynamicsObject">
 <summary>
 Apply for R# object cast .NET CLR object to list
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.IDynamicMeta`1">
 <summary>
 Abstracts for the dynamics property.
 </summary>
 <typeparam name="T"></typeparam>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.IDynamicMeta`1.Properties">
 <summary>
 Properties
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.DynamicMetadataAttribute">
 <summary>
 just used for tagged on the <see cref="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.DynamicPropertyBase`1.Properties"/> property
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.DynamicMetadataAttribute.GetMetadata(System.Collections.Generic.IEnumerable{System.Reflection.PropertyInfo})">
 <summary>
 find the first <see cref="T:System.Reflection.PropertyInfo"/> which is tagged with <see cref="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.DynamicMetadataAttribute"/>
 </summary>
 <param name="properties"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.DynamicMetadataAttribute.GetMetadata(System.Type)">
 <summary>
 get the target <see cref="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.DynamicPropertyBase`1.Properties"/> its <see cref="T:System.Reflection.PropertyInfo"/>
 </summary>
 <param name="type"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedCollection`1">
 <summary>
 The value object collection that have a name string, using <see cref="T:Microsoft.VisualBasic.Text.Xml.Models.NamedVector`1"/> 
 for XML serialization instead of using this data model.
 </summary>
 <typeparam name="T"></typeparam>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedCollection`1.name">
 <summary>
 这个集合对象的标识符名称
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedCollection`1.value">
 <summary>
 目标集合对象
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedCollection`1.description">
 <summary>
 目标集合对象的描述信息
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedCollection`1.IsEmpty">
 <summary>
 当前的这个命名的目标集合对象是否是空对象？
 </summary>
 <returns></returns>
 <remarks>
 has no <see cref="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedCollection`1.name"/> andalso no <see cref="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedCollection`1.value"/>
 </remarks>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedCollection`1.Item(System.Int32)">
 <summary>
 get/set value in a gvien offset position of the data array.
 </summary>
 <param name="index"></param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedCollection`1.Length">
 <summary>
 <see cref="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedCollection`1.value"/> array length
 </summary>
 <returns></returns>
 <remarks>
 this is a safe property getter, null value will returns ZERO always
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedCollection`1.#ctor(System.Collections.Generic.IEnumerable{Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedValue{`0}})">
 <summary>
 
 </summary>
 <param name="source">名称属性<see cref="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedValue`1.Name"/></param>必须是相同的
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedValue`1">
 <summary>
 The value object have a name string.(一个具有自己的名称的变量值)
 </summary>
 <typeparam name="T"></typeparam>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedValue`1.Name">
 <summary>
 Identifier tag data. you can using this property value as a dictionary key.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedValue`1.Value">
 <summary>
 Object value
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedValue`1.Description">
 <summary>
 Additional description text about this variable <see cref="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedValue`1.Value"/>
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedValue`1.IsEmpty">
 <summary>
 Does this object have value?
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedValue`1.ValueType">
 <summary>
 Returns object gettype
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedValue`1.#ctor(System.String,`0,System.String)">
 <summary>
 Creates a object bind with a specific <see cref="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedValue`1.Name"/>.
 </summary>
 <param name="name"></param>
 <param name="value"></param>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedValue`1.ToString">
 <summary>
 View object.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedValue`1.op_Addition(Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedValue{`0},System.Collections.Generic.Dictionary{System.String,`0})">
 <summary>
 这个函数会将<paramref name="value"/>插入为<paramref name="table"/>的第一个元素
 </summary>
 <param name="value"></param>
 <param name="table"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedValue`1.op_Implicit(System.ValueTuple{System.String,`0})~Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedValue{`0}">
 <summary>
 Convert from tuple
 </summary>
 <param name="tuple"></param>
 <returns></returns>
 
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.PropertyValue`1">
 <summary>
 The <see cref="T:System.Reflection.PropertyInfo"/> like definition of the extension property.
 </summary>
 <typeparam name="T"></typeparam>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.PropertyValue`1.Value">
 <summary>
 The Extension property value.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.PropertyValue`1.obj">
 <summary>
 The instance object for this extension property
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.PropertyValue`1.#ctor(System.Func{`0},System.Action{`0})">
 <summary>
 Custom property value.(value generated based on the extension property host <see cref="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.PropertyValue`1.obj"/>)
 </summary>
 <param name="[get]">请勿使用<see cref="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.PropertyValue`1.GetValue``1(``0,System.String)"/></param>函数，否则会出现栈空间溢出
 <param name="[set]">请勿使用<see cref="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.PropertyValue`1.SetValue(`0)"/></param>方法，否则会出现栈空间溢出
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.PropertyValue`1.#ctor">
 <summary>
 Tag property value.(默认是将数据写入到基本类型的值之中)
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.PropertyValue`1.SetValue(`0)">
 <summary>
 这个主要是应用于Linq表达式之中，将属性值设置之后返回宿主对象实例
 </summary>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.PropertyValue`1.op_Explicit(Microsoft.VisualBasic.ComponentModel.DataSourceModel.PropertyValue{`0})~`0">
 <summary>
 Property Get Value
 </summary>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.PropertyValue`1.ToString">
 <summary>
 <see cref="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.PropertyValue`1.Value"/> -> <see cref="M:Microsoft.VisualBasic.Serialization.JSON.JsonContract.GetObjectJson(System.Object,System.Boolean,System.Boolean,System.Collections.Generic.IEnumerable{System.Type})"/>
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.PropertyValue`1.New``1(``0,System.String)">
 <summary>
 Creates a new extension property for the target <see cref="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.DynamicPropertyBase`1"/>
 </summary>
 <typeparam name="Cls"></typeparam>
 <param name="x"></param>
 <param name="name"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.PropertyValue`1.Read``1(``0,System.String)">
 <summary>
 Gets the tag property value from the <see cref="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.DynamicPropertyBase`1"/>.
 (读取<see cref="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.DynamicPropertyBase`1"/>对象之中的一个拓展属性)
 </summary>
 <typeparam name="Cls"></typeparam>
 <param name="x"></param>
 <param name="name"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Repository.ILocalSearchHandle.Matches(System.String,Microsoft.VisualBasic.CompareMethod)">
 <summary>
 
 </summary>
 <param name="Keyword"></param>
 <param name="CaseSensitive">是否大小写敏感，默认不敏感</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Repository.ILocalSearchHandle.Match(System.String,Microsoft.VisualBasic.CompareMethod)">
 <summary>
 
 </summary>
 <param name="Keyword"></param>
 <param name="CaseSensitive">是否大小写敏感，默认不敏感</param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Repository.IMatched">
 <summary>
 The object implements on this interface can be matched with some rules.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Repository.IMatched.IsMatched">
 <summary>
 Is this object matched the condition?
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Repository.IKeyIndex`1.Index">
 <summary>
 一般是一些短的字符串所构成的能够唯一标记该<see cref="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Repository.IKeyIndex`1.Entity"/>对象的术语列表
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Repository.QueryCacheFactory`1">
 <summary>
 这个库检索模型仅建议在目标数据量非常巨大的时候使用，如果数据量比较小，可以直接保存在一个文件之中，然后一次性加载在内存之中来进行查找
 </summary>
 <typeparam name="T"></typeparam>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Repository.QueryCacheFactory`1.#ctor(System.Func{System.String,`0},System.Collections.Generic.IReadOnlyDictionary{System.String,`0},System.Predicate{System.Object})">
 <summary>
 
 </summary>
 <param name="factory"></param>
 <param name="cache"></param>
 <param name="assertIsNothing">如果这个函数返回的结果是True，说明目标为空值，这个主要是针对于structure类型而言的</param>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Repository.QueryCacheFactory`1.Clear">
 <summary>
 Clear the cache memory
 </summary>
 
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Repository.QueryCacheFactory`1.GetByKey(System.String)">
 <summary>
 Load by <see cref="F:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Repository.QueryCacheFactory`1.factory"/> or read from <see cref="F:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Repository.QueryCacheFactory`1.cache"/>.
 </summary>
 <param name="key"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Repository.QueryCacheFactory`1.GetWhere(System.Func{`0,System.Boolean})">
 <summary>
 Only works on cache
 </summary>
 <param name="clause"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Repository.QueryCacheFactory`1.GetAll">
 <summary>
 Only works on cache
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Repository.IKeyedEntity`1">
 <summary>
 Interface defining any item we can store in a repository and can identify by
 an unique key
 </summary>
 <remarks>
 This interface is typed so we can make type-safe code for retrieving the entity
 (don't pass in an integer if the entity is keyed by string etc.)
 </remarks>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Repository.IKeyedEntity`1.Key">
 <summary>
 Get the key to find the entity by
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Repository.ClientRecord">
 <summary>
 Record for storing a client record in the common database
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Repository.ClientRecord.ClientUniqueKey">
 <summary>
 The unique number by which we know this client
 </summary>
 <remarks>
 Every client has an unique id but this is not needed publically
 </remarks>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Repository.ClientRecord.Code">
 <summary>
 The short code for the client
 </summary>
 <remarks>
 e.g. MCL for Merrion Computing Ltd etc.
 </remarks>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Repository.IRepositoryRead`2">
 <summary>
 Interface to support reading entities from the backing store
 </summary>
 <typeparam name="TEntity">
 The key-identified type of entity we are reading
 </typeparam>
 <typeparam name="TKey">
 The type of the key
 </typeparam>
 <remarks>
 In this architecture there is a seperate read and write interface but often this
 pattern has just the one interface for both functions
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Repository.IRepositoryRead`2.Exists(`0)">
 <summary>
 Does a record exist in the repository identified by this key
 </summary>
 <param name="key">
 The unique identifier of the entity we are looking for
 </param>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Repository.IRepositoryRead`2.GetByKey(`0)">
 <summary>
 Get the entity uniquely identified by the given key
 </summary>
 <param name="key">
 The unique identifier to use to get the entity
 </param>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Repository.IRepositoryRead`2.GetWhere(System.Func{`1,System.Boolean})">
 <summary>
 Get a set of entities from the repository that match the where clause
 </summary>
 <param name="clause">
 A function to apply to filter the results from the repository
 </param>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Repository.IRepositoryRead`2.GetAll">
 <summary>
 Get all of this type of thing from the repository
 </summary>
 <remarks>
 returns an IQueryable so this request can be filtered further
 </remarks>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Repository.IRepositoryWrite`2">
 <summary>
 Interface to support writing (and deletes) to a typed repository
 </summary>
 <typeparam name="TEntity">
 The type of entity in the repository
 </typeparam>
 <typeparam name="TKey">
 The type of the key to uniquely identify the entity
 </typeparam>
 <remarks>
 In this architecture there is a seperate read and write interface but often this
 pattern has just the one interface for both functions
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Repository.IRepositoryWrite`2.Delete(`0)">
 <summary>
 Delete the entity uniquely identified by this key
 </summary>
 <param name="key">
 The unique identifier of the record to delete
 </param>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Repository.IRepositoryWrite`2.AddOrUpdate(`1,`0)">
 <summary>
 Add or update the entity
 </summary>
 <param name="entity">
 The record to add or update on the repository
 </param>
 <param name="key" >
 The key that uniquely identifies the record to add or update
 </param>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Repository.IRepositoryWrite`2.AddNew(`1)">
 <summary>
 Adds an entity that we know to be new and returns its assigned key
 </summary>
 <param name="entity">
 The entity we are adding to the repository
 </param>
 <returns>
 The unique identifier for the entity
 </returns>
 <remarks>
 This is useful if the unique identifier is not an intrinsic property of
 the entity - for example if it is a memory address or a GUID
 </remarks>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Repository.IRepository`2">
 <summary>
 Read/write repository of typed entites
 </summary>
 <typeparam name="TKey">
 The type by which the entity is uniquely identified
 </typeparam>
 <typeparam name="TEntity">
 The type of entity in the repository
 </typeparam>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Repository.RepositoryReadException">
 <summary>
 An exception that occured when reading from the repository backing store
 </summary>
 <remarks>
 The inner exception is from whatever
 </remarks>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Repository.SearchFramework">
 <summary>
 Extensions for data query
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Repository.SearchFramework.UniqueNames``1(System.Collections.Generic.IEnumerable{Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedValue{``0}},System.String[]@)">
 <summary>
 A general method for make the tuple name unique
 </summary>
 <typeparam name="T"></typeparam>
 <param name="list"></param>
 <param name="duplicated"></param>
 <returns></returns>
 <remarks>
 the name is uniqued via the <see cref="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Repository.SearchFramework.UniqueNames(System.Collections.Generic.IEnumerable{System.String},System.String[]@)"/> method 
 via add numeric suffix to the name key string.
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Repository.SearchFramework.MakeUniqueNames``1(System.Collections.Generic.IEnumerable{``0},System.String[]@)">
 <summary>
 update and set the unique names to the index collection
 </summary>
 <typeparam name="T"></typeparam>
 <param name="list"></param>
 <param name="duplicated"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Repository.SearchFramework.UniqueNames(System.Collections.Generic.IEnumerable{System.String},System.String[]@)">
 <summary>
 makes the name string unique by adding an additional numeric suffix
 </summary>
 <param name="names"></param>
 <param name="duplicated">
 get the duplicated names
 </param>
 <returns>
 this function is a safe function, it will returns an empty string collection 
 if the given <paramref name="names"/> is nothing. this function returns a string
 array with the same size equals to the input string collection with duplicated values
 renamed with numeric counter suffix
 </returns>
 <remarks>
 this function will erase the <paramref name="duplicated"/> at first and then make value assigned.
 </remarks>
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Repository.QGramIndex._q">
 <summary>
 q-gram的长度
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Repository.QGramIndex.AddString(System.String,System.Nullable{System.Int32})">
 <summary>
 向索引中添加字符串
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Repository.QGramIndex.GenerateQGrams(System.String)">
 <summary>
 生成字符串的所有q-grams
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Repository.QGramIndex.PadString(System.String)">
 <summary>
 为短字符串添加填充字符
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Repository.QGramIndex.FindSimilar(System.String,System.Double)">
 <summary>
 基于q-gram重叠度查找相似字符串
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Repository.QGramIndex.GetIndexStats">
 <summary>
 获取索引统计信息
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Repository.SimHashIndex._hashSize">
 <summary>
 哈希位数（通常为64或128）
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Repository.SimHashIndex._bands">
 <summary>
 波段数量
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Repository.SimHashIndex._rows">
 <summary>
 每波段行数
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Repository.SimHashIndex.ComputeSimHash(System.String)">
 <summary>
 计算字符串的SimHash指纹
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Repository.SimHashIndex.ExtractFeatures(System.String)">
 <summary>
 从文本中提取特征（使用3-grams作为特征）
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Repository.SimHashIndex.AddString(System.String)">
 <summary>
 向索引中添加字符串
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Repository.SimHashIndex.GetBandHash(System.Int64,System.Int32)">
 <summary>
 获取指定波段的哈希值
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Repository.SimHashIndex.FindSimilar(System.String,System.Int32)">
 <summary>
 查找相似字符串（基于汉明距离）
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Repository.SimHashIndex.FindCandidates(System.Int64)">
 <summary>
 通过LSH查找候选字符串
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Repository.SimHashIndex.ComputeHammingDistance(System.Int64,System.Int64)">
 <summary>
 计算两个指纹的汉明距离
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Repository.SimHashIndex.ComputeLevenshtein(System.String,System.String)">
 <summary>
 计算Levenshtein编辑距离（与QGramIndex中相同）
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.BindProperty`1">
 <summary>
 Schema for <see cref="T:System.Attribute"/> and its bind <see cref="T:System.Reflection.PropertyInfo"/>/<see cref="T:System.Reflection.FieldInfo"/> object target.
 </summary>
 <typeparam name="T"></typeparam>
 <remarks>
 (使用这个对象将公共的域或者属性的读写统一起来)
 </remarks>
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.BindProperty`1.field">
 <summary>
 The flag for this field binding.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.BindProperty`1.Identity">
 <summary>
 The map name or the <see cref="P:System.Reflection.MemberInfo.Name"/>.
 (这个属性会首先查找标记的自定义属性的名称结果，如果不存在才会使用属性或者字段的反射成员名称)
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.BindProperty`1.IsNull">
 <summary>
 Is this map data is null on its attribute or property data?
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.BindProperty`1.SetValue(System.Object@,System.Object)">
 <summary>
 Sets the property value of a specified object with optional index values for
 index properties.
 (这个设置值的函数只适用于``Class``类型，对于``Structure``类型而言，则无法正常的工作)
 </summary>
 <param name="obj">The object whose property value will be set.</param>
 <param name="value">The new property value.</param>
 
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.BindProperty`1.GetValue(System.Object)">
 <summary>
 Returns the property value of a specified object with optional index values for
 indexed properties.
 </summary>
 <param name="x">The object whose property value will be returned.</param>
 <returns>The property value of the specified object.</returns>
 
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.BindProperty`1.ToString">
 <summary>
 Display this schema maps in Visualbasic style.
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.ColumnAttribute">
 <summary>
 field data mapping
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.Field">
 <summary>
 <see cref="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.DataFrameColumnAttribute"/>属性的别称
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.Field.#ctor(System.String)">
 <summary>
 Initializes a new instance by name.
 </summary>
 <param name="FieldName">The name.</param>
 
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.DataFrameColumnAttribute">
 <summary>
 Represents a column of certain data frames. The mapping between to schema is also can be represent by this attribute. 
 (也可以使用这个对象来完成在两个数据源之间的属性的映射，由于对于一些列名称的属性值缺失的映射而言，
 其是使用属性名来作为列映射名称的，故而在修改这些没有预设的列名称的映射属性的属性名的时候，请注意
 要小心维护这种映射关系)
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.DataFrameColumnAttribute.Index">
 <summary>
 Gets the index.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.DataFrameColumnAttribute.Name">
 <summary>
 Gets the name.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.DataFrameColumnAttribute.#ctor(System.String)">
 <summary>
 Initializes a new instance by name.
 </summary>
 <param name="FieldName">The name.</param>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.DataFrameColumnAttribute.#ctor(System.Int32)">
 <summary>
 Initializes a new instance by index.
 </summary>
 <param name="index">The index.</param>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.DataFrameColumnAttribute.#ctor">
 <summary>
 会默认使用目标对象的反射的Name属性作为映射的名称
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.DataFrameColumnAttribute.#ctor(System.String,System.Int32)">
 <summary>
 
 </summary>
 <param name="Name">列名称，假若本参数为空的话，则使用属性名称</param>
 <param name="index">从1开始的下标，表示为第几列</param>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.DataFrameColumnAttribute.LoadMapping``1(System.String[],System.Boolean)">
 <summary>
 没有名称属性的映射使用属性名来表述，请注意，字典的Key是属性的名称
 </summary>
 <typeparam name="T"></typeparam>
 <returns></returns>
 <remarks></remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.DataFrameColumnAttribute.LoadMapping(System.Type,System.String[],System.Boolean)">
 <summary>
 Load the mapping property, if the custom attribute <see cref="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.DataFrameColumnAttribute"></see> 
 have no name value, then the property name will be used as the mapping name.
 (这个函数会自动给空名称值进行属性名的赋值操作的)
 </summary>
 <param name="typeInfo">The type should be a class type or its properties should have the 
 mapping option which was created by the custom attribute <see cref="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.DataFrameColumnAttribute"></see>
 </param>
 <param name="ignores">这个是大小写敏感的</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.DataFrameColumnAttribute.GetMapping(System.Collections.Generic.KeyValuePair{Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.DataFrameColumnAttribute,System.Reflection.PropertyInfo})">
 <summary>
 假若名称是空的，则会在这里自动的使用属性名称进行赋值
 </summary>
 <param name="pinfo"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.DataFrameColumnAttribute.__source(System.Type,System.String[],System.Boolean)">
 <summary>
 
 </summary>
 <param name="type"></param>
 <param name="ignores$"></param>
 <param name="mapsAll">
 Some property probably didn't have masked by <see cref="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.DataFrameColumnAttribute"/>, 
 so if this option is set to TRUE, then means indexing these property that without <see cref="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.DataFrameColumnAttribute"/> masked as well. 
 otherwise only indexing the property that have <see cref="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.DataFrameColumnAttribute"/> masked on it.
 </param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.DataFrameIO`1.InitializeSchema``1">
 <summary>
 
 </summary>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.Mappings.GetSchemaName``1(System.Type,System.Func{``0,System.String},System.Boolean)">
 <summary>
 get alias name of a specific type class
 </summary>
 <typeparam name="T"></typeparam>
 <param name="type"></param>
 <param name="getName">get name from the attribute <typeparamref name="T"/> object</param>
 <param name="explict"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.Mappings.GetFields``1(System.Type,System.Func{``0,System.String},System.Boolean)">
 <summary>
 这个只是得到最上面的一层属性值
 </summary>
 <typeparam name="T"></typeparam>
 <param name="type"></param>
 <param name="getName"></param>
 <param name="explict">
 当自定义属性不存在的时候，隐式的使用域名或者属性名作为名称，否则会跳过该对象，默认是跳过该对象
 </param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.Mappings.GetFields``1(System.Boolean)">
 <summary>
 
 </summary>
 <typeparam name="T"></typeparam>
 <param name="explict">
 construct the default masked <see cref="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.ColumnAttribute"/> if this parameter value is set to True
 </param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.Mappings.FieldNameMappings``1(System.Boolean,System.Boolean,System.Boolean)">
 <summary>
 获取从目标类型定义之中的从类型成员域名称映射到列名称的哈希表
 </summary>
 <typeparam name="T"></typeparam>
 <param name="explict"></param>
 <param name="reversed">
 当这个参数为真的时候，将会：
 
 ```
 <see cref="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.ColumnAttribute.Name"/> => <see cref="P:System.Reflection.MemberInfo.Name"/>
 ```
 </param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.Mappings.GetAliasName(System.Reflection.PropertyInfo)">
 <summary>
 try to get the alias name for the specific property object
 </summary>
 <param name="p"></param>
 <returns>
 this function will returns nothing if no alias name mapping attribute could be found
 </returns>
 <remarks>
 the alias name could be tagged with attributes:
 
 1. <see cref="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.ColumnAttribute"/>
 2. <see cref="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.Field"/>
 3. <see cref="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.DataFrameColumnAttribute"/>
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.Mappings.FieldNameMappings``1(System.Collections.Generic.IEnumerable{Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.BindProperty{Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.ColumnAttribute}},System.Boolean,System.Boolean)">
 <summary>
 
 </summary>
 <typeparam name="T"></typeparam>
 <param name="fields">raw mapping</param>
 <param name="reversed"></param>
 <param name="includesAliasNames"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.Mappings.GetColumnName(Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.BindProperty{Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.ColumnAttribute})">
 <summary>
 get name value from <see cref="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.ColumnAttribute.Name"/>
 </summary>
 <param name="[property]"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.SoapGraph">
 <summary>
 object schema provider for json/xml
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.SoapGraph.valueType">
 <summary>
 Value type of the dictionary
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.SoapGraph.#ctor(System.Reflection.MethodInfo,System.Boolean,System.Collections.Generic.IReadOnlyDictionary{System.String,System.Reflection.PropertyInfo},System.Type,System.Type,System.Type,System.Type[],Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.Serializations)">
 <summary>
 
 </summary>
 <param name="addMethod"></param>
 <param name="isTable"></param>
 <param name="writers"></param>
 <param name="valueType"></param>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.SoapGraph.Activate(Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.SoapGraph,System.String[],Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.SoapGraph@)">
 <summary>
 just create a new and blank .net clr object
 </summary>
 <param name="parent"></param>
 <param name="docs"><see cref="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.SoapGraph.Score(System.Collections.Generic.IEnumerable{System.String})"/></param>
 <returns></returns>
 <param name="schema">
 gets the actual object class type information from this parameters,
 if the input object type(myself/this/me/myclass) <see cref="F:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.SoapGraph.raw"/> 
 type information is acutualy an interfacve type or abstract base 
 type or something could be variant
 </param>
 <remarks>
 this function is going to handling of create the clr object instance
 for the interface type, abstract base type or something
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.SoapGraph.Score(System.Collections.Generic.IEnumerable{System.String})">
 <summary>
 
 </summary>
 <param name="obj">
 the parsed object member names from the document file, example as
 json field names or xml element names
 </param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.SoapGraph.GetSchema``1(Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.Serializations)">
 <summary>
 get (or cache a new schema graph object if not exists) a schema graph object
 </summary>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.SoapGraph.GetSchema(System.Type,Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.Serializations)">
 <summary>
 get (or cache a new schema graph object if not exists) a schema graph object
 </summary>
 <param name="type"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.SoapGraph.FindInterfaceImplementations(System.Type)">
 <summary>
 Find the implementations of the abstract interface define
 </summary>
 <param name="type"></param>
 <returns></returns>
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.Bind.member">
 <summary>
 The property/field object that bind with its custom attribute <see cref="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.Field"/> of type 
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.Bind.Type">
 <summary>
 Gets the type of this <see cref="F:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.Bind.member"/>.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.Bind.memberName">
 <summary>
 get member name directly
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.Bind.IsPrimitive">
 <summary>
 Gets a value indicating whether the <see cref="T:System.Type"/> is one of the primitive types.
 </summary>
 <returns>
 true if the <see cref="T:System.Type"/> is one of the primitive types; otherwise, false.
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.Bind.Parse(System.String)">
 <summary>
 parse string as the target type value by 
 using the specific caster method.
 </summary>
 <param name="val"></param>
 <returns></returns>
 
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.Schema`1">
 <summary>
 Schema for two dimension table.
 </summary>
 <typeparam name="T"></typeparam>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.SQLTable">
 <summary>
 A generic abstract model of a SQL table.
 </summary>
 <remarks>
 (SQL之中的一个数据表的抽象描述接口)
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.SQLTable.GetInsertSQL">
 <summary>
 INSERT INTO table_name (field1, field2,...) VALUES (value1, value2,....)
 </summary>
 <returns></returns>
 <remarks>http://www.w3school.com.cn/sql/sql_insert.asp</remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.SQLTable.GetUpdateSQL">
 <summary>
 UPDATE table_name SET field = &lt;new value> WHERE field = &lt;value>
 </summary>
 <returns></returns>
 <remarks>http://www.w3school.com.cn/sql/sql_update.asp</remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.SQLTable.GetDeleteSQL">
 <summary>
 DELETE FROM table_name WHERE field = value;
 </summary>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.SQLTable.ToString">
 <summary>
 Display the INSERT INTO sql from function <see cref="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.SQLTable.GetInsertSQL"/>.
 </summary>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.SQLTable.Clone">
 <summary>
 Clones the property values.
 </summary>
 <returns></returns>
 <remarks>
 (由于这个<see cref="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.SQLTable"/>对象的所有属性都是简单的基本类型，所以能够很容易
 的复制这些属性，从而很容易的复制数据表之中的一个行对象)
 </remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.SQLTable.Copy">
 <summary>
 MemberwiseClone
 </summary>
 <returns></returns>
 
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.IStringGetter">
 <summary>
 a simple helper object for get string value
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.IStringGetter.HasKey(System.String)">
 <summary>
 check the given key name is existed inside current string collection data source
 </summary>
 <param name="name"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.IStringGetter.GetString(System.String)">
 <summary>
 get a string by a given key name.
 </summary>
 <param name="name"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.IStringGetter.GetString(System.Int32)">
 <summary>
 get a string by a given collection index(offset).
 </summary>
 <param name="ordinal"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.IStringGetter.GetSize">
 <summary>
 get the string collection size
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.IStringGetter.GetOrdinal(System.String)">
 <summary>
 Return the index Of the named field. 
 </summary>
 <returns>If the name is not exists in the parameter list, 
 then a -1 value will be return.</returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.IStringGetter.MoveNext">
 <summary>
 optionally implements this function for move the reader
 cursor to next row if this data source consists with
 mutliple rows.
 </summary>
 <returns></returns>
 <remarks>
 non-table liked data source should always returns false
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.StringReader.GetByte(System.String)">
 <summary>
 Gets the 8-bit unsigned Integer value Of the specified column.
 </summary>
 <param name="parameter"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.StringReader.GetBytes(System.String)">
 <summary>
 Reads a stream Of bytes from the specified column offset into the buffer As an array, starting at the given buffer offset.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.StringReader.GetChar(System.String)">
 <summary>
 Gets the character value Of the specified column.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.StringReader.GetChars(System.String)">
 <summary>
 Reads a stream Of characters from the specified column offset into the buffer As an array, starting at the given buffer offset.
 </summary>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.StringReader.GetDateTime(System.String)">
 <summary>
 Gets the Date And time data value Of the specified field.
 </summary>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.StringReader.GetDecimal(System.String)">
 <summary>
 Gets the fixed-position numeric value Of the specified field.
 </summary>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.StringReader.GetDouble(System.String)">
 <summary>
 Gets the Double-precision floating point number Of the specified field.
 </summary>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.StringReader.GetFloat(System.String)">
 <summary>
 Gets the Single-precision floating point number Of the specified field.
 </summary>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.StringReader.GetGuid(System.String)">
 <summary>
 Returns the GUID value Of the specified field.
 </summary>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.StringReader.GetInt16(System.String)">
 <summary>
 Gets the 16-bit signed Integer value Of the specified field.
 </summary>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.StringReader.GetInt32(System.String)">
 <summary>
 Gets the 32-bit signed Integer value Of the specified field.
 </summary>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.StringReader.GetInt64(System.String)">
 <summary>
 Gets the 64-bit signed Integer value Of the specified field.
 </summary>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.StringReader.GetString(System.String)">
 <summary>
 Gets the String value Of the specified field.
 </summary>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.StringReader.IsNull(System.String)">
 <summary>
 Return whether the specified field Is Set To null.
 </summary>
 <returns></returns>
 
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.PropertyAccess">
 <summary>
 the data access
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.DataSourceModel.PropertyAccess.NotSure">
 <summary>
 no data access
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.DataSourceModel.PropertyAccess.Readable">
 <summary>
 data can be read from the clr object(get/readonly property)
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.DataSourceModel.PropertyAccess.Writeable">
 <summary>
 data can be write to the clr object(set/writeonly property)
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.DataSourceModel.PropertyAccess.ReadWrite">
 <summary>
 data can be read and write to the clr object(get/set)
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.DataIgnoredAttribute">
 <summary>
 在数据框数据映射操作之中是否忽略掉这个属性或者方法？
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Projector`2">
 <summary>
 Class field reader
 </summary>
 <typeparam name="T"></typeparam>
 <typeparam name="Tout"></typeparam>
 <param name="[in]"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.ScriptIgnoreAttribute">
 <summary>
 用于与.NET Framework之中的ScriptIgnore属性标记兼容的一个对象
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.DataFramework">
 <summary>
 在目标对象中必须要具有一个属性有自定义属性<see cref="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.DataFrameColumnAttribute"></see>
 </summary>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.DataFramework.Flags">
 <summary>
 Controls for <see cref="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.PropertyAccess"/> on <see cref="T:System.Reflection.PropertyInfo"/>
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.DataFramework.Schema``1(Microsoft.VisualBasic.ComponentModel.DataSourceModel.PropertyAccess,System.Boolean,System.Boolean,System.Reflection.BindingFlags)">
 <summary>
 获取类型之中的属性列表
 </summary>
 <typeparam name="T"></typeparam>
 <param name="flag"></param>
 <param name="nonIndex"><see cref="M:System.Reflection.PropertyInfo.GetIndexParameters"/> IsNullOrEmpty</param>
 <returns></returns>
 <remarks>
 这个函数不会缓存类型信息，因为参数组合条件过多
 </remarks>
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.DataSourceModel.DataFramework.PublicProperty">
 <summary>
 (instance) ``Public Property xxxxx As xxxxx``
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.DataSourceModel.DataFramework.PublicShared">
 <summary>
 (statics) ``Public Shared Property xxxx As xxxx``
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.DataFramework.Schema(System.Type,Microsoft.VisualBasic.ComponentModel.DataSourceModel.PropertyAccess,System.Reflection.BindingFlags,System.Boolean)">
 <summary>
 请注意：对于VisualBasic的My.Resources.Resources类型而言，里面的属性都是Friend Shared访问类型的，
 所以在解析内部资源管理器对象的时候应该要特别注意<paramref name="binds"/>参数值的设置，
 因为这个参数默认是<see cref="F:Microsoft.VisualBasic.ComponentModel.DataSourceModel.DataFramework.PublicProperty"/>
 </summary>
 <param name="type"></param>
 <param name="flag"></param>
 <param name="binds"></param>
 <param name="nonIndex"><see cref="M:System.Reflection.PropertyInfo.GetIndexParameters"/> IsNullOrEmpty</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.DataFramework.DictionaryTable``1(``0,System.Boolean,System.Predicate{System.Object})">
 <summary>
 将对象之中的所有属性值都取出来以字符串的形式生成一个字典对象
 </summary>
 <typeparam name="T"></typeparam>
 <param name="x"></param>
 <param name="where">用来判断属性值是否应该被添加进入字典之中</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.DataFramework.getOrCache(System.Type)">
 <summary>
 Helper for <see cref="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.DataFramework.DictionaryTable``1(``0,System.Boolean,System.Predicate{System.Object})"/>
 </summary>
 <param name="type"></param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.DataFramework.StringParsers">
 <summary>
 Converts the .NET primitive types from string.(将字符串数据类型转换为其他的数据类型)
 </summary>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.DataFramework.StringBuilders">
 <summary>
 Object <see cref="T:System.Object"/> methods.
 </summary>
 <returns></returns>
 <remarks>
 在这个和Scripting命名空间下的基础类型的判断不一样
 在这里只会判断.NET框架中的基础类型
 在Scripting命名空间下的基础类型,是规定为所有包含有类型和字符串值之间的隐式转换的类型
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.DataFramework.valueToString(System.Object)">
 <summary>
 这个函数是为了提供转换的方法给字典对象<see cref="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.DataFramework.StringBuilders"/>
 </summary>
 <param name="o">
 因为<see cref="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.DataFramework.StringBuilders"/>要求的是<see cref="T:Microsoft.VisualBasic.Serialization.IStringBuilder"/>，
 即<see cref="T:System.Object"/>类型转换为字符串，所以在这里就不适用T泛型了，而是直接
 使用<see cref="T:System.Object"/>类型
 </param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.DataFramework.IsPrimitive(System.Type,System.Boolean)">
 <summary>
 Is one of the primitive type in the hash <see cref="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.DataFramework.StringBuilders"/>?
 </summary>
 <param name="type"></param>
 <param name="autoCastEnum">
 and also treate the enum type as primitive value?(enum is integer)
 </param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.DataFramework.GetPrimitiveTypes">
 <summary>
 Enumerates all pre-defined clr runtime primitive types.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.DataFramework.IsCollection``1(System.Type)">
 <summary>
 
 </summary>
 <typeparam name="T">the data type of the element inside a data collection</typeparam>
 <param name="type"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.DataFramework.IsNumericCollection(System.Type)">
 <summary>
 Does the given type is any kind of numeric collection type?
 </summary>
 <param name="type"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.DataFramework.IsNumericType(System.Type,System.Boolean)">
 <summary>
 the given <paramref name="type"/> is any of the CLR numeric primitive type?
 </summary>
 <param name="type"></param>
 <param name="includeComplex">
 and also should treat the complex number as the primitive numeric type?
 </param>
 <returns></returns>
 <remarks>
 This function testing all of the possible numeric type at here
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.DataFramework.IsIntegerType(System.Type,System.Boolean)">
 <summary>
 
 </summary>
 <param name="type"></param>
 <param name="autoCastEnums">
 and also treated the enum value as integer type?
 </param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.DataFramework.IsComplexType(System.Type,Microsoft.VisualBasic.ComponentModel.DataSourceModel.DataFramework.EnumCastTo)">
 <summary>
 如果目标类型的属性之中值包含有基础类型，则是一个非复杂类型，反之包含任意一个非基础类型，则是一个复杂类型
 </summary>
 <param name="type"></param>
 <param name="enumCast">by default we treat the enum type as non-primitive type.</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.DataFramework.CreateObject``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>
 Convert target data object collection into a datatable for the data source of the ``DataGridView``.
 (将目标对象集合转换为一个数据表对象，用作DataGridView控件的数据源)
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.DataFramework.GetValue``1(System.Data.DataTable)">
 <summary>
 Retrive data from a specific datatable object.(从目标数据表中获取数据)
 </summary>
 <typeparam name="T"></typeparam>
 <param name="dataTable"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.DefaultAttribute">
 <summary>
 Property default value
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.ILabeledMatrix">
 <summary>
 dataframe helper
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.ILabeledMatrix.GetLabels">
 <summary>
 get the labels of each row data
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.TsvFileIO">
 <summary>
 将文件读取出来然后对每一行数据进行分割，由于没有使用自定义属性来标记列的名称，所以这个很简单的tsv加载器要求属性的名称与列名称要完全一致。
 而且，还不能够为非初始数据类型，这个模块之中提供了简单的数据类型转换操作，这个只是一个简单的内置TSv文件读取模块
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.TsvFileIO.Load``1(System.String,Microsoft.VisualBasic.Text.Encodings)">
 <summary>
 Columns indexing by title.(自动将tsv文件数据之中的行解析反序列化加载为一个Class对象)
 </summary>
 <typeparam name="T"></typeparam>
 <param name="Path"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.TsvFileIO.LoadByIndex``1(System.String,Microsoft.VisualBasic.Text.Encodings,System.Int32)">
 <summary>
 Columns indexing by position.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="path$"></param>
 <param name="encoding"></param>
 <param name="base">
 By default the array index is ZERO based, or you can specific this array index base from 1, or any other integer values
 </param>
 <returns></returns>
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.DataSourceModel.TsvFileIO.withoutProcess">
 <summary>
 Returns the source string without any processing
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.TsvFileIO.GetTsvHeader(System.IO.StreamReader,System.Boolean,System.Func{System.String,System.String})">
 <summary>
 Just read the first line and parse as the data headers
 </summary>
 <param name="stream">A stream connection to the target text file</param>
 <param name="lower"></param>
 <param name="process"></param>
 <returns>A data headers collection</returns>
 <remarks>
 Linux平台上面的mono这里有bug，为什么<see cref="M:System.IO.StreamReader.ReadLine"/>一直都输出空值？
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.TsvFileIO.LoadFile(System.String,System.Text.Encoding,System.Boolean)">
 <summary>
 读取文件并且按照TAb进行分割
 </summary>
 <param name="path"></param>
 <param name="skipFirstLine">The first line of the text document maybe is the title headers, skip this line?</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.TsvFileIO.ValidateSchemaNames(Microsoft.VisualBasic.ComponentModel.Collection.Index{System.String},System.String[])">
 <summary>
 Check of does all <paramref name="required"/> field names is inside current data index?
 </summary>
 <param name="headers">the data header names that read from the data file</param>
 <param name="required">
 a name vector of the required data fields
 </param>
 <returns>
 true if all <paramref name="required"/> is presents inside the given <paramref name="headers"/>
 </returns>
 
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.TypeCast.DataImports.SampleForType(System.Collections.Generic.IReadOnlyCollection{System.String},System.Boolean)">
 <summary>
 Sampling column data for test data type
 </summary>
 <param name="column"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.TypeCast.DataImports.IsPossibleEnumFactor(System.Collections.Generic.IReadOnlyCollection{System.String})">
 <summary>
 Check the given string collection is a possible enum factor type?
 </summary>
 <param name="v"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.TypeCast.DataImports.ParseVector(System.String[])">
 <summary>
 Measuring the data type automatically, and then try to parse the given
 string vector as the array of result data type
 </summary>
 <param name="column"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataSourceModel.TypeCast.Extensions.ParseObject(System.Type)">
 <summary>
 get helper function for parse the string to clr object
 </summary>
 <param name="type"></param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.TypeCast.TypeCaster`1.sizeOf">
 <summary>
 
 </summary>
 <returns></returns>
 <remarks>
 string has no marshal size value, but data type of string always has a zero terminator
 </remarks>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.BitSet">
 <summary>
 A replacement for BitArray.(BitSet in java)
 </summary>
 <remarks>
 https://stackoverflow.com/questions/14035687/what-is-the-c-sharp-equivalent-of-bitset-of-java#
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.BitSet.#ctor(System.Int32)">
 <summary>
 create bits vector data from a given 32 bits integer
 </summary>
 <param name="v"></param>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.BitSet.Duplicate">
 <summary>
 Not part of ICloneable, but better - returns a strongly-typed result
 </summary>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.BitSet.ToString">
 <summary>
 <see cref="M:Microsoft.VisualBasic.ComponentModel.BitSet.ToBinaryString(System.Char,System.Char)"/>
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.BitSet.FromBinaryString(System.String,System.Char[])">
 <summary>
 
 </summary>
 <param name="bin"></param>
 <param name="true">The chars in this collection means <see cref="T:System.Boolean"/></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.BitSet.Set(System.Int32,System.Boolean)">
 <summary>
 Set specific index bit to TRUE
 </summary>
 <param name="index"></param>
 <param name="v"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.BitSet.SetBits(System.Collections.Generic.ICollection{System.Boolean},System.Int32,System.Int32,System.Int32,System.Boolean)">
 <summary>
 
 </summary>
 <param name="bits"></param>
 <param name="destStartBit"></param>
 <param name="srcStartBit"></param>
 <param name="numBits">
 negative value means set all <paramref name="bits"/>.
 </param>
 <param name="allowExtend"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.BitSet.ToInteger">
 <summary>
 create a 32 bit integer
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.BitSet.ToInteger(System.Int32,System.Int32)">
 <summary>
 bits to integer
 </summary>
 <param name="start"></param>
 <param name="length"></param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.LinkNode`1.node">
 <summary>
 Current node in the chain list
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.LinkNode`1.Next">
 <summary>
 The next element in the chain after this element
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.LinkNode`1.Previous">
 <summary>
 The previous element in the chain before this element
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.HashHandle`1.__allocate">
 <summary>
 Allocate memory
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.HashList`1.Replace(`0)">
 <summary>
 overrides the item value at specific address
 </summary>
 <param name="item"></param>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.HashList`1.ReplaceAt(System.Int32,`0)">
 <summary>
 overrides the item value at specific index
 </summary>
 <param name="i"></param>
 <param name="item"></param>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.IAddressOf">
 <summary>
 This object gets a object handle value to indicated that the position this object exists 
 in the list collection structure. 
 </summary>
 <remarks>(这个对象具有一个用于指明该对象在列表对象中的位置的对象句柄值)</remarks>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.IIndexOf`1.Address">
 <summary>
 The ID that this object in a list instance.
 (本对象在一个列表对象中的位置索引号) 
 </summary>
 <value></value>
 <returns></returns>
 <remarks>因为索引号在赋值之后是不可以被修改了的，所以这个属性使用ReadOnly</remarks>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.IAddress`1">
 <summary>
 This object gets a object handle value to indicated that the position this object exists 
 in the list collection structure. 
 (这个对象具有一个用于指明该对象在列表对象中的位置的对象句柄值)
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.CapacityQueue`1.#ctor(System.Int32)">
 <summary>
 
 </summary>
 <param name="capacity">The initial number of elements that the System.Collections.Generic.Queue`1 can
 contain.</param>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Collection.CircularBuffer`1">
 <summary>
 Represents a fixed-capacity circular buffer (or ring list).
 When the buffer is full, adding a new element overwrites the oldest element.
 </summary>
 <typeparam name="T">The type of elements in the buffer.</typeparam>
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.Collection.CircularBuffer`1._ends">
 <summary>
 Points to the next position to write (tail)
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Collection.CircularBuffer`1.Count">
 <summary>
 Gets the number of elements currently stored in the buffer.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Collection.CircularBuffer`1.Capacity">
 <summary>
 Gets the total capacity of the buffer.
 </summary>
 <remarks>
 if this property value is equals to the <see cref="P:Microsoft.VisualBasic.ComponentModel.Collection.CircularBuffer`1.Count"/> then it
 means current array buffer is full of data
 </remarks>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Collection.CircularBuffer`1.Item(System.Int32)">
 <summary>
 Gets or sets the element at the specified logical index.
 Index 0 is the oldest element, index Count-1 is the newest.
 </summary>
 <param name="index">The logical index of the element.</param>
 <exception cref="T:System.IndexOutOfRangeException">Thrown when the index is out of range.</exception>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Collection.CircularBuffer`1.First">
 <summary>
 Gets the first (oldest) element in the buffer.
 </summary>
 <exception cref="T:System.InvalidOperationException">Thrown when the buffer is empty.</exception>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Collection.CircularBuffer`1.Last">
 <summary>
 Gets the last (newest) element in the buffer.
 </summary>
 <exception cref="T:System.InvalidOperationException">Thrown when the buffer is empty.</exception>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Collection.CircularBuffer`1.HeadIndex">
 <summary>
 Calculates and gets the index of the first element (head) in the internal array.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.CircularBuffer`1.#ctor(System.Int32)">
 <summary>
 Initializes a new instance of the CircularBuffer class.
 </summary>
 <param name="capacity">The buffer capacity. Must be a positive number.</param>
 <exception cref="T:System.ArgumentException">Thrown when capacity is ≤ 0.</exception>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.CircularBuffer`1.Add(`0)">
 <summary>
 Adds a new element to the tail of the buffer.
 If the buffer is full, this operation overwrites the oldest element.
 </summary>
 <param name="item">The element to add.</param>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.CircularBuffer`1.Clear">
 <summary>
 Clears all elements in the buffer.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.CircularBuffer`1.GetEnumerator">
 <summary>
 Returns an enumerator that iterates through the collection.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.CircularBuffer`1.IEnumerable_GetEnumerator">
 <summary>
 Returns an enumerator that iterates through the collection.
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Collection.Deque.Data`1">
 <summary>
 contains actuall data od deque, Deque(Of T) provides abstraction above this data
 </summary>
 <typeparam name="S"></typeparam>
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.Collection.Deque.Data`1.sizeOfBlock">
 <summary>
 Number of elements in Deque(Of T)
 </summary>   
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.Collection.Deque.Data`1.NumOfBlockRefs">
 <summary>
 Current number of allocated references to data blocks, 
 data blocks themselves doesn't have to be allocated 
 yet
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.Collection.Deque.Data`1.NumOfBlockInitialized">
 <summary>
 Current number of actually allocated blocks
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.Collection.Deque.Data`1.beforeFirst">
 <summary>
 number of allocated indices before the Head of a Deque
 to be able to allocate blocks only when its necessary - 
 only one block at time
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.Collection.Deque.Data`1.headBlockIndex">
 <summary>
 index of the first allocated block - in array of block references
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Collection.Deque.Data`1.afterLast">
 <summary>
 number of allocated indices after the Tail of a Deque
 to be able to allocate blocks only when its necessary - 
 only one block at time
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.Collection.Deque.Data`1.HeadIndex">
 <summary>
 index of the firts item in the Deque - relative to the 
 first index in the first block there is reference to 
 (not to the first block actually allocated)
 pretends that data is stored linearly
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Collection.Deque.Data`1.TailIndex">
 <summary>
 index of last item in the Deque
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Collection.Deque.Data`1.Item(System.Int32)">
 <summary>
 allows to treat the Deque(Of T) as if it stored data linearly
 </summary>
 <param name="i"></param>
 <returns></returns>  
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Deque.Data`1.DoubleSize">
 <summary>
 Doubles the number of references to data blocks, copies existing 
 data blocks to the middle of new reference array of double size
 do not actually allocate any data blocks
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Deque.Data`1.AllocBlockBeginning">
 <summary>
 allocs one data block in front of the first block currently allocated
 doubles the size of reference array if necessary
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Deque.Data`1.AllocBlockEnd">
 <summary>
 allocs one data block in front of the first block currently allocated
 doubles the size of reference array if necessary
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Deque.Data`1.AddBegining(`0)">
 <summary>
 Adds Item as a new Head of the Deque(Of T), Count is incremented
 </summary>
 <param name="item"></param>   
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Deque.Data`1.AddEnd(`0)">
 <summary>
 Adds Item as a new Tail of the Deque(Of T), Count is incremented
 </summary>
 <param name="item"></param> 
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Deque.Data`1.RemoveHead">
 <summary>
 returns the firts element of the Deque(Of T) while removing it from Deque(Of T)
 </summary>
 <returns></returns>    
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Deque.Data`1.RemoveTail">
 <summary>
 returns the last element of the Deque(Of T) and removes it from Deque(Of T)
 </summary>
 <returns></returns> 
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Deque.Data`1.Insert(System.Int32,`0)">
 <summary>
 Inserts element on a specified index id Deque(Of T)
 Insert at the beggining or end in O(1)
 Allows to insert item on index 0 of an empty Deque(Of T) - List(Of T) behaves the same way, I recon
 </summary>
 <param name="index"></param>
 <param name="item"></param> 
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Deque.Data`1.RemoveAt(System.Int32)">
 <summary>
 Removes an element from the specified index of Deque(Of T), 
 removal of the first and the last item in O(1)
 </summary>
 <param name="index"></param> 
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Deque.Data`1.IndexOf(`0)">
 <summary>
 Searches for the specified object and returns the zero-based index of 
 the first occurrence within the entire Deque(Of T).
 </summary>
 <returns>
 e zero-based index of the first occurrence of item within the 
 entire Deque(Of T), if found; otherwise, -1.
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Deque.Data`1.Remove(`0)">
 <summary>
 Removes item from the Deque(Of T), removal of the first and the last item in O(1)
 </summary>
 <param name="item"></param>
 <returns></returns> 
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Deque.Data`1.Contains(`0)">
 <summary>
 Determines whether an element is in the Deque(Of T).
 </summary>
 <param name="item"></param>
 <returns>true if item is found in the List(Of T); otherwise, false</returns> 
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Deque.Data`1.Clear">
 <summary>
 Removes all elements from the Deque(Of T).
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Deque.Data`1.CopyTo(`0[],System.Int32,System.Boolean)">
 <summary>
 Copies the entire Deque(Of T) to a compatible one-dimensional array, 
 starting at the specified index of the target array.
 </summary>    
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Collection.Deque.Deque`1">
 <summary>
 Double ended queue implementation
 </summary>
 <typeparam name="T"></typeparam>
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.Collection.Deque.Deque`1.data">
 <summary>
 actuall data of this Deque(Of T)
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Collection.Deque.Deque`1.version">
 <summary>
 to detect changes during enumeration
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Collection.Deque.Deque`1.First">
 <summary>
 peek the firts element of the Deque(Of T)
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Collection.Deque.Deque`1.Last">
 <summary>
 peek the last element of the Deque(Of T)
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Collection.Deque.Deque`1.Count">
 <summary>
 Number of elements in Deque(Of T)
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Deque.Deque`1.Peek">
 <summary>
 Retrieves, but does not remove, the head of this queue, or returns null if this queue is empty.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Deque.Deque`1.Add(`0)">
 <summary>
 Adds an object to the end of the Deque(Of T).
 </summary>
 <param name="item"></param>
 
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Deque.Deque`1.AddHead(`0)">
 <summary>
 Adds an element to the beggining of the Deque(Of T)
 </summary>
 <param name="item"></param>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Deque.Deque`1.RemoveHead">
 <summary>
 pop returns the firts element of the Deque(Of T) and removes it from Deque(Of T)
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Deque.Deque`1.RemoveTail">
 <summary>
 returns the last element of the Deque(Of T) and removes it from Deque(Of T)
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Deque.Deque`1.Clear">
 <summary>
 Removes all elements from the Deque(Of T).
 </summary> 
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Deque.Deque`1.Contains(`0)">
 <summary>
 Determines whether an element is in the Deque(Of T).
 </summary>
 <param name="item"></param>
 <returns>true if item is found in the Deque(Of T); otherwise, false.</returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Deque.Deque`1.CopyTo(`0[],System.Int32)">
 <summary>
 Copies the entire Deque(Of T) to a compatible one-dimensional array, 
 starting at the specified index of the target array.
 </summary>
 <param name="array"></param>
 <param name="arrayIndex"></param>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Deque.Deque`1.CopyToReversed(`0[],System.Int32)">
 <summary>
 Copies the entire Deque(Of T) to a compatible one-dimensional array, 
 starting at the specified index of the target array, in reversed 
 order
 </summary>
 <param name="array"></param>
 <param name="arrayIndex"></param>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Deque.Deque`1.IndexOf(`0)">
 <summary>
 Searches for the specified object and returns the zero-based index of the first occurrence within the entire Deque(Of T).
 </summary>
 <returns>e zero-based index of the first occurrence of item within the entire Deque(Of T), if found; otherwise, -1.</returns> 
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Deque.Deque`1.Insert(System.Int32,`0)">
 <summary>
 Inserts an element into the Deque(Of T) at the specified index.
 </summary>
 <param name="index"></param>
 <param name="item"></param>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Deque.Deque`1.Remove(`0)">
 <summary>
 Removes the first occurrence of a specific object from the Deque(Of T).
 </summary>
 <param name="item"></param>
 <returns>true if item is successfully removed; otherwise, false. This method also returns false if item was not found in the List(Of T).</returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Deque.Deque`1.RemoveAt(System.Int32)">
 <summary>
 Removes the element at the specified index of the Deque(Of T).
 </summary>
 <param name="index"></param> 
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Deque.Deque`1.Reverse">
 <summary>
 returns reverse view on this instance of Deque(Of T)
 </summary>
 <returns></returns> 
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.Collection.Deque.Enumerator`1.curIndex">
 <summary>
 initialize with -1 to ensure that InvalidOperationException 
 is thrown when Current is called befor the first call of 
 MoveNext
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.Collection.Deque.Enumerator`1.version">
 <summary>
 version of Deque(Of T) this Enumerator is enumerating from the moment this enumerator has been created
 </summary>
 
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.Collection.Deque.Enumerator`1.que">
 <summary>
 Deque(Of T) this enumerator is enumerating
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.Collection.Deque.ReversedEnumerator`1.version">
 <summary>
 version of Deque(Of T) this Enumerator is enumerating from the moment this enumerator has been created
 </summary> 
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.Collection.Deque.ReversedEnumerator`1.que">
 <summary>
 Deque(Of T) this enumerator is enumerating
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Collection.Deque.ReverseQueue`1.First">
 <summary>
 peek the firts element of the reversed Deque(Of T)
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Collection.Deque.ReverseQueue`1.Last">
 <summary>
 peek the last element of the reversed Deque(Of T)
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Collection.Deque.ReverseQueue`1.Count">
 <summary>
 Number of elements in Deque(Of T)
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.Collection.Deque.ReverseQueue`1.deque">
 <summary>
 Deque(Of T) that this instance of ReverseView wraps and allows to access in the reversed order
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Deque.ReverseQueue`1.Add(`0)">
 <summary>
 Adds an object to the end of the reversed Deque(Of T).
 </summary>
 <param name="item"></param>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Deque.ReverseQueue`1.AddHead(`0)">
 <summary>
 Adds an element to the beggining of the reversed Deque(Of T)
 </summary>
 <param name="item"></param>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Deque.ReverseQueue`1.Clear">
 <summary>
 Removes all elements from the Deque(Of T).
 </summary> 
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Deque.ReverseQueue`1.Contains(`0)">
 <summary>
 Determines whether an element is in the Deque(Of T).
 </summary>
 <param name="item"></param>
 <returns>true if item is found in the List(Of T); otherwise, false</returns> 
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Deque.ReverseQueue`1.CopyTo(`0[],System.Int32)">
 <summary>
 Copies the entire Deque(Of T) to a compatible one-dimensional array, starting at the specified index of the target array.
 </summary> 
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Deque.ReverseQueue`1.IndexOf(`0)">
 <summary>
 Searches for the specified object and returns the zero-based index of the first occurrence within the entire Deque(Of T).
 </summary>
 <returns>e zero-based index of the first occurrence of item within the entire Deque(Of T), if found; otherwise, -1.</returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Deque.ReverseQueue`1.Insert(System.Int32,`0)">
 <summary>
 Inserts an element into the reversedDeque(Of T) at the specified index.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Deque.ReverseQueue`1.Remove(`0)">
 <summary>
 Removes the first occurrence of a specific object from the Deque(Of T).
 </summary>
 <returns>true if item is successfully removed; otherwise, false. This method also returns false if item was not found in the List(Of T).</returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Deque.ReverseQueue`1.RemoveAt(System.Int32)">
 <summary>
 Removes the element at the specified index of the Deque(Of T).
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Deque.ReverseQueue`1.RemoveHead">
 <summary>
 returns the firts element of the reversed Deque(Of T) and removes it from Deque(Of T)
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Deque.ReverseQueue`1.RemoveTail">
 <summary>
 returns the last element of the reversed Deque(Of T) and removes it from Deque(Of T)
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Deque.ReverseQueue`1.Reverse">
 <summary>
 returns 
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Generic.BucketSet`1.ForEachBucket">
 <summary>
 populate each pack data from the bucket data
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Generic.BucketSet`1.GetItemByGlobalIndex(System.Int64)">
 <summary>
 根据全局索引获取元素
 </summary>
 <param name="index">全局索引（从0开始）</param>
 <returns>指定索引处的元素</returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Generic.BucketSet`1.GetRange(System.Int64,System.Int64)">
 <summary>
 根据全局索引范围获取元素序列
 </summary>
 <param name="startIndex">起始索引（包含，从0开始）</param>
 <param name="endIndex">结束索引（包含，从0开始）</param>
 <returns>指定范围内的元素序列</returns>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Collection.Generic.INamedValue">
 <summary>
 This type of object have a <see cref="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Repository.IKeyedEntity`1.Key"></see> property to 
 unique identified itself in a collection.
 This interface was inherits from type <see cref="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Repository.IKeyedEntity`1"/>.
 </summary>
 <remarks>
 (一个具有自己的名称的变量值的抽象)
 </remarks>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Collection.Generic.IReadOnlyId">
 <summary>
 与<see cref="T:Microsoft.VisualBasic.ComponentModel.Collection.Generic.INamedValue"/>所不同的是，这个对象的标识属性是只读的.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Collection.Generic.IReadOnlyId.Identity">
 <summary>
 The unique identifer in the object collection. 
 Unique-Id of the target implements object.
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Collection.Generic.ISequenceData`2">
 <summary>
 The sequence analysis data model, example as biological sequence, 
 time signal, time sequence anaysis
 </summary>
 <typeparam name="T"></typeparam>
 <remarks>
 A general abstract model apply for the SGT algorithm analysis
 </remarks>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Collection.Generic.ISequenceData`2.SequenceData">
 <summary>
 the sequence data provider, example like time serial signals, 
 logging data, biological sequence
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Generic.NamedValueList`1.op_Addition(System.Collections.Generic.Dictionary{System.String,`0},Microsoft.VisualBasic.ComponentModel.Collection.Generic.NamedValueList{`0})">
 <summary>
 This operator will makes a copy of <paramref name="table"/>
 </summary>
 <param name="table"></param>
 <param name="list"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Collection.Generic.HashDictionary`1">
 <summary>
 The key of the dictionary is string value and the keys is not sensitive to the character case.
 (字典的键名为字符串，大小写不敏感，行为和哈希表类型)
 </summary>
 <typeparam name="T"></typeparam>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Generic.HashDictionary`1.#ctor">
 <summary>
 Initializes a new instance of the System.Collections.Generic.Dictionary`2 class
 that is empty, has the default initial capacity, and uses the default equality
 comparer for the key type.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Generic.HashDictionary`1.ContainsKey(System.String)">
 <summary>
 
 </summary>
 <param name="key">大小写不敏感</param>
 <returns></returns>
 <remarks></remarks>
 
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Collection.Generic.HashDictionary`1.Item(System.String)">
 <summary>
 添加<see cref="M:Microsoft.VisualBasic.ComponentModel.Collection.Generic.HashDictionary`1.Add(System.Collections.Generic.KeyValuePair{System.String,`0})"></see>和替换操作主要在这里进行
 </summary>
 <param name="key">大小写不敏感</param>
 <value></value>
 <returns></returns>
 <remarks></remarks>
 
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Collection.Generic.IKeyValuePairObject`2">
 <summary>
 Defines a key/value pair that can be set or retrieved.
 </summary>
 <typeparam name="TKey"></typeparam>
 <typeparam name="TValue"></typeparam>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Collection.Generic.IKeyValuePairObject`2.Key">
 <summary>
 Gets the key in the key/value pair.
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Collection.Generic.IKeyValuePairObject`2.Value">
 <summary>
 Gets the value in the key/value pair.
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Collection.Generic.IReadOnlyDataSource`1">
 <summary>
 Defines a key/value pair that only can be retrieved.
 </summary>
 <typeparam name="TValue"></typeparam>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Collection.Generic.KeyValuePairObject`2">
 <summary>
 Defines a key/value pair that can be set or retrieved.
 </summary>
 <typeparam name="TKey"></typeparam>
 <typeparam name="TValue"></typeparam>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Collection.Generic.KeyValuePairObject`2.Key">
 <summary>
 Gets the key in the key/value pair.
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Collection.Generic.KeyValuePairObject`2.Value">
 <summary>
 Gets the value in the key/value pair.
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Collection.FuzzyGroup">
 <summary>
 对数据进行分组，通过标签数据的相似度
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.FuzzyGroup.FuzzyGroups``1(System.Collections.Generic.IEnumerable{``0},System.Double,System.Boolean)">
 <summary>
 Grouping objects in a collection based on their <see cref="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Repository.IKeyedEntity`1.Key"/> string Fuzzy equals to others'.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <param name="cut">字符串相似度的阈值</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.FuzzyGroup.FuzzyGroups``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.String},System.Double,System.Boolean)">
 <summary>
 Grouping objects in a collection based on their unique key string Fuzzy equals to others'.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <param name="getKey">The unique key provider</param>
 <param name="cut">字符串相似度的阈值</param>
 <returns></returns>
 <remarks>
 由于list在查找方面的速度非常的慢，而字典可能在生成的时候会慢一些，但是查找很快，所以在这里函数里面使用字典来替代列表
 </remarks>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Collection.FuzzyGroup.__groupHelper`1">
 <summary>
 分组操作的内部帮助类
 </summary>
 <typeparam name="T"></typeparam>
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.Collection.FuzzyGroup.__groupHelper`1.key">
 <summary>
 Key for represent this object.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.Collection.FuzzyGroup.__groupHelper`1.x">
 <summary>
 Target element object in the grouping 
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.Collection.FuzzyGroup.__groupHelper`1.keyASC">
 <summary>
 Key cache
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.FuzzyGroup.__groupHelper`1.Equals(Microsoft.VisualBasic.ComponentModel.Collection.FuzzyGroup.__groupHelper{`0})">
 <summary>
 判断Key是否模糊相等
 </summary>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Collection.BinaryHeap`1">
 <summary>
 Binary heap implementation from:
 
 > http://eloquentjavascript.net/appendix2.html
 </summary>
 <typeparam name="T"></typeparam>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Collection.IBucketVector">
 <summary>
 clr interface for implements the ``as.vector`` function in R# language
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.IBucketVector.GetVector">
 <summary>
 Get elements from current object to construct a new vector object
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Collection.BucketDictionary`2">
 <summary>
 An ultralarge size dictionary object.
 (当你发现一个数据集合非常的大的时候，一个字典会出现溢出，则这个时候就需要这个超大容量的Bucket字典容器了)
 </summary>
 <typeparam name="K"></typeparam>
 <typeparam name="V"></typeparam>
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.Collection.BucketDictionary`2.bucketSize">
 <summary>
 每一个字典之中的最大的元素数目
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Collection.BucketDictionary`2.Count">
 <summary>
 获取这个超大的字典集合之中的对象的数量总数
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Collection.BucketDictionary`2.Item(`0)">
 <summary>
 注意，不要直接使用这个方法来添加新的数据，使用<see cref="T:Microsoft.VisualBasic.ComponentModel.Collection.BucketDictionaryExtensions"/>的方法会更加高效
 </summary>
 <param name="key"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.BucketDictionaryExtensions.CreateBuckets``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Int32,System.Boolean)">
 <summary>
 
 </summary>
 <typeparam name="T"></typeparam>
 <typeparam name="K"></typeparam>
 <param name="source"></param>
 <param name="getKey"></param>
 <param name="size%"></param>
 <param name="overridesDuplicates">
 当数据中存在重复的键名的时候，是将前面已有的数据覆盖掉还是抛出键名重复的错误？默认是不进行重写覆盖，而是键重复抛出错误。
 </param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Collection.Index`1">
 <summary>
 Mappings of ``key As String -> index As Integer``
 </summary>
 <typeparam name="T"></typeparam>
 <remarks>
 ###### 2017-12-10
 
 经过测试，字典对象是完全可以容纳UniProt数据库之中的物种的数量上限的
 </remarks>
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.Collection.Index`1.index">
 <summary>
 list value will be set to nothing on <see cref="M:Microsoft.VisualBasic.ComponentModel.Collection.Index`1.Delete(`0)"/>
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.Collection.Index`1.base">
 <summary>
 the index offset value ,zero by default
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Collection.Index`1.Count">
 <summary>
 获取包含在<see cref="T:System.Collections.Generic.Dictionary`2"/>中的键/值对的数目。
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Collection.Index`1.Objects">
 <summary>
 Gets the input object keys that using for the construction of this index.
 </summary>
 <returns>an array of value copy of the map keys</returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Index`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Int32)">
 <summary>
 请注意，这里的数据源请尽量使用Distinct的，否则对于重复的数据，只会记录下第一个位置
 </summary>
 <param name="source"></param>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Index`1.#ctor(System.Int32)">
 <summary>
 默认是从0开始的
 </summary>
 <param name="base"></param>
 
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Index`1.#ctor(System.Collections.Generic.IDictionary{`0,System.Int32},System.Int32)">
 <summary>
 
 </summary>
 <param name="maps">如果是json加载，可能会出现空值的字典</param>
 <param name="base%"></param>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Collection.Index`1.IndexOf(`0)">
 <summary>
 获取目标对象在本索引之中的位置编号，不存在则返回-1
 </summary>
 <param name="x"></param>
 <returns>
 this function always returns -1(ignores of the <see cref="F:Microsoft.VisualBasic.ComponentModel.Collection.Index`1.base"/> offset value) 
 if the target element is not found.
 </returns>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Collection.Index`1.IndexOf(System.Int32)">
 <summary>
 直接通过索引获取目标对象的值，请注意，如果<typeparamref name="T"/>泛型类型是<see cref="T:System.Int32"/>，
 则如果需要查找index的话，则必须要显式的指定参数名为``x:=``，否则调用的是当前的这个索引方法，
 得到错误的结果
 </summary>
 <param name="index%"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Index`1.EnumerateMapKeys">
 <summary>
 与<see cref="P:Microsoft.VisualBasic.ComponentModel.Collection.Index`1.Objects"/>只读属性的功能相似，只不过这个函数是Linq枚举器模式
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Index`1.GetOrdinal(System.Collections.Generic.IEnumerable{`0})">
 <summary>
 get element index
 </summary>
 <param name="items"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Index`1.GetSynonymOrdinal(`0[])">
 <summary>
 
 </summary>
 <param name="synonym"></param>
 <returns>this function returns -1 if synonym value is not found inside the index</returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Index`1.Delete(`0)">
 <summary>
 just removes the key, the index ordinal offset will not make any changes
 </summary>
 <param name="index"></param>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Index`1.Delete(`0[])">
 <summary>
 just removes the key, the index ordinal offset will not make any changes
 </summary>
 <param name="index"></param>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Index`1.NotExists(`0)">
 <summary>
 For Linq ``where``
 </summary>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Index`1.Add(`0)">
 <summary>
 这个函数是线程不安全的
 </summary>
 <param name="x"></param>
 <returns>
 这个函数所返回来的值是所添加的<paramref name="x"/>的index值
 </returns>
 <remarks>
 this function will ignores of the existed duplicated item
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Index`1.Add(`0,System.Int32)">
 <summary>
 insert the specific element into the specific location of the index
 </summary>
 <param name="x"></param>
 <param name="index"></param>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Index`1.Add(`0[])">
 <summary>
 add a collection of the unique items into current index object
 </summary>
 <param name="x"></param>
 <returns></returns>
 <remarks>
 Please note that this function is a iterator function. <b>which means your MUST
 call the ToArray or ToList method to execute this function</b>, <span style="color: red;">or the items
 will not be added into current index object.</span>
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Index`1.Clear">
 <summary>
 clear mapping and reset the index offset
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Index`1.ToString">
 <summary>
 Display the input source sequence.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Collection.Index`1.Map">
 <summary>
 Returns the ``obj => index`` mapping table.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Index`1.op_Explicit(Microsoft.VisualBasic.ComponentModel.Collection.Index{`0})~System.Collections.Generic.Dictionary{`0,System.Int32}">
 <summary>
 cast index to a dictionary mapping of object element value to its index value
 </summary>
 <param name="index"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Index`1.op_Implicit(`0[])~Microsoft.VisualBasic.ComponentModel.Collection.Index{`0}">
 <summary>
 Create a index of target element array with index base zero
 </summary>
 <param name="objs"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Index`1.op_Implicit(Microsoft.VisualBasic.Language.List{`0})~Microsoft.VisualBasic.ComponentModel.Collection.Index{`0}">
 <summary>
 Create a index of target element array with index base zero
 </summary>
 <param name="list"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Index`1.op_Addition(Microsoft.VisualBasic.ComponentModel.Collection.Index{`0},`0)">
 <summary>
 Add a new key to this index object.
 </summary>
 <param name="index">Element key index object.</param>
 <param name="element"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Index`1.op_Subtraction(Microsoft.VisualBasic.ComponentModel.Collection.Index{`0},Microsoft.VisualBasic.Language.List{`0})">
 <summary>
 Delete items from source <paramref name="index"/> and then returns the new modify index collection
 </summary>
 <param name="index"></param>
 <param name="list"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Index`1.op_Like(`0,Microsoft.VisualBasic.ComponentModel.Collection.Index{`0})">
 <summary>
 <paramref name="item"/> is one of the element in <paramref name="indexr"/>
 </summary>
 <param name="item"></param>
 <param name="indexr"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Index`1.op_Equality(Microsoft.VisualBasic.ComponentModel.Collection.Index{`0},System.Int32)">
 <summary>
 The element numbers in current index object is equals to given count number value?
 </summary>
 <param name="index"></param>
 <param name="count%"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Index`1.op_GreaterThan(Microsoft.VisualBasic.ComponentModel.Collection.Index{`0},System.Int32)">
 <summary>
 The element count inside current index object greater than the given <paramref name="count"/>?
 </summary>
 <param name="index"></param>
 <param name="count%"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Index`1.op_LessThan(Microsoft.VisualBasic.ComponentModel.Collection.Index{`0},System.Int32)">
 <summary>
 The element count inside current index object smaller than the given <paramref name="count"/>?
 </summary>
 <param name="index"></param>
 <param name="count%"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Index`1.op_Subtraction(`0[],Microsoft.VisualBasic.ComponentModel.Collection.Index{`0})">
 <summary>
 removes elements from <paramref name="list"/> based on a 
 given <paramref name="filter"/> element list.
 </summary>
 <param name="list"></param>
 <param name="filter"></param>
 <returns>a new sequence that not have any elements 
 inside the <paramref name="filter"/> list.
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Index`1.indexing(System.Collections.Generic.IEnumerable{`0})">
 <summary>
 create a zero-based object index
 </summary>
 <param name="data"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Collection.Dictionary`1">
 <summary>
 Represents a collection of keys and values.To browse the .NET Framework source
 code for this type, see the Reference Source.
 </summary>
 <typeparam name="V"></typeparam>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Collection.Dictionary`1.Item(System.String)">
 <summary>
 不存在的键名或者空值的键名都会返回``Nothing``
 </summary>
 <param name="key"></param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Collection.Dictionary`1.Item(System.Collections.Generic.IEnumerable{System.String})">
 <summary>
 The <paramref name="keys"/> element counts should equals to the value length when invoke property set.
 </summary>
 <param name="keys"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Dictionary`1.#ctor">
 <summary>
 create a new empty <see cref="T:System.Collections.Generic.SortedDictionary`2"/> 
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Dictionary`1.#ctor(System.Collections.Generic.Dictionary{System.String,`0})">
 <summary>
 Initializes a new instance of the System.Collections.Generic.SortedDictionary`2
 class that contains elements copied from the specified System.Collections.Generic.IDictionary`2
 and uses the default System.Collections.Generic.IComparer`1 implementation for
 the key type.
 </summary>
 <param name="source">
 The System.Collections.Generic.IDictionary`2 whose elements are copied to the
 new System.Collections.Generic.SortedDictionary`2.
 </param>
 
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Dictionary`1.Add(`0)">
 <summary>
 Adds an element with the specified key and value into the System.Collections.Generic.SortedDictionary`2.
 </summary>
 <param name="item"></param>
 
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Dictionary`1.Find(System.String)">
 <summary>

 </summary>
 <param name="name">不区分大小写的</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Dictionary`1.Have(`0)">
 <summary>
 Inline method alias of function <see cref="M:System.Collections.Generic.SortedDictionary`2.ContainsKey(`0)"/> in parent class
 </summary>
 <param name="item"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Dictionary`1.SafeGetValue(System.String,`0@,System.Boolean@)">
 <summary>
 If the value is not found in the hash directionary, then the default value will be returns, and the default value is nothing.
 </summary>
 <param name="name"></param>
 <param name="[default]"></param>
 <param name="success">可能value本身就是空值，所以在这里使用这个参数来判断是否存在</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Dictionary`1.TryGetValue(System.String,System.Boolean@)">
 <summary>
 Gets the value associated with the specified key.(假若找不到键值，就会返回Nothing)
 </summary>
 <param name="name">The key of the value to get.</param>
 <param name="success">true if the System.Collections.Generic.SortedDictionary`2 contains an element
 with the specified key; otherwise, false.</param>
 <returns>When this method returns, the value associated with the specified key, if the
 key is found; otherwise, the default value for the type of the value parameter.</returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Dictionary`1.Remove(`0)">
 <summary>
 假若目标元素不存在于本字典之中，则会返回False
 </summary>
 <param name="vec"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Dictionary`1.op_Addition(Microsoft.VisualBasic.ComponentModel.Collection.Dictionary{`0},`0)">
 <summary>
 Adds an element with the specified key and value into the System.Collections.Generic.SortedDictionary`2.
 </summary>
 <param name="list"></param>
 <param name="item"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Dictionary`1.op_Exponent(Microsoft.VisualBasic.ComponentModel.Collection.Dictionary{`0},System.String)">
 <summary>
 Find a variable in the hash table
 </summary>
 <param name="table"></param>
 <param name="uid"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Dictionary`1.op_Subtraction(Microsoft.VisualBasic.ComponentModel.Collection.Dictionary{`0},System.Collections.Generic.IEnumerable{System.String})">
 <summary>
 批量移除字典之中的键值对
 </summary>
 <param name="hash"></param>
 <param name="keys">需要移除的键名的列表</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Dictionary`1.op_LessThanOrEqual(Microsoft.VisualBasic.ComponentModel.Collection.Dictionary{`0},System.String)">
 <summary>
 Get value by key.
 </summary>
 <param name="hash"></param>
 <param name="key"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Dictionary`1.op_Concatenate(Microsoft.VisualBasic.ComponentModel.Collection.Dictionary{`0},System.String)">
 <summary>
 <see cref="M:System.Collections.Generic.SortedDictionary`2.ContainsKey(`0)"/>
 </summary>
 <param name="hash"></param>
 <param name="null"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.Dictionary`1.op_Concatenate(Microsoft.VisualBasic.ComponentModel.Collection.Dictionary{`0},`0)">
 <summary>
 <see cref="M:System.Collections.Generic.SortedDictionary`2.ContainsKey(`0)"/>
 </summary>
 <param name="table"></param>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.BinaryPriorityQueue.Push(System.Object)">
 <summary>
 Push an object onto the PQ
 </summary>
 <param name="O">The new object</param>
 <returns>The index in the list where the object is _now_. This will change when objects are taken from or put onto the PQ.</returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.BinaryPriorityQueue.Pop">
 <summary>
 Get the smallest object and remove it.
 </summary>
 <returns>The smallest object</returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.BinaryPriorityQueue.Update(System.Int32)">
 <summary>
 Notify the PQ that the object at position i has changed
 and the PQ needs to restore order.
 Since you dont have access to any indexes (except by using the
 explicit IList.this) you should not call this function without knowing exactly
 what you do.
 </summary>
 <param name="i">The index of the changed object.</param>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.BinaryPriorityQueue.Peek">
 <summary>
 Get the smallest object without removing it.
 </summary>
 <returns>The smallest object</returns>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Collection.PairingHeap`1">
 <summary>
 from: https://gist.github.com/nervoussystem
 ``{elem:object, subheaps:[array of heaps]}``
 </summary>
 <typeparam name="T"></typeparam>
 <remarks>
 堆对象应该没有节点删除的操作吧？
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.PairingHeap`1.merge(Microsoft.VisualBasic.ComponentModel.Collection.PairingHeap{`0},System.Func{`0,`0,System.Boolean})">
 <summary>
 优先度比较大的对象将会先被push到stack之中
 </summary>
 <param name="heap2"></param>
 <param name="lessThan"></param>
 <returns></returns>
 <remarks>
 会在这个函数始终构建出一个二叉树的结构
 </remarks>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Collection.PriorityQueue`1">
 <summary>
 a min priority queue backed by a pairing heap
 </summary>
 <typeparam name="T"></typeparam>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.PriorityQueue`1.#ctor(System.Func{`0,`0,System.Boolean})">
 <summary>
 ```
 priority = a &lt; b
 ```
 </summary>
 <param name="lessThan"></param>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.PriorityQueue`1.top">
 <summary>
 the top element (the min element as defined by lessThan)
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Collection.KeyValuePairExtensions">
 <summary>
 KeyValue pair data related extensions API.
 </summary>
 
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.KeyValuePairExtensions.Popout``2(System.Collections.Generic.Dictionary{``0,``1},``0)">
 <summary>
 从目标字典中按照给定的键名称获取值然后删除给定的键名称对应的数据
 </summary>
 <typeparam name="K"></typeparam>
 <typeparam name="V"></typeparam>
 <param name="table"></param>
 <param name="key"></param>
 <returns>
 returns nothing if the given key is not existed inside the dictionary
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.KeyValuePairExtensions.ToLower``1(System.Collections.Generic.Dictionary{System.String,``0})">
 <summary>
 transform the hash key string to lower case characters
 </summary>
 <typeparam name="T"></typeparam>
 <param name="table"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.KeyValuePairExtensions.ToUpper``1(System.Collections.Generic.Dictionary{System.String,``0})">
 <summary>
 transform the hash key string to upper case characters
 </summary>
 <typeparam name="T"></typeparam>
 <param name="table"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.KeyValuePairExtensions.ComputeIfAbsent``2(System.Collections.Generic.IDictionary{``0,``1},``0,System.Func{``0,``1})">
 <summary>
 这个拓展函数主要是针对值得构建比较耗时的操作，主要应用于数据缓存场景
 </summary>
 <typeparam name="K"></typeparam>
 <typeparam name="V"></typeparam>
 <param name="table"></param>
 <param name="key"></param>
 <param name="lazyValue"></param>
 <returns></returns>
 <remarks>
 thread safe: target <paramref name="table"/> has been SyncLock at here
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.KeyValuePairExtensions.Tuple``2(``0,``1)">
 <summary>
 Create a tuple for two elements
 </summary>
 <typeparam name="T1"></typeparam>
 <typeparam name="T2"></typeparam>
 <param name="a"></param>
 <param name="b"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.KeyValuePairExtensions.Tsv(System.Collections.Generic.Dictionary{System.String,System.String},System.String,Microsoft.VisualBasic.Text.Encodings,System.Boolean)">
 <summary>
 将目标键值对集合保存为一个``Tsv``文件
 </summary>
 <param name="table"></param>
 <param name="saveTo$"></param>
 <param name="encoding"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.KeyValuePairExtensions.AsTable``2(System.Collections.Generic.IEnumerable{System.ValueTuple{``0,``1}})">
 <summary>
 tuple set to dictionary table
 </summary>
 <typeparam name="K"></typeparam>
 <typeparam name="V"></typeparam>
 <param name="tuples"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.KeyValuePairExtensions.KeyItem``1(System.Collections.Generic.IEnumerable{``0},System.String)">
 <summary>
 Item selector by directly text equals match.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <param name="key"></param>
 <returns>
 nothing will be return if the <paramref name="key"/> is not exists
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.KeyValuePairExtensions.Takes``1(System.Collections.Generic.IEnumerable{``0},System.String)">
 <summary>
 Item selector by using regex expression.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <param name="pattern">The regular expression pattern.</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.KeyValuePairExtensions.Subset``1(System.Collections.Generic.Dictionary{System.String,``0},System.String[],System.Boolean)">
 <summary>
 根据所给定的一个主键列表批量化取出目标字典之中的一部分数据构成一个新的字典子集对象
 函数会根据<see cref="M:Microsoft.VisualBasic.ComponentModel.Collection.KeyValuePairExtensions.Keys``1(Microsoft.VisualBasic.Linq.Enumeration{``0},System.Boolean)"/>参数来做排序
 </summary>
 <typeparam name="T"></typeparam>
 <param name="table"></param>
 <param name="keys$"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.KeyValuePairExtensions.Takes``1(System.Collections.Generic.IDictionary{System.String,``0},System.Collections.Generic.IEnumerable{System.String},``0)">
 <summary>
 按照给定的键名列表<paramref name="keys"/>将字典之中的对应的元素按照键名的顺序取出来
 </summary>
 <typeparam name="T"></typeparam>
 <param name="table"></param>
 <param name="keys"></param>
 <param name="default">
 Use this as default value is key is not exists
 </param>
 <returns>
 <paramref name="default"/> value will be returned if the 
 specific key is not exists in the given <paramref name="table"/>
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.KeyValuePairExtensions.RemoveAndGet``2(System.Collections.Generic.Dictionary{``0,``1},``0)">
 <summary>
 Removes the target key in the dictionary table, and then gets the removed value.
 (删除字典之中的指定的键值对，然后返回被删除的数据值)
 </summary>
 <typeparam name="K"></typeparam>
 <typeparam name="V"></typeparam>
 <param name="table"></param>
 <param name="key"></param>
 <returns>The value of the removed <paramref name="key"/></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.KeyValuePairExtensions.IteratesAll``1(System.Collections.Generic.IEnumerable{Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedCollection{``0}})">
 <summary>
 Iterates all of the values in the <paramref name="source"/> collection data.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.KeyValuePairExtensions.GroupByKey``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>
 Groups source by <see cref="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Repository.IKeyedEntity`1.Key"/>
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.KeyValuePairExtensions.Values``1(System.Collections.Generic.IEnumerable{Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedValue{``0}})">
 <summary>
 Retrieve all items' value data.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.KeyValuePairExtensions.Values``2(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{``0,``1}})">
 <summary>
 get values from the key-value paires
 </summary>
 <typeparam name="T"></typeparam>
 <typeparam name="V">the tuple value type</typeparam>
 <param name="src"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.KeyValuePairExtensions.Keys``1(System.Collections.Generic.IEnumerable{``0},System.Boolean)">
 <summary>
 gets all <see cref="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Repository.IKeyedEntity`1.Key"/> values.
 (按照顺序得到输入的序列之中的<see cref="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Repository.IKeyedEntity`1.Key"/>属性值)
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <param name="distinct">是否还进行去重操作？默认不做去重</param>
 <returns>
 A collection list of the index key name values which is extract from the <paramref name="source"/>,
 the label key orders keeps the same with the elements inside the input <paramref name="source"/>
 sequence.
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.KeyValuePairExtensions.Keys``2(System.Collections.Generic.IEnumerable{System.Linq.IGrouping{``0,``1}})">
 <summary>
 get group keys
 </summary>
 <typeparam name="K"></typeparam>
 <typeparam name="V"></typeparam>
 <param name="source"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.KeyValuePairExtensions.GetByKey``1(System.Collections.Generic.IEnumerable{``0},System.String,System.StringComparison)">
 <summary>
 Get a specific item value from the target collction data using its UniqueID property，
 (请注意，请尽量不要使用本方法，因为这个方法的效率有些低，对于获取<see cref="T:Microsoft.VisualBasic.ComponentModel.Collection.Generic.INamedValue">
 </see>类型的集合之中的某一个对象，请尽量先转换为字典对象，在使用该字典对象进行查找以提高代码效率，使用本方法的优点是可以选择忽略<paramref name="uid">
 </paramref>参数之中的大小写，以及对集合之中的存在相同的Key的这种情况的容忍)
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <param name="uid"></param>
 <param name="IgnoreCase"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.KeyValuePairExtensions.ContainsKey``1(Microsoft.VisualBasic.ComponentModel.Collection.Dictionary{``0},Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedValue{``0})">
 <summary>
 Dictionary object contains the specific <see cref="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedValue`1.Name"/>?
 </summary>
 <typeparam name="T"></typeparam>
 <param name="table"></param>
 <param name="k"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.KeyValuePairExtensions.ContainsKey``1(System.Collections.Generic.Dictionary{System.String,``0},Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedValue{``0})">
 <summary>
 Dictionary object contains the specific <see cref="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedValue`1.Name"/>?
 </summary>
 <typeparam name="T"></typeparam>
 <param name="table"></param>
 <param name="k"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.KeyValuePairExtensions.DictionaryData``2(System.Collections.Generic.IReadOnlyDictionary{``0,``1})">
 <summary>
 Converts the interface object into a Dictionary object.
 </summary>
 <typeparam name="T"></typeparam>
 <typeparam name="V"></typeparam>
 <param name="source"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.KeyValuePairExtensions.EnumParser``1(System.Boolean,System.Boolean)">
 <summary>
 Creates the dictionary for string converts to enum value.
 (接受的泛型类型必须是枚举类型)
 </summary>
 <typeparam name="T"></typeparam>
 <param name="lcaseKey"></param>
 <param name="usingDescription"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.KeyValuePairExtensions.NamedValues``1(System.Collections.Generic.Dictionary{System.String,``0})">
 <summary>
 Convert the dictionary table as the <see cref="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedValue`1"/> collection.
 (将目标字典之中的键值对转换为被命名为的变量值)
 </summary>
 <typeparam name="T"></typeparam>
 <param name="table"></param>
 <returns></returns>
 <remarks>
 如果需要调用Linq模式的方法，可以使用<see cref="M:Microsoft.VisualBasic.ComponentModel.Collection.KeyValuePairExtensions.IterateNameValues``1(System.Collections.Generic.Dictionary{System.String,``0})"/>
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.KeyValuePairExtensions.NameValueCollection(System.Collections.Generic.IEnumerable{Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedValue{System.String}})">
 <summary>
 获取得到的集合对象是一个安全的集合对象，不存在的键名会直接返回空值
 </summary>
 <param name="maps">
 the duplicated keys in this tuple list can be existed
 </param>
 <returns>
 the duplicated key can be existed
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.KeyValuePairExtensions.SortByKey``2(System.Collections.Generic.Dictionary{``0,``1}@,System.Boolean)">
 <summary>
 按照键名对字典进行重新排序
 </summary>
 <typeparam name="V"></typeparam>
 <typeparam name="T"></typeparam>
 <param name="table"></param>
 <param name="desc">默认为从小到大的升序排序</param>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.KeyValuePairExtensions.ContainsKey(System.Collections.Specialized.NameValueCollection,System.String)">
 <summary>
 Determines whether the <see cref="M:Microsoft.VisualBasic.ComponentModel.Collection.KeyValuePairExtensions.NameValueCollection(System.Collections.Generic.IEnumerable{Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedValue{System.String}})"/> contains the specified key.
 </summary>
 <param name="d"></param>
 <param name="key$">The key to locate in the <see cref="M:Microsoft.VisualBasic.ComponentModel.Collection.KeyValuePairExtensions.NameValueCollection(System.Collections.Generic.IEnumerable{Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedValue{System.String}})"/></param>
 <returns>true if the System.Collections.Generic.Dictionary`2 contains an element with
 the specified key; otherwise, false.</returns>
 
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.KeyValuePairExtensions.ParserDictionary``1">
 <summary>
 请注意，这里的类型约束只允许枚举类型
 </summary>
 <typeparam name="T"></typeparam>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.KeyValuePairExtensions.HaveData``1(System.Collections.Generic.Dictionary{``0,System.String},``0)">
 <summary>
 Data exists and not nothing
 </summary>
 <typeparam name="T"></typeparam>
 <param name="d"></param>
 <param name="key"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.KeyValuePairExtensions.ToDictionary(System.Collections.Specialized.NameValueCollection,System.Boolean)">
 <summary>
 
 </summary>
 <param name="nc"></param>
 <param name="allStrings">get all of the string values for each 
 parameter name? if this parameter value is TRUE, then the value 
 of the output dictionary will be a string array.
 </param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.KeyValuePairExtensions.ToDictionary``1(System.Collections.Generic.IEnumerable{``0},System.Boolean)">
 <summary>
 Creates a <see cref="T:System.Collections.Generic.Dictionary`2"/>`2 from an <see cref="T:System.Collections.Generic.IEnumerable`1"/>`1
 according to a specified key selector function.
 </summary>
 <typeparam name="T">Unique identifier provider <see cref="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Repository.IKeyedEntity`1.Key"/></typeparam>
 <param name="source"></param>
 <returns></returns>
 <remarks>
 20241125
 NOTE: the generated dictionary is a sort dictionary, keys will be re-ordered!
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.KeyValuePairExtensions.FlatTable``1(Microsoft.VisualBasic.ComponentModel.Collection.Dictionary{Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedValue{``0}})">
 <summary>
 将命名变量对象进行降维，名字作为键名，值作为键值，生成字典
 </summary>
 <typeparam name="T"></typeparam>
 <param name="table"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.KeyValuePairExtensions.Add``2(Microsoft.VisualBasic.Language.List{Microsoft.VisualBasic.ComponentModel.Collection.Generic.KeyValuePairObject{``0,``1}}@,``0,``1)">
 <summary>
 Adds an object to the end of the List`1.
 </summary>
 <typeparam name="TKey"></typeparam>
 <typeparam name="TValue"></typeparam>
 <param name="list"></param>
 <param name="key"></param>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.KeyValuePairExtensions.ReverseMaps``2(System.Collections.Generic.Dictionary{``0,``1},System.Boolean)">
 <summary>
 使用这个函数应该要确保value是没有重复的，假若<paramref name="removeDuplicated"/>是默认值的话.
 </summary>
 <typeparam name="T"></typeparam>
 <typeparam name="V"></typeparam>
 <param name="d"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.KeyValuePairExtensions.Selects``2(System.Collections.Generic.Dictionary{``0,``1},System.Collections.Generic.IEnumerable{``0},System.Boolean)">
 <summary>
 一次性地使用一个键名的集合从字典之中选出一组数据
 </summary>
 <typeparam name="T"></typeparam>
 <typeparam name="V"></typeparam>
 <param name="d"></param>
 <param name="keys"></param>
 <param name="skipNonExist"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.MatrixExtensions.Matrix``2(System.Collections.Generic.IEnumerable{``1})">
 <summary>
 将数据集之中的虽有属性值取出来构建一个矩阵
 </summary>
 <param name="data"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.MatrixExtensions.ToFloatMatrix(System.Data.DataTable)">
 <summary>
 Converts a <see cref="T:System.Data.DataTable"/> to a 2-dimensional array
 </summary>
 <param name="table">A System.Data.DataTable containing data to cluster</param>
 <returns>A 2-dimensional array containing data to cluster</returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.MatrixExtensions.DATA``1(System.Collections.Generic.IEnumerable{Microsoft.VisualBasic.ComponentModel.DataSourceModel.DynamicPropertyBase{``0}},System.String)">
 <summary>
 Gets property field data from a generic data frame
 </summary>
 <typeparam name="T"></typeparam>
 <param name="dataframe"></param>
 <param name="property$"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.MatrixExtensions.Rectangle(System.Type,System.Int32,System.Int32)">
 <summary>
 An extension method shortcut to the function <see cref="M:Microsoft.VisualBasic.ComponentModel.Collection.RectangularArray.Matrix(System.Type,System.Int32,System.Int32)"/>.
 </summary>
 <param name="type"></param>
 <param name="m%"></param>
 <param name="n%"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.MatrixExtensions.DimensionSizeOf``1(``0[][])">
 <summary>
 Measure the dimension size of the rectangle array.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="rect"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.MatrixExtensions.ToMatrix``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}})">
 <summary>
 Convert the data collection into a matrix value.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source">The elements number in each collection should be agreed!(要求集合之中的每一列之中的数据的元素数目都相等)</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.MatrixExtensions.ToVectorList``1(``0[0:,0:])">
 <summary>
 Convert the matrix data into a collection of collection data type.(将矩阵对象转换为集合的集合的类型)
 </summary>
 <typeparam name="T"></typeparam>
 <param name="MAT"></param>
 <returns></returns>
 <remarks></remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.MatrixExtensions.GetSize``1(``0[0:,0:])">
 <summary>
 Get matrix width and height values.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="m"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.MatrixExtensions.RowIterator``1(``0[0:,0:])">
 <summary>
 Iterates each row data in a matrix type array.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="MAT"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.RectangularArray.CopyOf``1(``0[][]@)">
 <summary>
 Make deep copy of the rectangular array value
 </summary>
 <typeparam name="T"></typeparam>
 <param name="m"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.RectangularArray.Matrix``1(System.Int32,System.Int32)">
 <summary>
 Create an empty matrix with m row and n cols.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="m">m Rows</param>
 <param name="n">n Cols</param>
 <returns></returns>
 <remarks>
 (生成一个有m行n列的矩阵，但是是使用数组来表示的)
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Collection.RectangularArray.Matrix``1(System.Int32,System.Int32,``0)">
 <summary>
 Create an empty matrix with m row and n cols.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="m">m Rows</param>
 <param name="n">n Cols</param>
 <param name="s">fill the generated matrix this scalar value</param>
 <returns></returns>
 <remarks>
 (生成一个有m行n列的矩阵，但是是使用数组来表示的)
 </remarks>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.DataStructures.LoopArray`1">
 <summary>
 Infinite loop iterates of the target element collection.
 </summary>
 <typeparam name="T"></typeparam>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.LoopArray`1.Next">
 <summary>
 Gets the next elements in the array, is move to end, then the index will 
 moves to the array begining position.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.LoopArray`1.GET(System.Int32)">
 <summary>
 
 </summary>
 <param name="delta%">The pointer move delta</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.LoopArray`1.op_UnaryPlus(Microsoft.VisualBasic.ComponentModel.DataStructures.LoopArray{`0})">
 <summary>
 get current value and then move to next
 </summary>
 <param name="array"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.LoopArray`1.Break">
 <summary>
 Exit the Infinite loop iterator <see cref="M:Microsoft.VisualBasic.ComponentModel.DataStructures.LoopArray`1.GetEnumerator"/>
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.LoopArray`1.GetEnumerator">
 <summary>
 Infinite loop iterates of the target element collection.
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.DataStructures.Pointer`1">
 <summary>
 进行集合之中的元素的取出操作的帮助类
 </summary>
 <typeparam name="T"></typeparam>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.Pointer`1.op_Addition(`0[],Microsoft.VisualBasic.ComponentModel.DataStructures.Pointer{`0})">
 <summary>
 Returns current line in the array and then pointer moves to next.
 </summary>
 <param name="array"></param>
 <param name="i"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.EnumSet`1.noneOf">
 <summary>
 create a new empty enum set
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.DataStructures.Set">
 <summary>
 Represents an unordered grouping of unique hetrogenous members.
 </summary>
 <remarks>
 (这个对象的功能和List类似，但是这个对象的主要的作用是进行一些集合运算：使用AND求交集以及使用OR求并集的)
 </remarks>
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.DataStructures.Set._equals">
 <summary>
 如何判断两个元素是否相同？
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataStructures.Set.Item(System.Int32)">
 <summary>
 Public accessor for the members of the <see cref="T:Microsoft.VisualBasic.ComponentModel.DataStructures.Set">Set</see>.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataStructures.Set.Length">
 <summary>
 The number of members of the set.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataStructures.Set.IsEmpty">
 <summary>
 A method to determine whether the <see cref="T:Microsoft.VisualBasic.ComponentModel.DataStructures.Set">Set</see> has members.
 </summary>
 <returns>True is there are members, false if there are 0 members.</returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.Set.#ctor(System.Func{System.Object,System.Object,System.Boolean})">
 <summary>
 Default constructor.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.Set.#ctor(Microsoft.VisualBasic.ComponentModel.DataStructures.Set[],System.Func{System.Object,System.Object,System.Boolean})">
 <summary>
 Constructor called when the source data is an array of <see cref="T:Microsoft.VisualBasic.ComponentModel.DataStructures.Set">Sets</see>.  They will
 be unioned together, with addition exceptions quietly eaten.
 </summary>
 <param name="sources">The source array of <see cref="T:Microsoft.VisualBasic.ComponentModel.DataStructures.Set">Set</see> objects.</param>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.Set.Clear">
 <summary>
 Empty the set of all members.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.Set.Remove(System.Object)">
 <summary>
 Remove a member from the <see cref="T:Microsoft.VisualBasic.ComponentModel.DataStructures.Set">Set</see>.
 </summary>
 <param name="target">The member to remove.</param>
 <returns>True if a member was removed, false if nothing was found that 
 was removed.</returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.Set.Add(System.Object)">
 <summary>
 Method to add an <see cref="T:System.Object">Object</see> to the set.  The new member 
 must be unique.
 </summary>
 <param name="member"><see cref="T:System.Object">Object</see> to add.</param>
 <exception cref="T:System.InvalidOperationException">If the member being added is
 already a member of the set an InvalidOperationException is thrown.</exception>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.Set.Contains(System.Object)">
 <summary>
 Method to determine if a given object is a member of the set.
 </summary>
 <param name="target">The object to look for in the set.</param>
 <returns>True if it is a member of the <see cref="T:Microsoft.VisualBasic.ComponentModel.DataStructures.Set">Set</see>, false if not.</returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.Set.ToArray">
 <summary>
 Copies the members of the <see cref="T:Microsoft.VisualBasic.ComponentModel.DataStructures.Set">Set</see> to an array of 
 <see cref="T:System.Object">Objects</see>.
 </summary>
 <returns>An <see cref="T:System.Object">Object</see> array copies of the 
 elements of the <see cref="T:Microsoft.VisualBasic.ComponentModel.DataStructures.Set">Set</see></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.Set.op_Explicit(System.Array)~Microsoft.VisualBasic.ComponentModel.DataStructures.Set">
 <summary>
 If the Set is created by casting an array to it, add the members of
 the array through the Add method, so if the array has dupes an error
 will occur.
 </summary>
 <param name="array">The array with the objects to initialize the array.</param>
 <returns>A new Set object based on the members of the array.</returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.Set.op_BitwiseOr(Microsoft.VisualBasic.ComponentModel.DataStructures.Set,Microsoft.VisualBasic.ComponentModel.DataStructures.Set)">
 <summary>
 Performs a union of two sets. The elements can exists 
 in <paramref name="s1"/> or <paramref name="s2"/>.
 </summary>
 <param name="s1">Any set.</param>
 <param name="s2">Any set.</param>
 <returns>A new <see cref="T:Microsoft.VisualBasic.ComponentModel.DataStructures.Set">Set</see> object that contains all of the
 members of each of the input sets.</returns>
 <remarks>
 (求并集)
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.Set.op_BitwiseAnd(Microsoft.VisualBasic.ComponentModel.DataStructures.Set,Microsoft.VisualBasic.ComponentModel.DataStructures.Set)">
 <summary>
 Performs an intersection of two sets, the elements should exists 
 in <paramref name="s1"/> and <paramref name="s2"/>.
 (求交集)
 </summary>
 <param name="s1">Any set.</param>
 <param name="s2">Any set.</param>
 <returns>A new <see cref="T:Microsoft.VisualBasic.ComponentModel.DataStructures.Set">Set</see> object that contains the members
 that were common to both of the input sets.</returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.Set.op_Addition(Microsoft.VisualBasic.ComponentModel.DataStructures.Set,Microsoft.VisualBasic.ComponentModel.DataStructures.Set)">
 <summary>
 求两个集合的并集，将两个集合之中的所有元素都合并在一起，这个操作符会忽略掉重复出现的元素
 </summary>
 <param name="s1"></param>
 <param name="s2"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.Set.op_Subtraction(Microsoft.VisualBasic.ComponentModel.DataStructures.Set,Microsoft.VisualBasic.ComponentModel.DataStructures.Set)">
 <summary>
 except(差集)集合运算：先将其中完全重复的数据行删除，再返回只在第一个集合中出现，在第二个集合中不出现的所有行。
 </summary>
 <param name="s1"></param>
 <param name="s2"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.Set.op_Equality(Microsoft.VisualBasic.ComponentModel.DataStructures.Set,Microsoft.VisualBasic.ComponentModel.DataStructures.Set)">
 <summary>
 Overloaded == operator to determine if 2 sets are equal.
 </summary>
 <param name="s1">Any set.</param>
 <param name="s2">Any set.</param>
 <returns>True if the two comparison sets have the same number of elements, and
 all of the elements of set s1 are contained in s2.</returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.Set.op_Inequality(Microsoft.VisualBasic.ComponentModel.DataStructures.Set,Microsoft.VisualBasic.ComponentModel.DataStructures.Set)">
 <summary>
 Overloaded != operator to determine if 2 sets are unequal.
 </summary>
 <param name="s1">A benchmark set.</param>
 <param name="s2">The set to compare against the benchmark.</param>
 <returns>True if the two comparison sets fail the equality (==) test,
 false if the pass the equality test.</returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.Set.Equals(System.Object)">
 <summary>
 Determines whether two <see cref="T:Microsoft.VisualBasic.ComponentModel.DataStructures.Set">Set</see> instances are equal.
 </summary>
 <param name="obj">The <see cref="T:Microsoft.VisualBasic.ComponentModel.DataStructures.Set">Set</see> to compare to the current Set.</param>
 <returns>true if the specified <see cref="T:Microsoft.VisualBasic.ComponentModel.DataStructures.Set">Set</see> is equal to the current 
 Set; otherwise, false.</returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.Set.GetHashCode">
 <summary>
 Serves as a hash function for a particular type, suitable for use in hashing 
 algorithms and data structures like a hash table.
 </summary>
 <returns>A hash code for the current <see cref="T:Microsoft.VisualBasic.ComponentModel.DataStructures.Set">Set</see>.</returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.Set.ToString">
 <summary>
 Returns a <see cref="T:System.String">String</see> that represents the current
 <see cref="T:Microsoft.VisualBasic.ComponentModel.DataStructures.Set">Set</see>.
 </summary>
 <returns>A <see cref="T:System.String">String</see> that represents the current
 <see cref="T:Microsoft.VisualBasic.ComponentModel.DataStructures.Set">Set</see>.</returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.Set.Dispose">
 <summary>
 Performs cleanup tasks on the <see cref="T:Microsoft.VisualBasic.ComponentModel.DataStructures.Set">Set</see> object.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.Set.Integer(System.Int32[])">
 <summary>
 create an empty integer set
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.SetAPI.Intersection``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},Microsoft.VisualBasic.ComponentModel.DataStructures.GenericLambda{``0}.GetUid)">
<summary>
 Performs an intersection of two sets.(求交集，这个函数总是会挑选出<paramref name="s1"/>集合之中的元素的)
 </summary>
 <param name="s1">Any set.</param>
 <param name="s2">Any set.</param>
 <returns>A new <see cref="T:Microsoft.VisualBasic.ComponentModel.DataStructures.Set">Set</see> object that contains the members
 that were common to both of the input sets.</returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.SetAPI.Intersection``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},Microsoft.VisualBasic.ComponentModel.DataStructures.GenericLambda{``0}.IEquals)">
<summary>
 Performs an intersection of two sets.(求交集)
 </summary>
 <param name="s1">Any set.</param>
 <param name="s2">Any set.</param>
 <returns>A new <see cref="T:Microsoft.VisualBasic.ComponentModel.DataStructures.Set">Set</see> object that contains the members
 that were common to both of the input sets.</returns>
 
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.SetAPI.VennExclusiveSet(System.Collections.Generic.Dictionary{System.String,System.String[]},System.String[]@)">
 <summary>
 
 </summary>
 <param name="groups"></param>
 <param name="commonIds">
 common ids in all groups, if you do not need this parameter, you can set it to <c>Nothing</c>.
 </param>
 <returns>
 exclusive ids in each groups
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.SetsExtension.ToArray``1(Microsoft.VisualBasic.ComponentModel.DataStructures.Set)">
 <summary>
 DirectCast
 </summary>
 <typeparam name="T"></typeparam>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.SetsExtension.Except(Microsoft.VisualBasic.ComponentModel.DataStructures.Set,Microsoft.VisualBasic.ComponentModel.DataStructures.Set)">
 <summary>
 差集，函数会从<paramref name="s1"/>集合之中删除<paramref name="s2"/>中共同的元素
 </summary>
 <param name="s1"></param>
 <param name="s2"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.SetsExtension.Union(Microsoft.VisualBasic.ComponentModel.DataStructures.Set,Microsoft.VisualBasic.ComponentModel.DataStructures.Set)">
 <summary>
 Performs a union of two sets.
 (就并集)
 </summary>
 <param name="s1"></param>
 <param name="s2"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.SetsExtension.Intersection(Microsoft.VisualBasic.ComponentModel.DataStructures.Set,Microsoft.VisualBasic.ComponentModel.DataStructures.Set)">
 <summary>
 Performs an intersection of two sets.
 (求交集)
 </summary>
 <param name="s1"></param>
 <param name="s2"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.SetsExtension.AsSet(System.Collections.IEnumerable)">
 <summary>
 将任意序列转换为集合类型
 </summary>
 <param name="source"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.SetsExtension.AsSet(System.Collections.Generic.IEnumerable{System.String})">
 <summary>
 Create a string set
 </summary>
 <param name="strings"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.SetsExtension.PollLast``1(System.Collections.Generic.SortedSet{``0})">
 <summary>
 get the last element in the <paramref name="set"/>, and then removes the last element
 </summary>
 <typeparam name="T"></typeparam>
 <param name="[set]"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.SetsExtension.PollFirst``1(System.Collections.Generic.SortedSet{``0})">
 <summary>
 get the first element in the <paramref name="set"/>, and then removes the first element
 </summary>
 <typeparam name="T"></typeparam>
 <param name="[set]"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.DataStructures.StringSet">
 <summary>
 A string set collection object.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.StringSet.#ctor(System.Collections.Generic.IEnumerable{System.String},Microsoft.VisualBasic.CompareMethod)">
 <summary>
 
 </summary>
 <param name="strings"></param>
 <param name="caseSensitive">
 String comparision should be in case sensitive mode? By default is yes.
 </param>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.StringSet.op_Subtraction(Microsoft.VisualBasic.ComponentModel.DataStructures.StringSet,System.Collections.Generic.IEnumerable{System.String})">
 <summary>
 Removes all of the <paramref name="s2"/> from <see cref="T:Microsoft.VisualBasic.ComponentModel.DataStructures.StringSet"/> <paramref name="s1"/>
 </summary>
 <param name="s1"></param>
 <param name="s2"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.BinaryTree.Extensions.NameCompare(System.String,System.String)">
 <summary>
 字符串名字的比较规则：
 
 假若字符串是空值或者空字符串，则该变量小
 假若字符串相等（忽略大小写），则变量值一样
 最后逐个字符进行比较，按照字母的charcode大小来比较，第一个charcode大的变量大
 </summary>
 <param name="a$"></param>
 <param name="b$"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.BinaryTree.Extensions.NameFuzzyMatch(System.String,System.String)">
 <summary>
 The term index search engine.
 
 + If the string similarity less than threshold, then will returns negative value
 + If the string similarity greater than threshold, then will returns positive value
 + If the string text equals to other, then will reutrns ZERO
 </summary>
 <param name="a$"></param>
 <param name="b$"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.DataStructures.BinaryTree.TreeNode`1">
 <summary>
 Define tree nodes
 </summary>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataStructures.BinaryTree.TreeNode`1.Count">
 <summary>
 递归的得到子节点的数目
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.BinaryTree.TreeNode`1.#ctor(System.String,`0)">
 <summary>
 Constructor  to create a single node 
 </summary>
 <param name="name"></param>
 <param name="obj"></param>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.BinaryTree.TreeNode`1.GetEnumerator">
 <summary>
 最多只有两个元素
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataStructures.Tree.ITreeNodeData`1.ChildNodes">
 <summary>
 Children
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataStructures.Tree.ITreeNodeData`1.IsLeaf">
 <summary>
 Is this node have no childs
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataStructures.Tree.ITreeNodeData`1.IsRoot">
 <summary>
 I this node have no parents
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.DataStructures.Tree.TreeNodeBase`1">
 <summary>
 Generic Tree Node base class
 </summary>
 <typeparam name="T"></typeparam>
 <remarks>https://www.codeproject.com/Articles/345191/Simple-Generic-Tree</remarks>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataStructures.Tree.TreeNodeBase`1.Name">
 <summary>
 Name
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataStructures.Tree.TreeNodeBase`1.Parent">
 <summary>
 Parent
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataStructures.Tree.TreeNodeBase`1.ChildNodes">
 <summary>
 Children
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataStructures.Tree.TreeNodeBase`1.MySelf">
 <summary>
 Me/this
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.Tree.TreeNodeBase`1.#ctor(System.String)">
 <summary>
 
 </summary>
 <param name="name"></param>
 
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataStructures.Tree.TreeNodeBase`1.IsLeaf">
 <summary>
 True if a Leaf Node
 </summary>
 <value>
 True for <see cref="P:Microsoft.VisualBasic.ComponentModel.DataStructures.Tree.TreeNodeBase`1.ChildNodes"/> contains no data.
 </value>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataStructures.Tree.TreeNodeBase`1.IsRoot">
 <summary>
 True if the Root of the Tree
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.Tree.TreeNodeBase`1.GetLeafNodes">
 <summary>
 List of Leaf Nodes
 </summary>
 
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.Tree.TreeNodeBase`1.GetNonLeafNodes">
 <summary>
 List of Non Leaf Nodes
 </summary>
 
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.Tree.TreeNodeBase`1.GetRootNode">
 <summary>
 Get the Root Node of the Tree
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.DataStructures.Tree.TreeNodeBase`1.FullyQualifiedName">
 <summary>
 Dot separated name from the Root to this Tree Node
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.Tree.TreeNodeBase`1.AddChild(`0)">
 <summary>
 Add a Child Tree Node
 </summary>
 <param name="child"></param>
 <remarks>
 1. hook <see cref="P:Microsoft.VisualBasic.ComponentModel.DataStructures.Tree.TreeNodeBase`1.MySelf"/> to <see cref="P:Microsoft.VisualBasic.ComponentModel.DataStructures.Tree.TreeNodeBase`1.Parent"/>
 2. add <paramref name="child"/> to <see cref="P:Microsoft.VisualBasic.ComponentModel.DataStructures.Tree.TreeNodeBase`1.ChildNodes"/>
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.Tree.TreeNodeBase`1.AddChildren(System.Collections.Generic.IEnumerable{`0})">
 <summary>
 Add a collection of child Tree Nodes
 </summary>
 <param name="children"></param>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.Tree.TreeNodeBase`1.GenericEnumerator">
 <summary>
 enumerates all childs in current tree node
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.DataStructures.Tree.TreeTools">
 <summary>
 extension method tools for abstract tree model
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DataStructures.Tree.TreeTools.EnumerateAllChilds``1(Microsoft.VisualBasic.ComponentModel.DataStructures.Tree.ITreeNodeData{``0})">
 <summary>
 enumerates all childs in current tree node
 </summary>
 <typeparam name="T"></typeparam>
 <param name="tree"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Triggers.ITrigger.TestRun">
 <summary>
 Test if success then run callback
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Triggers.DailyTimerTrigger">
 <summary>
 这个只会比较时和分，每天都会触发
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Triggers.DailyTimerTrigger.#ctor(System.DateTime,System.Action,System.Int32)">
 <summary>
 
 </summary>
 <param name="time">只需要赋值小时和分钟即可</param>
 <param name="task"></param>
 <param name="interval"></param>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Triggers.TimerTrigger">
 <summary>
 在指定的日期和时间呗触发，因此这个触发器只会运行一次
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Triggers.TimerTrigger.Time">
 <summary>
 当判定到达这个指定的时间之后就会触发动作
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Triggers.TimerTrigger.Interval">
 <summary>
 ms
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Triggers.TimerTrigger.#ctor(System.DateTime,System.Action,System.Int32)">
 <summary>
 
 </summary>
 <param name="time">只精确到分，不会比较秒数</param>
 <param name="task"></param>
 <param name="interval">ms</param>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Triggers.TimerTrigger.__test">
 <summary>
 不计算毫秒
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Triggers.TimerTrigger.Start">
 <summary>
 启动计时器线程，这个方法不会阻塞当前的线程
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.ITaskDriver">
 <summary>
 Driver abstract model
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.ITaskDriver.Run">
 <summary>
 Start run this driver object.
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.ISaveHandle">
 <summary>
 This is a file object which have a handle to save its data to the filesystem.
 </summary>
 <remarks>(这是一个带有文件数据保存方法的文件模型)</remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.ISaveHandle.Save(System.String,System.Text.Encoding)">
 <summary>
 Handle for saving the file data.
 </summary>
 <param name="path">The file path that will save data to.(进行文件数据保存的文件路径)</param>
 <param name="encoding">The text encoding value for the text document.(文本文档的编码格式)</param>
 <returns></returns>
 <remarks>(保存文件的方法)</remarks>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.IFileReference">
 <summary>
 表示一个对文件的引用接口
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.IFileReference.FilePath">
 <summary>
 进行文件引用的路径
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.IFileReference.MimeType">
 <summary>
 一个可选的只读属性用来标记文件所符合的类型
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.IOWorkModes">
 <summary>
 '<see cref="T:Microsoft.VisualBasic.ComponentModel.IOWorkModes"/>' is only used to determine whether to return data length or capacity from the 'limit' method:
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.ITextWriter">
 <summary>
 <see cref="T:System.IO.TextWriter"/>
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.DigitalSignature">
 <summary>
 helper for parse the .NET CLR type metadata 
 inside a xml file content which is generated 
 by <see cref="T:Microsoft.VisualBasic.ComponentModel.XmlDataModel"/>
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DigitalSignature.#ctor(System.String)">
 <summary>
 the file path or the xml file content text
 </summary>
 <param name="file"></param>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DigitalSignature.GetModelInfo">
 <summary>
 parse xml assembly type reference which is generated 
 by <see cref="T:Microsoft.VisualBasic.ComponentModel.XmlDataModel"/>
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.DigitalSignature.GetModelInfo(System.String)">
 <summary>
 parse xml assembly type reference which is generated by <see cref="T:Microsoft.VisualBasic.ComponentModel.XmlDataModel"/>
 </summary>
 <param name="file"></param>
 <returns></returns>
 
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.XmlDataModel">
 <summary>
 这个基类型对象主要是用来生成类型全称注释方便编写XML文件加载代码功能的
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.XmlDataModel.IXmlType">
 <summary>
 只适合最外层面的容器类型的对象来实现
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.XmlDataModel.Stylesheet">
 <summary>
 The external css/xsl file name for styling current xml file
 </summary>
 <returns></returns>
 <remarks>
 This property is only works for the root element type
 </remarks>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.XmlDataModel.TypeComment">
 <summary>
 ReadOnly, Data model type tracking use Xml Comment.
 </summary>
 <returns></returns>
 <remarks>
 JSON存储的时候,这个属性会被自动忽略掉
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.XmlDataModel.GetTypeReferenceComment(System.Type,System.Int32)">
 <summary>
 生成的注释信息是默认空了四个空格的
 </summary>
 <param name="modelType"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.LazyLoader`2">
 <summary>
 当所需要进行加载的数据的量非常大的时候，则可以使用本方法进行延时按需加载
 </summary>
 <typeparam name="TOutput"></typeparam>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.LazyLoader`2.Value">
 <summary>
 Gets the value from the data source <see cref="P:Microsoft.VisualBasic.ComponentModel.LazyLoader`2.URL"></see>
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.LazyLoader`2.URL">
 <summary>
 The data source.(数据源)
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.LazyLoader`2.WriteData(Microsoft.VisualBasic.ComponentModel.LazyLoader{`0,`1}.DataWriteMethod)">
 <summary>
 Write the data back onto the filesystem.(将数据回写进入文件系统之中)
 </summary>
 <param name="WriteMethod"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Lazy`1">
 <summary>
 The layze loader.
 </summary>
 <typeparam name="TOut"></typeparam>
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.Lazy`1.__factory">
 <summary>
 the data source handler.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.Lazy`1._cache">
 <summary>
 The output result cache data.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Lazy`1.Value">
 <summary>
 Get cache data if it exists, or the data will be loaded first.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Lazy`1.#ctor(System.Func{`0})">
 <summary>
 Init this lazy loader with the data source handler.
 </summary>
 <param name="valueFactory">
 The data source provider handler.
 </param>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Ranges.Extensions.MinMax(System.Collections.Generic.IEnumerable{System.Double})">
 <summary>
 get min and max element value from the given numeric vector
 </summary>
 <param name="v"></param>
 <returns>[min,max]</returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Ranges.Extensions.SymmetricalRange(System.Double)">
 <summary>
 对称的的范围，假若X为正数，那么其为max，而-x为min。假若x为负数，那么-x为max
 </summary>
 <param name="x#"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Ranges.Extensions.Parser(System.String,System.Double@,System.Double@)">
 <summary>
 + ``min -> max``
 + ``min—max``
 + ``min~max``
 + ``[min,max]``
 + ``{min,max}``
 + ``(min,max)``
 + ``min,max``
 </summary>
 <param name="exp$"></param>
 <param name="min#"></param>
 <param name="max#"></param>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Ranges.Extensions.GetScaler(Microsoft.VisualBasic.ComponentModel.Ranges.Model.DoubleRange)">
 <summary>
 返回一个实数区间的范围百分比的生成函数：``[0-1]``之间
 </summary>
 <param name="range"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Ranges.Extensions.RangeTransform(System.Collections.Generic.IEnumerable{System.Double},Microsoft.VisualBasic.ComponentModel.Ranges.Model.DoubleRange)">
 <summary>
 将目标区间内的任意实数全部转换为<paramref name="to"/>区间内的实数
 </summary>
 <param name="from"></param>
 <param name="[to]"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Ranges.Extensions.RangeTransform(System.Collections.Generic.IEnumerable{System.Int32},Microsoft.VisualBasic.ComponentModel.Ranges.Model.IntRange)">
 <summary>
 将目标区间内的任意实数全部转换为<paramref name="to"/>区间内的实数
 </summary>
 <param name="from"></param>
 <param name="[to]"></param>
 <returns></returns>
 
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Ranges.Model.DoubleRange">
 <summary>
 Represents a double range with minimum and maximum values
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Ranges.Model.DoubleRange.Min">
 <summary>
 Minimum value
 </summary>
 
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Ranges.Model.DoubleRange.Max">
 <summary>
 Maximum value
 </summary>
   
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Ranges.Model.DoubleRange.Length">
 <summary>
 Length of the range (deffirence between maximum and minimum values)
 </summary>
 
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Ranges.Model.DoubleRange.MinMax">
 <summary>
 A vector with 2 elements: [min, max]
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Ranges.Model.DoubleRange.#ctor(System.Double,System.Double)">
 <summary>
 Initializes a new instance of the <see cref="T:Microsoft.VisualBasic.ComponentModel.Ranges.Model.DoubleRange"/> class
 </summary>
 
 <param name="min">Minimum value of the range</param>
 <param name="max">Maximum value of the range</param>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Ranges.Model.DoubleRange.#ctor(System.Double[])">
 <summary>
 从一个任意的实数数组之中构建出一个实数区间范围
 </summary>
 <param name="data"></param>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Ranges.Model.DoubleRange.#ctor(System.Collections.Generic.IEnumerable{System.Double})">
 <summary>
 从一个任意的实数向量之中构建出一个实数区间范围
 </summary>
 <param name="vector"></param>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Ranges.Model.DoubleRange.#ctor(Microsoft.VisualBasic.ComponentModel.Ranges.Model.DoubleRange)">
 <summary>
 Value copy
 </summary>
 <param name="range"></param>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Ranges.Model.DoubleRange.#ctor">
 <summary>
 For xml serialization.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Ranges.Model.DoubleRange.ToString">
 <summary>
 [min=xxx, max=xxx]
 </summary>
 <returns></returns>
 <remarks>
 因为进行json序列化的话，因为这个实现了<see cref="T:System.Collections.Generic.IEnumerable`1"/>接口，但是并没有实现Add方法，
 所以会出错，这里取消使用json来生成<see cref="M:Microsoft.VisualBasic.ComponentModel.Ranges.Model.DoubleRange.ToString"/>函数的结果
 </remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Ranges.Model.DoubleRange.IsInside(System.Double)">
 <summary>
 Check if the specified value is inside this range
 </summary>
 
 <param name="x">Value to check</param>
 
 <returns><b>True</b> if the specified value is inside this range or
 <b>false</b> otherwise.</returns>
 
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Ranges.Model.DoubleRange.IsInside(Microsoft.VisualBasic.ComponentModel.Ranges.Model.DoubleRange)">
 <summary>
 Check if the specified <paramref name="range"/> is inside this range.
 (如果函数参数<paramref name="range"/>在当前的这个range之中，则返回真)
 </summary>
 <param name="range">Range to check</param>
 <returns>
 + <b>True</b> if the specified input <paramref name="range"/> parameter is inside this range or
 + <b>false</b> otherwise.</returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Ranges.Model.DoubleRange.IsOverlapping(Microsoft.VisualBasic.ComponentModel.Ranges.Model.DoubleRange)">
 <summary>
 Check if the specified range overlaps with this range
 </summary>
 
 <param name="range">Range to check for overlapping</param>
 
 <returns><b>True</b> if the specified range overlaps with this range or
 <b>false</b> otherwise.</returns>
 
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Ranges.Model.DoubleRange.op_Implicit(System.Double[])~Microsoft.VisualBasic.ComponentModel.Ranges.Model.DoubleRange">
 <summary>
 get [min,max] value range from a given vector of the input data
 </summary>
 <param name="data"></param>
 <returns></returns>
 <remarks>
 this type cast operator is a kind of the safe function, for null input or
 empty vector input, this operator will returns nothing.
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Ranges.Model.DoubleRange.op_Like(System.Double,Microsoft.VisualBasic.ComponentModel.Ranges.Model.DoubleRange)">
 <summary>
 Value in this range or not?
 </summary>
 <param name="x"></param>
 <param name="range"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Ranges.Model.DoubleRange.op_Multiply(Microsoft.VisualBasic.ComponentModel.Ranges.Model.DoubleRange,System.Double)">
 <summary>
 Scale numeric range
 </summary>
 <param name="range"></param>
 <param name="factor#"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Ranges.Model.DoubleRange.Enumerate(System.Int32)">
 <summary>
 这个函数需要通过一个返回结果的元素个数参数来计算出step步长
 </summary>
 <param name="n%">所返回来的数组的元素的个数</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Ranges.Model.DoubleRange.ScaleMapping(System.Double,Microsoft.VisualBasic.ComponentModel.Ranges.Model.DoubleRange)">
 <summary>
 Transform a numeric value in this <see cref="T:Microsoft.VisualBasic.ComponentModel.Ranges.Model.DoubleRange"/> into 
 target numeric range: ``<paramref name="valueRange"/>``.
 </summary>
 <param name="x">A numeric value in this <see cref="T:Microsoft.VisualBasic.ComponentModel.Ranges.Model.DoubleRange"/></param>
 <param name="valueRange"></param>
 <returns></returns>
 <remarks>
 (将当前的范围内的一个实数映射到另外的一个范围内的实数区间之中)
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Ranges.Model.DoubleRange.ScaleMapping(System.Double,Microsoft.VisualBasic.ComponentModel.Ranges.Model.IntRange)">
 <summary>
 Transform a numeric value in this <see cref="T:Microsoft.VisualBasic.ComponentModel.Ranges.Model.DoubleRange"/> into 
 target numeric range: ``<paramref name="valueRange"/>``.
 </summary>
 <param name="x"></param>
 <param name="valueRange">levels in integer values.</param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Ranges.Model.IntRange">
 <summary>
 Represents an <see cref="T:System.Int32"/> range with minimum and maximum values
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Ranges.Model.IntRange.Min">
 <summary>
 Minimum value
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Ranges.Model.IntRange.Max">
 <summary>
 Maximum value
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Ranges.Model.IntRange.Interval">
 <summary>
 Length of the range (deffirence between maximum and minimum values)
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Ranges.Model.IntRange.#ctor(System.Int32,System.Int32)">
 <summary>
 Initializes a new instance of the <see cref="T:Microsoft.VisualBasic.ComponentModel.Ranges.Model.IntRange"/> class
 </summary>

 <param name="min">Minimum value of the range</param>
 <param name="max">Maximum value of the range</param>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Ranges.Model.IntRange.#ctor(System.Collections.Generic.IEnumerable{System.Int32})">
 <summary>
 这个构造函数之中会自动求出最大值和最小值
 </summary>
 <param name="source"></param>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Ranges.Model.IntRange.ToString">
 <summary>
 
 </summary>
 <returns></returns>
 <remarks>
 <see cref="M:Microsoft.VisualBasic.ComponentModel.Ranges.Model.DoubleRange.ToString"/>
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Ranges.Model.IntRange.IsInside(System.Int32)">
 <summary>
 Check if the specified value ``<paramref name="x"/>`` is inside this range
 </summary>
 <param name="x">Value to check</param>
 <returns><b>True</b> if the specified value is inside this range or
 <b>false</b> otherwise.</returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Ranges.Model.IntRange.IsInside(Microsoft.VisualBasic.ComponentModel.Ranges.Model.IntRange)">
 <summary>
 Check if the specified range is inside this range
 </summary>

 <param name="range">Range to check</param>

 <returns><b>True</b> if the specified range is inside this range or
 <b>false</b> otherwise.</returns>

</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Ranges.Model.IntRange.IsOverlapping(Microsoft.VisualBasic.ComponentModel.Ranges.Model.IntRange)">
 <summary>
 Check if the specified range overlaps with this range
 </summary>

 <param name="range">Range to check for overlapping</param>

 <returns><b>True</b> if the specified range overlaps with this range or
 <b>false</b> otherwise.</returns>

</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Ranges.Model.IntRange.ScaleMapping(System.Int32,Microsoft.VisualBasic.ComponentModel.Ranges.Model.IntRange)">
 <summary>
 Transform a numeric value in this <see cref="T:Microsoft.VisualBasic.ComponentModel.Ranges.Model.IntRange"/> into 
 target numeric range: ``<paramref name="valueRange"/>``.
 (将当前的范围内的一个实数映射到另外的一个范围内的实数区间之中)
 </summary>
 <param name="x#"></param>
 <param name="valueRange"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Ranges.Model.IntRange.GetEnumerator">
 <summary>
 枚举出这个数值范围内的所有整数值，步长为1
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Ranges.Model.IRange`1.Min">
 <summary>
 Minimum value
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Ranges.Model.IRange`1.Max">
 <summary>
 Maximum value
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Ranges.Model.IRangeModel`1">
 <summary>
 Represents a generic range with minimum and maximum values
 </summary>
 <typeparam name="T"></typeparam>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Ranges.Model.IRangeModel`1.IsInside(`0)">
 <summary>
 Check if the specified value is inside this range
 </summary>
 <param name="x">Value to check</param>
 <returns><b>True</b> if the specified value is inside this range or
 <b>false</b> otherwise.</returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Ranges.Model.IRangeModel`1.IsInside(Microsoft.VisualBasic.ComponentModel.Ranges.Model.IRangeModel{`0})">
 <summary>
 Check if the specified range is inside this range
 </summary>
 <param name="range">Range to check</param>
 <returns><b>True</b> if the specified range is inside this range or
 <b>false</b> otherwise.</returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Ranges.Model.IRangeModel`1.IsOverlapping(Microsoft.VisualBasic.ComponentModel.Ranges.Model.IRangeModel{`0})">
 <summary>
 Check if the specified range overlaps with this range
 </summary>
 <param name="range">Range to check for overlapping</param>
 <returns><b>True</b> if the specified range overlaps with this range or
 <b>false</b> otherwise.</returns>
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.Ranges.Relations.Irrelevant">
 <summary>
 a &lt;> b
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.Ranges.Relations.Equals">
 <summary>
 a = b
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.Ranges.Relations.Include">
 <summary>
 a = {b} (a including b, b is one of the element in range a)
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.Ranges.Relations.IncludeBy">
 <summary>
 b = {a} (a is included by b, a is one of the element in range b)
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Ranges.IndexSelector">
 <summary>
 A numeric index helper
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Ranges.IndexSelector.SelectByRange(System.Double,System.Double)">
 <summary>
 Get index by a given numeric range
 </summary>
 <param name="min"></param>
 <param name="max"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Ranges.IndexSelector.FromSortSequence(System.Double[])">
 <summary>
 所使用的序列参数必须是经过了排序操作的
 </summary>
 <param name="seq"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Ranges.NumericTagged`1">
 <summary>
 Almost equals to <see cref="T:Microsoft.VisualBasic.ComponentModel.TagData.DoubleTagged`1"/>, but this object is a structure type. 
 (作用几乎等同于<see cref="T:Microsoft.VisualBasic.ComponentModel.TagData.DoubleTagged`1"/>，只不过这个是Structure类型，开销会小一些)
 </summary>
 <typeparam name="T"></typeparam>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Ranges.NumericTagged`1.CompareTo(System.Double)">
 <summary>
 比较的是<see cref="F:Microsoft.VisualBasic.ComponentModel.Ranges.NumericTagged`1.tag"/>属性
 </summary>
 <param name="other"></param>
 <returns></returns>
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.Ranges.OrderSelector`1.direct">
 <summary>
 <see cref="F:Microsoft.VisualBasic.ComponentModel.Ranges.OrderSelector`1.source"/>序列的排序的方向字符串显示
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.Ranges.OrderSelector`1.source">
 <summary>
 目标序列
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Ranges.OrderSelector`1.Desc">
 <summary>
 是否为降序排序?
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Ranges.OrderSelector`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Boolean)">
 <summary>
 
 </summary>
 <param name="source"></param>
 <param name="asc">
 当这个参数为真的时候为升序排序
 </param>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Ranges.OrderSelector`1.Find``1(``0,System.Func{`0,``0},`0)">
 <summary>
 Find value by key via binary search
 </summary>
 <typeparam name="K"></typeparam>
 <param name="key"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Ranges.OrderSelector`1.SelectUntilGreaterThan(`0)">
 <summary>
 直到当前元素大于指定值
 </summary>
 <param name="n"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Ranges.OrderSelector`1.SelectUntilLessThan(`0)">
 <summary>
 直到当前元素小于指定值
 </summary>
 <param name="n"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Ranges.OrderSelector`1.FirstGreaterThan(`0)">
 <summary>
 遍历整个列表直到找到第一个大于<paramref name="o"/>的元素，然后函数会返回这第一个元素的index
 </summary>
 <param name="o"></param>
 <returns>
 返回-1表示这个列表之中没有任何元素是大于输入的参数<paramref name="o"/>的
 </returns>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Ranges.Unit.ByteSize">
 <summary>
 the unit for binary data file size
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Ranges.Unit.ParserExtensions.ParseByteSize(System.String)">
 <summary>
 Parse the byte size in bytes
 </summary>
 <param name="desc">
 1111B means 1111 byte
 1KB means 1024 byte
 1MB means 1024*1024 byte
 etc
 </param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Ranges.Unit.Convertor.Convertor`1">
 <summary>
 
 </summary>
 <typeparam name="TUnit">枚举类型？</typeparam>
 <param name="value"></param>
 <param name="toUnit"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Ranges.Unit.UnitValue`1">
 <summary>
 
 </summary>
 <typeparam name="TUnit">枚举类型，基础类型必须是值等于1</typeparam>
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.Ranges.Unit.UnitValue`1.d">
 <summary>
 分（d） ``10^-1``
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.Ranges.Unit.UnitValue`1.c">
 <summary>
 厘（c） ``10^-2``
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.Ranges.Unit.UnitValue`1.m">
 <summary>
 毫（m） ``10^-3``
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.Ranges.Unit.UnitValue`1.u">
 <summary>
 微（μ） ``10^-6``
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.Ranges.Unit.UnitValue`1.n">
 <summary>
 纳（n） ``10^-9``
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.Ranges.Unit.UnitValue`1.p">
 <summary>
 皮（p） ``10^-12``
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.Ranges.Unit.UnitValue`1.f">
 <summary>
 飞（f） ``10^-15``
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.Ranges.Unit.UnitValue`1.a">
 <summary>
 阿（a） ``10^-18``
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Ranges.Unit.UnitValue`1.ScaleTo(`0)">
 <summary>
 Unit convert
 </summary>
 <param name="convert"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Ranges.Unit.UnitValue`1.op_Equality(Microsoft.VisualBasic.ComponentModel.Ranges.Unit.UnitValue{`0},`0)">
 <summary>
 将当前的单位值转换为目标<paramref name="unit"/>单位制
 </summary>
 <param name="value"></param>
 <param name="unit"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.RelayCommand">
 <summary>
 Taken from http://msdn.microsoft.com/en-us/magazine/dd419663.aspx
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Settings.ConfigEngine">
 <summary>
 只包含有对数据映射目标对象的属性读写，并不包含有文件数据的读写操作
 </summary>
 
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.Settings.ConfigEngine.profilesData">
 <summary>
 所映射的数据源
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.Settings.ConfigEngine.profileItemCollection">
 <summary>
 键名都是小写的
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Settings.ConfigEngine.AllItems">
 <summary>
 List all of the available settings nodes in this profile data session.
 (枚举出当前配置会话之中的所有可用的配置节点)
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Settings.ConfigEngine.ExistsNode(System.String)">
 <summary>
 大小写不敏感
 </summary>
 <param name="Name"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Settings.ConfigEngine.Set(System.String,System.String)">
 <summary>
 请注意，<paramref name="name"/>必须是小写的
 </summary>
 <param name="Name">The name of the configuration entry should be in lower case.</param>
 <param name="Value"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Settings.ConfigEngine.View(System.String)">
 <summary>
假若函数参数<paramref name="name"/>为空，则函数输出所有的变量的值，请注意，这个函数并不在终端上面显示任何消息
 </summary>
 <param name="name">假若本参数为空，则函数输出所有的变量的值，大小写不敏感的</param>
 <returns></returns>
 <remarks></remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Settings.ConfigEngine.GetSettingsNode(System.String)">
 <summary>
 大小写不敏感的
 </summary>
 <param name="Name"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Settings.ConfigEngine.Save(System.String,System.Text.Encoding)">
 <summary>
 save the settings data in xml file format
 </summary>
 <param name="FilePath"></param>
 <param name="Encoding"></param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Settings.BindMapping.AsOutString">
 <summary>
 打印在终端窗口上面的字符串
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Settings.BindMapping.IsFsysValid">
 <summary>
 这个方法只是针对<see cref="F:Microsoft.VisualBasic.ComponentModel.Settings.ValueTypes.File"/>和<see cref="F:Microsoft.VisualBasic.ComponentModel.Settings.ValueTypes.Directory"/>这两种类型而言才有效的
 对于其他的类型数据，都是返回False
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Settings.IProfile">
 <summary>
 具备有保存数据功能的可配置数据文件的基本定义
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Settings.ValueTypes">
 <summary>
 这个并不是指宿主属性的数据类型，而是指代这一数据类型所代表的具体的实际对象
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.Settings.ValueTypes.Directory">
 <summary>
 这个字符串的值是一个文件夹
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.Settings.ValueTypes.File">
 <summary>
 这个字符串的值是一个文件的路径
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.Settings.ValueTypes.Text">
 <summary>
 普通的文本字符串
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.Settings.ValueTypes.Double">
 <summary>
 带有小数的数值
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.Settings.ValueTypes.Integer">
 <summary>
 整数
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Settings.ProfileItem">
 <summary>
 The simple configuration mapping node in the current profile data, the data type of this node 
 object should be just the simplest data type such as String, Integer, Long, Double, Boolean.
 (当前的配置节点为一个简单节点，即目标属性的属性值类型的字符串，数字或者逻辑值等最基本的数据类型)
 </summary>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Settings.ProfileItem.Type">
 <summary>
 默认的数据类型是字符串类型
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Settings.ProfileItem.#ctor(System.String,System.String)">
 <summary>
 Initialize a node in the settings xml document.
 </summary>
 <param name="NodeName">The name of the node in the document xml file</param>
 <param name="NodeDescription">The brief introduction information about this profile node.</param>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Settings.ProfileNodeItem">
 <summary>
 当前的配置节点为一个复杂数据类型的配置节点，即目标属性的属性类型为一个Class对象
 </summary>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Settings.IniExtensions">
 <summary>
 读写Ini文件的拓展
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Settings.IniExtensions.WriteIni``1(Microsoft.VisualBasic.ComponentModel.Settings.IProfile,System.String)">
 <summary>
 The section name of the profile data is the type name
 </summary>
 <typeparam name="T"></typeparam>
 <param name="x"></param>
 <param name="path"></param>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Settings.IniExtensions.LoadIni``1(System.String)">
 <summary>
 The section name of the profile data is the type name
 </summary>
 <typeparam name="T"></typeparam>
 <param name="path"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Settings.Inf.ClassMapper">
 <summary>
 使用这个属性来标记需要进行序列化的对象属性: <see cref="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.DataFrameColumnAttribute"/>
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Settings.Inf.ClassMapper.MapParser(System.Type)">
 <summary>
 Get mapping data, includes section name and keys
 </summary>
 <param name="type"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Settings.Inf.ClassMapper.ClassWriter``1(Microsoft.VisualBasic.ComponentModel.Settings.Inf.IniFile)">
 <summary>
 Read data from ini file.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="ini"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Settings.Inf.ClassMapper.LoadIni``1(System.String)">
 <summary>
 Load a ini section profile data from a ini file.
 </summary>
 <typeparam name="T">The section mapper</typeparam>
 <param name="path">*.ini file</param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Settings.Inf.ClassMapper.WriteClass``1(``0,System.String,System.Boolean)">
 <summary>
 Write ini section into data file.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="x">A section class in the ini profile file.</param>
 <param name="ini"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Settings.Inf.IniFile">
 <summary>
 Ini file I/O handler
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.Settings.Inf.IniFile.data">
 <summary>
 为了避免频繁的读写文件，会使用这个数组来做缓存
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Settings.Inf.IniFile.#ctor(System.String)">
 <summary>
 Open a ini file handle.
 </summary>
 <param name="INIPath"></param>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Settings.Inf.IniFile.Flush">
 <summary>
 将缓存数据写入文件之中
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Settings.Inf.IniFile.WriteComment(System.String,System.String,System.String)">
 <summary>
 在给定的section,key上面写入注释
 </summary>
 <param name="section"></param>
 <param name="key">如果这个键名称不存在的话，则是将注释写入到目标<paramref name="section"/>之中的</param>
 <param name="comment">不需要添加注释符号,函数会自动添加</param>
 
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Settings.Inf.INIProfile">
 <summary>
 Wrapper class for *.ini and *.inf configure file.
 (可能文件中的注释行会受到影响，所以请尽量使用本类型中的两个静态函数来操作INI文件)
 </summary>
 <remarks></remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Settings.Inf.INIProfile.readDataLines(System.String,System.Boolean)">
 <summary>
 在读取的时候会将空白行给删除掉
 </summary>
 <param name="path"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Settings.Inf.INIProfile.GetPrivateProfileString(System.String,System.String,System.String)">
 <summary>
 Get profile data from the ini file which the data is stores in a specific path like: ``section/key``
 </summary>
 <param name="path"></param>
 <param name="key"></param>
 <param name="section">
 因为这个函数是使用正则表达式进行匹配的，所以section名称不可以有正则表达式之中的特殊符号
 </param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Settings.Inf.INIProfile.PopulateSections(System.String)">
 <summary>
 解析ini配置文件数据为通用数据模型
 </summary>
 <param name="path"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Settings.Inf.INIProfile.GetPrivateProfileString(System.String[],System.String,System.String)">
 <summary>
 Get profile data from the ini file data lines which stores in a specific path like: ``section/key``
 </summary>
 <param name="lines$"></param>
 <param name="section$"></param>
 <param name="key$"></param>
 <returns></returns>
 <remarks>
 比较轻量化的文件解析
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Settings.Inf.INIProfile.isCommentsOrBlank(System.String)">
 <summary>
 判断当前的行是否是空白或者注释行
 </summary>
 <param name="str"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Settings.Inf.INIProfile.WritePrivateProfileString(System.String,System.String,System.String,System.String)">
 <summary>
 Setting profile data from the ini file which the data is stores in a specific path like: ``section/key``. 
 If the path is not exists, the function will create new.
 </summary>
 <param name="path"></param>
 <param name="Section"></param>
 <param name="key"></param>
 <param name="value"></param>
 <remarks>
 这个函数会保留下在配置文件之中原来的注释信息
 </remarks>
 
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Settings.Inf.IOProvider">
 <summary>
 在这个模块之中提供了.NET对象与``*.ini``配置文件之间的相互映射的序列化操作
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Settings.Inf.IOProvider.WriteProfile``1(``0,System.String)">
 <summary>
 将目标对象写为``*.ini``文件
 (目标对象之中的所有的简单属性都会被保存在一个对象名称的section中，)
 </summary>
 <typeparam name="T"></typeparam>
 <param name="x"></param>
 <param name="path"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Settings.Inf.IOProvider.WriteProfile``1(``0,Microsoft.VisualBasic.ComponentModel.Settings.Inf.IniFile)">
 <summary>
 将目标对象写为``*.ini``文件
 (目标对象之中的所有的简单属性都会被保存在一个对象名称的section中，)
 </summary>
 <typeparam name="T"></typeparam>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Settings.Inf.IOProvider.WriteProfile``1(``0)">
 <summary>
 属性的类型需要定义<see cref="T:Microsoft.VisualBasic.ComponentModel.Settings.Inf.ClassName"/>，Section类型里面的属性还需要
 定义<see cref="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.DataFrameColumnAttribute"/>，否则将不会将对应的属性的值
 写入到ini文件之中。
 </summary>
 <typeparam name="T"></typeparam>
 <param name="x"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Settings.Inf.IOProvider.__getSections``1">
 <summary>
 查找出所有<see cref="T:Microsoft.VisualBasic.ComponentModel.Settings.Inf.ClassName"/>标记的属性
 </summary>
 <typeparam name="T"></typeparam>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Settings.Inf.IOProvider.LoadProfile``1(System.String)">
 <summary>
 从指定的``*.ini``文件之中加载配置数据，如果配置文件不存在，则这个函数会返回空值
 </summary>
 <typeparam name="T"></typeparam>
 <param name="path"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Settings.Inf.IOProvider.LoadProfile``1(System.Boolean@,System.String@)">
 <summary>
 加载配置文件然后反序列化为一个指定类型的.NET对象
 </summary>
 <typeparam name="T"></typeparam>
 <param name="fileExists"></param>
 <param name="path">
 如果这个参数是空值，则会需要在<typeparamref name="T"/>类型定义之中定义有一个<see cref="T:Microsoft.VisualBasic.ComponentModel.Settings.Inf.IniMapIO"/>属性来存储文件路径
 </param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Settings.Inf.Section">
 <summary>
 一个配置数据区域的抽象模型
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Settings.Inf.Section.Name">
 <summary>
 区域的名称
 </summary>
 <returns></returns>
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.Settings.Inf.Section.configTable">
 <summary>
 这个字典之中的所有键名称都是小写形式的
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Settings.Inf.Section.SetValue(System.String,System.String,System.String)">
 <summary>
 不存在则自动添加
 </summary>
 <param name="Name"></param>
 <param name="value"></param>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Settings.Inf.Section.CreateDocFragment">
 <summary>
 利用这个函数所生成的文档片段的格式如下所示
 
 ```
 [name]
 # comment region of 
 # this section

 ; comment of this key
 key=value
 ; comment of this key
 key=value
 ```
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Settings.Inf.ClassName">
 <summary>
 define a single section inside a ini configuration file
 </summary>
 <remarks>
 you may needs defined a class array for mapping multiple sections inside a ini file.
 (定义在Ini配置文件之中的Section的名称)
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Settings.Inf.ClassName.#ctor(System.String)">
 <summary>
 Defines the section name in the ini profile data.(定义在Ini配置文件之中的Section的名称)
 </summary>
 <param name="name"></param>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Settings.Inf.IniMapIO">
 <summary>
 The path parameter can be shortcut by method <see cref="M:Microsoft.VisualBasic.My.UNIX.PathMapper.GetMapPath(System.String)"/>.
 additional, using ``@fileName`` for using <see cref="M:Microsoft.VisualBasic.App.GetFile(System.String)"/> API.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Settings.Inf.IniMapIO.#ctor(System.String)">
 <summary>
 The path parameter can be shortcut by method <see cref="M:Microsoft.VisualBasic.My.UNIX.PathMapper.GetMapPath(System.String)"/>
 </summary>
 <param name="path"></param>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Settings.Settings`1.SettingsData">
 <summary>
 The target object instance that provides the data source for this config engine.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Settings.Settings`1.#ctor(`0)">
 <summary>
 从配置数据的实例对象创建配置映射
 </summary>
 <param name="config"></param>
 
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Settings.Settings`1.LoadFile(System.String,System.Action{`0,System.String})">
 <summary>

 </summary>
 <param name="XmlFile">目标配置文件的Xml文件的文件名</param>
 <returns>可以调用的配置项的数目，解析失败则返回0</returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Settings.Settings`1.Load(`0)">
 <summary>
 使用<see cref="T:Microsoft.VisualBasic.ComponentModel.Settings.ProfileItem"/>来标记想要作为变量的属性
 </summary>
 <param name="Data"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Settings.SimpleConfig.ToString">
 <summary>
 Display <see cref="P:Microsoft.VisualBasic.ComponentModel.Settings.SimpleConfig.Name"/>
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Settings.SimpleConfig.TryParse``2(System.Boolean,System.Boolean)">
 <summary>

 </summary>
 <typeparam name="T"></typeparam>
 <typeparam name="TConfig"></typeparam>
 <param name="canRead">向文件之中写数据的时候，需要设置为真</param>
 <param name="canWrite">从文件之中读取数据的时候，需要设置为真</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Settings.SimpleConfig.GenerateConfigurations``1(``0,System.Func{System.String,System.String,System.String})">
 <summary>
 从类型实体生成配置文件数据
 </summary>
 <typeparam name="T"></typeparam>
 <param name="target"></param>
 <param name="formats">
 ``[name, value] => format_output``
 </param>
 <returns></returns>
 <remarks>类型实体之中的简单属性，只要具备可读属性即可被解析出来</remarks>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.MapsHelper`1">
 <summary>
 其实这个对象就是字典查询的一个简化操作而已
 </summary>
 <typeparam name="T"></typeparam>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.NameMapping">
 <summary>
 将文件之中的字段名称映射为另一个名称的帮助模块
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.NameMapping.emptyMaps">
 <summary>
 
 </summary>
 <remarks>
 ###### 2019-03-08 因为会存在<see cref="M:Microsoft.VisualBasic.ComponentModel.NameMapping.Add(System.String,System.String)"/>添加数据的过程,所以在这里应该是使用constructor新构建一个对象
 否则会因为第二次使用<see cref="T:Microsoft.VisualBasic.ComponentModel.NameMapping"/>的时候因为对象引用的原因而出现错误
 </remarks>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Map`2.Key">
 <summary>
 The map source
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Map`2.Maps">
 <summary>
 The mapped target value.
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Map`2.IMap">
 <summary>
 与<see cref="T:Microsoft.VisualBasic.ComponentModel.Collection.Generic.IKeyValuePairObject`2"/>相比，这个类型更加倾向于特定化的描述两个对象之间的一一对应关系
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Map`2.op_Explicit(Microsoft.VisualBasic.ComponentModel.Map{`0,`1})~`1">
 <summary>
 因为map主要的作用是获取得到key所配对的value结果，所以在这里是转换为<see cref="P:Microsoft.VisualBasic.ComponentModel.Map`2.Maps"/>结果值的
 </summary>
 <param name="map"></param>
 <returns></returns>
 
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.IDMap">
 <summary>
 字符串类型的映射
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.IDMap.Key">
 <summary>
 
 </summary>
 <returns></returns>
 <remarks>
 虽然说这个对象也实现了<see cref="T:Microsoft.VisualBasic.ComponentModel.Collection.Generic.INamedValue"/>接口，但是Key也可能是会出现重复的
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.IDMap.TSV">
 <summary>
 将这个映射转换为tsv文件之中的一行数据
 </summary>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.IDMap.ParseTsvFile(System.String,System.Boolean,Microsoft.VisualBasic.ComponentModel.IDMap@)">
 <summary>
 将TSV文件之中的数据行解析为IDMapping结果
 </summary>
 <param name="path$"></param>
 <param name="haveHeader"></param>
 <param name="header"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.TimeInterval.ToString">
 <summary>
 (dd hh:mm:ss) 输出可以被MySQL数据库所识别的字符串格式
 </summary>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Uid">
 <summary>
 The unique id generator.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.Uid.chars">
 <summary>
 index collection of array <see cref="F:Microsoft.VisualBasic.ComponentModel.Uid.__chars"/>.(<see cref="F:Microsoft.VisualBasic.ComponentModel.Uid.__chars"/>数组的下标集合)
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.Uid.value">
 <summary>
 tick n
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Uid.Key">
 <summary>
 可以通过这个属性来重设uid的字符串的值
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Uid.__error(System.Char)">
 <summary>
 Throw error helper
 </summary>
 <param name="c"></param>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Uid.#ctor(System.Int32,System.Collections.Generic.IEnumerable{System.Char})">
 <summary>
 使用自定义顺序的字符序列
 </summary>
 <param name="n"></param>
 <param name="_chars"></param>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Uid.#ctor(System.Int32,System.Boolean)">
 <summary>
 
 </summary>
 <param name="n"></param>
 <param name="caseSensitive">
 假若是使用这个uid对象来生成临时文件名的话，由于Windows的文件系统是不区分大小写的，所以Aa的情况会出现同名的情况，
 所以在这里就需要设置为False了，大小写重名的情况在Linux或者Mac上面没有影响
 </param>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Uid.#ctor(System.Boolean)">
 <summary>
 ZERO
 </summary>
 <param name="caseSensitive">
 大小写敏感？假若是需要应用于文件名称，在Windows操作系统之上建议设置为False不敏感，
 否则会出现相同字母但是不同大小写的文件会被覆盖的情况出现
 </param>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Uid.Plus">
 <summary>
 current id value +1
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Uid.op_Addition(Microsoft.VisualBasic.ComponentModel.Uid,System.Int32)">
 <summary>
 Thread unsafe operator for current id value plus <paramref name="n"/>.
 (请注意，这个操作是线程不安全的，所以请确保在执行这个命令之前使用``SyncLock``加锁)
 </summary>
 <param name="i"></param>
 <param name="n"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Uid.op_UnaryPlus(Microsoft.VisualBasic.ComponentModel.Uid)">
 <summary>
 Thread unsafe operator for current id value +1.
 (请注意，这个操作是线程不安全的，所以请确保在执行这个命令之前使用``SyncLock``加锁)
 </summary>
 <param name="i"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Uid.ToString">
 <summary>
 Convert the internal id value as the uid string value.(直接字符串序列，不会产生步进前移)
 </summary>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Uid.op_Concatenate(Microsoft.VisualBasic.ComponentModel.Uid,System.String)">
 <summary>
 String contract of current id value string with a specific <paramref name="s"/> value.
 </summary>
 <param name="i"></param>
 <param name="s$"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Uid.op_Explicit(Microsoft.VisualBasic.ComponentModel.Uid)~System.String">
 <summary>
 Alias for <see cref="M:Microsoft.VisualBasic.ComponentModel.Uid.ToString"/>
 </summary>
 <param name="i"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.Binding`2">
 <summary>
 Functioning the same as the <see cref="T:System.Collections.Generic.KeyValuePair`2"/>, but with more specific on the name. 
 <see cref="T:System.Collections.Generic.KeyValuePair`2"/> its name is too generic.
 (作用与<see cref="T:System.Collections.Generic.KeyValuePair`2"/>类似，只不过类型的名称更加符合绑定的描述)
 </summary>
 <typeparam name="T"></typeparam>
 <typeparam name="K"></typeparam>
</member>
<member name="F:Microsoft.VisualBasic.ComponentModel.Binding`2.name">
 <summary>
 the name of current binding, can be optional
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.Binding`2.IsEmpty">
 <summary>
 If the field <see cref="F:Microsoft.VisualBasic.ComponentModel.Binding`2.Bind"/> and <see cref="F:Microsoft.VisualBasic.ComponentModel.Binding`2.Target"/> are both nothing, then this binding is empty.
 (当<see cref="F:Microsoft.VisualBasic.ComponentModel.Binding`2.Bind"/>以及<see cref="F:Microsoft.VisualBasic.ComponentModel.Binding`2.Target"/>都同时为空值的时候这个参数才会为真)
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Binding`2.Tuple">
 <summary>
 Convert this binding to tuple
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.Binding`2.op_Explicit(Microsoft.VisualBasic.ComponentModel.Binding{`0,`1})~System.Tuple{`0,`1}">
 <summary>
 Implicit convert this binding as the <see cref="T:System.Tuple`2"/>
 </summary>
 <param name="b"></param>
 <returns></returns>
 
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.TagData.FactorValue`2.factor">
 <summary>
 should be a numeric factor value
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.TagData.FactorValue`2.op_Implicit(System.ValueTuple{`0,`1})~Microsoft.VisualBasic.ComponentModel.TagData.FactorValue{`0,`1}">
 <summary>
 Make conversion from a tuple object
 </summary>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.TagData.FactorString`1">
 <summary>
 target string label tagged with a numeric factor
 </summary>
 <typeparam name="T">should be a numeric factor type, example as double, single, etc</typeparam>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.TagData.IndexingExtensions.BinarySearch``2(``1[],``0,System.Func{``1,``0},``1)">
 <summary>
 
 </summary>
 <typeparam name="K"></typeparam>
 <typeparam name="T"></typeparam>
 <param name="inputArray">传入的数组必须是经过升序排序的</param>
 <param name="key"></param>
 <param name="getKey"></param>
 <param name="[default]"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.TagData.IndexingExtensions.BinarySearch``2(``1[],``0,System.Func{``1,``0},System.Func{``0,``0,System.Boolean},``1)">
 <summary>
 传入的数组必须是经过升序排序的
 </summary>
 <typeparam name="K"></typeparam>
 <typeparam name="T"></typeparam>
 <param name="inputArray">传入的数组必须是经过升序排序的</param>
 <param name="key"></param>
 <param name="getKey"></param>
 <param name="[default]"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.TagData.TagData`2">
 <summary>
 Target value have a specific tag key.
 </summary>
 <typeparam name="T">The type of the <see cref="P:Microsoft.VisualBasic.ComponentModel.TagData.TagData`2.Tag"/> key</typeparam>
 <typeparam name="V">The type of the value data</typeparam>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.TagData.TagData`2.Key">
 <summary>
 ``<see cref="P:Microsoft.VisualBasic.ComponentModel.TagData.TagData`2.Tag"/> -> <see cref="M:Microsoft.VisualBasic.Language.Value`1.GetJson"/>``
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.TagData.TagData`2.Tag">
 <summary>
 Target value have this specific tag data.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.TagData.TagData`2.TagStr">
 <summary>
 默认都有一个字符串类型的标签用于保存其他的数据，但是主要还是使用``<see cref="P:Microsoft.VisualBasic.ComponentModel.TagData.TagData`2.Tag"/>``属性来进行标记
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.TagData.TagData`2.op_Explicit(Microsoft.VisualBasic.ComponentModel.TagData.TagData{`0,`1})~System.Tuple{`0,`1}">
 <summary>
 将这个标签数据转换为``元组``类型
 </summary>
 <param name="r"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.TagData.IntegerTagged`1">
 <summary>
 使用一个整形数作为目标对象值的标签信息
 </summary>
 <typeparam name="T"></typeparam>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.TagData.DoubleTagged`1">
 <summary>
 使用一个实数作为目标对象值的标签信息
 </summary>
 <typeparam name="T"></typeparam>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.TagData.INumericKey">
 <summary>
 an object that tagged a number value as its index key
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.TagData.INumericKey.key">
 <summary>
 a number index key
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.TagData.LongTagged`1">
 <summary>
 使用一个长整形数作为目标对象值的标签信息
 </summary>
 <typeparam name="T"></typeparam>
</member>
<member name="T:Microsoft.VisualBasic.ComponentModel.TagData.ITimeSignal">
 <summary>
 Interface representing the time series data
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.TagData.ITimeSignal.time">
 <summary>
 the time point data
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ComponentModel.TagData.ITimeSignal.intensity">
 <summary>
 the signal intensity value of current time point
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.TagData.TimeSignalDataExtensions.Time``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>
 get time signal time point as vector
 </summary>
 <typeparam name="T"></typeparam>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.TagData.TimeSignalDataExtensions.Intensity``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>
 get signal intensity value as vector
 </summary>
 <typeparam name="T"></typeparam>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.TagData.TimeSignalDataExtensions.X``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>
 get time signal time point as vector
 </summary>
 <typeparam name="T"></typeparam>
 <param name="data"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ComponentModel.TagData.TimeSignalDataExtensions.Y``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>
 get signal intensity value as vector
 </summary>
 <typeparam name="T"></typeparam>
 <param name="data"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Data.NamespaceDoc">
 <summary>
 The sciBASIC.NET data handling module
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Data.Repository.BKDRHash">
 <summary>
 
 </summary>
 <remarks>
 https://github.com/fernandezja/ColorHashSharp/blob/master/src/ColorHashSharp/BKDRHash.cs
 </remarks>
</member>
<member name="F:Microsoft.VisualBasic.Data.Repository.BKDRHash.JAVASCRIPT_MAX_SAFE_INTEGER">
 <summary>
 The Number.MAX_SAFE_INTEGER constant represents the maximum safe integer in JavaScript  
 https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/Number/MAX_SAFE_INTEGER
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Data.Repository.BKDRHash.GenerateVersion3(System.String)">
 <summary>
 BKDR Hash (modified version). Idem  original code.
 https://github.com/zenozeng/color-hash/blob/master/lib/bkdr-hash.js
 Example values nodejs https://repl.it/@Jose_AA/BKDR-Hash
 </summary>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Data.Repository.FNV1a.GetDeterministicHashCode(System.String)">
 <summary>
 What if you need GetHashCode() to be deterministic across program executions?
 
 https://andrewlock.net/why-is-string-gethashcode-different-each-time-i-run-my-program-in-net-core/
 </summary>
 <param name="str"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Data.Repository.FNV1a.GetHashCode(System.Collections.Generic.IEnumerable{System.Object})">
 <summary>
 get FNV-1a hascode
 
 ```
 hash = offset_basis
 
 for each octet_of_data to be hashed
   hash = hash Xor octet_of_data
   hash = hash * FNV_prime
   
 return hash
 ```
 </summary>
 <param name="targets"></param>
 <returns></returns>
 <remarks>
 http://www.isthe.com/chongo/tech/comp/fnv/index.html
 </remarks>
</member>
<member name="T:Microsoft.VisualBasic.Data.Repository.Nilsimsa">
 <summary>
 Computes the Nilsimsa hash for the given string.
 
 <para>
 This class is based on the Python implementation by Michael Itz
 http://code.google.com/p/py-nilsimsa
 
 </para>
 <para>
 Original C nilsimsa-0.2.4 implementation by cmeclax:
 http://ixazon.dynip.com/~cmeclax/nilsimsa.html
 
 @author Albert Weichselbraun
 </para>
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Data.Repository.Nilsimsa.count">
 <summary>
 num characters seen
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Data.Repository.Nilsimsa.acc">
 <summary>
 accumulators for computing the digest
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Data.Repository.Nilsimsa.lastch">
 <summary>
 the last four seen characters
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Data.Repository.Nilsimsa.m_digest">
 <summary>
 the Nilsimsa digest
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Data.Repository.Nilsimsa.TRAN">
 <summary>
 pre-defined transformation array
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Data.Repository.Nilsimsa.update(System.Byte[])">
 <summary>
 Updates the Nilsimsa digest with the given byte array.
 </summary>
 <param name="data"> the data to consider in the update. </param>
 <returns> The updated Nilsimsa object. </returns>
</member>
<member name="M:Microsoft.VisualBasic.Data.Repository.Nilsimsa.update(System.String)">
 <summary>
 Update the current Nilsimsa object with the given String s.
 </summary>
 <param name="s"> the String to add to the hash. </param>
 <returns> The updated Nilsimsa object. </returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Data.Repository.Nilsimsa.reset">
 <summary>
 Reset the Hash computation.
 </summary>
 <returns> A reset (i.e., empty) Nilsimsa object. </returns>
</member>
<member name="M:Microsoft.VisualBasic.Data.Repository.Nilsimsa.tran3(System.Int32,System.Int32,System.Int32,System.Int32)">
 <summary>
 Accumulator for a transition n between the chars a, b, c.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Data.Repository.Nilsimsa.digest">
 <summary>
 Return the digest for the current Nilsimsa object.
 </summary>
 <returns> The digest of the current Nilsimsa object. </returns>
</member>
<member name="M:Microsoft.VisualBasic.Data.Repository.Nilsimsa.digest(System.String)">
 <summary>
 Compute the Nilsimsa digest for the given String.
 </summary>
 <param name="s"> the String to hash </param>
 <returns> The Nilsimsa digest. </returns>
</member>
<member name="M:Microsoft.VisualBasic.Data.Repository.Nilsimsa.digest(System.Byte[])">
 <summary>
 Compute the Nilsimsa digest for the given String.
 </summary>
 <param name="data"> an array of bytes to hash </param>
 <returns> The Nilsimsa digest. </returns>
</member>
<member name="M:Microsoft.VisualBasic.Data.Repository.Nilsimsa.getHash(System.Byte[])">
 <summary>
 Compute the Nilsimsa digest for the given byte array.
 </summary>
 <param name="data"> to hash </param>
 <returns> The byte array's Nilsimsa hash. </returns>
</member>
<member name="M:Microsoft.VisualBasic.Data.Repository.Nilsimsa.getHash(System.String)">
 <summary>
 Compute the Nilsimsa digest for the given String.
 </summary>
 <param name="s"> the String to hash </param>
 <returns> The String's Nilsimsa hash. </returns>
</member>
<member name="M:Microsoft.VisualBasic.Data.Repository.Nilsimsa.hexdigest">
 <summary>
 Return the hex digest of the current Nilsimsa object.
 </summary>
 <returns> A String representation of the current state of the Nilsimsa object. </returns>
</member>
<member name="M:Microsoft.VisualBasic.Data.Repository.Nilsimsa.hexdigest(System.Byte[])">
 <summary>
 Compute the Nilsimsa hexDigest for the given String.
 </summary>
 <param name="data"> an array of bytes to hash </param>
 <returns> The Nilsimsa hexdigest. </returns>
</member>
<member name="M:Microsoft.VisualBasic.Data.Repository.Nilsimsa.hexdigest(System.String)">
 <summary>
 Compute the Nilsimsa hexDigest for the given String.
 </summary>
 <param name="s"> the String to hash </param>
 <returns> The Nilsimsa hexdigest. </returns>
</member>
<member name="M:Microsoft.VisualBasic.Data.Repository.Nilsimsa.bitwiseDifference(Microsoft.VisualBasic.Data.Repository.Nilsimsa)">
 <summary>
 Compare a Nilsimsa object to the current one and return the number of bits that differ.
 </summary>
 <param name="cmp"> the comparison Nilsimsa object </param>
 <returns> The number of bits in which the Nilsimsa digests differ. </returns>
</member>
<member name="M:Microsoft.VisualBasic.Data.Repository.Nilsimsa.compare(Microsoft.VisualBasic.Data.Repository.Nilsimsa)">
 <summary>
 Return a value between -128 and + 128 that indicates the difference between the nilsimsa digest
 of the current object and cmp.
 </summary>
 <param name="cmp"> comparison Nilsimsa object </param>
 <returns> A value between -128 (no matching bits) and 128 (all bits match; both hashes are equal) </returns>
</member>
<member name="T:Microsoft.VisualBasic.Data.Repository.RepositoryFileSystem">
 <summary>
 Using file system as repository system provider
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Data.Repository.RepositoryFileSystem.GetFile(System.String,System.String,System.String[])">
 <summary>

 </summary>
 <param name="DIR"></param>
 <param name="keyword"></param>
 <param name="ext">元素的排布是有顺序的</param>
 <returns></returns>
 <remarks></remarks>

</member>
<member name="M:Microsoft.VisualBasic.Data.Repository.RepositoryFileSystem.LoadSourceEntryList(System.String,System.String[],System.Boolean)">
 <summary>
 Load the file from a specific directory from the source parameter as the resource entry list.
 
 [<see cref="F:Microsoft.VisualBasic.FileIO.SearchOption.SearchAllSubDirectories"/>，这个函数会扫描目标文件夹下面的所有文件。]
 请注意，本方法是不能够产生具有相同的主文件名的数据的。假若目标GBK是使用本模块之中的方法保存或者导出来的，
 则可以使用本方法生成Entry列表；（在返回的结果之中，KEY为文件名，没有拓展名，VALUE为文件的路径）
 </summary>
 <param name="source"></param>
 <returns></returns>
 <remarks></remarks>

</member>
<member name="M:Microsoft.VisualBasic.Data.Repository.RepositoryFileSystem.LoadSourceEntryList(System.String,System.String[])">
 <summary>
 可以使用本方法生成Entry列表；（在返回的结果之中，KEY为文件名，没有拓展名，VALUE为文件的路径）
 请注意，这个函数会搜索目标文件夹下面的所有的文件夹的
 </summary>
 <param name="source"></param>
 <param name="ext">文件类型的拓展名称</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Data.Repository.RepositoryFileSystem.LoadEntryList(System.String,System.String[])">
 <summary>
 允许有重复的数据
 </summary>
 <param name="DIR"></param>
 <param name="exts"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Data.Repository.RepositoryFileSystem.LoadSourceEntryList(System.Collections.Generic.IEnumerable{System.String})">
 <summary>
 Load the file from a specific directory from the source parameter as the resource entry list.
 </summary>
 <param name="source"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Data.Repository.RepositoryFileSystem.SourceCopy(System.Collections.Generic.IEnumerable{System.String},System.String,System.Boolean)">
 <summary>
 Copy the file in the source list into the copyto directory, function returns the failed operation list.
 (将不同来源<paramref name="source"></paramref>的文件复制到目标文件夹<paramref name="copyto"></paramref>之中)
 </summary>
 <param name="source"></param>
 <param name="copyto"></param>
 <returns>返回失败的文件列表</returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Data.Repository.RepositoryFileSystem.GetMostAppreancePath(System.Collections.Generic.IEnumerable{System.String})">
 <summary>
 Gets a directory path which is most frequent appeared in the file list.
 </summary>
 <param name="files"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Data.Repository.SnowflakeIdGenerator">
 <summary>
 a twitter unique Snowflake ID generator
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Data.Repository.SnowflakeIdGenerator.GenerateId">
 <summary>
 generates a new snowflake id
 </summary>
 <returns></returns>
 <remarks>
 Snowflake ID 通常是一个 64 位整数，由以下部分组成：41 位用于时间戳，提供毫秒级精度的自定义纪元；
 10 位用于机器/数据中心标识符，允许多达 1024 个唯一节点；12 位用于序列号，支持每个节点每毫秒生成
 多达 4096 个 ID。
 可扩展性：通过分散 ID 生成，Snowflake ID 允许系统水平扩展，而无需中央 ID 生成服务的瓶颈。
 唯一性：Snowflake ID 的结构确保了整个系统中每个 ID 的唯一性。可排序性：Snowflake ID 的时间戳组件
 允许它们可排序，这对于组织和索引数据可能有益。
 分布式数据库：Snowflake ID 在分布式数据库中被广泛使用，以确保从不同节点插入的记录具有唯一标识符。
 微服务架构：在微服务架构中，多个服务可能需要独立生成唯一标识符，Snowflake ID 提供了可靠的解决方案。
 
 Snowflake ID 的概念起源于 Twitter，作为其对可扩展的唯一标识符生成系统的需求的解决方案。
 自那时起，它已被需要大规模唯一标识符的各种分布式系统和服务采用。演变：在 Twitter 推出后，
 Snowflake ID 算法被开源，允许开发者社区对其进行演变和适应各种平台和技术的贡献。
 </remarks>
</member>
<member name="T:Microsoft.VisualBasic.Data.Trinity.Expression">
 <summary>
 Natural expression builder for AI output
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Data.Trinity.Expression.Concatenate(System.Collections.Generic.IEnumerable{System.String},System.String,System.String,System.String,System.Boolean,System.Boolean,System.Int32)">
 <summary>
 If <paramref name="list"/> contains no elements or it is nothing, then this function will returns nothing
 </summary>
 <param name="list"></param>
 <param name="comma$"></param>
 <param name="andalso$"></param>
 <param name="etc$"></param>
 <param name="joinSpace"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Data.Trinity.NLP.TextTokens">
 <summary>
 应用于字符串分析的，自然语言处理
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Data.Trinity.NLP.Word">
 <summary>
 A single word text token
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Data.Trinity.NLP.Word.class">
 <summary>
 the word class type
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Data.Trinity.NLP.Word.str">
 <summary>
 the word text
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Data.Trinity.NLP.Word.num">
 <summary>
 the reference count of current word
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Data.Trinity.NLP.WordClass">
 <summary>
 单词的词性分类
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Data.Trinity.NLP.WordClass.NA">
 <summary>
 未知的词性
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Data.Trinity.NLP.WordClass.noun">
 <summary>
 名词：to describe a person or thing
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Data.Trinity.NLP.WordClass.countable_noun">
 <summary>
 可数名词
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Data.Trinity.NLP.WordClass.verb">
 <summary>
 动词
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Data.Trinity.NLP.WordClass.adjective">
 <summary>
 形容词
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Data.Trinity.NLP.WordClass.adverb">
 <summary>
 副词 
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Data.Trinity.NLP.WordClass.pronoun">
 <summary>
 代词 
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Data.Trinity.NLP.WordClass.preposition">
 <summary>
 介词
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Data.Trinity.NLP.WordClass.numeral">
 <summary>
 数词
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Data.Trinity.NLP.WordClass.conjunction">
 <summary>
 连词
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Data.Trinity.NLP.WordClass.article">
 <summary>
 冠词 
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Data.Trinity.NLP.WordClass.interjection">
 <summary>
 感叹词
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Data.Trinity.WordSimilarityIndex">
 <summary>
 使用模拟比较来建立所给定的字符串的快速模糊查找的索引对象模型
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Data.Trinity.WordSimilarityIndex.bin">
 <summary>
 二叉树的主键是字符串的ASCII编码缓存
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Data.Trinity.WordSimilarityIndex`1">
 <summary>
 使用模拟比较来建立所给定的字符串的快速模糊查找的索引对象模型
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.BitmapImage.BitmapBuffer">
 <summary>
 Unsafe memory pointer of the <see cref="T:Microsoft.VisualBasic.Imaging.Bitmap"/> data buffer. buffer image object in java
 </summary>
 <remarks>
 (线程不安全的图片数据对象)
 </remarks>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.BitmapImage.BitmapBuffer.handle">
 <summary>
 BitmapData
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.BitmapImage.BitmapBuffer.memoryBuffer">
 <summary>
 current bitmap data is construct from a pixel data array, not read from memory via pointer.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.BitmapImage.BitmapBuffer.channels">
 <summary>
 图片可能是 BGRA 4通道
 也可能是 BGR 3通道的
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.BitmapImage.BitmapBuffer.#ctor(System.IntPtr,System.Int32,System.Int32)">
 <summary>
 Make the memory data copy
 </summary>
 <param name="ptr">the memory data will be copy via this pointer</param>
 <param name="byts"></param>
 <param name="channel"></param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.BitmapImage.BitmapBuffer.#ctor(Microsoft.VisualBasic.Imaging.BitmapImage.BitmapBuffer)">
 <summary>
 make in-memory data copy
 </summary>
 <param name="source"></param>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.BitmapImage.BitmapBuffer.Width">
 <summary>
 The dimension width of the current bitmap buffer object
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.BitmapImage.BitmapBuffer.Height">
 <summary>
 The dimension height of the current bitmap buffer object
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.BitmapImage.BitmapBuffer.Size">
 <summary>
 the dimension size of current bitmap buffer object, 
 it is constructed via the <see cref="P:Microsoft.VisualBasic.Imaging.BitmapImage.BitmapBuffer.Width"/> and 
 <see cref="P:Microsoft.VisualBasic.Imaging.BitmapImage.BitmapBuffer.Height"/> data.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.BitmapImage.BitmapBuffer.Stride">
 <summary>
 Stride is the number of bytes your code must iterate past to reach the next vertical pixel.
 </summary>
 <returns>
 always be width * pixel_size on .NET 8.0 runtime;
 may be not matched with width * pixel_size on .net 4.8 runtime
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.BitmapImage.BitmapBuffer.White(System.Int32,System.Int32)">
 <summary>
 Create a new blank bitmap data with all pixel fill with color white
 </summary>
 <param name="width"></param>
 <param name="height"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.BitmapImage.BitmapBuffer.GetPixelChannels">
 <summary>
 get the pixel channels in memory buffer
 </summary>
 <returns>
 3 - for 24bit rgb pixel format
 4 - for 32bit argb pixel format
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.BitmapImage.BitmapBuffer.GetImage(System.Boolean)">
 <summary>
 Gets a copy of the original raw image value that which constructed 
 this bitmap object class
 </summary>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.BitmapImage.BitmapBuffer.GetIndex(System.Int32,System.Int32)">
 <summary>
 返回第一个元素的位置
 </summary>
 <param name="x"></param>
 <param name="y"></param>
 <returns>B, G, R, [A]</returns>
 <remarks>
 ###### 2017-11-29 
 经过测试，对第一行的数据的计算没有问题
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.BitmapImage.BitmapBuffer.GetPixel(System.Int32,System.Int32)">
 <summary>
 Gets the color of the specified pixel in this <see cref="T:Microsoft.VisualBasic.Imaging.Bitmap"/>.
 (<paramref name="x"/>和<paramref name="y"/>都是以零为底的)
 </summary>
 <param name="x">The x-coordinate of the pixel to retrieve.</param>
 <param name="y">The y-coordinate of the pixel to retrieve.</param>
 <returns>
 A <see cref="T:System.Drawing.Color"/> structure that represents the color of the specified pixel.
 </returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.BitmapImage.BitmapBuffer.GetAlpha(System.Int32,System.Int32)">
 <summary>
 get the alpha channel data from a given pixel
 </summary>
 <param name="x"></param>
 <param name="y"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.BitmapImage.BitmapBuffer.GetARGBStream">
 <summary>
 get image data array in ARGB format
 </summary>
 <returns>
 scan0.ToPointer
 </returns>
 <remarks>
 helper function for hqx algorithm module
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.BitmapImage.BitmapBuffer.Unpack(System.Drawing.Color[],System.Drawing.Size)">
 <summary>
 argb channels=4
 </summary>
 <param name="pixels"></param>
 <param name="size"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.BitmapImage.BitmapBuffer.Unpack(System.Drawing.Color[0:,0:],System.Drawing.Size)">
 <summary>
 argb channels=4
 </summary>
 <param name="pixels"></param>
 <param name="size"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.BitmapImage.BitmapBuffer.WriteARGBStream(System.UInt32[])">
 <summary>
 helper function for hqx algorithm module
 </summary>
 <param name="ints"></param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.BitmapImage.BitmapBuffer.GetPixel(System.Drawing.Rectangle)">
 <summary>
 row scans
 </summary>
 <param name="rect"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.BitmapImage.BitmapBuffer.GetPixel(System.Int32,System.Int32,System.Int32)">
 <summary>
 
 </summary>
 <param name="channel">0r 1g 2b 3a</param>
 <param name="x"></param>
 <param name="y"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.BitmapImage.BitmapBuffer.SetPixel(System.Int32,System.Int32,System.Drawing.Color)">
 <summary>
 Sets the color of the specified pixel in this <see cref="T:Microsoft.VisualBasic.Imaging.Bitmap"/>.(这个函数线程不安全)
 </summary>
 <param name="x">The x-coordinate of the pixel to set. [0, width-1]</param>
 <param name="y">The y-coordinate of the pixel to set. [0, height-1]</param>
 <param name="color">
 A <see cref="T:System.Drawing.Color"/> structure that represents the color to assign to the specified
 pixel.</param>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.BitmapImage.BitmapBuffer.SetPixel(System.Int32,System.Int32,System.Int32,System.Byte)">
 <summary>
 
 </summary>
 <param name="channel">0r 1g 2b 3a</param>
 <param name="x"></param>
 <param name="y"></param>
 <param name="val"></param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.BitmapImage.BitmapBuffer.Save(System.String)">
 <summary>
 save in-memory data as local bitmap file
 </summary>
 <param name="file"></param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.BitmapImage.BitmapBuffer.Save(System.IO.Stream)">
 <summary>
 save in-memory data as bitmap file
 </summary>
 <param name="s"></param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.BitmapImage.BitmapBuffer.FromImage(Microsoft.VisualBasic.Imaging.Image)">
 <summary>
 这个函数会自动复制原始图片数据里面的东西的
 </summary>
 <param name="res"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.BitmapImage.BitmapBuffer.FromBitmap(Microsoft.VisualBasic.Imaging.Bitmap)">
 <summary>
 
 </summary>
 <param name="curBitmap"></param>
 <returns>
 get the reference of the <see cref="P:Microsoft.VisualBasic.Imaging.Bitmap.MemoryBuffer"/> data directly
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.BitmapImage.BitmapBuffer.op_Addition(Microsoft.VisualBasic.Imaging.BitmapImage.BitmapBuffer,System.Int32)">
 <summary>
 Current pointer location offset to next position
 </summary>
 <param name="bmp"></param>
 <param name="offset%"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.BitmapImage.BitmapChannels.RGB(Microsoft.VisualBasic.Imaging.BitmapImage.BitmapBuffer,System.Boolean)">
 <summary>
 split the bitmap into rgb channels
 </summary>
 <param name="bitmap"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.BitmapImage.BitmapReader">
 <summary>
 a bitmap image data reader for help huge scientific image data processing.
 (more than the 2GB limitation of gdi+ <see cref="T:Microsoft.VisualBasic.Imaging.Bitmap"/>.)
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.BitmapImage.BitmapReader.#ctor(System.String)">
 <summary>
 
 </summary>
 <param name="filename"></param>
 <remarks>
 the bitmap image data maybe load into memory at once if the file size is less then 2GB.
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.BitmapImage.BitmapReader.GetPixelColor(System.Int32,System.Int32)">
 <summary>
 get pixel via given x,y location
 </summary>
 <param name="row">the y location</param>
 <param name="column">the x location</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.BitmapImage.BitmapResizer.CubicInterpolation(System.Byte[0:,0:],System.Double)">
 <summary>
 Cubic interpolate
 </summary>
 <param name="input"></param>
 <param name="scale"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.BitmapImage.BitmapResizer.BilinearInterpolation(System.Byte[0:,0:]@,System.Int32,System.Int32,System.Int32,System.Int32)">
 <summary>
 Bilinear interpolation
 </summary>
 <param name="srcImage"></param>
 <param name="srcWidth"></param>
 <param name="srcHeight"></param>
 <param name="dstWidth"></param>
 <param name="dstHeight"></param>
 <returns></returns>
 
</member>
<member name="T:Microsoft.VisualBasic.Imaging.BitmapImage.BitmapScale">
 <summary>
 Grayscale and binarization extensions
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.BitmapImage.BitmapScale.PixelSize">
 <summary>
 A, R, G, B
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.BitmapImage.BitmapScale.PixelScanPointer">
 <summary>
 
 </summary>
 <param name="byts">Unmanaged memory pointer that point to the bitmap data buffer.</param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.BitmapImage.BitmapScale.BitmapPixelScans(Microsoft.VisualBasic.Imaging.Bitmap@,Microsoft.VisualBasic.Imaging.BitmapImage.BitmapScale.PixelScanPointer)">
 <summary>
 A generic bitmap pixel scan framework that using memory pointer
 </summary>
 <param name="curBitmap"></param>
 <param name="scan"></param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.BitmapImage.BitmapScale.Binarization(Microsoft.VisualBasic.Imaging.Bitmap@,Microsoft.VisualBasic.Imaging.BitmapImage.BitmapScale.BinarizationStyles)">
 <summary>
 
 </summary>
 <param name="curBitmap"></param>
 <remarks>
 http://www.codeproject.com/Articles/1094534/Image-Binarization-Using-Program-Languages
 
 The .net Bitmap object keeps a reference to HBITMAP handle, Not to the underlying bitmap itself.
 So, single pixel access call to <see cref="M:Microsoft.VisualBasic.Imaging.Bitmap.SetPixel(System.Int32,System.Int32,System.Drawing.Color)"/>/<see cref="M:Microsoft.VisualBasic.Imaging.Bitmap.GetPixel(System.Int32,System.Int32)"/> Or 
 even retrieve Width/Height properties does something Like: 
 lock handle In place-Get/Set value/unlock handle. It Is the most inefficient way To manipulate bitmaps In .NET. 
 The author should read about ``Bitmap.LockBits`` first.
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.BitmapImage.BitmapScale.scanInternal(Microsoft.VisualBasic.Emit.Marshal.Byte,Microsoft.VisualBasic.Imaging.BitmapImage.BitmapScale.BinarizationStyles)">
 <summary>
 Binarization: just black and white
 </summary>
 <param name="byts"></param>
 <param name="style"></param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.BitmapImage.BitmapScale.AdjustContrast(Microsoft.VisualBasic.Imaging.Bitmap@,System.Double)">
 <summary>
 Adjust the contrast of an image.
 (调整图像的对比度)
 </summary>
 <param name="bmp"></param>
 <param name="contrast">
 Used to set the contrast (-100 to 100)
 </param>
 <remarks>
 https://stackoverflow.com/questions/3115076/adjust-the-contrast-of-an-image-in-c-sharp-efficiently
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.BitmapImage.BitmapScale.AdjustContrast(Microsoft.VisualBasic.Imaging.BitmapImage.BitmapBuffer@,System.Double)">
 <summary>
 Adjust the contrast of an image.
 (调整图像的对比度)
 </summary>
 <param name="destPixels">target bitmap data buffer for make contrast processing.</param>
 <param name="contrast">
 Used to set the contrast (-100 to 100)
 </param>
 <remarks>
 https://stackoverflow.com/questions/3115076/adjust-the-contrast-of-an-image-in-c-sharp-efficiently
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.BitmapImage.BitmapScale.Grayscale(Microsoft.VisualBasic.Imaging.Image)">
 <summary>
 convert color bitmaps to grayscale.(灰度图)
 </summary>
 <param name="source"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.BitmapImage.BitmapScale.Grayscale(Microsoft.VisualBasic.Imaging.BitmapImage.BitmapBuffer@,System.Single,System.Single,System.Single)">
 <summary>
 将彩色图转换为灰度图
 </summary>
 <param name="source"></param>
 <returns></returns>
 <remarks>
 这个函数会直接改变输入数据的值，如果不想对输入的位图对象做修改，请先复制一份，再使用这个函数进行灰度处理
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.BitmapImage.BitmapScale.Grayscale(System.Int32,System.Int32,System.Int32,System.Single,System.Single,System.Single)">
 <summary>
 luma
 </summary>
 <param name="R"></param>
 <param name="G"></param>
 <param name="B"></param>
 <returns>[0,255]</returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.BitmapImage.BitmapScale.GrayScaleF(System.Int32,System.Int32,System.Int32,System.Single,System.Single,System.Single)">
 <summary>
 luma
 </summary>
 <param name="R"></param>
 <param name="G"></param>
 <param name="B"></param>
 <returns>[0,255]</returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.BitmapImage.BitmapScale.Grayscale(System.Drawing.Color,System.Single,System.Single,System.Single)">
 <summary>
 Color gray scale
 </summary>
 <param name="c"></param>
 <returns>[0,255]</returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.BitmapImage.BitmapScale.ByteLength(System.Drawing.Rectangle)">
 <summary>
 How many bytes does this bitmap contains?
 </summary>
 <param name="rect">The bitmap size or a specific region on the bitmap.</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.BitmapImage.BitmapScale.Colors(System.Byte[])">
 <summary>
 Convert the bitmap memory bytes into pixels
 </summary>
 <param name="buffer"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.BitmapImage.BitmapTools.CropBitmapBuffer(Microsoft.VisualBasic.Imaging.BitmapImage.BitmapBuffer,System.Drawing.Rectangle)">
 <summary>
 裁剪BitmapBuffer的指定区域
 </summary>
 <param name="sourceBuffer">源BitmapBuffer</param>
 <param name="cropRect">裁剪区域</param>
 <returns>裁剪后的新BitmapBuffer</returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.BitmapImage.BitmapTools.GetValidCropRectangle(System.Drawing.Rectangle,System.Int32,System.Int32)">
 <summary>
 确保裁剪矩形在图像有效范围内
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.BitmapImage.FileStream.Bitmap">
 <summary>
 A in-memory bitmap image model
 </summary>
 <remarks>
 This is simple Bitmap library that helps you wrap binary data (pixels) into BMP header for saving into file and vice versa.
 
 It supports only 24 bits BGR And 32 bits BGRA Byte arrays.
 Library supports x86 (little-endian) And ARM (big-endian).
 
 > https://github.com/dsoronda/bmp-sharp
 </remarks>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.BitmapImage.FileStream.Bitmap.BytesPerRow">
 <summary>
 BMP file must be aligned at 4 butes at the end of row
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.BitmapImage.FileStream.Bitmap.BytesPerPixel">
 <summary>
 NOTE: we don't care for images that are less than 24 bits
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.BitmapImage.FileStream.Bitmap.PixelDataFliped">
 <summary>
 Get reversed order or rows.
 For Bitmap image, pixel rows are stored from bottom to top.
 So first row in bitmap file is lowest row in Image.
 </summary>
 <returns>Pixel data with reversed (fliped) rows</returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.BitmapImage.FileStream.Bitmap.#ctor(System.Int32,System.Int32,System.Byte[],Microsoft.VisualBasic.Imaging.BitmapImage.FileStream.BitsPerPixelEnum)">
 <summary>
 Create new Bitmap object
 </summary>
 <param name="width"></param>
 <param name="height"></param>
 <param name="pixelData"></param>
 <param name="bitsPerPixel"></param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.BitmapImage.FileStream.Bitmap.GetBmpBytes(System.Boolean)">
 <summary>
 Get bitmap as byte aray for saving to file
 </summary>
 <param name="flipped">Flip (reverse order of) rows. Bitmap pixel rows are stored from bottom to up as shown in image</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.BitmapImage.FileStream.Bitmap.GetBmpStream(System.Boolean)">
 <summary>
 Get bitmap as byte stream for saving to file
 </summary>
 <param name="flipped">Flip (reverse order of) rows. Bitmap pixel rows are stored from bottom to up as shown in image</param>
 <returns>
 get in-memory stream data of the current bitmap object, could not 
 be processed when bitmap object is greater than 2GB.
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.BitmapImage.FileStream.Bitmap.RequiredBytesPerRow(System.Int32,Microsoft.VisualBasic.Imaging.BitmapImage.FileStream.BitsPerPixelEnum)">
 <summary>
 BMP file must be aligned at 4 bytes at the end of row
 </summary>
 <param name="width">Image Width</param>
 <param name="bitsPerPixel">Bits per pixel</param>
 <returns>How many bytes BMP requires per row</returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.BitmapImage.FileStream.Bitmap.IsPaddingRequired(System.Int32,Microsoft.VisualBasic.Imaging.BitmapImage.FileStream.BitsPerPixelEnum,System.Int32)">
 <summary>
 Check if padding is required (extra bytes for a row).
 </summary>
 <param name="width">Width of image</param>
 <param name="bitsPerPixel">Bits per pixels to calculate actual byte requirement</param>
 <param name="bytesPerRow">BMP required bytes per row</param>
 <returns>True/false if we need to allocate extra bytes (for BMP saving) for padding</returns>
 
</member>
<member name="T:Microsoft.VisualBasic.Imaging.BitmapImage.FileStream.BitmapFileHeader">
 <summary>
 Keep proper byte layout in memory
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.BitmapImage.FileStream.BitmapFileHeader.BitmapFileHeaderSizeInBytes">
 <summary>
 FileHeader headerSize in bytes (fist 14 bytes from start)
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.BitmapImage.FileStream.BitmapFileHeader.#ctor(System.UInt32)">
 <summary>
 Explicitly set file in size
 </summary>
 <param name="fileSize"></param>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.BitmapImage.FileStream.BitmapFileHeader.PixelDataOffset">
 <summary>
 The offset, i.e. starting address, of the byte where the bitmap image data (pixel array) can be found from the beggining of the file
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.BitmapImage.FileStream.BitmapFileHeader.#ctor(System.Int32,System.Int32,Microsoft.VisualBasic.Imaging.BitmapImage.FileStream.BitsPerPixelEnum,System.Int32)">
 <summary>
 Create header and calculate file size depending on input data
 </summary>
 <param name="width"></param>
 <param name="height"></param>
 <param name="bitsPerPixel"></param>
 <param name="rawImageSize">Depends on row padding and number of rows</param>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.BitmapImage.FileStream.BitmapFileHeader.HeaderBytes">
 <summary>
 Get header bytes
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.BitmapImage.FileStream.BitmapFileHeader.GetHeaderFromBytes(System.Byte[])">
 <summary>
 Generate BitmapFileHeader from first 14 bytes
 </summary>
 <param name="headerBytes"></param>
 <returns>BitmapFileHeader or throws exception</returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.BitmapImage.FileStream.BitmapFileHelper.ReadFileAsBitmap(System.String,System.Boolean)">
 <summary>
 read bitmap file in-memory
 </summary>
 <param name="fileName"></param>
 <param name="flipRows"></param>
 <returns></returns>
 <remarks>
 only process the bitmap image data in size smaller than 2GB
 </remarks>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.BitmapImage.FileStream.BytesPerPixelEnum">
 <summary>
 Number of bytes for specific Pixel format.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.BitmapImage.FileStream.BitmapInfoHeader.Width">
 <summary>
 the bitmap Width in pixels (signed integer)
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.BitmapImage.FileStream.BitmapInfoHeader.Height">
 <summary>
 the bitmap Height in pixels (signed integer)
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.BitmapImage.FileStream.BitmapInfoHeader.ColorPlanes">
 <summary>
 the number of color planes (must be 1)
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.BitmapImage.FileStream.BitmapInfoHeader.BitsPerPixel">
 <summary>
 the number of bits per pixel, which is the color depth of the image. Typical values are 1, 4, 8, 16, 24 and 32.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.BitmapImage.FileStream.BitmapInfoHeader.CompressionMethod">
 <summary>
 0 	BI_RGB (UNCOMPRESSED)
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.BitmapImage.FileStream.BitmapInfoHeader.ImageSize">
 <summary>
 the image size. This is the size of the raw bitmap data; a dummy 0 can be given for BI_RGB bitmaps.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.BitmapImage.FileStream.BitmapInfoHeader.HorizontalPixelPerMeter">
 <summary>
 the horizontal resolution of the image. (pixel per metre, signed integer)
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.BitmapImage.FileStream.BitmapInfoHeader.VerticalPixelPerMeter">
 <summary>
 the vertical resolution of the image. (pixel per metre, signed integer)
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.BitmapImage.FileStream.BitmapInfoHeader.nuberOfColorsInPallete">
 <summary>
 the number of colors in the color palette, or 0 to default to 2n (not used)
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.BitmapImage.FileStream.BitmapInfoHeader.numberOfImportantColorsUsed">
 <summary>
 numberOfImportantColorsUsed (not used)
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.BitmapImage.FileStream.BitmapInfoHeader.#ctor(System.Int32,System.Int32,Microsoft.VisualBasic.Imaging.BitmapImage.FileStream.BitsPerPixelEnum,System.Int32,System.Int32,System.Int32,Microsoft.VisualBasic.Imaging.BitmapImage.FileStream.CompressionMethod)">
 <summary>
 DIB header (bitmap information header)
 This is standard Windows BITMAPINFOHEADER as described here https://en.wikipedia.org/wiki/BMP_file_format#Bitmap_file_header
 </summary>
 <param name="width"></param>
 <param name="height"></param>
 <param name="bitsPerPixel"></param>
 <param name="rawImageSize"></param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.BitmapImage.FileStream.BitmapInfoHeaderRGBA.#ctor(System.Int32,System.Int32,Microsoft.VisualBasic.Imaging.BitmapImage.FileStream.BitsPerPixelEnum,System.Int32,System.Int32,System.Int32,Microsoft.VisualBasic.Imaging.BitmapImage.FileStream.CompressionMethod)">
 <summary>
 DIB header (bitmap information header)
 This is standard Windows BITMAPINFOHEADER as described here https://en.wikipedia.org/wiki/BMP_file_format#Bitmap_file_header
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.BitmapImage.FileStream.BitmapInfoHeaderRGBA.HeaderInfoBytes">
 <summary>
 This is BitmapInfoHeader for ARGB32 as described here https://en.wikipedia.org/wiki/BMP_file_format#Example_2
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.BitmapImage.RTCP">
 <summary>
 .NET Implement of Real-time Contrast Preserving Decolorization
 </summary>
 <remarks>
 https://github.com/IntPtrZero/RTCPRGB2Gray/tree/master
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.BitmapImage.RTCP.RTCPGrayGlobalWeightIndex(System.Byte[],System.Drawing.Size,System.Int32,System.Collections.Generic.List{System.Numerics.Vector3},System.Single)">
 <summary>
 
 </summary>
 <param name="bpBuffer"></param>
 <param name="bp"></param>
 <param name="stride"></param>
 <param name="W"></param>
 <param name="sigma"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.BitmapImage.RTCP.RTCPGray(Microsoft.VisualBasic.Imaging.Bitmap,System.Single)">
 <summary>
 .NET Implement of Real-time Contrast Preserving Decolorization
 </summary>
 <param name="inBitmap"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.BitmapImage.SaveGdiBitmap.Save(System.IO.Stream,Microsoft.VisualBasic.Imaging.ImageFormats)">
 <summary>
 <see cref="M:Microsoft.VisualBasic.Imaging.Image.Save(System.IO.Stream,Microsoft.VisualBasic.Imaging.ImageFormats)"/>
 </summary>
 <param name="stream"></param>
 <param name="format"></param>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.CMYKColor">
 <summary>
 The CMYK color model (also known as process color, or four color) 
 is a subtractive color model, based on the CMY color model, used 
 in color printing, and is also used to describe the printing process
 itself. The abbreviation CMYK refers to the four ink plates used: 
 cyan, magenta, yellow, and key (black).
 </summary>
 <remarks>
 All color channel in this color class should be in value range of ``[0,1]``.
 </remarks>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.CMYKColor.C">
 <summary>
 cyan
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.CMYKColor.M">
 <summary>
 magenta
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.CMYKColor.Y">
 <summary>
 yellow
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.CMYKColor.K">
 <summary>
 key (black)
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.CMYKColor.ToString">
 <summary>
 CMYK
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.ColorCube">
 <summary>
 Describes the RGB color space as a 3D cube with the origin at Black.
 </summary>
 <remarks>
 http://social.technet.microsoft.com/wiki/contents/articles/20990.generate-color-sequences-using-rgb-color-cube-in-vb-net.aspx
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.ColorCube.Compare(System.Drawing.Color,System.Drawing.Color)">
 <summary>
 Compares two colors according to their distance from the origin of the cube (black).
 </summary>
 <param name="source"></param>
 <param name="target"></param>
 <returns></returns>
 <remarks></remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.ColorCube.GetBrightness(System.Drawing.Color)">
 <summary>
 Returns an integer between 0 and 255 indicating the perceived brightness of the color.
 </summary>
 <param name="target">A System.Drawing.Color instance.</param>
 <returns>An integer indicating the brightness with 0 being dark and 255 being bright.</returns>
 <remarks>
 Formula found using web search at:
 http://www.nbdtech.com/Blog/archive/2008/04/27/Calculating-the-Perceived-Brightness-of-a-Color.aspx This link is external to TechNet Wiki. It will open in a new window.
 with reference to : http://alienryderflex.com/hsp.html This link is external to TechNet Wiki. It will open in a new window.
 Effectively the same as measuring a color's distance from black, but constrained to a 0-255 range.
 </remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.ColorCube.GetColorFrom(System.Int32,System.Int32,System.Int32)">
 <summary>
 Gets a color from within the cube starting at the origin and moving a given distance in the specified direction.
 </summary>
 <param name="azimuth">The side-to-side angle in degrees; 0 points toward red and 90 points toward blue.</param>
 <param name="elevation">The top-to-bottom angle in degrees; 0 is no green and 90 points toward full green.</param>
 <param name="distance">The distance to travel within the cube; 500 is max.</param>
 <returns>The color within the cube at the given distance in the specified direction.</returns>
 <remarks></remarks>
 
</member>
<member name="F:Microsoft.VisualBasic.Imaging.ColorCube.InvalidRange">
 <summary>
 Value must be between 0 and 90.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.ColorCube.GetColorFrom(System.Drawing.Color,System.Double,System.Double,System.Double,System.Boolean,System.Int32)">
 <summary>
 Gets a color from within the cube starting at the specified location and moving a given distance in the specified direction.
 </summary>
 <param name="source">The source location within the cube from which to start moving.</param>
 <param name="azimuth">The side-to-side angle in degrees; 0 points toward red and 90 points toward blue.</param>
 <param name="elevation">The top-to-bottom angle in degrees; 0 is no green and 90 points toward full green.</param>
 <param name="distance">The distance to travel within the cube; the approximate distance from black to white is 500.</param>
 <returns>The color within the cube at the given distance in the specified direction.</returns>
 <remarks></remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.ColorCube.GetColorsAround(System.Drawing.Color,System.Int32,System.Int32)">
 <summary>
 Creates an array of colors from a selection within a sphere around the specified color.
 </summary>
 <param name="target">The color to select around.</param>
 <param name="distance">The radius of the selection sphere.</param>
 <param name="increment">The increment within the sphere at which a selection is taken; larger numbers result in smaller selection sets.</param>
 <returns>An array of colors located around the specified color within the cube.</returns>
 <remarks></remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.ColorCube.GetColorSequence(System.Drawing.Color,System.Drawing.Color,System.Int32,System.Int32)">
 <summary>
 Creates an array of colors in a gradient sequence between two specified colors.
 </summary>
 <param name="source">The starting color in the sequence.</param>
 <param name="target">The end color in the sequence.</param>
 <param name="increment">The increment between colors.</param>
 <returns>A gradient array of colors.</returns>
 <remarks></remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.ColorCube.GetColorSpectrum(System.Int32)">
 <summary>
 Creates a rainbow array of colors by selecting from the edges of the cube in ROYGBIV order at the specified increment.
 </summary>
 <param name="increment">The increment along the edges at which a selection is taken; larger numbers result in smaller selection sets.</param>
 <returns>An array of colors in ROYGBIV order at the given increment.</returns>
 <remarks></remarks>
 
</member>
<member name="T:Microsoft.VisualBasic.Imaging.ColorMapsExtensions">
 <summary>
 Create Custom Color Maps
 </summary>
 <remarks>http://www.codeproject.com/Articles/18150/Create-Custom-Color-Maps-in-C</remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.ColorMapsExtensions.IsBlackOrWhite(System.Drawing.Color,System.Int32)">
 <summary>
 Is this given color value is near black or white
 </summary>
 <param name="c"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.ColorMapsExtensions.ColorSequence(Microsoft.VisualBasic.Imaging.ColorMap,System.String,System.Int32)">
 <summary>
 <paramref name="mapName"/>大小写不敏感
 </summary>
 <param name="mapName"></param>
 <param name="map"><see cref="P:Microsoft.VisualBasic.Imaging.ColorMap.MaxDepth"/></param>
 <param name="min">value should smaller than <see cref="P:Microsoft.VisualBasic.Imaging.ColorMap.MaxDepth"/> in parameter <paramref name="map"/></param>
 <returns></returns>
 
</member>
<member name="P:Microsoft.VisualBasic.Imaging.ColorMap.Alpha">
 <summary>
 Alpha value in the RBG color function.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.ColorMap.#ctor(System.Int32,System.Int32)">
 <summary>
 
 </summary>
 <param name="colorLength%"></param>
 <param name="alpha%"><see cref="P:System.Drawing.Color.A"/>: color alpha value</param>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.ColorMap.PatternSpring">
 <summary>
 Spring
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.ColorMap.PatternSummer">
 <summary>
 Summer
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.ColorMap.PatternAutumn">
 <summary>
 Autumn
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.ColorMap.PatternWinter">
 <summary>
 Winter
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.ColorMap.PatternJet">
 <summary>
 Jet
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.ColorMap.PatternGray">
 <summary>
 Gray
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.ColorMap.PatternHot">
 <summary>
 Hot
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.ColorMap.PatternCool">
 <summary>
 Cool
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.ColorMap.GetMaps(System.String,System.Boolean)">
 <summary>
 If failure, then this function will returns <see cref="M:Microsoft.VisualBasic.Imaging.ColorMap.Jet"/> by default, 
 or nothing if parameter <paramref name="noDefault"/> is set True.
 </summary>
 <param name="name">大小写不敏感</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.ColorMap.Jet">
 <summary>
 *
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.HexColor">
 <summary>
 Convert hex color string to RGB color
 </summary>
 <remarks>http://stackoverflow.com/questions/13356486/convert-hex-color-string-to-rgb-color</remarks>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.HexColor.ToHtmlColor(System.Drawing.Color,System.Boolean)">
 <summary>
 To HTML color
 </summary>
 <param name="color"></param>
 <returns></returns>
 <remarks>
 2020-12-06
 
 alpha value in html color is not supported, you will lost the 
 alpha value from this function when your color value is 
 translate to html color string.
 </remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.HexColor.ConvertToRbg(System.String)">
 <summary>
 Parse html color code as rgb color
 </summary>
 <param name="HexColor"></param>
 <returns>
 this function will returns <see cref="P:System.Drawing.Color.Black"/> if the given html color string is empty.
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.HexColor.OLE(System.String)">
 <summary>
 
 </summary>
 <param name="c">Example: ``#ffffff``</param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.GDIColors">
 <summary>
 Extensions function for the gdi+ color type.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.GDIColors.Middle(System.Drawing.Color,System.Drawing.Color)">
 <summary>
 ``<paramref name="x"/> -> <paramref name="y"/>``：返回两个颜色之间的中间的颜色，这个函数是某些插值操作所需要的
 </summary>
 <param name="x"></param>
 <param name="y"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.GDIColors.Alpha(System.Collections.Generic.IEnumerable{System.Drawing.Color},System.Int32)">
 <summary>
 调整所输入的这一组颜色的alpha值
 </summary>
 <param name="colors"></param>
 <param name="alphaValue%"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.GDIColors.Alpha(System.Drawing.Color,System.Int32)">
 <summary>
 adjust the color alpha value, ``alpha=[0, 255]``
 </summary>
 <param name="c"></param>
 <param name="alphaValue%"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.GDIColors.Average(System.Collections.Generic.IEnumerable{System.Drawing.Color})">
 <summary>
 Create an average color via the average value of the A,R,G,B channels
 </summary>
 <param name="colors"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.GDIColors.Lighten(System.Drawing.Color,System.Single)">
 <summary>
 Creates a new light color object for the control from the specified color and
 lightens it by the specified percentage.
 </summary>
 <param name="base">The <see cref="T:System.Drawing.Color"/> to be lightened.</param>
 <param name="percent!">The percentage to lighten the specified <see cref="T:System.Drawing.Color"/>.</param>
 <returns>A <see cref="T:System.Drawing.Color"/> that represents the light color on the control.</returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.GDIColors.Darken(System.Drawing.Color,System.Single)">
 <summary>
 Makes the specified color darker: creates a new dark color object for the control from the specified color and
 darkens it by the specified percentage.
 </summary>
 <param name="base">The <see cref="T:System.Drawing.Color"/> to be darkened.</param>
 <param name="percent!">
 The percentage to darken the specified <see cref="T:System.Drawing.Color"/>. By default is makes the color 50% darken.
 </param>
 <returns>A <see cref="T:System.Drawing.Color"/> that represent the dark color on the control.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.GDIColors.RGBExpression(System.Drawing.Color)">
 <summary>
 ``rgb(r,g,b)``
 </summary>
 <param name="c"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.GDIColors.ARGBExpression(System.Drawing.Color)">
 <summary>
 ``rgb(a,r,g,b)``
 </summary>
 <param name="c"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.GDIColors.Rgba(System.Drawing.Color)">
 <summary>
 html rgba color
 </summary>
 <param name="c"></param>
 <returns></returns>
 <remarks>
 |RGBA 成分|含义|取值范围|
 |---------|----|--------|
 |R (Red)|​红色通道的强度|0 - 255 的整数 或 0% - 100% 的百分比|
 |G (Green)|​绿色通道的强度|0 - 255 的整数 或 0% - 100% 的百分比|
 |B (Blue)|​蓝色通道的强度|0 - 255 的整数 或 0% - 100% 的百分比|
 |A (Alpha)|​透明度（或不透明度）|0.0（完全透明）到 1.0（完全不透明）之间的小数| 
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.GDIColors.__getDotNetColors">
 <summary>
 Reads all of the color property from <see cref="T:System.Drawing.Color"/> and 
 then creates the color dictionary based on the property name.
 </summary>
 <returns></returns>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.GDIColors.__allDotNETPrefixColors">
 <summary>
 Key都是小写的
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.GDIColors.AllDotNetPrefixColors">
 <summary>
 Gets all of the known name color from the Color object its shared property.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.GDIColors.ChartColors">
 <summary>
 经过人工筛选的颜色，不会出现过白或者过黑，过度相似的情况
 </summary>
 <returns></returns>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.GDIColors.rgbExprValues">
 <summary>
 Regex expression for parsing the rgb(a,r,g,b) expression of the color.(解析颜色表达式里面的RGB的正则表达式)
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.GDIColors.ToColor(System.String,System.Drawing.Color,System.Boolean,System.Boolean@)">
 <summary>
 <see cref="T:System.Drawing.Color"/>.Name, rgb(a,r,g,b)
 </summary>
 <param name="str">颜色表达式或者名称</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.GDIColors.TranslateColor(System.String,System.Boolean,System.Boolean@)">
 <summary>
 这个函数会尝试用不同的模式来解析颜色表达式
 </summary>
 <param name="exp">RGB expression/html color/ole color, etc</param>
 <returns>
 <see cref="P:System.Drawing.Color.Black"/> will be return if the <paramref name="exp"/> is null or empty,
 
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.GDIColors.IsColorExpression(System.String)">
 <summary>
 test of the given string expression is color value or not?
 </summary>
 <param name="expression">
 the color expression string for make asserts:
 
 1. html color: rgb(xxx)
 2. any color name
 3. integer ole color value
 4. #xxxxxx html color value
 
 </param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.GDIColors.IsNullOrEmpty(System.Drawing.Color)">
 <summary>
 Determine that the target color value is a empty variable.(判断目标颜色值是否为空值)
 </summary>
 <returns></returns>
 <remarks></remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.GDIColors.IsTransparent(System.Drawing.Color)">
 <summary>
 Check of the given color value is transparent color?
 </summary>
 <param name="c"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.GDIColors.Equals(System.Drawing.Color,System.Drawing.Color,System.Int32)">
 <summary>
 分别比较A,R,G,B这些属性值来判断这样个颜色对象值是否相等
 </summary>
 <param name="a"></param>
 <param name="b"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.GDIColors.EuclideanDistance(System.Drawing.Color,System.Drawing.Color)">
 <summary>
 Evaluate the color distance via euclidean distance
 </summary>
 <param name="a"></param>
 <param name="b"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.HSBColor">
 <summary>
 Provides methods for conversion between RGB and HSB color models
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.HSBColor.ToRgb(System.Double,System.Double,System.Double,System.Double@,System.Double@,System.Double@)">
 <summary>Converts HSB color model values to RGB values</summary>
 <param name="hue">Input <paramref name="hue"/> value range [0.0; 1.0]</param>
 <param name="saturation">Input <paramref name="saturation"/> value range [0.0; 1.0]</param>
 <param name="brightness">Input <paramref name="brightness"/> value range [0.0; 1.0]</param>
 <param name="red">Output <paramref name="red"/> channel value range [0.0; 1.0]</param>
 <param name="green">Output <paramref name="green"/> channel value range [0.0; 1.0]</param>
 <param name="blue">Output <paramref name="blue"/> channel value range [0.0; 1.0]</param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.HSBColor.FromRgb(System.Double,System.Double,System.Double,System.Double@,System.Double@,System.Double@)">
 <summary>Converts RGB color model values to HSB values</summary>
 <param name="red">Input <paramref name="red"/> channel value range [0.0; 1.0]</param>
 <param name="green">Input <paramref name="green"/> channel value range [0.0; 1.0]</param>
 <param name="blue">Input <paramref name="blue"/> channel value range [0.0; 1.0]</param>
 <param name="hue">Output <paramref name="hue"/> value range [0.0; 1.0]</param>
 <param name="saturation">Output <paramref name="saturation"/> value range [0.0; 1.0]</param>
 <param name="brightness">Output <paramref name="brightness"/> value range [0.0; 1.0]</param>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.HSLColor">
 <summary>
 Describes a RGB color in Hue, Saturation, and Luminance values.
 
 HSL (hue, saturation, lightness)
 SL (hue, saturation, lightness) and HSV (hue, saturation, value) 
 are alternative representations of the RGB color model
 https://en.wikipedia.org/wiki/HSL_and_HSV
 </summary>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.HSLColor.H">
 <summary>
 The color hue.
 </summary>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.HSLColor.S">
 <summary>
 The color saturation.
 </summary>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.HSLColor.L">
 <summary>
 The color luminance.
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.HSLColor.Lighten(System.Double,System.Drawing.Color)">
 <summary>
 Lighten target color composition.
 </summary>
 <param name="percentage"></param>
 <param name="lightColor"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.HSLColor.GetHSL(System.Drawing.Color)">
 <summary>
 Converts a RGB color into its Hue, Saturation, and Luminance (HSL) values.
 </summary>
 <param name="rgb">The color to convert.</param>
 <returns>The HSL representation of the color.</returns>
 <remarks>
 Source algorithm found using web search at:
 http://geekymonkey.com/Programming/CSharp/RGB2HSL_HSL2RGB.htm This link is external to TechNet Wiki. It will open in a new window.
 (Adapted to VB)
 </remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Driver.DeviceInterop.CreateCanvas2D(Microsoft.VisualBasic.Imaging.Bitmap,System.Boolean)">
 <summary>
 
 </summary>
 <param name="background"></param>
 <param name="direct_access">
 create the graphics canvas directly based on the input background image resource if set this parameter to true, 
 or make a copy of the image and then create the graphics canvas if set this parameter false.
 </param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Driver.DeviceInterop.GetData(Microsoft.VisualBasic.Imaging.IGraphics,System.Int32[])">
 <summary>
 
 </summary>
 <param name="g"></param>
 <param name="padding">
 the graphics drawing layout context information, should be an integer vector of paddings
 </param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Driver.DriverLoad.LoadFromStream(System.IO.Stream)">
 <summary>
 load image from stream data
 </summary>
 <param name="s"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Driver.DriverLoad.MeasureTextSize(System.String,Microsoft.VisualBasic.Imaging.Font)">
 <summary>
 A helper function for measure string size
 </summary>
 <param name="text"></param>
 <param name="font"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Driver.DriverLoad.DefaultGraphicsDevice(System.Nullable{Microsoft.VisualBasic.Imaging.Driver.Drivers})">
 <summary>
 用户所指定的图形引擎驱动程序类型，但是这个值会被开发人员设定的驱动程序类型的值所覆盖，
 通常情况下，默认引擎选用的是``gdi+``引擎
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Driver.Drivers">
 <summary>
 The imaging graphics engine list for <see cref="T:Microsoft.VisualBasic.Imaging.IGraphics"/>
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Driver.Drivers.Default">
 <summary>
 与具体上下文相关的。当用户从命令行参数之中设置了环境变量之后，这个Default的含义与用户所设置的驱动程序类型一致，但是会被程序开发人员所设置的类型值所覆盖
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Driver.Drivers.GDI">
 <summary>
 libgdi+ raster image model
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Driver.Drivers.SVG">
 <summary>
 mime type: image/svg+xml
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Driver.Drivers.WMF">
 <summary>
 Windows meta file
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Driver.Drivers.PDF">
 <summary>
 application/pdf
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Driver.Drivers.PostScript">
 <summary>
 The PostScript file format is a page description language (PDL) developed by Adobe Systems, Inc. It was first 
 introduced in 1982 and has since become a standard for printing and imaging in the graphics and publishing 
 industries. PostScript is a powerful and flexible format used primarily for printing high-quality text and
 graphics.
 
 Here are some key aspects of the PostScript file format:
 
 1. **Language-Based Format**: PostScript is not just a file format but a full-fledged programming language. 
    It includes a set of commands that describe how text, graphics, and images should be rendered on a page.
 2. **Device Independence**: One of the main advantages of PostScript is its device independence. This means
    that a PostScript file can be created on one device and then printed or displayed on another device without 
    needing to adjust the file for the specific characteristics of the output device.
 3. **Vector Graphics**: PostScript is particularly well-suited for vector graphics, which are defined by 
    mathematical equations rather than pixels. This allows for crisp, high-resolution output at any size.
 4. **Encapsulated PostScript (EPS)**: A variant of PostScript, EPS is a file format that can be used to exchange 
    graphics between different applications. EPS files can contain both vector and bitmap graphics and are often
    used for logos, illustrations, and other graphics that need to be integrated into larger documents.
 5. **Font Handling**: PostScript introduced sophisticated font handling, including the ability to scale and rotate 
    text. It also supports both Type 1 and Type 3 fonts, which are outline fonts that can be scaled to any size
    without losing quality.
 6. **Complex Page Layouts**: PostScript is capable of describing very complex page layouts, including text in 
    multiple columns, overlapping graphics, and nested objects.
 7. **Interpreted Language**: PostScript files are interpreted by a PostScript interpreter, which is typically 
    built into a printer or a raster image processor (RIP). The interpreter reads the PostScript commands and
    renders the page accordingly.
 8. **Compatibility**: While PostScript was once the dominant format for professional printing, its use has declined 
    somewhat with the rise of PDF (Portable Document Format), also developed by Adobe. However, PostScript remains 
    important in certain niches, and many printers and RIPs still support it.
 9. **File Extensions**: PostScript files commonly have the extensions .ps (for PostScript) or .eps (for Encapsulated PostScript).
 10. **Programming Features**: PostScript includes programming constructs such as variables, loops, and conditionals, 
     which allow for a high degree of automation and customization in the creation of documents.
     
 Despite the rise of other formats like PDF, PostScript still has a place in the world of digital printing and publishing, 
 particularly for applications where precise control over the output is required. It's also worth noting that many of the
 concepts and technologies introduced with PostScript laid the groundwork for later developments in digital graphics and 
 document management.
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Driver.GdiRasterGraphics">
 <summary>
 
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Driver.IGraphicsData.Driver">
 <summary>
 The graphics engine driver type indicator, 
 
 + for <see cref="F:Microsoft.VisualBasic.Imaging.Driver.Drivers.GDI"/> -> ImageData(<see cref="T:Microsoft.VisualBasic.Imaging.Image"/>, <see cref="T:Microsoft.VisualBasic.Imaging.Bitmap"/>)
 + for <see cref="F:Microsoft.VisualBasic.Imaging.Driver.Drivers.SVG"/> -> SVGData(SVGDocument)
 
 (驱动程序的类型)
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Driver.IGraphicsData.content_type">
 <summary>
 http content type
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Driver.IGraphicsData.Save(System.String)">
 <summary>
 Save the image graphics to file
 </summary>
 <param name="path$"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Driver.IGraphicsData.Save(System.IO.Stream)">
 <summary>
 Save the image graphics to a specific output stream
 </summary>
 <param name="out"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.FontFace">
 <summary>
 Font names collection
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.FontFace.MicrosoftYaHei">
 <summary>
 微软雅黑字体的名称
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.FontFace.PointSizeScale(System.Single,System.Single)">
 <summary>
 fix for dpi bugs on unix mono platform when create a font object.
 
 https://github.com/dotnet/runtime/issues/28361
 </summary>
 <param name="pointSize"></param>
 <param name="dpiResolution"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.FontFace.IsInstalled(System.String)">
 <summary>
 检查当前的操作系统之中是否安装有指定名称的字体
 </summary>
 <param name="name"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.FontFace.GetFontName(System.String,System.String)">
 <summary>
 由于字体名称的大小写敏感，所以假若是html css之类的渲染的话，由于可能会是小写的字体名称会导致无法
 正确的加载所需要的字体，所以可以使用这个函数来消除这种由于大小写敏感而带来的bug
 </summary>
 <param name="name$"></param>
 <param name="default">默认使用Windows10的默认字体</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.FontFace.MeasureString(System.String,Microsoft.VisualBasic.Imaging.Font)">
 <summary>
 A common shared method for measure text drawing size in gdi+ environment.
 </summary>
 <param name="s"></param>
 <param name="font"></param>
 <returns></returns>
 
</member>
<member name="T:Microsoft.VisualBasic.Imaging.DefaultFontValues">
 <summary>
 Default font values
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.GraphicsExtensions">
 <summary>
 GDI+
 </summary>

</member>
<member name="M:Microsoft.VisualBasic.Imaging.GraphicsExtensions.ParseImageFormat(System.String)">
 <summary>
 不存在的名称会返回<see cref="F:Microsoft.VisualBasic.Imaging.ImageFormats.Png"/>类型
 </summary>
 <param name="format$">大小写不敏感</param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.GraphicsExtensions.SaveAs(Microsoft.VisualBasic.Imaging.Image,System.String,Microsoft.VisualBasic.Imaging.ImageFormats,System.Boolean)">
 <summary>
 Saves this <see cref="T:Microsoft.VisualBasic.Imaging.Image"/> to the specified file in the specified format.
 (这个函数可以很容易的将图像对象保存为tiff文件)
 </summary>
 <param name="res">
 The image resource data that will be saved to the disk.
 (因为这个函数可能会被<see cref="P:Microsoft.VisualBasic.Imaging.Driver.GdiRasterGraphics.ImageResource"/>所调用，
 由于该属性的Set方法是不公开可见的，所以将会不兼容这个方法，如果这个
 参数被设置为ByRef的话)
 </param>
 <param name="path">path string</param>
 <param name="format">Image formats enumeration.</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.GraphicsExtensions.PointF(System.Collections.Generic.IEnumerable{System.Drawing.Point})">
 <summary>
 Make batch convert of <see cref="T:System.Drawing.Point"/> to <see cref="T:System.Drawing.PointF"/> object
 </summary>
 <param name="polygon"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.GraphicsExtensions.Opacity(System.Drawing.Color,System.Double)">
 <summary>
 
 </summary>
 <param name="fill"></param>
 <param name="val">a value in range ``[0, 1]``</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.GraphicsExtensions.Opacity(Microsoft.VisualBasic.Imaging.Brush,System.Double)">
 <summary>
 adjust the color opacity value of the <see cref="T:Microsoft.VisualBasic.Imaging.SolidBrush"/>
 </summary>
 <param name="fill"></param>
 <param name="val">
 the alpha value for <see cref="M:Microsoft.VisualBasic.Imaging.GraphicsExtensions.Opacity(Microsoft.VisualBasic.Imaging.Brush,System.Double)"/>, value in range ``[0, 1]``.
 </param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.GraphicsExtensions.GetBrush(System.String)">
 <summary>
 同时兼容颜色以及图片纹理画刷的创建
 </summary>
 <param name="res$"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.GraphicsExtensions.GetBrushes(System.Collections.Generic.IEnumerable{System.Drawing.Color})">
 <summary>
 Converts the colors into solidbrushes in batch.
 </summary>
 <param name="colors"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.GraphicsExtensions.DrawCircle(Microsoft.VisualBasic.Imaging.IGraphics@,Microsoft.VisualBasic.Imaging.Pen,System.Single,System.Single,System.Single,System.Boolean)">
 <summary>
 模仿Java之中的``DrawCircle``方法
 </summary>
 <param name="g"></param>
 <param name="color"></param>
 <param name="x!"></param>
 <param name="y!"></param>
 <param name="r!"></param>
 <param name="fill"></param>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.GraphicsExtensions.DrawCircle(Microsoft.VisualBasic.Imaging.IGraphics@,System.Drawing.PointF,System.Single,Microsoft.VisualBasic.Imaging.Brush)">
 <summary>
 a helper method for fill pie
 </summary>
 <param name="g"></param>
 <param name="centra"></param>
 <param name="r!"></param>
 <param name="color"></param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.GraphicsExtensions.DrawCircle(Microsoft.VisualBasic.Imaging.IGraphics@,System.Drawing.PointF,System.Single,Microsoft.VisualBasic.Imaging.Pen,System.Boolean)">
 <summary>
 进行圆的绘制
 </summary>
 <param name="g"></param>
 <param name="centra">圆心的坐标，这个函数之中会自动转换为<see cref="T:System.Drawing.Rectangle"/>的左上角位置坐标</param>
 <param name="r!">圆的半径</param>
 <param name="color">线条的颜色</param>
 <param name="fill">是否进行填充？</param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.GraphicsExtensions.EntireImage(Microsoft.VisualBasic.Imaging.Image)">
 <summary>
 返回整个图像的区域
 </summary>
 <param name="img"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.GraphicsExtensions.X(System.Collections.Generic.IEnumerable{System.Drawing.Point})">
 <summary>
 get x axis of the input geometry data
 </summary>
 <param name="pts"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.GraphicsExtensions.Y(System.Collections.Generic.IEnumerable{System.Drawing.Point})">
 <summary>
 get y axis of the input geometry data
 </summary>
 <param name="pts"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.GraphicsExtensions.LoadImage(System.String,System.Boolean,System.Boolean)">
 <summary>
 Load image from a file and then close the file handle.
 (使用<see cref="M:Microsoft.VisualBasic.Imaging.Image.FromStream(System.IO.Stream)"/>函数在加载完成图像到Dispose这段之间内都不会释放文件句柄，
 则使用这个函数则没有这个问题，在图片加载之后会立即释放掉文件句柄)
 </summary>
 <param name="path"></param>
 <returns>
 当参数<paramref name="throwEx"/>为false时候，函数返回空值的话，说明图片文件错误
 例如文件未下载完成或者发生了二进制移码
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.GraphicsExtensions.LoadImage(System.Byte[],System.Boolean)">
 <summary>
 cast the memory stream buffer as the gdi+ image
 </summary>
 <param name="rawStream"></param>
 <param name="throwEx"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.GraphicsExtensions.GetStreamBuffer(Microsoft.VisualBasic.Imaging.Image)">
 <summary>
 将图片对象转换为原始的字节流
 </summary>
 <param name="image"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.GraphicsExtensions.ColorReplace(Microsoft.VisualBasic.Imaging.Bitmap,System.Drawing.Color,System.Drawing.Color,System.Int32)">
 <summary>
 Color replace using memory pointer
 </summary>
 <param name="image"></param>
 <param name="subject"></param>
 <param name="replaceAs"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.GraphicsExtensions.ImageAddFrame(Microsoft.VisualBasic.Imaging.IGraphics,Microsoft.VisualBasic.Imaging.Pen,System.Int32)">
 <summary>
 Adding a frame box to the target image source.(为图像添加边框)
 </summary>
 <param name="canvas"></param>
 <param name="pen">Default pen width is 1px and with color <see cref="P:System.Drawing.Color.Black"/>.(默认的绘图笔为黑色的1个像素的边框)</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.GraphicsExtensions.IsValidGDIParameter(System.Drawing.Size)">
 <summary>
 both width and height in current size object must be greater than zero
 </summary>
 <param name="size"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.ImageTools.ImageCrop(Microsoft.VisualBasic.Imaging.Image,System.Drawing.Rectangle)">
 <summary>
 Crop an image 
 </summary>
 <param name="img">image to crop</param>
 <param name="cropArea">rectangle to crop</param>
 <returns>resulting image</returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.ImageTools.ImageCrop(Microsoft.VisualBasic.Imaging.Bitmap,System.Drawing.Rectangle)">
 <summary>
 Crop region on an bitmap image 
 </summary>
 <param name="bmpImage">bitmap image to crop</param>
 <param name="cropArea">rectangle to crop</param>
 <returns>resulting bitmap image object</returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.ImageTools.CorpBlank(Microsoft.VisualBasic.Imaging.Image,System.Int32,System.Drawing.Color,System.String)">
 <summary>
 将图像的多余的空白处给剪裁掉，确定边界，然后进行剪裁，使用这个函数需要注意下设置空白色，默认使用的空白色为<see cref="P:System.Drawing.Color.White"/>
 </summary>
 <param name="res"></param>
 <param name="margin"></param>
 <param name="blankColor">默认白色为空白色</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.ImageTools.CorpBlank(Microsoft.VisualBasic.Imaging.Bitmap,System.Int32,System.Drawing.Color,System.String)">
 <summary>
 将图像的多余的空白处给剪裁掉，确定边界，然后进行剪裁，使用这个函数需要注意下设置空白色，默认使用的空白色为<see cref="P:System.Drawing.Color.White"/>
 </summary>
 <param name="res"></param>
 <param name="margin"></param>
 <param name="blankColor">默认白色为空白色</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.ImageTools.CorpBlankInternal(Microsoft.VisualBasic.Imaging.Bitmap,System.Int32,System.Drawing.Color,System.Boolean,System.String)">
 <summary>
 将图像的多余的空白处给剪裁掉，确定边界，然后进行剪裁，使用这个函数需要注意下设置空白色，默认使用的空白色为<see cref="P:System.Drawing.Color.White"/>
 </summary>
 <param name="res"></param>
 <param name="margin"></param>
 <param name="blankColor">默认白色为空白色</param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.IGraphics">
 <summary>
 Encapsulates a GDI+(bitmap, wmf)/SVG etc drawing surface. This class must be inherited.
 </summary>
 <remarks>
 an default interface wrapper of the .NET gdi+ Graphics object
 </remarks>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.IGraphics.Size">
 <summary>
 the current canvas size in pixels: [width, height]
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.IGraphics.Driver">
 <summary>
 Get graphics driver code
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.IGraphics.Width">
 <summary>
 the image graphics width
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.IGraphics.Height">
 <summary>
 the image graphics height
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.IGraphics.Background">
 <summary>
 set background via <see cref="M:Microsoft.VisualBasic.Imaging.IGraphics.Clear(Microsoft.VisualBasic.Imaging.Brush)"/> method.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.IGraphics.Stroke">
 <summary>
 Default pen for drawing
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.IGraphics.Font">
 <summary>
 Default font value for text drawing
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.IGraphics.Dpi">
 <summary>
 max value of the [DpiX, DpiY]
 </summary>
 <returns></returns>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.IGraphics.m_isDisposed">
 <summary>
 use this flag for avoid multiple calls of the dispose/release handle method
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.IGraphics.#ctor(System.Int32)">
 <summary>
 config graphics canvas dpi
 </summary>
 <param name="dpi"></param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.IGraphics.#ctor(System.Drawing.Size)">
 <summary>
 config graphics canvas dpi
 </summary>
 <param name="dpiXY"></param>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.IGraphics.RenderingOrigin">
 <summary>
 Gets or sets the rendering origin of this System.Drawing.Graphics for dithering
 and for hatch brushes.
 </summary>
 <returns>
 A System.Drawing.Point structure that represents the dither origin for 8-bits-per-pixel
 and 16-bits-per-pixel dithering and is also used to set the origin for hatch
 brushes.
 </returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.IGraphics.TextContrast">
 <summary>
 Gets or sets the gamma correction value for rendering text.
 </summary>
 <returns>
 The gamma correction value used for rendering antialiased and ClearType text.
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.IGraphics.AddMetafileComment(System.Byte[])">
 <summary>
 Adds a comment to the current System.Drawing.Imaging.Metafile.
 </summary>
 <param name="data">
 Array of bytes that contains the comment.
 </param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.IGraphics.Clear(System.Drawing.Color)">
 <summary>
 Clears the entire drawing surface and fills it with the specified background
 color.
 </summary>
 <param name="color">
 <see cref="T:System.Drawing.Color"/> structure that represents the background color of the drawing
 surface.
 </param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.IGraphics.ClearCanvas(System.Drawing.Color)">
 <summary>
 Clears the entire drawing surface and fills it with the specified background
 color.
 </summary>
 <param name="color"></param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.IGraphics.Dispose">
 <summary>
 Releases all resources used by this System.Drawing.Graphics.    
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.IGraphics.DrawArc(Microsoft.VisualBasic.Imaging.Pen,System.Drawing.RectangleF,System.Single,System.Single)">
 <summary>
 Draws an arc representing a portion of an ellipse specified by a System.Drawing.RectangleF
 structure.
 </summary>
 <param name="pen">System.Drawing.Pen that determines the color, width, and style of the arc.</param>
 <param name="rect">System.Drawing.RectangleF structure that defines the boundaries of the ellipse.</param>
 <param name="startAngle">Angle in degrees measured clockwise from the x-axis to the starting point of
 the arc.</param>
 <param name="sweepAngle">Angle in degrees measured clockwise from the startAngle parameter to ending point
 of the arc.</param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.IGraphics.DrawArc(Microsoft.VisualBasic.Imaging.Pen,System.Drawing.Rectangle,System.Single,System.Single)">
 <summary>
 Draws an arc representing a portion of an ellipse specified by a System.Drawing.Rectangle
 structure.
 </summary>
 <param name="pen">System.Drawing.Pen that determines the color, width, and style of the arc.</param>
 <param name="rect">System.Drawing.RectangleF structure that defines the boundaries of the ellipse.</param>
 <param name="startAngle">Angle in degrees measured clockwise from the x-axis to the starting point of
 the arc.</param>
 <param name="sweepAngle">Angle in degrees measured clockwise from the startAngle parameter to ending point
 of the arc.</param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.IGraphics.DrawImage(Microsoft.VisualBasic.Imaging.Image,System.Drawing.Rectangle)">
 <summary>
 Draws the specified <see cref="T:Microsoft.VisualBasic.Imaging.Image"/> at the specified location and with the
 specified size.
 </summary>
 <param name="image">Image to draw.</param>
 <param name="rect">Rectangle structure that specifies the location and size of the
 drawn image.</param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.IGraphics.DrawImage(Microsoft.VisualBasic.Imaging.Image,System.Drawing.PointF)">
 <summary>
 Draws the specified <see cref="T:Microsoft.VisualBasic.Imaging.Image"/>, using its original physical size, at
 the specified location.
 </summary>
 <param name="image"><see cref="T:Microsoft.VisualBasic.Imaging.Image"/> to draw.</param>
 <param name="point"><see cref="T:System.Drawing.PointF"/> structure that represents the upper-left corner of the
 drawn image.</param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.IGraphics.DrawImage(Microsoft.VisualBasic.Imaging.Image,System.Drawing.RectangleF)">
 <summary>
 Draws the specified System.Drawing.Image at the specified location and with the
 specified size.
 </summary>
 <param name="image">Image to draw.</param>
 <param name="rect">RectangleF structure that specifies the location and size of the
 drawn image.</param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.IGraphics.DrawLine(Microsoft.VisualBasic.Imaging.Pen,System.Drawing.PointF,System.Drawing.PointF)">
 <summary>
 Draws a line connecting two System.Drawing.PointF structures.
 </summary>
 <param name="pen"><see cref="T:Microsoft.VisualBasic.Imaging.Pen"/> that determines the color, width, and style of the line.</param>
 <param name="pt1"><see cref="T:System.Drawing.PointF"/> structure that represents the first point to connect.</param>
 <param name="pt2"><see cref="T:System.Drawing.PointF"/> structure that represents the second point to connect.</param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.IGraphics.DrawLine(Microsoft.VisualBasic.Imaging.Pen,System.Drawing.Point,System.Drawing.Point)">
 <summary>
 Draws a line connecting two System.Drawing.Point structures.
 </summary>
 <param name="pen">System.Drawing.Pen that determines the color, width, and style of the line.</param>
 <param name="pt1">System.Drawing.Point structure that represents the first point to connect.</param>
 <param name="pt2">System.Drawing.Point structure that represents the second point to connect.</param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.IGraphics.DrawLine(Microsoft.VisualBasic.Imaging.Pen,System.Int32,System.Int32,System.Int32,System.Int32)">
 <summary>
 Draws a line connecting the two points specified by the coordinate pairs.
 </summary>
 <param name="pen">System.Drawing.Pen that determines the color, width, and style of the line.</param>
 <param name="x1">The x-coordinate of the first point.</param>
 <param name="y1">The y-coordinate of the first point.</param>
 <param name="x2">The x-coordinate of the second point.</param>
 <param name="y2">The y-coordinate of the second point.</param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.IGraphics.DrawLine(Microsoft.VisualBasic.Imaging.Pen,System.Single,System.Single,System.Single,System.Single)">
 <summary>
 Draws a line connecting the two points specified by the coordinate pairs.
 </summary>
 <param name="pen">System.Drawing.Pen that determines the color, width, and style of the line.</param>
 <param name="x1">The x-coordinate of the first point.</param>
 <param name="y1">The y-coordinate of the first point.</param>
 <param name="x2">The x-coordinate of the second point.</param>
 <param name="y2">The y-coordinate of the second point.</param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.IGraphics.DrawRectangle(Microsoft.VisualBasic.Imaging.Pen,System.Drawing.Rectangle)">
 <summary>
 Draws a rectangle specified by a System.Drawing.Rectangle structure.
 </summary>
 <param name="pen">A System.Drawing.Pen that determines the color, width, and style of the rectangle.</param>
 <param name="rect">A System.Drawing.Rectangle structure that represents the rectangle to draw.</param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.IGraphics.DrawRectangle(Microsoft.VisualBasic.Imaging.Pen,System.Single,System.Single,System.Single,System.Single)">
 <summary>
 Draws a rectangle specified by a coordinate pair, a width, and a height.
 </summary>
 <param name="pen">A System.Drawing.Pen that determines the color, width, and style of the rectangle.</param>
 <param name="x">The x-coordinate of the upper-left corner of the rectangle to draw.</param>
 <param name="y">The y-coordinate of the upper-left corner of the rectangle to draw.</param>
 <param name="width">The width of the rectangle to draw.</param>
 <param name="height">The height of the rectangle to draw.</param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.IGraphics.DrawRectangle(Microsoft.VisualBasic.Imaging.Pen,System.Int32,System.Int32,System.Int32,System.Int32)">
 <summary>
 Draws a rectangle specified by a coordinate pair, a width, and a height.
 </summary>
 <param name="pen">System.Drawing.Pen that determines the color, width, and style of the rectangle.</param>
 <param name="x">The x-coordinate of the upper-left corner of the rectangle to draw.</param>
 <param name="y">The y-coordinate of the upper-left corner of the rectangle to draw.</param>
 <param name="width">Width of the rectangle to draw.</param>
 <param name="height">Height of the rectangle to draw.</param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.IGraphics.DrawRectangles(Microsoft.VisualBasic.Imaging.Pen,System.Drawing.RectangleF[])">
 <summary>
 Draws a series of rectangles specified by System.Drawing.RectangleF structures.
 </summary>
 <param name="pen">System.Drawing.Pen that determines the color, width, and style of the outlines
 of the rectangles.</param>
 <param name="rects">Array of System.Drawing.RectangleF structures that represent the rectangles to
 draw.</param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.IGraphics.DrawRectangles(Microsoft.VisualBasic.Imaging.Pen,System.Drawing.Rectangle[])">
 <summary>
 Draws a series of rectangles specified by System.Drawing.Rectangle structures.
 </summary>
 <param name="pen">System.Drawing.Pen that determines the color, width, and style of the outlines
 of the rectangles.</param>
 <param name="rects">Array of System.Drawing.Rectangle structures that represent the rectangles to
 draw.</param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.IGraphics.DrawString(System.String,Microsoft.VisualBasic.Imaging.Font,Microsoft.VisualBasic.Imaging.Brush,System.Drawing.PointF@)">
 <summary>
 Draws the specified text string at the specified location with the specified
 <see cref="T:Microsoft.VisualBasic.Imaging.Brush"/> and <see cref="P:Microsoft.VisualBasic.Imaging.IGraphics.Font"/> objects.
 </summary>
 <param name="s">String to draw.</param>
 <param name="font">System.Drawing.Font that defines the text format of the string.</param>
 <param name="brush">System.Drawing.Brush that determines the color and texture of the drawn text.</param>
 <param name="point">System.Drawing.PointF structure that specifies the upper-left corner of the drawn
 text.</param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.IGraphics.DrawString(System.String,Microsoft.VisualBasic.Imaging.Font,Microsoft.VisualBasic.Imaging.Brush,System.Single,System.Single)">
 <summary>
 Draws the specified text string at the specified location with the specified
 System.Drawing.Brush and System.Drawing.Font objects.
 </summary>
 <param name="s">String to draw.</param>
 <param name="font">System.Drawing.Font that defines the text format of the string.</param>
 <param name="brush">System.Drawing.Brush that determines the color and texture of the drawn text.</param>
 <param name="x">The x-coordinate of the upper-left corner of the drawn text.</param>
 <param name="y">The y-coordinate of the upper-left corner of the drawn text.</param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.IGraphics.FillEllipse(Microsoft.VisualBasic.Imaging.Brush,System.Drawing.RectangleF)">
 <summary>
 Fills the interior of an ellipse defined by a bounding rectangle specified by
 a System.Drawing.RectangleF structure.
 </summary>
 <param name="brush">System.Drawing.Brush that determines the characteristics of the fill.</param>
 <param name="rect">System.Drawing.RectangleF structure that represents the bounding rectangle that
 defines the ellipse.</param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.IGraphics.FillPath(Microsoft.VisualBasic.Imaging.Brush,Microsoft.VisualBasic.Imaging.GraphicsPath)">
 <summary>
 Fills the interior of a System.Drawing.Drawing2D.GraphicsPath.
 </summary>
 <param name="brush">System.Drawing.Brush that determines the characteristics of the fill.</param>
 <param name="path">System.Drawing.Drawing2D.GraphicsPath that represents the path to fill.</param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.IGraphics.FillPie(Microsoft.VisualBasic.Imaging.Brush,System.Drawing.RectangleF,System.Single,System.Single)">
 <summary>
 Fills the interior of a pie section defined by an ellipse specified by a System.Drawing.RectangleF
 structure and two radial lines.
 </summary>
 <param name="brush">System.Drawing.Brush that determines the characteristics of the fill.</param>
 <param name="rect"><see cref="T:System.Drawing.RectangleF"/> structure that represents the bounding rectangle that
 defines the ellipse from which the pie section comes.</param>
 <param name="startAngle">Angle in degrees measured clockwise from the x-axis to the first side of the
 pie section.</param>
 <param name="sweepAngle">Angle in degrees measured clockwise from the startAngle parameter to the second
 side of the pie section.</param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.IGraphics.FillPie(Microsoft.VisualBasic.Imaging.Brush,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
 <summary>
 Fills the interior of a pie section defined by an ellipse specified by a pair
 of coordinates, a width, a height, and two radial lines.
 </summary>
 <param name="brush">System.Drawing.Brush that determines the characteristics of the fill.</param>
 <param name="x">The x-coordinate of the upper-left corner of the bounding rectangle that defines
 the ellipse from which the pie section comes.</param>
 <param name="y">The y-coordinate of the upper-left corner of the bounding rectangle that defines
 the ellipse from which the pie section comes.</param>
 <param name="width">Width of the bounding rectangle that defines the ellipse from which the pie section
 comes.</param>
 <param name="height">Height of the bounding rectangle that defines the ellipse from which the pie
 section comes.</param>
 <param name="startAngle">Angle in degrees measured clockwise from the x-axis to the first side of the
 pie section.</param>
 <param name="sweepAngle">Angle in degrees measured clockwise from the startAngle parameter to the second
 side of the pie section.</param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.IGraphics.FillPie(Microsoft.VisualBasic.Imaging.Brush,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
 <summary>
 Fills the interior of a pie section defined by an ellipse specified by a pair
 of coordinates, a width, a height, and two radial lines.
 </summary>
 <param name="brush">System.Drawing.Brush that determines the characteristics of the fill.</param>
 <param name="x">The x-coordinate of the upper-left corner of the bounding rectangle that defines
 the ellipse from which the pie section comes.</param>
 <param name="y">The y-coordinate of the upper-left corner of the bounding rectangle that defines
 the ellipse from which the pie section comes.</param>
 <param name="width">Width of the bounding rectangle that defines the ellipse from which the pie section
 comes.</param>
 <param name="height">Height of the bounding rectangle that defines the ellipse from which the pie
 section comes.</param>
 <param name="startAngle">Angle in degrees measured clockwise from the x-axis to the first side of the
 pie section.</param>
 <param name="sweepAngle">Angle in degrees measured clockwise from the startAngle parameter to the second
 side of the pie section.</param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.IGraphics.FillPolygon(Microsoft.VisualBasic.Imaging.Brush,System.Drawing.Point[])">
 <summary>
 Fills the interior of a polygon defined by an array of points specified by System.Drawing.Point
 structures.
 </summary>
 <param name="brush">System.Drawing.Brush that determines the characteristics of the fill.</param>
 <param name="points">Array of System.Drawing.Point structures that represent the vertices of the polygon
 to fill.</param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.IGraphics.FillPolygon(Microsoft.VisualBasic.Imaging.Brush,System.Drawing.PointF[])">
 <summary>
 Fills the interior of a polygon defined by an array of points specified by System.Drawing.PointF
 structures.
 </summary>
 <param name="brush">System.Drawing.Brush that determines the characteristics of the fill.</param>
 <param name="points">Array of System.Drawing.PointF structures that represent the vertices of the
 polygon to fill.</param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.IGraphics.FillRectangle(Microsoft.VisualBasic.Imaging.Brush,System.Drawing.Rectangle)">
 <summary>
 Fills the interior of a rectangle specified by a <see cref="T:System.Drawing.Rectangle"/> structure.
 </summary>
 <param name="brush">System.Drawing.Brush that determines the characteristics of the fill.</param>
 <param name="rect">System.Drawing.Rectangle structure that represents the rectangle to fill.</param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.IGraphics.FillRectangle(Microsoft.VisualBasic.Imaging.Brush,System.Single,System.Single,System.Drawing.SizeF)">
 <summary>
 <see cref="M:Microsoft.VisualBasic.Imaging.IGraphics.FillRectangle(Microsoft.VisualBasic.Imaging.Brush,System.Drawing.RectangleF)"/> extensions
 </summary>
 <param name="brush"></param>
 <param name="x!"></param>
 <param name="y!"></param>
 <param name="size"></param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.IGraphics.FillRectangle(Microsoft.VisualBasic.Imaging.Brush,System.Drawing.RectangleF)">
 <summary>
 Fills the interior of a rectangle specified by a <see cref="T:System.Drawing.RectangleF"/> structure.
 </summary>
 <param name="brush">
 <see cref="T:Microsoft.VisualBasic.Imaging.Brush"/> that determines the characteristics of the fill.
 </param>
 <param name="rect">
 <see cref="T:System.Drawing.RectangleF"/> structure that represents the rectangle to fill.
 </param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.IGraphics.FillRectangle(Microsoft.VisualBasic.Imaging.Brush,System.Int32,System.Int32,System.Int32,System.Int32)">
 <summary>
 Fills the interior of a rectangle specified by a pair of coordinates, a width,
 and a height.
 </summary>
 <param name="brush">System.Drawing.Brush that determines the characteristics of the fill.</param>
 <param name="x">The x-coordinate of the upper-left corner of the rectangle to fill.</param>
 <param name="y">The y-coordinate of the upper-left corner of the rectangle to fill.</param>
 <param name="width">Width of the rectangle to fill.</param>
 <param name="height">Height of the rectangle to fill.</param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.IGraphics.FillRectangle(Microsoft.VisualBasic.Imaging.Brush,System.Single,System.Single,System.Single,System.Single)">
 <summary>
 Fills the interior of a rectangle specified by a pair of coordinates, a width,
 and a height.
 </summary>
 <param name="brush">System.Drawing.Brush that determines the characteristics of the fill.</param>
 <param name="x">The x-coordinate of the upper-left corner of the rectangle to fill.</param>
 <param name="y">The y-coordinate of the upper-left corner of the rectangle to fill.</param>
 <param name="width">Width of the rectangle to fill.</param>
 <param name="height">Height of the rectangle to fill.</param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.IGraphics.FillRectangles(Microsoft.VisualBasic.Imaging.Brush,System.Drawing.RectangleF[])">
 <summary>
 Fills the interiors of a series of rectangles specified by System.Drawing.Rectangle
 structures.
 </summary>
 <param name="brush">System.Drawing.Brush that determines the characteristics of the fill.</param>
 <param name="rects">Array of System.Drawing.Rectangle structures that represent the rectangles to
 fill.</param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.IGraphics.FillRectangles(Microsoft.VisualBasic.Imaging.Brush,System.Drawing.Rectangle[])">
 <summary>
 Fills the interiors of a series of rectangles specified by System.Drawing.Rectangle
 structures.
 </summary>
 <param name="brush">System.Drawing.Brush that determines the characteristics of the fill.</param>
 <param name="rects">Array of System.Drawing.Rectangle structures that represent the rectangles to
 fill.</param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.IGraphics.Flush">
 <summary>
 Forces execution of all pending graphics operations and returns immediately without
 waiting for the operations to finish.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.IGraphics.GetContextInfo">
 <summary>
 Gets the cumulative graphics context.
 </summary>
 <returns>
 An System.Object representing the cumulative graphics context.
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.IGraphics.IsVisible(System.Drawing.PointF)">
 <summary>
 Indicates whether the specified System.Drawing.PointF structure is contained
 within the visible clip region of this System.Drawing.Graphics.
 </summary>
 <param name="point">System.Drawing.PointF structure to test for visibility.</param>
 <returns>
 true if the point specified by the point parameter is contained within the visible
 clip region of this System.Drawing.Graphics; otherwise, false.
 </returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.IGraphics.IsVisible(System.Drawing.Point)">
 <summary>
 Indicates whether the specified System.Drawing.Point structure is contained within
 the visible clip region of this System.Drawing.Graphics.
 </summary>
 <param name="point">System.Drawing.Point structure to test for visibility.</param>
 <returns>
 true if the point specified by the point parameter is contained within the visible
 clip region of this System.Drawing.Graphics; otherwise, false.
 </returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.IGraphics.IsVisible(System.Single,System.Single)">
 <summary>
 Indicates whether the point specified by a pair of coordinates is contained within
 the visible clip region of this System.Drawing.Graphics.
 </summary>
 <param name="x">The x-coordinate of the point to test for visibility.</param>
 <param name="y">The y-coordinate of the point to test for visibility.</param>
 <returns>
 true if the point defined by the x and y parameters is contained within the visible
 clip region of this System.Drawing.Graphics; otherwise, false.
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.IGraphics.IsVisible(System.Int32,System.Int32)">
 <summary>
 Indicates whether the point specified by a pair of coordinates is contained within
 the visible clip region of this System.Drawing.Graphics.
 </summary>
 <param name="x">The x-coordinate of the point to test for visibility.</param>
 <param name="y">The y-coordinate of the point to test for visibility.</param>
 <returns>
 true if the point defined by the x and y parameters is contained within the visible
 clip region of this System.Drawing.Graphics; otherwise, false.
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.IGraphics.IsVisible(System.Single,System.Single,System.Single,System.Single)">
 <summary>
 Indicates whether the rectangle specified by a pair of coordinates, a width,
 and a height is contained within the visible clip region of this System.Drawing.Graphics.
 </summary>
 <param name="x">The x-coordinate of the upper-left corner of the rectangle to test for visibility.</param>
 <param name="y">The y-coordinate of the upper-left corner of the rectangle to test for visibility.</param>
 <param name="width">Width of the rectangle to test for visibility.</param>
 <param name="height">Height of the rectangle to test for visibility.</param>
 <returns>true if the rectangle defined by the x, y, width, and height parameters is contained
 within the visible clip region of this System.Drawing.Graphics; otherwise, false.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.IGraphics.MeasureString(System.String,Microsoft.VisualBasic.Imaging.Font)">
 <summary>
 Measures the specified string when drawn with the specified <see cref="P:Microsoft.VisualBasic.Imaging.IGraphics.Font"/>.
 </summary>
 <param name="text">String to measure.</param>
 <param name="font"><see cref="P:Microsoft.VisualBasic.Imaging.IGraphics.Font"/> that defines the text format of the string.</param>
 <returns>This method returns a <see cref="M:Microsoft.VisualBasic.Imaging.GraphicsExtensions.SizeF(System.Drawing.Size)"/> structure that represents the size,
 in the units specified by the PageUnit property, of the
 string specified by the text parameter as drawn with the font parameter.
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.IGraphics.MeasureString(System.String,Microsoft.VisualBasic.Imaging.Font,System.Int32)">
 <summary>
 Measures the specified string when drawn with the specified System.Drawing.Font.
 </summary>
 <param name="text">String to measure.</param>
 <param name="font">System.Drawing.Font that defines the format of the string.</param>
 <param name="width">Maximum width of the string in pixels.</param>
 <returns>This method returns a System.Drawing.SizeF structure that represents the size,
 in the units specified by the System.Drawing.Graphics.PageUnit property, of the
 string specified in the text parameter as drawn with the font parameter.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.IGraphics.MeasureString(System.String,Microsoft.VisualBasic.Imaging.Font,System.Drawing.SizeF)">
 <summary>
 Measures the specified string when drawn with the specified System.Drawing.Font
 within the specified layout area.
 </summary>
 <param name="text">String to measure.</param>
 <param name="font">System.Drawing.Font defines the text format of the string.</param>
 <param name="layoutArea">System.Drawing.SizeF structure that specifies the maximum layout area for the
 text.</param>
 <returns>This method returns a System.Drawing.SizeF structure that represents the size,
 in the units specified by the System.Drawing.Graphics.PageUnit property, of the
 string specified by the text parameter as drawn with the font parameter.</returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.LayoutModel.ILayoutedObject`1">
 <summary>
 Any typed object with a location layout value
 </summary>
 <typeparam name="T"></typeparam>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.LayoutModel.ColaExtensions.rayIntersection(Microsoft.VisualBasic.Imaging.LayoutModel.Rectangle2D,System.Double,System.Double)">
 <summary>
 return any intersection points between a line extending from the centre of this rectangle to the given point,
 And the sides of this rectangle
 </summary>
 <param name="x2">second x coord of line</param>
 <param name="y2">second y coord of line</param>
 <returns>any intersection points found</returns>
 
</member>
<member name="T:Microsoft.VisualBasic.Imaging.LayoutModel.Point2D">
 <summary>
 Implements a 2-dimensional point with <see cref="T:System.Double"/> precision coordinates.
 </summary>
 <remarks>
 这个数据对象主要是用来储存作图的原始数据
 因为如果作图的原始数据值很高的话，往往会超过single的上限，所以会需要使用double
 类型的数据进行存储，在经过绘图函数的scale之后，就可以转换为pointf对象进行作图了
 </remarks>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.LayoutModel.Point2D.X">
 <summary>
 Returns the x-coordinate of the point.
 </summary>
 <returns> Returns the x-coordinate. </returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.LayoutModel.Point2D.Y">
 <summary>
 Returns the x-coordinate of the point.
 </summary>
 <returns> Returns the x-coordinate. </returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.LayoutModel.Point2D.Point">
 <summary>
 Returns the coordinates as a new point.
 </summary>
 <returns> Returns a new point for the location. </returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.LayoutModel.Point2D.#ctor">
 <summary>
 Constructs a new point at (0, 0).
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.LayoutModel.Point2D.#ctor(System.Drawing.Point)">
 <summary>
 Constructs a new point at the location of the given point.
 </summary>
 <param name="point"> Point that specifies the location. </param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.LayoutModel.Point2D.#ctor(Microsoft.VisualBasic.Imaging.LayoutModel.Point2D)">
 <summary>
 Constructs a new point at the location of the given point.
 </summary>
 <param name="point"> Point that specifies the location. </param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.LayoutModel.Point2D.#ctor(System.Double,System.Double)">
 <summary>
 Constructs a new point at (x, y).
 </summary>
 <param name="x"> X-coordinate of the point to be created. </param>
 <param name="y"> Y-coordinate of the point to be created. </param>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.LayoutModel.Point2D.Equals(System.Object)">
 
 <summary>
 Returns true if the given object equals this rectangle.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.LayoutModel.Point2D.Clone">
 <summary>
 Returns a new instance of the same point.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.LayoutModel.Point2D.ToString">
 <summary>
 Returns a <code>String</code> that represents the value
 of this <code>mxPoint</code>. </summary>
 <returns> a string representation of this <code>mxPoint</code>. </returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.LayoutModel.Rectangle2D">
 <summary>
 Implements a 2-dimensional rectangle with double precision coordinates.
 </summary>
 <remarks>
 除了左上角+宽和高这种方式进行矩形区域的定义，还可以用左上角+右下角的方式来定义一个矩形
 </remarks>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.LayoutModel.Rectangle2D.Width">
 <summary>
 Returns the width of the rectangle.
 </summary>
 <returns> Returns the width. </returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.LayoutModel.Rectangle2D.Height">
 <summary>
 Returns the height of the rectangle.
 </summary>
 <returns> Returns the height. </returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.LayoutModel.Rectangle2D.CenterX">
 <summary>
 Returns the x-coordinate of the center.
 </summary>
 <returns> Returns the x-coordinate of the center. </returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.LayoutModel.Rectangle2D.CenterY">
 <summary>
 Returns the y-coordinate of the center.
 </summary>
 <returns> Returns the y-coordinate of the center. </returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.LayoutModel.Rectangle2D.Bottom">
 <summary>
 底部的``Y``坐标值
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.LayoutModel.Rectangle2D.Rectangle">
 <summary>
 Returns the bounds as a new rectangle.
 </summary>
 <returns> Returns a new rectangle for the bounds. </returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.LayoutModel.Rectangle2D.#ctor">
 <summary>
 Constructs a new rectangle at (0, 0) with the width and height set to 0.
 </summary>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.LayoutModel.Rectangle2D.#ctor(System.Drawing.Rectangle)">
 <summary>
 Constructs a copy of the given rectangle.
 </summary>
 <param name="rect"> Rectangle to construct a copy of. </param>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.LayoutModel.Rectangle2D.#ctor(System.Drawing.RectangleF)">
 <summary>
 Constructs a copy of the given rectangle.
 </summary>
 <param name="rect"> Rectangle to construct a copy of. </param>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.LayoutModel.Rectangle2D.#ctor(Microsoft.VisualBasic.Imaging.LayoutModel.Rectangle2D)">
 <summary>
 Constructs a copy of the given rectangle.
 </summary>
 <param name="rect"> Rectangle to construct a copy of. </param>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.LayoutModel.Rectangle2D.#ctor(System.Double,System.Double,System.Double,System.Double)">
 <summary>
 Constructs a rectangle using the given parameters.
 </summary>
 <param name="x"> X-coordinate of the new rectangle. </param>
 <param name="y"> Y-coordinate of the new rectangle. </param>
 <param name="width"> Width of the new rectangle. </param>
 <param name="height"> Height of the new rectangle. </param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.LayoutModel.Rectangle2D.setRect(System.Double,System.Double,System.Double,System.Double)">
 <summary>
 Sets this rectangle to the specified values
 </summary>
 <param name="x"> the new x-axis position </param>
 <param name="y"> the new y-axis position </param>
 <param name="w"> the new width of the rectangle </param>
 <param name="h"> the new height of the rectangle </param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.LayoutModel.Rectangle2D.add(Microsoft.VisualBasic.Imaging.LayoutModel.Rectangle2D)">
 <summary>
 Adds the given rectangle to this rectangle. Union two rectangle.
 (取两个区域的交集部分，并且这个函数会改变当前的这个矩形对象的值)
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.LayoutModel.Rectangle2D.union(Microsoft.VisualBasic.Imaging.LayoutModel.Rectangle2D)">
 <summary>
 这个函数的功能和<see cref="M:Microsoft.VisualBasic.Imaging.LayoutModel.Rectangle2D.add(Microsoft.VisualBasic.Imaging.LayoutModel.Rectangle2D)"/>函数几乎一致，只不过这个函数返回新的<see cref="T:Microsoft.VisualBasic.Imaging.LayoutModel.Rectangle2D"/>
 而非修改自身的值
 </summary>
 <param name="rect"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.LayoutModel.Rectangle2D.grow(System.Double)">
 <summary>
 Grows the rectangle by the given amount, that is, this method subtracts
 the given amount from the x- and y-coordinates and adds twice the amount
 to the width and height.
 
 ``inflate(pad: number): Rectangle``
 </summary>
 <param name="amount"> Amount by which the rectangle should be grown. </param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.LayoutModel.Rectangle2D.contains(System.Double,System.Double)">
 <summary>
 Returns true if the given point is contained in the rectangle.
 </summary>
 <param name="x"> X-coordinate of the point. </param>
 <param name="y"> Y-coordinate of the point. </param>
 <returns> Returns true if the point is contained in the rectangle.</returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.LayoutModel.Rectangle2D.intersectLine(System.Double,System.Double,System.Double,System.Double)">
 <summary>
 Returns the point at which the specified point intersects the perimeter 
 of this rectangle or null if there is no intersection.
 </summary>
 <param name="x0"> the x co-ordinate of the first point of the line </param>
 <param name="y0"> the y co-ordinate of the first point of the line </param>
 <param name="x1"> the x co-ordinate of the second point of the line </param>
 <param name="y1"> the y co-ordinate of the second point of the line </param>
 <returns>
 The point at which the line intersects this rectangle, or null if there is no intersection 
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.LayoutModel.Rectangle2D.intersection(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
 <summary>
 Returns the intersection of two lines as an mxPoint.
 </summary>
 <param name="x0">X-coordinate of the first line's startpoint.</param>
 <param name="y0">Y-coordinate of the first line's startpoint.</param>
 <param name="x1">X-coordinate of the first line's endpoint.</param>
 <param name="y1">Y-coordinate of the first line's endpoint.</param>
 <param name="x2">X-coordinate of the second line's startpoint.</param>
 <param name="y2">Y-coordinate of the second line's startpoint.</param>
 <param name="x3">X-coordinate of the second line's endpoint.</param>
 <param name="y3">Y-coordinate of the second line's endpoint.</param>
 <returns> Returns the intersection between the two lines.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.LayoutModel.Rectangle2D.Equals(System.Object)">
 <summary>
 Returns true if the given object value equals this rectangle.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.LayoutModel.Rectangle2D.Clone">
 <summary>
 Returns a new instance of the same rectangle.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.LayoutModel.Rectangle2D.ToString">
 <summary>
 Returns the <code>String</code> representation of this
 <code>mxRectangle</code>. </summary>
 <returns> a <code>String</code> representing this
 <code>mxRectangle</code>. </returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.LayoutModel.Rectangle2D.Vertices">
 <summary>
 枚举出当前的这个矩形对象之中的4个顶点坐标
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.ImageFormats">
 <summary>
 Specifies the file format of the image.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.ImageFormats.Bmp">
 <summary>
 Gets the bitmap (BMP) image format.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.ImageFormats.Emf">
 <summary>
 Gets the enhanced metafile (EMF) image format.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.ImageFormats.Exif">
 <summary>
 Gets the Exchangeable Image File (Exif) format.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.ImageFormats.Gif">
 <summary>
 Gets the Graphics Interchange Format (GIF) image format.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.ImageFormats.Icon">
 <summary>
 Gets the Windows icon image format.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.ImageFormats.Jpeg">
 <summary>
 Gets the Joint Photographic Experts Group (JPEG) image format.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.ImageFormats.MemoryBmp">
 <summary>
 Gets the format of a bitmap in memory.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.ImageFormats.Png">
 <summary>
 Gets the W3C Portable Network Graphics (PNG) image format.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.ImageFormats.Tiff">
 <summary>
 Gets the Tagged Image File Format (TIFF) image format.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.ImageFormats.Wmf">
 <summary>
 Gets the Windows metafile (WMF) image format.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.ImageFormats.Base64">
 <summary>
 Base64
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.ImageFormats.PS">
 <summary>
 postscript
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Math2D.AffineTransform">
 <summary>
 2D Affine Transformation parameters.
 This represents a more general transform than similarity, allowing for non-uniform scaling and shearing.
 x' = ax + by + c
 y' = dx + ey + f
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Math2D.AffineTransform.a">
 <summary>
 The ‘a’ parameter in x’ = ax + by + c
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Math2D.AffineTransform.b">
 <summary>
 The ‘b’ parameter in x’ = ax + by + c
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Math2D.AffineTransform.c">
 <summary>
 The ‘c’ parameter (translation x) in x’ = ax + by + c
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Math2D.AffineTransform.d">
 <summary>
 The ‘d’ parameter in y’ = dx + ey + f
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Math2D.AffineTransform.e">
 <summary>
 The ‘e’ parameter in y’ = dx + ey + f
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Math2D.AffineTransform.f">
 <summary>
 The ‘f’ parameter (translation y) in y’ = dx + ey + f
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.AffineTransform.#ctor">
 <summary>
 Creates an identity (no-op) transform.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.AffineTransform.ApplyToPoint(System.Drawing.PointF)">
 <summary>
 Applies this transform to a point.
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Math2D.GeometryMath">
 <summary>
 https://stackoverflow.com/questions/30080/how-to-know-if-a-line-intersects-a-plane-in-c-basic-2d-geometry
 
 与几何相关的辅助类
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.GeometryMath.angleBetween2Lines(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
 <summary>
 cos(a,b)
 </summary>
 <param name="x1#"></param>
 <param name="y1#"></param>
 <param name="z1#"></param>
 <param name="x2#"></param>
 <param name="y2#"></param>
 <param name="z2#"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.GeometryMath.IntersectionOf(Microsoft.VisualBasic.Imaging.Math2D.Line,Microsoft.VisualBasic.Imaging.Math2D.Polygon2D)">
 <summary>
 判断线段与多边形的关系
 </summary>
 <param name="line"></param>
 <param name="polygon"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.GeometryMath.IntersectionOf(System.Drawing.PointF,Microsoft.VisualBasic.Imaging.Math2D.Polygon2D)">
 <summary>
 判断点与多边形的关系
 </summary>
 <param name="point"></param>
 <param name="polygon"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.GeometryMath.IntersectionOf(System.Drawing.PointF,Microsoft.VisualBasic.Imaging.Math2D.Line)">
 <summary>
 判断点与直线的关系
 </summary>
 <param name="point"></param>
 <param name="line"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.GeometryMath.IntersectionOf(Microsoft.VisualBasic.Imaging.Math2D.Line,Microsoft.VisualBasic.Imaging.Math2D.Line,System.Drawing.PointF@)">
 <summary>
 判断直线与直线的关系
 </summary>
 <param name="line1"></param>
 <param name="line2"></param>
 <param name="i">可以从这个参数取得交点</param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.GeometryMath.GetLineIntersection(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Drawing.PointF@)">
 <summary>
 + [(<paramref name="AX"/>, <paramref name="AY"/>), (<paramref name="BX"/>, <paramref name="BY"/>)]
 + [(<paramref name="CX"/>, <paramref name="CY"/>), (<paramref name="DX"/>, <paramref name="DY"/>)]
 </summary>
 <param name="AX!"></param>
 <param name="AY!"></param>
 <param name="BX!"></param>
 <param name="BY!"></param>
 <param name="CX!"></param>
 <param name="CY!"></param>
 <param name="DX!"></param>
 <param name="DY!"></param>
 <param name="i">可以从这个参数取得交点</param>
 <returns></returns>
 <remarks>
 https://stackoverflow.com/questions/563198/how-do-you-detect-where-two-line-segments-intersect/565282#
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.GeometryMath.QuadrantRegion(System.Double)">
 <summary>
 获取角度所指向的象限位置
 </summary>
 <param name="degree"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.GeometryMath.QuadrantRegion(System.Drawing.PointF,System.Drawing.PointF,System.Single)">
 <summary>
 获取坐标点相对于原点<paramref name="origin"/>的象限位置
 </summary>
 <param name="origin"></param>
 <param name="p"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Math2D.GeometryTransform">
 <summary>
 make geometry transform of a given <see cref="T:Microsoft.VisualBasic.Imaging.Math2D.Polygon2D"/> with given <see cref="T:Microsoft.VisualBasic.Imaging.Math2D.Transform"/> 
 or <see cref="T:Microsoft.VisualBasic.Imaging.Math2D.AffineTransform"/> parameters.
 </summary>
 <remarks>
 + `Transform` (相似变换)** 是 **`AffineTransform` (仿射变换)** 的一个特例：从 Transform 到 AffineTransform：总是可以。因为 Transform 类所描述的变换（旋转、平移、缩放）是 AffineTransform 类（仿射变换）的一个子集。任何相似变换都可以用一个仿射变换矩阵来表示。
 + `Transform` -> `AffineTransform`** 的转换是直接且总是可行的：从 AffineTransform 到 Transform：不一定可以。只有当 AffineTransform 不包含剪切效果时，才可以等价转换为一个 Transform 对象。如果 AffineTransform 包含剪切，那么它无法用 theta, scalex, scaley 这几个参数来唯一描述。
 + `AffineTransform` -> `Transform`** 的转换需要检查是否存在剪切。通过检查矩阵左上角 2x2 部分的两个列向量是否正交（`a*b + d*e ≈ 0`）来判断。
 
 ### 变换的矩阵表示
 
 一个 2D 点 (x, y) 用齐次坐标表示为 [x, y, 1]。变换矩阵 M 与之相乘得到新的点 [x', y', 1]。
 
 #### Transform 的组合矩阵
 
 Transform 类描述的变换顺序通常是：缩放 -> 旋转 -> 平移。
 
 缩放矩阵 (S):
 
     | scalex   0      0 |
     | 0        scaley 0 |
     | 0        0      1 |
     
 旋转矩阵 ® (注意：VB.NET 的 Math.Sin 和 Math.Cos 使用弧度):
 
     | cos(theta)  -sin(theta)  0 |
     | sin(theta)   cos(theta)  0 |
     | 0            0           1 |
     
 平移矩阵 (T):
 
     | 1  0  tx |
     | 0  1  ty |
     | 0  0  1  |
     
 最终的组合矩阵 M_transform 是 T * R * S：
 
 M_transform = T * R * S =
 | cos(theta)*scalex   -sin(theta)*scaley   tx |
 | sin(theta)*scalex    cos(theta)*scaley   ty |
 | 0                    0                   1  |
 
 #### AffineTransform 的矩阵
 
 AffineTransform 类直接定义了矩阵的元素：
 
 M_affine =
 | a  b  c |
 | d  e  f |
 | 0  0  1 |
 
 其中 x' = ax + by + c 和 y' = dx + ey + f。
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.GeometryTransform.ApplyTo(Microsoft.VisualBasic.Imaging.Math2D.Polygon2D)">
 <summary>
 Apply the current transformation parameters to the target polygon object.
 </summary>
 <param name="polygon"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.GeomTransform.ToAffineTransform(Microsoft.VisualBasic.Imaging.Math2D.Transform)">
 <summary>
 将一个 Transform 对象等价转换为 AffineTransform 对象。
 此转换总是可行的。
 </summary>
 <param name="source">源 Transform 对象。</param>
 <returns>等价的 AffineTransform 对象。</returns>
 <remarks>
 注意：此函数假设 source.theta 的单位是**弧度**。
 如果您的角度是度数，请先使用 `angle * Math.PI / 180.0` 进行转换。
 
 + a = cos(theta) * scalex
 + b = -sin(theta) * scaley
 + c = tx
 + d = sin(theta) * scalex
 + e = cos(theta) * scaley
 + f = ty
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.GeomTransform.ToTransform(Microsoft.VisualBasic.Imaging.Math2D.AffineTransform)">
 <summary>
 尝试将一个 AffineTransform 对象等价转换为 Transform 对象。
 </summary>
 <param name="source">源 AffineTransform 对象。</param>
 <returns>
 如果转换成功，返回等价的 Transform 对象。
 如果源变换包含剪切效果，无法转换，则返回 Nothing。
 </returns>
 <remarks>
 注意：返回的 theta 单位是**弧度**。
 
 #### `AffineTransform` -> `Transform` (有条件)
 
 我们需要从 `a, b, d, e` 中反解出 `theta`, `scalex`, `scaley`。
 
 1.  **平移部分很简单**：
 
     *   `tx = c`
     *   `ty = f`
 
 2.  **旋转和缩放部分**：
 
     我们有：
     
     *   `a = cos(theta) * scalex`
     *   `d = sin(theta) * scalex`
     *   `b = -sin(theta) * scaley`
     *   `e = cos(theta) * scaley`
 
     *   **计算 `theta`**:
     
         使用 `Math.Atan2(y, x)` 是最稳健的方法，它可以正确处理所有象限。
         
         `theta = Atan2(d, a)`  (因为 `tan(theta) = d/a`)
 
     *   **计算 `scalex` 和 `scaley`**:
     
         利用三角恒等式 `sin²θ + cos²θ = 1`，我们可以避免除以零的问题，并且结果更精确。
         
         *   `a² + d² = (cos²θ + sin²θ) * scalex² = scalex²`
         *   `b² + e² = (sin²θ + cos²θ) * scaley² = scaley²`
         
         所以：
         
         *   `scalex = sqrt(a² + d²)`
         *   `scaley = sqrt(b² + e²)`
 
 3.  **检测剪切**：
 
     一个纯粹的旋转+缩放矩阵，其两个列向量 `[a, d]` 和 `[b, e]` 是**正交**的（点积为0）。
     
     *   点积 = `a*b + d*e`
     *   如果这个值不为0（考虑到浮点数精度，只要不为0），就说明存在剪切。
     
 </remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.GeomTransform.SquareSize(System.Int32)">
 <summary>
 Returns a size value that its width equals height. 
 </summary>
 <param name="width%"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.GeomTransform.Area(System.Drawing.Rectangle)">
 <summary>
 这个方形区域的面积
 </summary>
 <param name="rect"></param>
 <returns>value of ``width * height``</returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.GeomTransform.Area(System.Drawing.Size)">
 <summary>
 这个方形区域的面积
 </summary>
 <param name="size"></param>
 <returns>value of ``width * height``</returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.GeomTransform.ShapePoints(System.Drawing.RectangleF)">
 <summary>
 left,top -> right, top -> right, bottom -> left, bottom
 </summary>
 <param name="rect"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.GeomTransform.InRegion(System.Drawing.Point,System.Drawing.Rectangle)">
 <summary>
 Is target point in the target region?
 </summary>
 <param name="x"></param>
 <param name="rect"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.GeomTransform.InRegion(System.Drawing.PointF,System.Drawing.Rectangle)">
 <summary>
 Is target point in the target region?
 </summary>
 <param name="x"></param>
 <param name="rect"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.GeomTransform.GetCenter(System.Drawing.Size)">
 <summary>
 Calculate the center location of the target sized region
 </summary>
 <param name="size"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.GeomTransform.OffSet2D(System.Drawing.Point,System.Int32,System.Int32)">
 <summary>
 返回位移的新的点位置值
 </summary>
 <param name="p"></param>
 <param name="x"></param>
 <param name="y"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.GeomTransform.OffSet2D(System.Drawing.Point,System.Drawing.Point)">
 <summary>
 返回位置的新的点位置值
 </summary>
 <param name="p"></param>
 <param name="offset"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.GeomTransform.OffSet2D(System.Drawing.Point,System.Drawing.PointF)">
 <summary>
 返回位置的新的点位置值
 </summary>
 <param name="p"></param>
 <param name="offset"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.GeomTransform.OffSet2D(System.Drawing.PointF,System.Drawing.PointF,System.Int32)">
 <summary>
 Default is ``A + B``
 </summary>
 <param name="pt"></param>
 <param name="offset"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.GeomTransform.OffSet2D(System.Drawing.PointF,System.Single,System.Single)">
 <summary>
 <see cref="T:System.Drawing.Point"/> <paramref name="pt"/> + offset
 </summary>
 <param name="pt"></param>
 <param name="x!"></param>
 <param name="y!"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.GeomTransform.MirrorY(System.Drawing.PointF,System.Drawing.RectangleF)">
 <summary>
 
 </summary>
 <param name="pt">假设<paramref name="pt"/>是位于<paramref name="rect"/>内部的</param>
 <param name="rect"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.GeomTransform.CircleRectangle(System.Drawing.PointF,System.Single)">
 <summary>
 <see cref="M:Microsoft.VisualBasic.Imaging.IGraphics.DrawEllipse(Microsoft.VisualBasic.Imaging.Pen,System.Drawing.RectangleF)"/>
 </summary>
 <param name="center"></param>
 <param name="r!"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.GeomTransform.Distance(System.Double,System.Double,System.Double,System.Double)">
 <summary>
 计算两个二维坐标的欧几里得距离
 </summary>
 <param name="x1#"></param>
 <param name="y1#"></param>
 <param name="x2#"></param>
 <param name="y2#"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.GeomTransform.DistanceTo(System.Int32[],System.Double,System.Double)">
 <summary>
 计算两个二维坐标的欧几里得距离
 </summary>
 <param name="x2#"></param>
 <param name="y2#"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.GeomTransform.DistanceTo``1(``0,``0)">
 <summary>
 Euclidean distance
 </summary>
 <typeparam name="T"></typeparam>
 <param name="a"></param>
 <param name="b"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.GeomTransform.Distance(System.Decimal,System.Decimal,System.Decimal,System.Decimal)">
 <summary>
 计算两个二维坐标的欧几里得距离
 </summary>
 <param name="x1#"></param>
 <param name="y1#"></param>
 <param name="x2#"></param>
 <param name="y2#"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.GeomTransform.Distance(System.Drawing.Point,System.Drawing.Point)">
 <summary>
 计算两个坐标点之间的欧几里得距离
 </summary>
 <param name="a"></param>
 <param name="b"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.GeomTransform.Distance(System.Drawing.PointF,System.Drawing.PointF)">
 <summary>
 计算任意两点之间的欧几里得距离
 </summary>
 <param name="a"></param>
 <param name="b"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.GeomTransform.Distance(System.Drawing.PointF,System.Double,System.Double)">
 <summary>
 计算任意两点之间的欧几里得距离
 </summary>
 <param name="a"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.GeomTransform.Distance(System.Collections.Generic.IEnumerable{System.Drawing.Point},System.Drawing.Point)">
 <summary>
 计算每一个顶点到同一个锚点的距离值的集合
 </summary>
 <param name="points"></param>
 <param name="anchor"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.GeomTransform.CalculateAngle(System.Drawing.PointF,System.Drawing.PointF)">
 <summary>
 函数返回角度
 </summary>
 <param name="p1"></param>
 <param name="p2"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.GeomTransform.CalculateAngle(System.Drawing.Point,System.Drawing.Point)">
 <summary>
 函数返回角度
 </summary>
 <param name="p1"></param>
 <param name="p2"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.GeomTransform.Angle(System.ValueTuple{System.Drawing.PointF,System.Drawing.PointF})">
 <summary>
 函数返回切线和X轴之间的夹角
 </summary>
 <param name="tangent"></param>
 <returns>单位为角度</returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.GeomTransform.GetBounds(System.Collections.Generic.IEnumerable{System.Drawing.Point})">
 <summary>
 获取目标多边形对象的边界结果，包括左上角的位置以及所占的矩形区域的大小
 </summary>
 <param name="points"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.GeomTransform.GetBounds(System.Collections.Generic.IEnumerable{System.Drawing.PointF})">
 <summary>
 获取目标多边形对象的边界结果，包括左上角的位置以及所占的矩形区域的大小
 </summary>
 <param name="points"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.GeomTransform.Centre(System.Drawing.Rectangle)">
 <summary>
 Gets the center location of the region rectangle.
 </summary>
 <param name="rect"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.GeomTransform.Scale(System.Drawing.RectangleF,System.Drawing.SizeF)">
 <summary>
 Resize the rectangle
 </summary>
 <param name="rect"></param>
 <param name="factor"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.GeomTransform.Scale(System.Drawing.SizeF,System.Double)">
 <summary>
 宽和高进行等比缩放
 </summary>
 <param name="size"></param>
 <param name="factor#"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.GeomTransform.Scale(System.Drawing.Size,System.Double)">
 <summary>
 宽和高进行等比缩放
 </summary>
 <param name="size"></param>
 <param name="factor#"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.GeomTransform.Centre(System.Collections.Generic.IEnumerable{System.Drawing.PointF})">
 <summary>
 获取目标多边形对象的中心点的坐标位置
 </summary>
 <param name="shape"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.GeomTransform.Centre(System.Drawing.RectangleF)">
 <summary>
 Gets the center location of the region rectangle.
 </summary>
 <param name="rect"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.GeomTransform.CentralOffset(System.Collections.Generic.IEnumerable{System.Drawing.Point},System.Drawing.Size)">
 <summary>
 获取将目标多边形置于区域的中央位置的位置偏移量
 </summary>
 <param name="pts"></param>
 <param name="frameSize"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.GeomTransform.CentralOffset(System.Collections.Generic.IEnumerable{System.Drawing.PointF},System.Drawing.SizeF)">
 <summary>
 获取将目标多边形置于区域的中央位置的位置偏移量
 </summary>
 <param name="pts"></param>
 <param name="frameSize"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.GeomTransform.Rotate(System.Double[]@,System.Double[]@,System.Double)">
 <summary>
 绕多边形自身中心旋转指定弧度
 </summary>
 <param name="theta">旋转角度（弧度），逆时针为正</param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.GeomTransform.Translate(System.Double[]@,System.Double[]@,System.Double,System.Double)">
 <summary>
 平移多边形
 </summary>
 <param name="tx">X轴平移量</param>
 <param name="ty">Y轴平移量</param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.GeomTransform.Scale(System.Double[]@,System.Double[]@,System.Double,System.Double)">
 <summary>
 缩放多边形
 </summary>
 <param name="sx">X轴缩放因子</param>
 <param name="sy">Y轴缩放因子</param>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Math2D.Intersections">
 <summary>
 几何体之间的关系类型
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Math2D.Intersections.Tangent">
 <summary>
 正切
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Math2D.Intersections.Intersection">
 <summary>
 相交
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Math2D.Intersections.Containment">
 <summary>
 包围
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Math2D.Moran">
 <summary>
 This function is useful for calculating Moran's I 
 Without holding an entire distance matrix in memory
 </summary>
 <remarks>
 https://github.com/mcooper/moranfast/blob/master/src/calc_moran.cpp
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.Moran.calc_moran(System.Double[],System.Double[],System.Double[],System.Boolean)">
 <summary>
 
 </summary>
 <param name="x">intensity value</param>
 <param name="c1">spatial x</param>
 <param name="c2">spatial y</param>
 <param name="parallel"></param>
 <returns>
 observed is the calculated moran-I value
 </returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Math2D.Transform">
 <summary>
 2D transformation parameters
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Math2D.Transform.theta">
 <summary>
 angle for rotation
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Math2D.Transform.tx">
 <summary>
 translate x
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Math2D.Transform.ty">
 <summary>
 translate y
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Math2D.Transform.scalex">
 <summary>
 scale x [1 means no scale]
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Math2D.Transform.scaley">
 <summary>
 scale y [1 means no scale]
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.Transform.ApplyTo(Microsoft.VisualBasic.Imaging.Math2D.Polygon2D)">
 <summary>
 Apply the current transformation parameters to the target polygon object.
 </summary>
 <param name="polygon"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Math2D.Line2D">
 <summary>
 This <code>Line2D</code> represents a line segment in {@code (x,y)}
 coordinate space.  This [Class], like all of the Java 2D API, uses a
 default coordinate system called <i>user space</i> in which the y-axis
 values increase downward and x-axis values increase to the right.  For
 more information on the user space coordinate system, see the
 <a href="https://docs.oracle.com/javase/1.3/docs/guide/2d/spec/j2d-intro.fm2.html#61857">
 Coordinate Systems</a> section of the Java 2D Programmer's Guide.
 
 This class is only the abstract superclass for all objects that
 store a 2D line segment.
 The actual storage representation of the coordinates is left to
 the subclass.
 
 @author      Jim Graham
 @since 1.2
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.Line2D.relativeCCW(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
 <summary>
 Returns an indicator of where the specified point
 {@code (px,py)} lies with respect to the line segment from
 {@code (x1,y1)} to {@code (x2,y2)}.
 
 The return value can be either 1, -1, or 0 and indicates
 in which direction the specified line must pivot around its
 first end point, {@code (x1,y1)}, in order to point at the
 specified point {@code (px,py)}.
 
 A return value of 1 indicates that the line segment must
 turn in the direction that takes the positive X axis towards
 the negative Y axis.  In the default coordinate system used by
 Java 2D, this direction is counterclockwise.
 
 A return value of -1 indicates that the line segment must
 turn in the direction that takes the positive X axis towards
 the positive Y axis.  In the default coordinate system, this
 direction is clockwise.
 
 A return value of 0 indicates that the point lies
 exactly on the line segment.  Note that an indicator value
 of 0 is rare and not useful for determining collinearity
 because of floating point rounding issues.
 
 If the point is colinear with the line segment, but
 not between the end points, then the value will be -1 if the point
 lies "beyond {@code (x1,y1)}" or 1 if the point lies
 "beyond {@code (x2,y2)}".
 </summary>
 <param name="x1"> the X coordinate of the start point of the
           specified line segment </param>
 <param name="y1"> the Y coordinate of the start point of the
           specified line segment </param>
 <param name="x2"> the X coordinate of the end point of the
           specified line segment </param>
 <param name="y2"> the Y coordinate of the end point of the
           specified line segment </param>
 <param name="px"> the X coordinate of the specified point to be
           compared with the specified line segment </param>
 <param name="py"> the Y coordinate of the specified point to be
           compared with the specified line segment </param>
 <returns> an integer that indicates the position of the third specified
                  coordinates with respect to the line segment formed
                  by the first two specified coordinates.
 @since 1.2 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.Line2D.linesIntersect(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
 <summary>
 Tests if the line segment from {@code (x1,y1)} to
 {@code (x2,y2)} intersects the line segment from {@code (x3,y3)}
 to {@code (x4,y4)}.
 </summary>
 <param name="x1"> the X coordinate of the start point of the first
           specified line segment </param>
 <param name="y1"> the Y coordinate of the start point of the first
           specified line segment </param>
 <param name="x2"> the X coordinate of the end point of the first
           specified line segment </param>
 <param name="y2"> the Y coordinate of the end point of the first
           specified line segment </param>
 <param name="x3"> the X coordinate of the start point of the second
           specified line segment </param>
 <param name="y3"> the Y coordinate of the start point of the second
           specified line segment </param>
 <param name="x4"> the X coordinate of the end point of the second
           specified line segment </param>
 <param name="y4"> the Y coordinate of the end point of the second
           specified line segment </param>
 <returns> <code>true</code> if the first specified line segment
                  and the second specified line segment intersect
                  each other; <code>false</code> otherwise.
 @since 1.2 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.Line2D.ptSegDistSq(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
 <summary>
 Returns the square of the distance from a point to a line segment.
 The distance measured is the distance between the specified
 point and the closest point between the specified end points.
 If the specified point intersects the line segment in between the
 end points, this method returns 0.0.
 </summary>
 <param name="x1"> the X coordinate of the start point of the
           specified line segment </param>
 <param name="y1"> the Y coordinate of the start point of the
           specified line segment </param>
 <param name="x2"> the X coordinate of the end point of the
           specified line segment </param>
 <param name="y2"> the Y coordinate of the end point of the
           specified line segment </param>
 <param name="px"> the X coordinate of the specified point being
           measured against the specified line segment </param>
 <param name="py"> the Y coordinate of the specified point being
           measured against the specified line segment </param>
 <returns> a double value that is the square of the distance from the
                  specified point to the specified line segment. </returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.Line2D.ptSegDist(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
 <summary>
 Returns the distance from a point to a line segment.
 The distance measured is the distance between the specified
 point and the closest point between the specified end points.
 If the specified point intersects the line segment in between the
 end points, this method returns 0.0.
 </summary>
 <param name="x1"> the X coordinate of the start point of the
           specified line segment </param>
 <param name="y1"> the Y coordinate of the start point of the
           specified line segment </param>
 <param name="x2"> the X coordinate of the end point of the
           specified line segment </param>
 <param name="y2"> the Y coordinate of the end point of the
           specified line segment </param>
 <param name="px"> the X coordinate of the specified point being
           measured against the specified line segment </param>
 <param name="py"> the Y coordinate of the specified point being
           measured against the specified line segment </param>
 <returns> a double value that is the distance from the specified point
                          to the specified line segment. </returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.Line2D.ptLineDistSq(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
 <summary>
 Returns the square of the distance from a point to a line.
 The distance measured is the distance between the specified
 point and the closest point on the infinitely-extended line
 defined by the specified coordinates.  If the specified point
 intersects the line, this method returns 0.0.
 </summary>
 <param name="x1"> the X coordinate of the start point of the specified line </param>
 <param name="y1"> the Y coordinate of the start point of the specified line </param>
 <param name="x2"> the X coordinate of the end point of the specified line </param>
 <param name="y2"> the Y coordinate of the end point of the specified line </param>
 <param name="px"> the X coordinate of the specified point being
           measured against the specified line </param>
 <param name="py"> the Y coordinate of the specified point being
           measured against the specified line </param>
 <returns> a double value that is the square of the distance from the
                  specified point to the specified line. </returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.Line2D.ptLineDist(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
 <summary>
 Returns the distance from a point to a line.
 The distance measured is the distance between the specified
 point and the closest point on the infinitely-extended line
 defined by the specified coordinates.  If the specified point
 intersects the line, this method returns 0.0.
 </summary>
 <param name="x1"> the X coordinate of the start point of the specified line </param>
 <param name="y1"> the Y coordinate of the start point of the specified line </param>
 <param name="x2"> the X coordinate of the end point of the specified line </param>
 <param name="y2"> the Y coordinate of the end point of the specified line </param>
 <param name="px"> the X coordinate of the specified point being
           measured against the specified line </param>
 <param name="py"> the Y coordinate of the specified point being
           measured against the specified line </param>
 <returns> a double value that is the distance from the specified
                   point to the specified line. </returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.Line3D.ptLineDistSq(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
 <summary>
 Returns the square of the distance from a point to a line.
 The distance measured is the distance between the specified
 point and the closest point on the infinitely-extended line
 defined by the specified coordinates.  If the specified point
 intersects the line, this method returns 0.0.
 </summary>
 <param name="x1"> the X coordinate of the start point of the specified line </param>
 <param name="y1"> the Y coordinate of the start point of the specified line </param>
 <param name="x2"> the X coordinate of the end point of the specified line </param>
 <param name="y2"> the Y coordinate of the end point of the specified line </param>
 <param name="px"> the X coordinate of the specified point being
           measured against the specified line </param>
 <param name="py"> the Y coordinate of the specified point being
           measured against the specified line </param>
 <returns> a double value that is the square of the distance from the
                  specified point to the specified line. </returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.Line3D.ptLineDist(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
 <summary>
 Returns the distance from a point to a line.
 The distance measured is the distance between the specified
 point and the closest point on the infinitely-extended line
 defined by the specified coordinates.  If the specified point
 intersects the line, this method returns 0.0.
 </summary>
 <param name="x1"> the X coordinate of the start point of the specified line </param>
 <param name="y1"> the Y coordinate of the start point of the specified line </param>
 <param name="x2"> the X coordinate of the end point of the specified line </param>
 <param name="y2"> the Y coordinate of the end point of the specified line </param>
 <param name="px"> the X coordinate of the specified point being
           measured against the specified line </param>
 <param name="py"> the Y coordinate of the specified point being
           measured against the specified line </param>
 <returns> a double value that is the distance from the specified
                   point to the specified line. </returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Math2D.EllipseShape">
 <summary>
 Ellipse shape polygon generator
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Math2D.EllipseShape.value">
 <summary>
 any other tagged value with current circle model
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.EllipseShape.#ctor(System.Single,System.Single,System.Double)">
 <summary>
 create a new circle model
 </summary>
 <param name="x"></param>
 <param name="y"></param>
 <param name="r"></param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.EllipseShape.GetPolygonPath">
 <summary>
 generates the ellipse or circle drawing path
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Math2D.Line.P1">
 <summary>
 (<see cref="P:Microsoft.VisualBasic.Imaging.Math2D.Line.X1"/>, <see cref="P:Microsoft.VisualBasic.Imaging.Math2D.Line.Y1"/>)
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Math2D.Line.P2">
 <summary>
 (<see cref="P:Microsoft.VisualBasic.Imaging.Math2D.Line.X2"/>, <see cref="P:Microsoft.VisualBasic.Imaging.Math2D.Line.Y2"/>)
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Math2D.PolarPoint">
 <summary>
 极坐标点
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Math2D.PolarPoint.Angle">
 <summary>
 Unit in degree.(单位为度)
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Math2D.PolarPoint.Point">
 <summary>
 与这个极坐标点等价的笛卡尔直角坐标系上面的坐标点
 </summary>
 <returns></returns>
 <remarks>
 这个是默认以[0,0]为圆心进行计算的
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.PolarPoint.ToString">
 <summary>
 显示这个极坐标点
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Math2D.Vector2D">
 <summary>
 <see cref="T:System.Drawing.PointF"/>, basic model for physical simulator
 </summary>
 <remarks>
 this vector model could be cast to gdi+ <see cref="T:System.Drawing.PointF"/> object directly.
 </remarks>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Math2D.Vector2D.x">
 <summary>
 position x
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Math2D.Vector2D.y">
 <summary>
 position y
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Math2D.Vector2D.Length">
 <summary>
 distance to zero [0,0]
 </summary>
 <returns>Magnitude of the vector</returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.Vector2D.op_UnaryNegation(Microsoft.VisualBasic.Imaging.Math2D.Vector2D)">
 <summary>
 reverse
 </summary>
 <param name="v"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.Vector2D.op_Multiply(System.Double,Microsoft.VisualBasic.Imaging.Math2D.Vector2D)">
 <summary>
 multiple
 </summary>
 <param name="scale#"></param>
 <param name="v"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.Vector2D.op_Multiply(Microsoft.VisualBasic.Imaging.Math2D.Vector2D,System.Double)">
 <summary>
 multiple
 </summary>
 <param name="v"></param>
 <param name="scale#"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.Vector2D.DistanceToSegment(Microsoft.VisualBasic.Imaging.Math2D.Vector2D,Microsoft.VisualBasic.Imaging.Math2D.Vector2D,Microsoft.VisualBasic.Imaging.Math2D.Vector2D)">
 <summary>
 计算点到线段的距离
 </summary>
 <param name="point">target 2d point</param>
 <param name="segStart">target 2d line start</param>
 <param name="segEnd">target 2d line ends</param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Math2D.NamespaceDoc">
 <summary>
 ### Euclidean space
 
 Euclidean space is the fundamental space of geometry, intended to represent physical space. Originally, 
 in Euclid's Elements, it was the three-dimensional space of Euclidean geometry, but in modern mathematics 
 there are Euclidean spaces of any positive integer dimension n, which are called Euclidean n-spaces when
 one wants to specify their dimension. For n equal to one or two, they are commonly called respectively
 Euclidean lines and Euclidean planes. The qualifier "Euclidean" is used to distinguish Euclidean spaces 
 from other spaces that were later considered in physics and modern mathematics.
 
 Ancient Greek geometers introduced Euclidean space For modeling the physical space. Their work was collected
 by the ancient Greek mathematician Euclid In his Elements, With the great innovation Of proving all 
 properties Of the space As theorems, by starting from a few fundamental properties, called postulates, which 
 either were considered As evident (For example, there Is exactly one straight line passing through two 
 points), Or seemed impossible To prove (parallel postulate).
 
 After the introduction at the End Of 19th century Of non-Euclidean geometries, the old postulates were 
 re-formalized To define Euclidean spaces through axiomatic theory. Another definition Of Euclidean spaces 
 by means Of vector spaces And linear algebra has been shown To be equivalent To the axiomatic definition. 
 It Is this definition that Is more commonly used In modern mathematics, And detailed In this article. In all 
 definitions, Euclidean spaces consist Of points, which are defined only by the properties that they must 
 have For forming a Euclidean space.
 
 There Is essentially only one Euclidean space of each dimension; that Is, all Euclidean spaces of a given 
 dimension are isomorphic. Therefore it Is usually possible to work with a specific Euclidean space, denoted ``E ^ n``, 
 which can be represented using Cartesian coordinates as the real n-space ``R ^ n`` equipped with the 
 standard dot product.
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Math2D.Polygon2D">
 <summary>
 polygon object in 2D plain
 </summary>
 <remarks>
 this object is a vector of x and y or a collection of the 2d points.
 </remarks>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Math2D.Polygon2D.Item(System.Int32)">
 <summary>
 get/set the point data by a given index
 </summary>
 <param name="index"></param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Math2D.Polygon2D.centroid">
 <summary>
 get centroid point of this 2d polygon shape
 </summary>
 <returns></returns>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Math2D.Polygon2D.bounds1">
 <summary>
 [left, top]
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Math2D.Polygon2D.bounds2">
 <summary>
 [right, bottom]
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Math2D.Polygon2D.length">
 <summary>
 the size of the polygon points collection
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Math2D.Polygon2D.height">
 <summary>
 max y - min y
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Math2D.Polygon2D.width">
 <summary>
 max x - min x
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.Polygon2D.#ctor(Microsoft.VisualBasic.Imaging.Math2D.Polygon2D[])">
 <summary>
 union multiple polygon
 </summary>
 <param name="polygons"></param>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.Polygon2D.#ctor(System.Collections.Generic.IEnumerable{System.Drawing.Point})">
 <summary>
 Construct a polygon 2d shape object from a point collection
 </summary>
 <param name="points"></param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.Polygon2D.#ctor(System.Drawing.RectangleF[])">
 <summary>
 
 </summary>
 <param name="rect">
 四个顶点是具有前后顺序的，按照顺序构建出一个四方形
 </param>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.Polygon2D.GetRandomPoint">
 <summary>
 get a random point that inside current polygon
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.Polygon2D.calculateBounds(System.Double[],System.Double[],System.Int32)">
 <summary>
 measure the [top,left] and [bottom, right] as rectangle bound
 </summary>
 <param name="x"></param>
 <param name="y"></param>
 <param name="n"></param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.Polygon2D.inside(Microsoft.VisualBasic.Imaging.Math2D.Vector2D)">
 <summary>
 check data point is inside current polygon?
 </summary>
 <param name="par2D"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.Polygon2D.inside(System.Double,System.Double)">
 <summary>
 Check the given target point is inside of this polygon object or not
 </summary>
 <param name="x">
 p.x of the target point
 </param>
 <param name="y">
 p.y of the target point
 </param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.Polygon2D.GetArea">
 <summary>
 Calculates the area of a simple polygon using the shoelace algorithm.
 
 https://myengineeringworld.net/2014/06/shoelace-polygon-area-excel.html
 </summary>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.Polygon2D.GetRectangle">
 <summary>
 Get the layout rectangle of current polygon object
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.Polygon2D.GetSize">
 <summary>
 get the polygon rectangle size
 </summary>
 <returns></returns>
 <remarks>
 width and height is generated from the rectangle width and height
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.Polygon2D.GetDimension">
 <summary>
 get the dimension size via the max x and max y
 </summary>
 <returns></returns>
 <remarks>
 the meaning of <see cref="M:Microsoft.VisualBasic.Imaging.Math2D.Polygon2D.GetDimension"/> is different with <see cref="M:Microsoft.VisualBasic.Imaging.Math2D.Polygon2D.GetSize"/>
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.Polygon2D.GetShoelaceArea(System.Double[],System.Double[])">
 <summary>
 Calculates the area of a simple polygon using the shoelace algorithm.
 
 https://myengineeringworld.net/2014/06/shoelace-polygon-area-excel.html
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.Polygon2D.GetFillPoints">
 <summary>
 Get scan line result for fill the space inside of this polygon object
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.Polygon2D.GenericEnumerator">
 <summary>
 just populate all input points data
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.Polygon2D.op_Addition(Microsoft.VisualBasic.Imaging.Math2D.Polygon2D,System.Drawing.PointF)">
 <summary>
 move current polygon object by a given offset
 </summary>
 <param name="p"></param>
 <param name="offset"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.PolygonFiller.FillPolygon(System.Collections.Generic.List{System.Drawing.Point})">
 <summary>
 填充多边形并返回内部所有点的集合
 </summary>
 <param name="vertices">多边形顶点（按顺时针或逆时针顺序）</param>
 <returns>填充点的集合（List(Of Point)）</returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Math2D.QuadrantRegions">
 <summary>
 请注意，视图上面的象限的位置和计算机之中的象限是反过来的
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Math2D.QuadrantRegions.Origin">
 <summary>
 重叠在一起
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Math2D.QuadrantRegions.RightTop">
 <summary>
 quadrant 1 = 0,90 ~ -90,0 ~ 270,360
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Math2D.QuadrantRegions.LeftTop">
 <summary>
 quadrant 2 = 90,180 ~ -180,-90 ~ 180,270
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Math2D.QuadrantRegions.LeftBottom">
 <summary>
 quadrant 3 = 180,270 ~ -270,-180 ~ 90,180 
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Math2D.QuadrantRegions.RightBottom">
 <summary>
 quadrant 4 = 270,360 ~ -270, -360 ~ 0, 90
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Math2D.RasterData">
 <summary>
 栅格化结果容器：每个栅格存储该区域内点的列表
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.Rasterizer.Rasterize(Microsoft.VisualBasic.Imaging.Math2D.Polygon2D,System.Double)">
 <summary>
 对Polygon2D点云进行栅格化
 </summary>
 <param name="pointCloud">输入点云数据</param>
 <param name="resolution">栅格分辨率（每个栅格的边长）</param>
 <returns>栅格化结果，包含每个栅格内的点集</returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Math2D.Rasterizer.EstimateResolution(Microsoft.VisualBasic.Imaging.Math2D.Polygon2D,System.Int32)">
 <summary>
 计算点云的平均最近邻距离，作为分辨率估算的基础
 </summary>
 <param name="pointCloud">输入的点云数据</param>
 <returns>估算出的平均点间距（分辨率）</returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Math2D.VectorMath2D">
 <summary>
 
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Image">
 <summary>
 the abstract image data model, example as gdi+ raster image bitmap, svg image, pdf image, etc
 </summary>
 <remarks>
 the image model implements the interface <see cref="T:Microsoft.VisualBasic.Imaging.IRasterMemory"/>
 </remarks>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Image.Size">
 <summary>
 the size of the image
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Image.Width">
 <summary>
 the width of the image <see cref="P:Microsoft.VisualBasic.Imaging.Image.Size"/>
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Image.Height">
 <summary>
 the height of the image <see cref="P:Microsoft.VisualBasic.Imaging.Image.Size"/>
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Image.ConvertToBitmapStream">
 <summary>
 Convert current image object as bitmap file data
 </summary>
 <returns></returns>
 <remarks>
 function for make bitmap object constructor
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Image.FromStream(System.IO.Stream)">
 <summary>
 Load bitmap image from file stream
 </summary>
 <param name="s">only works for bitmap image file stream</param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Bitmap">
 <summary>
 the gdi+ raster image data in memory
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Bitmap.#ctor(Microsoft.VisualBasic.Imaging.Image)">
 <summary>
 make memory data copy
 </summary>
 <param name="copy"></param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Bitmap.Save(System.IO.Stream,Microsoft.VisualBasic.Imaging.ImageFormats)">
 <summary>
 Save current bitmap object into a specific file
 </summary>
 <param name="s"></param>
 <param name="format"></param>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.PixelFormat">
 <summary>
 Specifies the format of the color data for each pixel in the image.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.PixelFormat.Format32bppArgb">
 <summary>
 Specifies that the format Is 32 bits per pixel; 8 bits each are used for the
 alpha, red, green, And blue components.
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Pen">
 <summary>
 The stroke pen wrapper for .net 8.0
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.LineJoin">
 <summary>
 Specifies how to join consecutive line Or curve segments in a figure (subpath)
 contained in a System.Drawing.Drawing2D.GraphicsPath object.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.LineJoin.Miter">
 <summary>
 Specifies a mitered join. This produces a sharp corner Or a clipped corner, depending
 on whether the length of the miter exceeds the miter limit.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.LineJoin.Bevel">
 <summary>
 Specifies a beveled join. This produces a diagonal corner.    
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.LineJoin.Round">
 <summary>
 Specifies a circular join. This produces a smooth, circular arc between the lines.    
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.LineJoin.MiterClipped">
 <summary>
 Specifies a mitered join. This produces a sharp corner Or a beveled corner, depending
 on whether the length of the miter exceeds the miter limit.
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.PointF3D">
 <summary>
 [x,y,z]
 
 这个接口是为了实现Imaging模块的Point3D对象和数学函数模块的3D插值模块的兼容
 </summary>
 <remarks>
 
 </remarks>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.SpatialIndex3D">
 <summary>
 a index point in 3d spatial geometry space
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.SpatialIndex3D.Z">
 <summary>
 the z axis index data
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Layout2D">
 <summary>
 a float 2d point
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Layout2D.X">
 <summary>
 the x axis data
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Layout2D.Y">
 <summary>
 the y axis data
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.IReadOnlyPoint">
 <summary>
 a float 2d point
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.IReadOnlyPoint.X">
 <summary>
 the x axis data
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.IReadOnlyPoint.Y">
 <summary>
 the y axis data
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.RasterPixel">
 <summary>
 [x,y] tuple
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.RasterPixel.X">
 <summary>
 the x axis data
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.RasterPixel.Y">
 <summary>
 the y axis data
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Pixel">
 <summary>
 a generic data model for HeatMap raster: [x,y,scale]
 </summary>
 <remarks>
 the layout information comes from the base <see cref="T:Microsoft.VisualBasic.Imaging.RasterPixel"/> model
 </remarks>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Pixel.Scale">
 <summary>
 the color scale data
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.AnonymousTypeHelper.CreateEmptyList``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>
 You can using this method to create a empty list for the specific type of anonymous type object.
 (使用这个方法获取得到匿名类型的列表数据集合对象)
 </summary>
 <typeparam name="TAnonymousType"></typeparam>
 <param name="typedef">The temp object which was created anonymous.
 (匿名对象的集合，这个是用来复制匿名类型的，虽然没有引用这个参数，但是却可以直接通过拓展来得到匿名类型生成列表对象)
 </param>
 <returns></returns>
 <remarks></remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.AnonymousTypeHelper.CopyTypeDef``2(System.Collections.Generic.Dictionary{``0,``1})">
 <summary>

 </summary>
 <typeparam name="TKey"></typeparam>
 <typeparam name="TValue"></typeparam>
 <param name="source">仅仅是起到类型复制的作用</param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.BucketOperators">
 <summary>
 进行集合分块切割或者合并等操作
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.BucketOperators.Split``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
 <summary>
 Data partitioning function.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <param name="partitionSize">每一个子集合之中的元素的数目</param>
 <returns></returns>
 <remarks>
 (将目标集合之中的数据按照<paramref name="partitionSize"></paramref>参数分配到子集合之中，
 这个函数之中不能够使用并行化Linq拓展，以保证元素之间的相互原有的顺序，
 每一个子集合之中的元素数量为<paramref name="partitionSize"/>)
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.BucketOperators.SplitIterator``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
 <summary>
 Performance the partitioning operation on the input sequence.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <param name="partitionSize">
 The partition size should be less than the array upbound size
 </param>
 <returns></returns>
 <remarks>
 (请注意，这个函数只适用于数量较少的序列。对所输入的序列进行分区操作，<paramref name="partitionSize"/>函数参数是每一个分区里面的元素的数量)
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.BucketOperators.Join``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
 <summary>
 Merge two type specific collection.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <param name="target"></param>
 <returns></returns>
 <remarks>
 (函数会忽略掉空的集合，函数会构建一个新的集合，原有的集合不受影响)
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.BucketOperators.Join``1(System.Collections.Generic.IEnumerable{``0},``0)">
 <summary>
 Source list join a new <paramref name="data"/> element.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <param name="data"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.BucketOperators.Join``1(``0,System.Collections.Generic.IEnumerable{``0})">
 <summary>
 ``X, ....``
 
 (这个函数是一个安全的函数，当<paramref name="collection"/>为空值的时候回忽略掉<paramref name="collection"/>，
 只返回包含有一个<paramref name="obj"/>元素的列表)
 </summary>
 <typeparam name="T"></typeparam>
 <param name="obj"></param>
 <param name="collection"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CategoryOperations.CategoryValues``1(System.Collections.Generic.IEnumerable{Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedCollection{``0}})">
 <summary>
 transform ``[category => items]`` to ``[item -> category][]``
 </summary>
 <typeparam name="T"></typeparam>
 <param name="categories"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CollectionValueGetter.AsEnumerable``1(Microsoft.VisualBasic.Language.Value{``0[]})">
 <summary>
 
 </summary>
 <typeparam name="T"></typeparam>
 <param name="value"></param>
 <returns>
 this function returns empty collection if the given <paramref name="value"/> is nothing
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.CollectionValueGetter.NotNull``1(``0[])">
 <summary>
 Returns the first not nothing object.
 </summary>
 <typeparam name="T">
 Due to the reason of value type is always not nothing, so that this generic type constrain as Class reference type.
 </typeparam>
 <param name="args"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CollectionValueGetter.FirstNotEmpty(System.String[])">
 <summary>
 Returns the first not null or empty string.
 </summary>
 <param name="args"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CollectionValueGetter.Get``1(System.Collections.Generic.IEnumerable{``0},System.Int32,``0)">
 <summary>
 Safe get the specific index element from the target collection, is the index value invalid, then default value will be return.
 (假若下标越界的话会返回默认值)
 </summary>
 <typeparam name="T"></typeparam>
 <param name="array"></param>
 <param name="index"></param>
 <param name="default">Default value for invalid index is nothing.</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CollectionValueGetter.ElementAtOrDefault``1(``0[],System.Int32,``0)">
 <summary>
 This is a safely method for gets the value in a array, if the index was 
 outside of the boundary or the given <paramref name="array"/> is nothing, 
 then the default value will be return.
 </summary>
 <typeparam name="T">The generic type of current array object</typeparam>
 <param name="array"></param>
 <param name="index">A 32-bit integer that represents the position of the System.Array element to
 get.</param>
 <param name="default">
 Default value for return when the array object is nothing or index outside of the boundary.
 </param>
 <returns>
 The value at the specified position in the one-dimensional System.Array.
 </returns>
 <remarks>
 假若目标数组是空值或者下标越界的话会返回<paramref name="default"/>默认值
 </remarks> 
</member>
<member name="M:Microsoft.VisualBasic.CollectionValueGetter.ElementAtOrNull``1(``0[],System.Int32)">
 <summary>
 Gets the value at the specified position in the one-dimensional System.Array.
 The index is specified as a 32-bit integer.
 </summary>
 <param name="array"></param>
 <param name="index">A 32-bit integer that represents the position of the System.Array element to
 get.</param>
 <returns>
 The value at the specified position in the one-dimensional System.Array.
 </returns>
 
</member>
<member name="M:Microsoft.VisualBasic.CollectionValueGetter.GetValueOrDefault(System.Array,System.Int32,System.Object)">
 <summary>
 Gets the value at the specified position in the one-dimensional System.Array.
 The index is specified as a 32-bit integer.
 </summary>
 <param name="array"></param>
 <param name="index">A 32-bit integer that represents the position of the System.Array element to
 get.</param>
 <param name="default">
 The default value if index is outside the range of valid indexes for the current System.Array.
 </param>
 <returns>
 The value at the specified position in the one-dimensional System.Array.
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.CollectionValueGetter.GetItem``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
 <summary>
 这个是一个安全的方法，假若下标越界或者目标数据源为空的话，则会返回空值
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <param name="index"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.CollectionValueGetter.TryPopOut``2(System.Collections.Generic.Dictionary{``0,``1},``0,``1)">
 <summary>
 get value by key and then removes the target 
 keyed value from the given <paramref name="table"/>.
 </summary>
 <typeparam name="TKey"></typeparam>
 <typeparam name="TValue"></typeparam>
 <param name="table"></param>
 <param name="key"></param>
 <param name="default"></param>
 <returns>
 the value that associated with the given <paramref name="key"/>,
 which is going to be removed from the specific dictionary 
 <paramref name="table"/> object.
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.CollectionValueGetter.TryPopOut``2(System.Collections.Generic.Dictionary{``0,``1},System.Collections.Generic.IEnumerable{``0},``1)">
 <summary>
 
 </summary>
 <typeparam name="TKey"></typeparam>
 <typeparam name="TValue"></typeparam>
 <param name="table"></param>
 <param name="synonyms"></param>
 <param name="default"></param>
 <returns>the default value will be returns if all synonym key is missing
 from the given table object.</returns>
</member>
<member name="M:Microsoft.VisualBasic.CollectionValueGetter.TryGetValue``2(System.Collections.Generic.Dictionary{``0,``1},``0[],``1,System.Boolean,System.String)">
 <summary>
 假若不存在目标键名，则返回空值，默认值为空值
 </summary>
 <typeparam name="TKey"></typeparam>
 <typeparam name="TValue"></typeparam>
 <param name="table"></param>
 <param name="keys">
 the synonym keys
 </param>
 <param name="default"></param>
 <returns>returns the key-value which is matched with any input synonym <paramref name="keys"/>.</returns>
</member>
<member name="M:Microsoft.VisualBasic.CollectionValueGetter.TryGetValue``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1,System.Boolean,System.String)">
 <summary>
 假若不存在目标键名，则返回空值，默认值为空值
 </summary>
 <typeparam name="TKey"></typeparam>
 <typeparam name="TValue"></typeparam>
 <param name="table"></param>
 <param name="index">这个函数会自动处理空键名的情况</param>
 <param name="default"></param>
 <param name="mute">
 mute the verbose debug echo in debug mode?
 </param>
 <returns></returns>
 <remarks>
 this function is a safe function:
 
 1. for input hash table object is nothing, this function will returns the default value
 2. for key is nothing or key is not found inside the hash table, this function also returns the default value
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.CollectionValueGetter.Values``1(System.Collections.Generic.IEnumerable{Microsoft.VisualBasic.Language.Value{``0}.IValueOf})">
 <summary>
 get value set
 </summary>
 <typeparam name="T"></typeparam>
 <param name="x">a collection of the value wrapper</param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.DelimiterLocation">
 <summary>
 分隔符对象在分块之中的位置
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.DelimiterLocation.PreviousLast">
 <summary>
 上一个分块的最末尾
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.DelimiterLocation.NotIncludes">
 <summary>
 不会再任何分块之中包含有分隔符
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.DelimiterLocation.NextFirst">
 <summary>
 包含在下一个分块之中的最开始的位置
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.DelimiterLocation.Individual">
 <summary>
 分隔符在单独的一个切割分块之中
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.IEnumerations.Next``1(System.Random,``0[])">
 <summary>
 Get a random element
 </summary>
 <typeparam name="T"></typeparam>
 <param name="random"></param>
 <param name="data"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.IEnumerations.CreateDictionary``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>
 将目标集合对象转换为一个字典对象
 </summary>
 <typeparam name="T"></typeparam>
 <param name="Collection"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="F:Microsoft.VisualBasic.IEnumerations.TextCompareStrict">
 <summary>
 Text compare in case sensitive mode
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.IEnumerations.Takes``1(System.Collections.Generic.IEnumerable{``0},System.String,System.Boolean)">
 <summary>
 这个函数假设参数<paramref name="source"/>之中是有重复的对象，则可以使用uniqueID数据提取出一个集合
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <param name="uniqueId"></param>
 <param name="strict">是否大小写敏感，默认大小写敏感</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.IEnumerations.Takes``1(System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{``0})">
 <summary>
 按照uniqueId列表来筛选出目标集合，这个函数是使用字典来进行查询操作的，故而效率会比较高
 </summary>
 <typeparam name="T"></typeparam>
 <param name="list">The list of ID value for <see cref="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Repository.IKeyedEntity`1.Key"/></param>
 <param name="source"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.IEnumerations.Take``1(System.Collections.Generic.IEnumerable{``0},System.String,System.Boolean)">
 <summary>
 使用<paramref name="uniqueId"/>唯一标识符从集合之中取出一个目标对象。
 小集合推荐使用这个函数，但是对于大型集合或者需要查询的次数非常多的话，则推荐使用字典操作来提升性能
 请注意这个函数会完全匹配字符串的，即大小写敏感
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <param name="uniqueId"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.IEnumerations.ToDictionary``1(System.Collections.Generic.IEnumerable{``0},System.Boolean)">
 <summary>
 
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <param name="distinct">
 True: 这个参数会去处重复项
 </param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.IsNullOrEmptyExtensions.Empty``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>
 check of the given collection is null or empty?
 </summary>
 <typeparam name="T"></typeparam>
 <param name="list"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.IsNullOrEmptyExtensions.IsNullOrEmpty(System.Text.StringBuilder)">
 <summary>
 The <see cref="T:System.Text.StringBuilder"/> object its content is nothing?
 </summary>
 <param name="sBuilder"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.IsNullOrEmptyExtensions.IsNullOrEmpty``2(System.Collections.Generic.IDictionary{``0,``1})">
 <summary>
 字典之中是否是没有任何数据的？
 </summary>
 <typeparam name="TKey"></typeparam>
 <typeparam name="TValue"></typeparam>
 <param name="dict"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.IsNullOrEmptyExtensions.IsNullOrEmpty``2(System.Collections.Generic.IReadOnlyDictionary{``0,``1})">
 <summary>
 字典之中是否是没有任何数据的？
 </summary>
 <typeparam name="TKey"></typeparam>
 <typeparam name="TValue"></typeparam>
 <param name="dict"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.IsNullOrEmptyExtensions.IsNullOrEmpty``2(System.Collections.Generic.Dictionary{``0,``1})">
 <summary>
 字典之中是否是没有任何数据的？
 </summary>
 <typeparam name="TKey"></typeparam>
 <typeparam name="TValue"></typeparam>
 <param name="dict"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.IsNullOrEmptyExtensions.IsNullOrEmpty``1(System.Collections.Generic.Queue{``0})">
 <summary>
 这个队列之中是否是没有任何数据的?
 </summary>
 <typeparam name="T"></typeparam>
 <param name="queue"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.IsNullOrEmptyExtensions.IsNullOrEmpty``1(System.Collections.Generic.ICollection{``0})">
 <summary>
 这个动态列表之中是否是没有任何数据的？
 </summary>
 <typeparam name="T"></typeparam>
 <param name="list"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.IsNullOrEmptyExtensions.IsNullOrEmpty(System.Array)">
 <summary>
 This object array is a null object or contains zero count items.
 </summary>
 <returns></returns>
 <remarks>
 (判断某一个对象数组是否为空)
 </remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.IsNullOrEmptyExtensions.IsNullOrEmpty``1(``0[])">
 <summary>
 This object array is a null object or contains zero count items.
 </summary>
 <returns></returns>
 <remarks>
 (判断某一个对象数组是否为空)
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.IsNullOrEmptyExtensions.GetLength``1(``0[])">
 <summary>
 0 for null object
 </summary>
 <typeparam name="T"></typeparam>
 <param name="array"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Linq.Enumeration`1">
 <summary>
 Exposes the enumerator, which supports a simple iteration over a collection of
 a specified type.To browse the .NET Framework source code for this type, see
 the Reference Source.
 </summary>
 <typeparam name="T">The type of objects to enumerate.This type parameter is covariant. That is, you
 can use either the type you specified or any type that is more derived. For more
 information about covariance and contravariance, see Covariance and Contravariance
 in Generics.</typeparam>
 <remarks>
 (使用这个的原因是系统自带的<see cref="T:System.Collections.Generic.IEnumerable`1"/>在Xml序列化之中的支持不太友好，
 实现这个接口之后可以通过<see cref="M:Microsoft.VisualBasic.Linq.EnumerationExtensions.AsEnumerable``1(Microsoft.VisualBasic.Linq.Enumeration{``0})"/>
 拓展来转换为查询操作的数据源)
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Linq.Enumeration`1.GenericEnumerator">
 <summary>
 Returns an enumerator that iterates through the collection.
 </summary>
 <returns>An enumerator that can be used to iterate through the collection.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Linq.EnumerationExtensions.AsObjectEnumerator(System.Array)">
 <summary>
 将一个<see cref="T:System.Array"/>对象转换为一个<see cref="T:System.Object"/>对象的枚举序列
 </summary>
 <param name="enums"></param>
 <returns></returns>
 <remarks>
 使用这个拓展函数的原因是<see cref="T:System.Array"/>对象不能够产生对象的枚举序列用于Linq拓展函数
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Linq.EnumerationExtensions.AsObjectEnumerator``1(System.Array)">
 <summary>
 将一个<see cref="T:System.Array"/>对象转换为一个<see cref="T:System.Object"/>对象的枚举序列
 </summary>
 <param name="enums"></param>
 <returns></returns>
 <remarks>
 使用这个拓展函数的原因是<see cref="T:System.Array"/>对象不能够产生对象的枚举序列用于Linq拓展函数
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Linq.EnumerationExtensions.AsEnumerable``1(Microsoft.VisualBasic.Linq.Enumeration{``0})">
 <summary>
 Returns the input typed as <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
 </summary>
 <typeparam name="T">The type of the elements of source.</typeparam>
 <param name="enums">The sequence to type as <see cref="T:System.Collections.Generic.IEnumerable`1"/></param>
 <returns>The input sequence typed as <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</returns>
 <remarks>
 this iterator function is a kind of safe function: for the given data source is nothing,
 this function will returns a empty collection, null reference error will not happends 
 in this iterator function.
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Linq.IteratorExtensions.SeqIterator(System.Collections.IEnumerable,System.Int32)">
 <summary>
 
 </summary>
 <param name="source"></param>
 <param name="offset%"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Linq.IteratorExtensions.SeqIterator``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
 <summary>
 Iterates all of the objects in the source sequence with collection index position.
 (``enumerate()`` 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，
 同时列出数据和数据下标，一般用在 Linq表达式 循环当中。
 这个拓展函数类似于python之中的 ``enumerate()`` 函数)
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source">the source sequence</param>
 <param name="offset">``[start=0]``下标的起始位置</param>
 <returns>
 ``[index, item_value]``
 </returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Linq.IteratorExtensions.Next``1(System.Collections.Generic.IEnumerator{``0})">
 <summary>
 Move the enumerator pointer to next and get next value, if the pointer is reach the end, then will returns nothing
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Linq.IteratorExtensions.ValueArray``1(System.Collections.Generic.IEnumerable{Microsoft.VisualBasic.Language.Value{``0}.IValueOf})">
 <summary>
 Creates an array from property <see cref="P:Microsoft.VisualBasic.Language.Value`1.IValueOf.Value"/>
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Linq.JoinExtensions.IteratesALL``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}})">
 <summary>
 Iterates all of the elements in a two dimension collection as the data source 
 for the linq expression or ForEach statement.<br />
 (适用于二维的集合做为linq的数据源，不像<see cref="M:Microsoft.VisualBasic.Extensions.Unlist``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}})"/>是进行转换，
 这个是返回迭代器的，推荐使用这个函数)
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <returns></returns>
 <remarks>
 this function is a safe function, the null collection value in the given
 <paramref name="source"/> will be ignored
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Linq.JoinExtensions.JoinIterates``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
 <summary>
 First, iterate populates the elements in collection <paramref name="a"/>, 
 and then populate out all of the elements on collection <paramref name="b"/>
 </summary>
 <typeparam name="T"></typeparam>
 <param name="a">Object collection</param>
 <param name="b">Another object collection.</param>
 <returns>
 <paramref name="a"/> or <paramref name="b"/> will be ignored if
 collection object is nothing
 </returns>
</member>
<member name="T:Microsoft.VisualBasic.Linq.Extensions">
 <summary>
 Linq Helpers.(为了方便编写Linq代码而构建的一个拓展模块)
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Linq.Extensions.AtWhich``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
 <summary>
 An index of liked function for find the first element its index offset that matches the condition test
 </summary>
 <typeparam name="T"></typeparam>
 <param name="collection"></param>
 <param name="where"></param>
 <returns>
 -1 means not found
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Linq.Extensions.Populate``1(System.Collections.Generic.IEnumerable{``0},System.Boolean,System.Int32)">
 <summary>
 Parallel helper
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <param name="parallel"></param>
 <param name="degreeOfParallelism%"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Linq.Extensions.ToArray``1(System.Collections.Generic.IEnumerable{System.Object})">
 <summary>
 DirectCast of the <paramref name="source"/> sequence into T() array.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Linq.Extensions.ToArray``1(``0[])">
 <summary>
 make array data copy
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Linq.Extensions.SafeQuery``1(System.Collections.Generic.IEnumerable{``0},System.String)">
 <summary>
 A query proxy function makes your linq not so easily crashed due to the 
 unexpected null reference collection as linq source.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Linq.Extensions.With``1(System.Collections.Generic.IEnumerable{``0},Microsoft.VisualBasic.Linq.Extensions.DoWith{``0})">
 <summary>
 <paramref name="doWith"/> each element in <paramref name="source"/> and then 
 returns the <paramref name="source"/> sequence after modify.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <param name="doWith"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Linq.Extensions.With``1(``0,Microsoft.VisualBasic.Linq.Extensions.DoWith{``0})">
 <summary>
 <paramref name="doWith"/> target object <paramref name="x"/>, and then reutrns x
 </summary>
 <typeparam name="T">Only works for reference type</typeparam>
 <param name="x"></param>
 <param name="doWith"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Linq.Extensions.MaxInd``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>
 Gets the max element its index in the collection
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Linq.Extensions.Removes``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean},System.Boolean)">
 <summary>

 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <param name="match">符合这个条件的所有的元素都将会被移除</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Linq.Extensions.RemoveLeft``2(System.Collections.Generic.Dictionary{``0,``1}@,``0)">
 <summary>
 Removes the specific key in the dicitonary and returns the last content.
 (删除指定的键之后返回剩下的数据)
 </summary>
 <typeparam name="TKey"></typeparam>
 <typeparam name="TValue"></typeparam>
 <param name="source"></param>
 <param name="key"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Linq.Extensions.Repeats``1(``0,System.Int32)">
 <summary>
 Copy <paramref name="source"/> <paramref name="times"/> times to construct a new vector.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <param name="times"></param>
 <returns>An array consist of source with n elements.</returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Linq.Extensions.CopyVector``1(System.Int32,System.Func{``0})">
 <summary>
 
 </summary>
 <typeparam name="T"></typeparam>
 <param name="n"></param>
 <param name="source">The object factory</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Linq.Extensions.Read``1(``0[],System.Int32@)">
 <summary>
 Read source at element position <paramref name="i"/> and returns its value, 
 and then this function makes position <paramref name="i"/> offset +1
 </summary>
 <typeparam name="T"></typeparam>
 <param name="array"></param>
 <param name="i"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Linq.Extensions.Sequence(System.Int32)">
 <summary>
 ``[0, n-1]``, 产生指定数目的一个递增序列(用于生成序列的输入参数<paramref name="n"/>数值就是生成的数组的元素的个数)
 </summary>
 <param name="n">大于或者等于0的一个数，当小于0的时候会出错</param>
 <returns></returns>
 <remarks></remarks>

</member>
<member name="M:Microsoft.VisualBasic.Linq.Extensions.SeqIterator(System.Int32,System.Int32)">
 <summary>
 ``0,1,2,3,...<paramref name="n"/>``
 </summary>
 <param name="n">the api function is already makes ``n-1`` for populate index sequence.</param>
 <param name="offset"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Linq.Extensions.SeqIterator(System.Int64,System.Int32)">
 <summary>
 假若数量已经超过了数组的容量，则需要使用这个函数来产生序列
 </summary>
 <param name="n"></param>
 <param name="offset"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Linq.Extensions.Sequence(System.Int64)">
 <summary>
 产生指定数目的一个递增序列(所生成序列的数值就是生成的数组的元素的个数)
 </summary>
 <param name="n"></param>
 <returns></returns>
 <remarks></remarks>

</member>
<member name="M:Microsoft.VisualBasic.Linq.Extensions.Sequence(System.UInt32)">
 <summary>
 产生指定数目的一个递增序列(所生成序列的数值就是生成的数组的元素的个数)
 </summary>
 <param name="n"></param>
 <returns></returns>
 <remarks></remarks>

</member>
<member name="M:Microsoft.VisualBasic.Linq.Extensions.ToArray``1(System.Int32,System.Func{System.Int32,``0})">
 <summary>
 (所生成序列的数值就是生成的数组的元素的个数)
 </summary>
 <typeparam name="T"></typeparam>
 <param name="len"></param>
 <param name="elementAt"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Linq.Extensions.FirstOrDefault``1(System.Collections.Generic.IEnumerable{``0},``0)">
 <summary>
 Returns the first element of a sequence, or a default value if the sequence contains no elements.
 </summary>
 <typeparam name="TSource">The type of the elements of source.</typeparam>
 <param name="source">The System.Collections.Generic.IEnumerable`1 to return the first element of.</param>
 <param name="[default]">
 If the sequence is nothing or contains no elements, then this default value will be returned.
 </param>
 <returns>default(TSource) if source is empty; otherwise, the first element in source.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Linq.Extensions.DefaultFirst``1(System.Collections.Generic.IEnumerable{``0},``0)">
 <summary>
 Returns the first element of a sequence, or a default value if the sequence contains no elements.
 </summary>
 <typeparam name="T">The type of the elements of source.</typeparam>
 <param name="source">The System.Collections.Generic.IEnumerable`1 to return the first element of.</param>
 <param name="default">
 If the sequence is nothing or contains no elements, then this default value will be returned.
 </param>
 <returns>default(<typeparamref name="T"/>) if source is empty; otherwise, the first element in source.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Linq.Extensions.ToVector(System.Collections.IEnumerable)">
 <summary>
 Convert the iterator source <see cref="T:System.Collections.IEnumerable"/> to an object array.
 </summary>
 <param name="source"></param>
 <returns></returns>
 <remarks>
 this function ensures that the array is not nothing
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Linq.Extensions.ToArray``1(System.Collections.IEnumerable)">
 <summary>
 Convert the iterator source <see cref="T:System.Collections.IEnumerable"/> to a specific type array.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <returns></returns>
 <remarks>
 this function ensures that the returns array is not nothing
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Linq.NumericSequence.Range(System.DateTime,System.DateTime,System.TimeSpan)">
 <summary>
 
 </summary>
 <param name="from"></param>
 <param name="[to]"></param>
 <param name="step%">Milliseconds</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Linq.PipelineExtensions.DoCall``2(``0,System.Func{``0,``1})">
 <summary>
 Delegate pipeline function
 </summary>
 <typeparam name="T"></typeparam>
 <typeparam name="Tout"></typeparam>
 <param name="input"></param>
 <param name="apply"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Linq.PipelineExtensions.DoCall``1(``0,System.Action{``0})">
 <summary>
 Delegate pipeline function
 </summary>
 <typeparam name="T"></typeparam>
 <param name="input"></param>
 <param name="apply"></param>
</member>
<member name="T:Microsoft.VisualBasic.Linq.SeqValue`1">
 <summary>
 Value <typeparamref name="T"/> with sequence index <see cref="P:Microsoft.VisualBasic.Linq.SeqValue`1.i"/>.
 </summary>
 <typeparam name="T"></typeparam>
</member>
<member name="P:Microsoft.VisualBasic.Linq.SeqValue`1.i">
 <summary>
 The position of this object value in the original sequence.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Linq.SeqValue`1.value">
 <summary>
 The Object data
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Linq.SeqValue`1.IsEmpty">
 <summary>
 This indexed value have no value.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Linq.SeqValue`1.#ctor(`0)">
 <summary>
 create index value with default index zero
 </summary>
 <param name="value"></param>
</member>
<member name="M:Microsoft.VisualBasic.Linq.SeqValue`1.op_Explicit(Microsoft.VisualBasic.Linq.SeqValue{`0})~`0">
 <summary>
 get value from the indexed object
 </summary>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Linq.SeqValue`1.op_Explicit(Microsoft.VisualBasic.Linq.SeqValue{`0})~System.Int32">
 <summary>
 get ordinal index offset from the given indexed object.
 </summary>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Linq.SeqValue`1.op_Modulus(Microsoft.VisualBasic.Linq.SeqValue{`0},System.Int32)">
 <summary>
 Calculation of: ``<see cref="P:Microsoft.VisualBasic.Linq.SeqValue`1.i"/> Mod <paramref name="n"/>``
 </summary>
 <param name="i"></param>
 <param name="n"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Linq.SeqValue`1.op_Inequality(Microsoft.VisualBasic.Linq.SeqValue{`0},System.Int32)">
 <summary>
 Not equals to index i
 </summary>
 <param name="v"></param>
 <param name="i%"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Linq.SeqValue`1.op_Equality(Microsoft.VisualBasic.Linq.SeqValue{`0},System.Int32)">
 <summary>
 Equals to index i
 </summary>
 <param name="v"></param>
 <param name="i%"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Linq.SeqValue`1.op_UnaryPlus(Microsoft.VisualBasic.Linq.SeqValue{`0})">
 <summary>
 Get value from <see cref="P:Microsoft.VisualBasic.Linq.SeqValue`1.value"/> property.
 </summary>
 <param name="x"></param>
 <returns></returns>
 <remarks>
 Syntax helper for the <see cref="T:Microsoft.VisualBasic.Emit.Marshal.Pointer`1"/>:
 
 ```vbnet
 Dim p As Pointer(Of T) = T()
 Dim x As T = ++p
 ```
 </remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.Linq.SeqValue`1.op_Addition(Microsoft.VisualBasic.Linq.SeqValue{`0},System.Int32)">
 <summary>
 <see cref="P:Microsoft.VisualBasic.Linq.SeqValue`1.i"/> + <paramref name="i"/>
 </summary>
 <param name="x"></param>
 <param name="i"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Linq.SeqValue`1.op_UnaryNegation(Microsoft.VisualBasic.Linq.SeqValue{`0})">
 <summary>
 Get value from <see cref="P:Microsoft.VisualBasic.Linq.SeqValue`1.value"/> property.
 </summary>
 <param name="x"></param>
 <returns></returns>
 <remarks>
 Syntax helper for the <see cref="T:Microsoft.VisualBasic.Emit.Marshal.Pointer`1"/>:
 
 ```vbnet
 Dim p As Pointer(Of T) = T()
 Dim x As T = --p
 ```
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Linq.SeqValue`1.CompareTo(System.Int32)">
 <summary>
 Compares the index value <see cref="P:Microsoft.VisualBasic.Linq.SeqValue`1.i"/>.
 </summary>
 <param name="other"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Linq.SetValuExtension`1.InvokeSet(System.String,System.Object)">
 <summary>
 
 </summary>
 <param name="name">Using NameOf</param>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Linq.SetValue`1">
 <summary>
 Set value linq expression helper
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Linq.SetValue`1.GetSet(System.String)">
 <summary>
 Public Delegate Function IInvokeSetValue(x As T, value As Object) As T
 </summary>
 <param name="name">Using NameOf</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Linq.SetValue`1.op_LessThanOrEqual(Microsoft.VisualBasic.Linq.SetValue{`0},System.String)">
 <summary>
 <see cref="M:Microsoft.VisualBasic.Linq.SetValue`1.GetSet(System.String)"/>
 </summary>
 <param name="setValue"></param>
 <param name="name">Using NameOf</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Linq.SetValue`1.InvokeSetValue(`0,System.String,System.Object)">
 <summary>
 Assigning the value to the specific named property to the target object.
 (将<paramref name="value"/>参数之中的值赋值给目标对象<paramref name="x"/>之中的指定的<paramref name="name"/>属性名称的属性，
 如果发生错误，则原有的对象<paramref name="x"/>不会被修改)
 </summary>
 <param name="x"></param>
 <param name="name">Using NameOf.(可以使用NameOf得到需要进行修改的属性名称)</param>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Linq.SetValue`1.InvokeSet``1(`0@,System.String,``0)">
 <summary>
 Assigning the value to the specific named property to the target object.
 (将<paramref name="value"/>参数之中的值赋值给目标对象<paramref name="obj"/>之中的指定的<paramref name="name"/>属性名称的属性，
 如果发生错误，则原有的对象<paramref name="obj"/>不会被修改)
 </summary>
 <typeparam name="Tvalue"></typeparam>
 <param name="obj"></param>
 <param name="Name">可以使用NameOf得到需要进行修改的属性名称</param>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Linq.TakesExtension.Takes``1(``0[],System.Int32)">
 <summary>
 An wrapper of <see cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)"/>
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <param name="count"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Linq.TakesExtension.Takes``1(System.Collections.Generic.IEnumerable{``0},System.Boolean[])">
 <summary>
 将所有对应的index处的<paramref name="flags"/>值为True的元素返回
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <param name="flags"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Linq.TakesExtension.Takes``1(System.Collections.Generic.IEnumerable{``0},System.Int32[],System.Int32,System.Boolean)">
 <summary>
 Take elements by <paramref name="index"/> list. 
 (将指定<paramref name="index"/>下标的元素从原始数据<paramref name="source"/>序列之中提取出来)
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <param name="index">所要获取的目标对象的下表的集合</param>
 <param name="reversed">是否为反向选择，即返回所有不在目标index集合之中的元素列表</param>
 <param name="OffSet">当进行反选的时候，本参数将不会起作用</param>
 <returns></returns>
 <remarks>
 ###### 2018-3-30 函数经过测试没有问题
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Linq.TakesExtension.doReversedTake``1(System.Collections.Generic.IEnumerable{``0},System.Int32[])">
 <summary>
 反选，即将所有不出现在<paramref name="index"></paramref>之中的元素都选取出来
 </summary>
 <typeparam name="T"></typeparam>
 <param name="collection"></param>
 <param name="index"></param>
 <returns></returns>
 <remarks></remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.Linq.TakesExtension.TakeRandomly``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
 <summary>
 随机的在目标集合中选取指定数目的子集合
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <param name="counts">当目标数目大于或者等于目标集合的数目的时候，则返回目标集合</param>
 <returns></returns>
 <remarks></remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.Linq.TakesExtension.TakeRandomly``1(``0[],System.Int32,System.Boolean)">
 <summary>
 随机的在目标集合中选取指定数目的子集合
 </summary>
 <typeparam name="T"></typeparam>
 <param name="array"></param>
 <param name="counts">当目标数目大于或者等于目标集合的数目的时候，则返回目标集合</param>
 <returns></returns>
 <remarks>
 this function use the default <see cref="P:Microsoft.VisualBasic.Math.RandomExtensions.seeds"/>; this function is very slow on processing huge dataset
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Linq.VectorAssertExtensions.LengthEquals``1(System.Int32,System.Boolean,System.Collections.Generic.IEnumerable{``0}[])">
 <summary>
 Determine that is all of the collection <paramref name="array"/> have the same size? 
 </summary>
 <typeparam name="T"></typeparam>
 <param name="n%">collection size Length</param>
 <param name="any">Is required all of the sequence must be the length equals</param>
 <param name="array"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Linq.VectorAssertExtensions.TestPairData``1(``0[],``0[])">
 <summary>
 + False: 测试失败，不会满足<see cref="M:Microsoft.VisualBasic.VectorExtensions.MappingData``1(``0[],``0[])"/>的条件
 + True: 可以使用<see cref="M:Microsoft.VisualBasic.VectorExtensions.MappingData``1(``0[],``0[])"/>来生成Mapping匹配
 </summary>
 <typeparam name="T"></typeparam>
 <param name="a"></param>
 <param name="b"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Linq.VectorAssertExtensions.InsideAny(Microsoft.VisualBasic.ComponentModel.Ranges.Model.IntRange,System.Collections.Generic.IEnumerable{System.Int32})">
 <summary>
 Any of the element in source <paramref name="sites"/> is in a specific <paramref name="range"/>??
 </summary>
 <param name="range"></param>
 <param name="sites"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Linq.VectorAssertor`1.op_Equality(System.Collections.Generic.IEnumerable{`0},Microsoft.VisualBasic.Linq.VectorAssertor{`0})">
 <summary>
 ALL elements in target <paramref name="list"/> equals to <paramref name="assert"/> value
 </summary>
 <param name="list"></param>
 <param name="assert"></param>
 <returns></returns>
</member>
<member name="F:Microsoft.VisualBasic.Linq.WhichSymbol.which">
 <summary>
 # Which indices are TRUE?
 
 Give the TRUE indices of a logical object, allowing for array indices.
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Linq.WhichIndex">
 <summary>
 Where is the Min() or Max() or first TRUE or FALSE ?
 (这个模块之中的函数返回来的都是集合之中的符合条件的对象元素的index坐标)
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Linq.WhichIndex.arrayInd(System.Collections.Generic.IEnumerable{System.Boolean})">
 <summary>
 Give the TRUE indices of a logical object, allowing for array indices.
 </summary>
 <param name="booleans">
 a logical vector or array. NAs are allowed and omitted (treated as if FALSE).
 </param>
 <returns>
 Basically, the result is (1:length(x))[x] in typical cases; 
 more generally, including when x has NA's, which(x) is 
 seq_along(x)[!is.na(x) &amp; x] plus names when x has.
 </returns>
 <remarks>
 Unlike most other base R functions this does not coerce x to logical: 
 only arguments with typeof logical are accepted and others give an 
 error.
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Linq.WhichIndex.Index``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
 <summary>
 Returns the collection element its index where the test expression <paramref name="predicate"/> result is TRUE
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <param name="predicate"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Linq.WhichIndex.#ctor">
 <summary>
 在这里不适用Module类型，要不然会和其他的Max拓展函数产生冲突的。。
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Linq.WhichIndex.Max``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>
 Determines the location, i.e., index of the (first) minimum or maximum of a numeric (or logical) vector.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="x">
 numeric (logical, integer or double) vector or an R object for which the internal coercion to 
 double works whose min or max is searched for.
 </param>
 <returns>
 A zero-based index offset for the item with max value, returns -1 means empty collection
 </returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Linq.WhichIndex.Min``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>
 Determines the location, i.e., index of the (first) minimum or maximum of a numeric (or logical) vector.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="x">
 numeric (logical, integer or double) vector or an R object for which the internal coercion to 
 double works whose min or max is searched for.
 </param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Linq.WhichIndex.IsTrue(System.Collections.Generic.IEnumerable{System.Boolean},System.Int32)">
 <summary>
 Return all of the indices which is True
 </summary>
 <param name="v"></param>
 <returns>
 the result index is zero-based by default
 </returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Linq.WhichIndex.IsTrue(System.Object)">
 <summary>
 Syntax helper for <see cref="M:Microsoft.VisualBasic.VectorExtensions.VectorShadows``1(System.Collections.Generic.IEnumerable{``0})"/>
 </summary>
 <param name="list"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Linq.WhichIndex.IsFalse(System.Collections.Generic.IEnumerable{System.Boolean})">
 <summary>
 Returns all of the indices which is False
 </summary>
 <param name="v"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Linq.WhichIndex.True``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
 <summary>
 查找出列表之中符合条件的所有的索引编号
 </summary>
 <typeparam name="T"></typeparam>
 <param name="array"></param>
 <param name="condi"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Linq.WhichIndex.IsGreaterThan``1(System.Collections.Generic.IEnumerable{``0},``0)">
 <summary>
 枚举出所有大于目标的顶点编号
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <param name="compareTo"></param>
 <returns></returns>
 <remarks>因为这个返回的是一个迭代器，所以可以和First结合产生FirstGreaterThan表达式</remarks>
 
</member>
<member name="T:Microsoft.VisualBasic.ListExtensions">
 <summary>
 Initializes a new instance of the <see cref="M:Microsoft.VisualBasic.Language.LanguageAPI.list(Microsoft.VisualBasic.Language.ArgumentReference[])"/>`1 class that
 contains elements copied from the specified collection and has sufficient capacity
 to accommodate the number of elements copied.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ListExtensions.AppendAfter``1(System.Collections.Generic.IEnumerable{``0},``0[])">
 <summary>
 append the <paramref name="list"/> after the collection <paramref name="first"/>.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="first"></param>
 <param name="list"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ListExtensions.TopMostFrequent``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
 <summary>
 查找出序列之中最频繁出现的对象(这个函数会自动跳过空值)
 </summary>
 <typeparam name="T"></typeparam>
 <param name="list"></param>
 <returns>
 this function returns the item with top frequency in the given list sequence; 
 and nothing will be returns if the given collection is empty.
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.ListExtensions.DoEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
 <summary>
 ForEach拓展的简化版本
 </summary>
 <typeparam name="T"></typeparam>
 <param name="collection"></param>
 <param name="[do]"></param>
</member>
<member name="M:Microsoft.VisualBasic.ListExtensions.Random``1(``0[])">
 <summary>
 返回数组集合之中的一个随机位置的元素
 </summary>
 <typeparam name="T"></typeparam>
 <param name="v"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ListExtensions.ReorderByKeys``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.String},System.String[])">
 <summary>
 根据对象的键名来进行重排序，请注意，要确保对象<paramref name="getKey"/>能够从泛型对象之中获取得到唯一的键名
 </summary>
 <typeparam name="T"></typeparam>
 <param name="list"></param>
 <param name="getKey"></param>
 <param name="customOrder">可能会出现大小写不对的情况？</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ListExtensions.Indexing``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
 <summary>
 从一个对象集合中创建索引，请注意，传递进入这个函数的参数应该是经过去重操作之后的数据
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <returns>
 returns an empty index collection if the given 
 <paramref name="source"/> id set is empty or 
 nothing.
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.ListExtensions.Swap``1(System.Collections.Generic.List{``0}@,System.Int32,System.Int32)">
 <summary>
 swap the position of two specific element inside a given list collection object
 </summary>
 <typeparam name="T"></typeparam>
 <param name="l"></param>
 <param name="i%"></param>
 <param name="j%"></param>
</member>
<member name="M:Microsoft.VisualBasic.ListExtensions.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Int32})">
 <summary>
 for each loop
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <param name="action"></param>
</member>
<member name="M:Microsoft.VisualBasic.ListExtensions.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
 <summary>
 for each loop
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <param name="action"></param>
</member>
<member name="M:Microsoft.VisualBasic.ListExtensions.ToList``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Boolean)">
 <summary>
 Initializes a new instance of the <see cref="M:Microsoft.VisualBasic.Language.LanguageAPI.list(Microsoft.VisualBasic.Language.ArgumentReference[])"/>`1 class that
 contains elements copied from the specified collection and has sufficient capacity
 to accommodate the number of elements copied.
 </summary>
 <param name="source">The collection whose elements are copied to the new list.</param>
</member>
<member name="M:Microsoft.VisualBasic.ListExtensions.AsList``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>
 Initializes a new instance of the <see cref="T:Microsoft.VisualBasic.Language.List`1"/> class that
 contains elements copied from the specified collection and has sufficient capacity
 to accommodate the number of elements copied.
 </summary>
 <param name="source">
 The collection whose elements are copied to the new list.
 </param>
 <remarks>
 如果source集合是空值的话，不会抛错
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.ListExtensions.HasKey(System.Collections.Hashtable,System.Object)">
 <summary>
 Function name alias of the function <see cref="M:System.Collections.Hashtable.ContainsKey(System.Object)"/>
 </summary>
 <param name="hashtable"></param>
 <param name="key"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ListExtensions.AsHashSet``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>
 Just using for the element index in a large collection
 </summary>
 <typeparam name="T"></typeparam>
 <param name="collection">
 If the element in this collection have some duplicated member, then only the first element will be keeped.
 </param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ListExtensions.AsHashList``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>
 <see cref="T:Microsoft.VisualBasic.ComponentModel.HashList`1"/>
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ListExtensions.ToList``1(System.Linq.ParallelQuery{``0})">
 <summary>
 Initializes a new instance of the <see cref="M:Microsoft.VisualBasic.Language.LanguageAPI.list(Microsoft.VisualBasic.Language.ArgumentReference[])"/> class that
 contains elements copied from the specified collection and has sufficient capacity
 to accommodate the number of elements copied.
 </summary>
 <param name="linq">The collection whose elements are copied to the new list.</param>
</member>
<member name="M:Microsoft.VisualBasic.ListExtensions.Pop``1(System.Collections.Generic.List{``0})">
 <summary>
 removes the last element inside the list and then returns it
 </summary>
 <typeparam name="T"></typeparam>
 <param name="list"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ListExtensions.PopFirst``1(System.Collections.Generic.List{``0}@)">
 <summary>
 Remove the first element from the list and then returns this removed element.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="list"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.VectorExtensions">
 <summary>
 Extension methods for the .NET object sequence
 </summary>
 
</member>
<member name="M:Microsoft.VisualBasic.VectorExtensions.All(System.Collections.Generic.IEnumerable{System.Boolean})">
 <summary>
 Does all boolean test result is TRUE?
 </summary>
 <param name="flags"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.VectorExtensions.Sort``1(``0[]@,System.Comparison{``0},System.Boolean)">
 <summary>
 
 </summary>
 <typeparam name="T"></typeparam>
 <param name="a"></param>
 <param name="compares"></param>
 <param name="modification">是否修改原始输入的<paramref name="a"/>序列? 否则会创建一个新的数组序列返回</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.VectorExtensions.Replicate``1(``0,System.Int32)">
 <summary>
 使用<paramref name="template"/>产生一个<paramref name="n"/>长度元素的目标序列
 </summary>
 <typeparam name="T"></typeparam>
 <param name="template"></param>
 <param name="n">
 the size of the generated sequence
 </param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.VectorExtensions.Add``1(``0[]@,``0)">
 <summary>
 Dynamics add a element into the target array.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="vector"></param>
 <param name="value"></param>
 <remarks>
 (注意：不推荐使用这个函数来频繁的向数组中添加元素，这个函数会频繁的分配内存，效率非常低)
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.VectorExtensions.Add``1(``0[]@,System.Collections.Generic.IEnumerable{``0})">
 <summary>
 Append value collection to the end of the target <paramref name="vector"/>
 </summary>
 <typeparam name="T"></typeparam>
 <param name="vector"></param>
 <param name="values"></param>
</member>
<member name="M:Microsoft.VisualBasic.VectorExtensions.Add``1(``0[]@,``0[])">
 <summary>
 Add given elements into an array object.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="vector"></param>
 <param name="value"></param>
 <remarks>
 (会自动跳过空集合，这个方法是安全的)
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.VectorExtensions.Append``1(``0[],System.Collections.Generic.IEnumerable{``0})">
 <summary>
 Add given elements into an array object and then returns the target array object <paramref name="buffer"/>.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="buffer"></param>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.VectorExtensions.Add``1(``0[]@,Microsoft.VisualBasic.Language.List{``0})">
 <summary>
 Add given elements into an array object.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="array"></param>
 <param name="value"></param>
 
</member>
<member name="M:Microsoft.VisualBasic.VectorExtensions.Fill``1(``0[],``0,System.Int32)">
 <summary>
 在原来的数组末尾追加由<paramref name="count"/>个<paramref name="item"/>填充的新数据
 </summary>
 <typeparam name="T"></typeparam>
 <param name="vector"></param>
 <param name="item"></param>
 <param name="count%"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.VectorExtensions.Fill``1(``0[]@,System.Collections.Generic.IEnumerable{``0},Microsoft.VisualBasic.Language.i32,System.Boolean)">
 <summary>
 使用给定的数据序列<paramref name="data"/>填充<paramref name="vector"/>的指定位置开始的区域
 填充的长度为<paramref name="data"/>的序列长度
 </summary>
 <typeparam name="T"></typeparam>
 <param name="vector"></param>
 <param name="data"></param>
 <param name="start%"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.VectorExtensions.Delete``1(``0[],System.Int32)">
 <summary>
 Removes array element at index.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="vector"></param>
 <param name="index"></param>
 <returns></returns>
 <remarks>
 (请注意，这个函数并不会修改原来的数组，而是创建一个新的拷贝)
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.VectorExtensions.Delete``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{System.Int32})">
 <summary>
 将指定下标的元素从原始的输入序列之中删除然后返回所得到的新序列
 </summary>
 <typeparam name="T"></typeparam>
 <param name="vector">原始序列不会被改变</param>
 <param name="index"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.VectorExtensions.VectorShadows``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>
 Create a vector shadow of your data collection.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <returns>返回<see cref="T:System.Object"/>类型是为了简化语法</returns>
 
</member>
<member name="M:Microsoft.VisualBasic.VectorExtensions.Coalesce``1(System.Collections.Generic.IEnumerable{System.Nullable{``0}})">
 <summary>
 聚合，将nullable类型结构体转换为原来的值类型
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.VectorExtensions.GetRange``1(``0[],System.Int32,System.Int32)">
 <summary>
 从所给定的数组之中获取得到指定位置范围内的数据
 </summary>
 <typeparam name="T"></typeparam>
 <param name="vector"></param>
 <param name="index%"></param>
 <param name="count%"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.VectorExtensions.Sort``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.IComparable},System.Boolean)">
 <summary>
 对目标序列进行排序生成新的序列，这个拓展函数尝试将升序排序和降序排序这两种操作的接口统一起来
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <param name="desc"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.VectorExtensions.MappingData``1(``0[],``0[])">
 <summary>
 用来生成map数据的，
 + 当两个向量长度相同，会不进行任何处理，即两个向量之间，元素都可以一一对应，
 + 但是当某一个向量的长度为1的时候，就会将该向量补齐，因为此时会是一对多的关系
 </summary>
 <typeparam name="T"></typeparam>
 <param name="a"></param>
 <param name="b"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.VectorExtensions.IndexOf``1(``0[],``0)">
 <summary>
 在一个一维数组中搜索指定对象，并返回其首个匹配项的索引。
 </summary>
 <typeparam name="T">数组元素的类型。</typeparam>
 <param name="array">要搜索的从零开始的一维数组。</param>
 <param name="o">要在 array 中查找的对象。</param>
 <returns>如果在整个 array 中找到 value 的第一个匹配项，则为该项的从零开始的索引；否则为 -1。</returns>
 <remarks>
 this function returns -1 always if the given array is nothing
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.VectorExtensions.Last``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
 <summary>
 从后往前访问集合之中的元素，请注意请不要使用Linq查询表达式，尽量使用``list``或者``array``
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source">请不要使用Linq查询表达式，尽量使用``list``或者``array``</param>
 <param name="index"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.VectorExtensions.After``1(System.Collections.Generic.IEnumerable{``0},``0)">
 <summary>
 取出在x元素之后的所有元素
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <param name="x"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.VectorExtensions.After``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
 <summary>
 Returns all of the elements which is after the element that detected by a specific 
 evaluation function <paramref name="predicate"/>.
 (取出在判定条件成立的元素之后的所有元素)
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <param name="predicate"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.VectorExtensions.Memset``1(``0[]@,``0,System.Int32)">
 <summary>
 Replace target array data by using specific object value.(替换目标向量为指定的对象的填充数据)
 </summary>
 <typeparam name="T"></typeparam>
 <param name="array"></param>
 <param name="o"></param>
 <param name="len"></param>
</member>
<member name="M:Microsoft.VisualBasic.VectorExtensions.Memset(System.String@,System.Char,System.Int32)">
 <summary>
 替换<paramref name="s"/>字符串变量数据为新的字符填充数据
 </summary>
 <param name="s"></param>
 <param name="c"></param>
 <param name="len"></param>
 
</member>
<member name="M:Microsoft.VisualBasic.VectorExtensions.Midv``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Int32)">
 <summary>
 <see cref="M:Microsoft.VisualBasic.Strings.Mid(System.String,System.Int32)"/> function like operation on any type collection data.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <param name="start">0 base</param>
 <param name="length"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.VectorExtensions.LoadAsNumericVector(System.String)">
 <summary>
 Load the text file as a numeric vector. Each line in the text file 
 should be a <see cref="T:System.Double"/> type numeric value.
 </summary>
 <param name="path"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.VectorExtensions.Split``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0},Microsoft.VisualBasic.DelimiterLocation)">
 <summary>
 Split the object array using a specific evaluation function.
 (Please note that, all of the object in the <paramref name="source"/> array 
 that match the <paramref name="delimiter"/> evaluation, will not includes 
 in the returned tokens.)
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <param name="delimiter">和字符串的Split函数一样，这里作为delimiter的元素都不会出现在结果之中</param>
 <param name="deliPosition">是否还应该在分区的结果之中包含有分隔符对象？默认不包含</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.VectorExtensions.CopyOf``1(``0[],System.Int32)">
 <summary>
 java arrays.copyOf
 </summary>
 <typeparam name="T"></typeparam>
 <param name="a"></param>
 <param name="newLen"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.VectorExtensions.CopyOf``1(``0[],System.Int32[],System.Boolean)">
 <summary>
 
 </summary>
 <typeparam name="T"></typeparam>
 <param name="v"></param>
 <param name="ordinals"></param>
 <param name="base1"></param>
 <returns></returns>
 <remarks>
 default index ordinals offset value is zero-based.
 </remarks>
</member>
<member name="T:Microsoft.VisualBasic.LargeTextFile">
 <summary>
 Wrapper for the file operations.
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.LargeTextFile.FixEscapes(System.String,System.Func{System.String,System.String},Microsoft.VisualBasic.Text.Encodings)">
 <summary>
 函数返回结果文件的临时文件的文件路径
 </summary>
 <param name="path"></param>
 <param name="escape">
 这个函数输入文本文件之中的一行数据,然后处理完转义之后将改行的数据返回
 </param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.LargeTextFile.IteratesTableData(System.String,System.String@,System.Int32,Microsoft.VisualBasic.Text.Encodings)">
 <summary>
 Iterates read all lines in a very large text file, 
 using for loading a very large size csv/tsv file
 </summary>
 <param name="path">file path</param>
 <param name="title">The header line of this large size csv/tsv file.</param>
 <param name="skip">Skip n lines, then start to populate data lines.</param>
 <param name="encoding">Text file encoding.</param>
 <returns></returns>
 <remarks>
 A helper function for read the csv/tsv table file
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.LargeTextFile.IteratesStream(System.IO.StreamReader)">
 <summary>
 Populate all lines of the text data from current 
 stream reader object
 </summary>
 <param name="s">The stream connection to the target text file data resource.</param>
 <returns>
 Try to pull all text lines from the given text stream data
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.LargeTextFile.Peeks(System.String,System.Int32)">
 <summary>
 当一个文件非常大以致无法使用任何现有的文本编辑器查看的时候，可以使用本方法查看其中的一部分数据 
 </summary>
 <param name="length">字节长度</param>
 <returns></returns>
 <remarks></remarks> 
</member>
<member name="M:Microsoft.VisualBasic.LargeTextFile.Tails(System.String,System.Int32,System.Text.Encoding)">
 <summary>
 Peek the tails of a large text file.(尝试查看大文件的尾部的数据)
 </summary>
 <param name="path">If the file is not exists, then this function will returns nothing.</param>
 <param name="length">
 Peeks of the number of characters. The number of the characters, not the bytes value.
 (字符的数目)
 </param>
 <param name="encoding">Default value is <see cref="P:Microsoft.VisualBasic.Text.TextEncodings.DefaultEncoding"/></param>
 <returns></returns>
 <remarks>
 请注意，如果字符编码是不定长的，则返回的字符串可能会出现乱码的问题
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.LargeTextFile.Tails(System.IO.Stream,System.Int32,System.Text.Encoding)">
 <summary>
 Peek the tails of a large text file.(尝试查看大文件的尾部的数据)
 </summary>
 <param name="length">
 Peeks of the number of characters. The number of the characters, not the bytes value.
 (字符的数目)
 </param>
 <param name="encoding">Default value is <see cref="P:Microsoft.VisualBasic.Text.TextEncodings.DefaultEncoding"/></param>
 <returns></returns>
 <remarks>
 请注意，如果字符编码是不定长的，则返回的字符串可能会出现乱码的问题
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.LargeTextFile.GetLastLine(System.String,System.Text.Encoding,System.String)">
 <summary>
 Get last line of the target text file.
 </summary>
 <param name="path$"></param>
 <param name="encoding"></param>
 <param name="newLine$"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.LargeTextFile.Merge(System.String)">
 <summary>
 Please make sure all of the file in the target directory is text file not binary file.
 </summary>
 <param name="dir$"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Text.PartitionedStream">
 <summary>
 只是针对文本文件的
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Text.PartitionedStream.#ctor(System.String,System.Int32,System.Text.Encoding)">
 <summary>
 依照换行符来进行分区
 </summary>
 <param name="path"></param>
 <param name="blockSize"></param>
 <param name="encoding"></param>
</member>
<member name="T:Microsoft.VisualBasic.Text.ASCII">
 <summary>
 ``ASCII`` (``American Standard Code for Information Interchange``，美国信息互换标准代码，``ASCⅡ``) 是基于拉丁字母的一套电脑编码系统。
 它主要用于显示现代英语和其他西欧语言。它是现今最通用的单字节编码系统，并等同于国际标准``ISO/IEC 646``。
 ASCII第一次以规范标准的型态发表是在1967年，最后一次更新则是在1986年，至今为止共定义了128个字符，其中33个字符无法显示
 （这是以现今操作系统为依归，但在DOS模式下可显示出一些诸如笑脸、扑克牌花式等8-bit符号），且这33个字符多数都已是陈废的控制字符，
 控制字符的用途主要是用来操控已经处理过的文字，在33个字符之外的是95个可显示的字符，包含用键盘敲下空白键所产生的空白字符也算1个可显示字符
 （显示为空白）。
 </summary>
 <remarks>http://ascii.911cha.com/</remarks>
</member>
<member name="F:Microsoft.VisualBasic.Text.ASCII.NUL">
 <summary>
 0000 0000	0	00	NUL	空字符（Null）
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.ASCII.SOH">
 <summary>
 0000 0001	1	01	SOH	标题开始
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.ASCII.STX">
 <summary>
 0000 0010	2	02	STX	本文开始
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.ASCII.ETX">
 <summary>
 0000 0011	3	03	ETX	本文结束
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.ASCII.EOT">
 <summary>
 0000 0100	4	04	EOT	传输结束
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.ASCII.ENQ">
 <summary>
 0000 0101	5	05	ENQ	请求
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.ASCII.ACK">
 <summary>
 0000 0110	6	06	ACK	确认回应
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.ASCII.BEL">
 <summary>
 0000 0111	7	07	BEL	响铃
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.ASCII.BS">
 <summary>
 0000 1000	8	08	BS	退格
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.ASCII.HT">
 <summary>
 0000 1001	9	09	HT	水平定位符号
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.ASCII.LF">
 <summary>
 0000 1010	10	0A	LF	换行键
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.ASCII.VT">
 <summary>
 0000 1011	11	0B	VT	垂直定位符号
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.ASCII.FF">
 <summary>
 0000 1100	12	0C	FF	换页键
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.ASCII.CR">
 <summary>
 0000 1101	13	0D	CR	归位键
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.ASCII.SO">
 <summary>
 0000 1110	14	0E	SO	取消变换（Shift out）
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.ASCII.SI">
 <summary>
 0000 1111	15	0F	SI	启用变换（Shift in）
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.ASCII.DLE">
 <summary>
 0001 0000	16	10	DLE	跳出数据通讯
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.ASCII.DC1">
 <summary>
 0001 0001	17	11	DC1	设备控制一（XON 启用软件速度控制）
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.ASCII.DC2">
 <summary>
 0001 0010	18	12	DC2	设备控制二
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.ASCII.DC3">
 <summary>
 0001 0011	19	13	DC3	设备控制三（XOFF 停用软件速度控制）
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.ASCII.DC4">
 <summary>
 0001 0100	20	14	DC4	设备控制四
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.ASCII.NAK">
 <summary>
 0001 0101	21	15	NAK	确认失败回应
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.ASCII.SYN">
 <summary>
 0001 0110	22	16	SYN	同步用暂停
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.ASCII.ETB">
 <summary>
 0001 0111	23	17	ETB	区块传输结束
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.ASCII.CAN">
 <summary>
 0001 1000	24	18	CAN	取消
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.ASCII.EM">
 <summary>
 0001 1001	25	19	EM	连接介质中断
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.ASCII.SUB">
 <summary>
 0001 1010	26	1A	SUB	替换
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.ASCII.ESC">
 <summary>
 0001 1011	27	1B	ESC	跳出
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.ASCII.FS">
 <summary>
 0001 1100	28	1C	FS	文件分割符
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.ASCII.GS">
 <summary>
 0001 1101	29	1D	GS	组群分隔符
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.ASCII.RS">
 <summary>
 0001 1110	30	1E	RS	记录分隔符
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.ASCII.US">
 <summary>
 0001 1111	31	1F	US	单元分隔符
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.ASCII.DEL">
 <summary>
 0111 1111	127	7F	DEL	删除
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Text.ASCII.Nonprintings">
 <summary>
 非打印字符也可以是正则表达式的组成部分。下表列出了表示非打印字符的转义序列：
 
 ##### 转义序列
 
 |字符|含义|
 |---|----|
 |\cx|匹配 x 指示的控制字符。例如，\cM 匹配 Control-M 或回车符。x 的值必须在 A-Z 或 a-z 之间。如果不是这样，则假定 c 就是“c”字符本身。|
 |\f |换页符匹配。等效于 \x0c 和 \cL。|
 |\n |换行符匹配。等效于 \x0a 和 \cJ。|
 |\r |匹配一个回车符。等效于 \x0d 和 \cM。|
 |\s |匹配任何空白字符，包括空格、制表符、换页符等。与 [\f\n\r\t\v] 等效。|
 |\S |匹配任何非空白字符。与 [^ \f\n\r\t\v] 等效。|
 |\t |制表符匹配。与 \x09 和 \cI 等效。|
 |\v |垂直制表符匹配。与 \x0b 和 \cK 等效。|
 </summary>
 <returns></returns>
</member>
<member name="F:Microsoft.VisualBasic.Text.ASCII.TAB">
 <summary>
 <see cref="F:Microsoft.VisualBasic.Constants.vbTab"/>
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.ASCII.Whitespace">
 <summary>
 a collection of the ascii whitespace chars
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.ASCII.Quot">
 <summary>
 双引号``"``
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.ASCII.n0">
 <summary>
 ASCII code for number ``0``
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.ASCII.n9">
 <summary>
 ASCII code for number ``9``
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.ASCII.Mark">
 <summary>
 单引号
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Text.ASCII.ReplaceQuot(System.String,System.String)">
 <summary>
 分别替换英文双引号，中文双引号为指定的字符串
 </summary>
 <param name="s"></param>
 <param name="replace"></param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Text.ASCII.Symbols">
 <summary>
 Symbols without white space.(可以印刷的ASCII符号列表)
 </summary>
 <returns></returns>
</member>
<member name="F:Microsoft.VisualBasic.Text.ASCII.Byte.NUL">
 <summary>
 0000 0000	0	00	NUL	空字符（Null）
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.ASCII.Byte.SOH">
 <summary>
 0000 0001	1	01	SOH	标题开始
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.ASCII.Byte.STX">
 <summary>
 0000 0010	2	02	STX	本文开始
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.ASCII.Byte.ETX">
 <summary>
 0000 0011	3	03	ETX	本文结束
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.ASCII.Byte.EOT">
 <summary>
 0000 0100	4	04	EOT	传输结束
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.ASCII.Byte.ENQ">
 <summary>
 0000 0101	5	05	ENQ	请求
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.ASCII.Byte.ACK">
 <summary>
 0000 0110	6	06	ACK	确认回应
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.ASCII.Byte.BEL">
 <summary>
 0000 0111	7	07	BEL	响铃
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.ASCII.Byte.BS">
 <summary>
 0000 1000	8	08	BS	退格
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.ASCII.Byte.HT">
 <summary>
 0000 1001	9	09	HT	水平定位符号
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.ASCII.Byte.LF">
 <summary>
 0000 1010	10	0A	LF	换行键
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.ASCII.Byte.VT">
 <summary>
 0000 1011	11	0B	VT	垂直定位符号
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.ASCII.Byte.FF">
 <summary>
 0000 1100	12	0C	FF	换页键
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.ASCII.Byte.CR">
 <summary>
 0000 1101	13	0D	CR	归位键
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.ASCII.Byte.SO">
 <summary>
 0000 1110	14	0E	SO	取消变换（Shift out）
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.ASCII.Byte.SI">
 <summary>
 0000 1111	15	0F	SI	启用变换（Shift in）
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.ASCII.Byte.DLE">
 <summary>
 0001 0000	16	10	DLE	跳出数据通讯
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.ASCII.Byte.DC1">
 <summary>
 0001 0001	17	11	DC1	设备控制一（XON 启用软件速度控制）
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.ASCII.Byte.DC2">
 <summary>
 0001 0010	18	12	DC2	设备控制二
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.ASCII.Byte.DC3">
 <summary>
 0001 0011	19	13	DC3	设备控制三（XOFF 停用软件速度控制）
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.ASCII.Byte.DC4">
 <summary>
 0001 0100	20	14	DC4	设备控制四
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.ASCII.Byte.NAK">
 <summary>
 0001 0101	21	15	NAK	确认失败回应
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.ASCII.Byte.SYN">
 <summary>
 0001 0110	22	16	SYN	同步用暂停
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.ASCII.Byte.ETB">
 <summary>
 0001 0111	23	17	ETB	区块传输结束
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.ASCII.Byte.CAN">
 <summary>
 0001 1000	24	18	CAN	取消
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.ASCII.Byte.EM">
 <summary>
 0001 1001	25	19	EM	连接介质中断
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.ASCII.Byte.SUB">
 <summary>
 0001 1010	26	1A	SUB	替换
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.ASCII.Byte.ESC">
 <summary>
 0001 1011	27	1B	ESC	跳出
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.ASCII.Byte.FS">
 <summary>
 0001 1100	28	1C	FS	文件分割符
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.ASCII.Byte.GS">
 <summary>
 0001 1101	29	1D	GS	组群分隔符
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.ASCII.Byte.RS">
 <summary>
 0001 1110	30	1E	RS	记录分隔符
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.ASCII.Byte.US">
 <summary>
 0001 1111	31	1F	US	单元分隔符
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.ASCII.Byte.DEL">
 <summary>
 0111 1111	127	7F	DEL	删除
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.ASCII.Byte.TAB">
 <summary>
 <see cref="F:Microsoft.VisualBasic.Constants.vbTab"/>
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Text.GreekAlphabets">
 <summary>
 Processing for the chemical compound name/genome species scientific name.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Text.GreekAlphabets.StripGreek(System.Text.StringBuilder@)">
 <summary>
 将字符串文本之中的希腊字母替换为英文单词
 </summary>
 <param name="s"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.GreekAlphabets.StripGreek(System.String)">
 <summary>
 将字符串文本之中的希腊字母替换为英文单词
 </summary>
 <param name="s$"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.GreekAlphabets.AlphabetUnescape(System.String,System.Boolean,System.Boolean)">
 <summary>
 
 </summary>
 <param name="s$"></param>
 <param name="removesContacts"></param>
 <param name="upperCase"></param>
 <returns></returns>
 
</member>
<member name="T:Microsoft.VisualBasic.Text.EncodingHelper">
 <summary>
 Helper for <see cref="T:Microsoft.VisualBasic.Text.Encodings"/>
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Text.EncodingHelper.TextEncoding">
 <summary>
 <see cref="T:System.Text.Encoding"/> instance
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.EncodingHelper.#ctor(Microsoft.VisualBasic.Text.Encodings)">
 <summary>
 Helper for <see cref="T:Microsoft.VisualBasic.Text.Encodings"/>
 </summary>
 <param name="encoding"></param>
</member>
<member name="M:Microsoft.VisualBasic.Text.EncodingHelper.GetBytes(System.String)">
 <summary>
 When overridden in a derived class, encodes all the characters in the specified
 string into a sequence of bytes.
 </summary>
 <param name="s">The string containing the characters to encode.</param>
 <returns>A byte array containing the results of encoding the specified set of characters.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.EncodingHelper.ToString(System.Byte[])">
 <summary>
 When overridden in a derived class, decodes all the bytes in the specified byte
 array into a string.
 </summary>
 <param name="byts">The byte array containing the sequence of bytes to decode.</param>
 <returns>A string that contains the results of decoding the specified sequence of bytes.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.EncodingHelper.ToString">
 <summary>
 <see cref="T:System.Text.Encoding"/> instance
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Text.Encodings">
 <summary>
 The text document encodings constant for text file read and write
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.Encodings.Default">
 <summary>
 <see cref="P:System.Text.Encoding.Default"/>: Gets an encoding for the operating system's current ANSI code page.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.Encodings.Unicode">
 <summary>
 Alias of the value <see cref="F:Microsoft.VisualBasic.Text.Encodings.UTF16"/>.
 (utf-16编码的别名？所以使用这个编码的效果是和<see cref="F:Microsoft.VisualBasic.Text.Encodings.UTF16"/>的效果是一样的)
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.Encodings.UTF8">
 <summary>
 在Linux平台上面是<see cref="P:Microsoft.VisualBasic.Text.TextEncodings.UTF8WithoutBOM"/>，而在Windows平台上面则是带有BOM的UTF8格式. 
 (HTML的默认的编码格式，假若所保存的html文本出现乱码，请考虑是不是应该要选择这个编码才行？)
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.Encodings.UTF16">
 <summary>
 VB.NET的XML文件的默认编码格式为utf-16
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.Encodings.GB2312">
 <summary>
 Text encoding for simplify Chinese.
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Text.GB2312">
 <summary>
 A helper module for processing of the chinese characters
 </summary>
 <remarks>
 汉字拼音转换类
 </remarks>
</member>
<member name="P:Microsoft.VisualBasic.Text.GB2312.otherChinese">
 <summary>
 二级汉字数组
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Text.GB2312.otherPinYin">
 <summary>
 二级汉字对应拼音数组
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.GB2312.firstChCode">
 <summary>
 ``GB2312-80``标准规范中第一个汉字的机内码.即``啊``的机内码 
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.GB2312.lastChCode">
 <summary>
 ``GB2312-80``标准规范中最后一个汉字的机内码.即``齄``的机内码 
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.GB2312.lastOfOneLevelChCode">
 <summary>
 ``GB2312-80``标准规范中最后一个一级汉字的机内码.即``座``的机内码
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Text.GB2312.a">
 <summary>
 ``啊``
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.GB2312.GetFirst(System.Char)">
 <summary>
 取拼音第一个字段
 </summary>        
 <param name="ch"></param>        
 <returns></returns>        
</member>
<member name="M:Microsoft.VisualBasic.Text.GB2312.GetFirst(System.String)">
 <summary>
 取拼音第一个字段
 </summary>
 <param name="str"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.GB2312.PinYin(System.Char,System.Boolean@)">
 <summary>
 获取单字拼音
 </summary>
 <param name="ch"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.GB2312.TranscriptPinYin(System.String,System.String)">
 <summary>
 把汉字转换成拼音(全拼)
 </summary>
 <param name="str">汉字字符串</param>
 <returns>转换后的拼音(全拼)字符串</returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.GB2312.IsChineseCharacter(System.Char)">
 <summary>
 Check of the given character is a chinese character or not?
 </summary>
 <param name="character"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Text.TextEncodings">
 <summary>
 表示字符编码。若要浏览此类型的.NET Framework 源代码，请参阅 Reference Source。
 </summary>
 
</member>
<member name="P:Microsoft.VisualBasic.Text.TextEncodings.DefaultEncoding">
 <summary>
 <see cref="P:System.Text.Encoding.Default"/>
 
 (获取操作系统的当前 ANSI 代码页的编码。这个属性可以通过``default_encoding``环境参数来设置)
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Text.TextEncodings.UTF8">
 <summary>
 UTF-8 without BOM.(获取 UTF-8 格式的编码。<see cref="P:System.Text.Encoding.UTF8"/>默认是带有BOM标记的，这里使用无BOM标记的UTF8编码)
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Text.TextEncodings.TextEncodings">
 <summary>
 编码由枚举类型<see cref="T:Microsoft.VisualBasic.Text.Encodings"/>到<see cref="T:System.Text.Encoding"/>之间的映射
 </summary>
 <returns></returns>
 <remarks>
 可能在Linux服务器上面没有使用gb2312编码集合，则在这个模块之中初始化会出错
 
 ```bash
 locale -a
 
 yum install -y mono-locale-extras
 ```
 </remarks>
</member>
<member name="F:Microsoft.VisualBasic.Text.TextEncodings.encodingFlags">
 <summary>
 use for parse encoding flags from string
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Text.TextEncodings.codePageTable">
 <summary>
 在这个函数之中会根据当前所运行的平台对utf8编码进行一下额外的处理
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.TextEncodings.#cctor">
 <summary>
 构造函数会自动的从命令行配置之中设置默认的编码格式
 </summary>
 <remarks>
 ###### Linux下面提示 Encoding 936 data could not be found.
 
 处理方法

 1. 应该首先``locale -a``看有没有安装``gbk``
 2. 没安装的话需要先安装gbk编码
 3. 然后再安装``mono-locale-extras``

 ```bash
 locale -a
 yum install -y mono-locale-extras
 ```
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Text.TextEncodings.__gbk2312_encoding">
 <summary>
 在linux上面如果没有安装gb2312的话，会出错，则这个函数会默认使用UTF8编码
 并给出警告信息
 </summary>
 <returns></returns>
 <remarks>
 If the linux server didn't enable the gb2312 text encoding, then this exception happends...
 
 ```bash
 [ERROR] FATAL UNHANDLED EXCEPTION: System.Exception: [Path]  /home/software/cytonetwork.test/cytonetwork ---> System.Exception: [DIR]  /home/software/cytonetwork.test ---> System.TypeInitializationException: The type initializer for 'Microsoft.VisualBasic.Text.TextEncodings' threw an exception. ---> System.NotSupportedException: Encoding 936 data could not be found. Make sure you have correct international codeset assembly installed and enabled.
 at System.Text.Encoding.GetEncoding (System.Int32 codepage) [0x0023f] In &lt;902ab9e386384bec9c07fa19aa938869>:0
 at System.Text.Encoding.GetEncoding (System.String name) [0x00012] In &lt;902ab9e386384bec9c07fa19aa938869>:0
 at Microsoft.VisualBasic.Text.TextEncodings..cctor () [0x00030] In &lt;00ade39f7ffc4ab69ceb325aefc4ee1b>:0
  --- End of inner exception stack trace ---
 at Microsoft.VisualBasic.TextDoc.SaveTo (System.String text, System.String path, System.Text.Encoding encoding, System.Boolean append, System.Boolean throwEx) [0x00063] In &lt;00ade39f7ffc4ab69ceb325aefc4ee1b>:0
  --- End of inner exception stack trace ---
  --- End of inner exception stack trace ---
 at Microsoft.VisualBasic.TextDoc.SaveTo (System.String text, System.String path, System.Text.Encoding encoding, System.Boolean append, System.Boolean throwEx) [0x000a7] In &lt;00ade39f7ffc4ab69ceb325aefc4ee1b>:0
 at Microsoft.VisualBasic.Language.UnixBash.LinuxRunHelper.BashShell () [0x0001b] In &lt;00ade39f7ffc4ab69ceb325aefc4ee1b>:0
 at Microsoft.VisualBasic.CommandLine.Interpreter.__methodInvoke (System.String commandName, System.Object[] argvs, System.String[] help_argvs) [0x001c9] In &lt;00ade39f7ffc4ab69ceb325aefc4ee1b>:0
 at Microsoft.VisualBasic.CommandLine.Interpreter.Execute (Microsoft.VisualBasic.CommandLine.CommandLine args) [0x00024] In &lt;00ade39f7ffc4ab69ceb325aefc4ee1b>:0
 at Microsoft.VisualBasic.App.RunCLI (System.Type Interpreter, Microsoft.VisualBasic.CommandLine.CommandLine args, System.String caller) [0x00012] In &lt;00ade39f7ffc4ab69ceb325aefc4ee1b>:0
 at cytonetwork.Program.Main () [0x0000f] In &lt;0Fa3aca1569b43dc8ca208295f3a029d>:0
 ```
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Text.TextEncodings.CodePage(Microsoft.VisualBasic.Text.Encodings)">
 <summary>
 Get text file save <see cref="T:System.Text.Encoding"/> instance
 </summary>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.TextEncodings.ParseEncodingsName(System.String,Microsoft.VisualBasic.Text.Encodings)">
 <summary>
 从字符串名称之中解析出编码格式的枚举值(名称的大小写不敏感)
 </summary>
 <param name="encoding">名称的大小写不敏感</param>
 <param name="onFailure"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.TextEncodings.TransEncoding(System.String,Microsoft.VisualBasic.Text.Encodings,System.Text.Encoding)">
 <summary>
 有时候有些软件对文本的编码是有要求的，则可以使用这个函数进行文本编码的转换
 例如R程序默认是读取ASCII，而。NET的默认编码是UTF8，则可以使用这个函数将目标文本文件转换为ASCII编码的文本文件
 </summary>
 <param name="path"></param>
 <param name="encoding"></param>
 <param name="from"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Text.TextFileEncodingDetector">
 <summary>
 Encoding fileEncoding = TextFileEncodingDetector.DetectTextFileEncoding("you file path",Encoding.Default);
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Text.TextFileEncodingDetector.DetectTextFileEncoding(System.String,System.Text.Encoding)">
 <summary>
 completely arbitrary - inappropriate for high numbers of files / high speed requirements
 </summary>
 <param name="InputFilename"></param>
 <param name="DefaultEncoding"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.Text.UnbufferedStreamReader">
 <summary>
 提供无缓冲的按行读取文本流的功能。
 用于避免 StreamReader 内部缓冲区导致流位置超出实际内容末尾的问题。
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Text.UnbufferedStreamReader.#ctor(System.IO.Stream,System.Text.Encoding,System.Boolean)">
 <summary>
 初始化 UnbufferedStreamReader 类的新实例。
 </summary>
 <param name="stream">要读取的流。</param>
 <param name="encoding">要使用的字符编码。默认为 UTF-8。</param>
 <param name="leaveOpen">在释放 Reader 后是否保持流打开。默认为 False。</param>
 <exception cref="T:System.ArgumentNullException">stream 为 Nothing。</exception>
 <exception cref="T:System.ArgumentException">流不支持读取。</exception>
</member>
<member name="M:Microsoft.VisualBasic.Text.UnbufferedStreamReader.ReadLine">
 <summary>
 从当前流中读取一行字符。
 </summary>
 <returns>当前行内容；如果已到达流末尾，则为 Nothing。</returns>
 <exception cref="T:System.ObjectDisposedException">方法在流被释放后调用。</exception>
</member>
<member name="M:Microsoft.VisualBasic.Text.UnbufferedStreamReader.Dispose(System.Boolean)">
 <summary>
 释放由 UnbufferedStreamReader 使用的所有资源。
 </summary>
 <param name="disposing">为 True 则释放托管资源和非托管资源；为 False 则仅释放非托管资源。</param>
</member>
<member name="T:Microsoft.VisualBasic.Text.UnbufferedStringReader">
 <summary>
 Represents a reader that can read a sequential series of characters.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Text.UnbufferedStringReader.Close">
 <summary>
 Closes the System.IO.TextReader and releases any system resources associated
 with the TextReader.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Text.UnbufferedStringReader.Peek">
 <summary>
 Reads the next character without changing the state of the reader or the character
 source. Returns the next available character without actually reading it from
 the reader.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.UnbufferedStringReader.Read">
 <summary>
 Reads the next character from the text reader and advances the character position
 by one character.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.UnbufferedStringReader.Read(System.Char[],System.Int32,System.Int32)">
 <summary>
 Reads a specified maximum number of characters from the current reader and writes
 the data to a buffer, beginning at the specified index.
 </summary>
 <param name="buffer"></param>
 <param name="index"></param>
 <param name="count"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.UnbufferedStringReader.ReadLine">
 <summary>
 Reads a line of characters from the text reader and returns the data as a string.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.UnbufferedStringReader.ReadToEnd">
 <summary>
 Reads all characters from the current position to the end of the text reader
 and returns them as one string.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Text.UnbufferedStringReader.Position">
 <summary>
 The current read position.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.Paragraph.Chunks(System.String,System.Int32)">
 <summary>
 对于空文本，这个函数返回一个空集合
 </summary>
 <param name="text">原始文本</param>
 <param name="lineBreak">每一行文本的最大字符数量</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.Paragraph.SplitParagraph(System.String,System.Int32,System.String,System.Int32)">
 <summary>
 
 </summary>
 <param name="text">一大段文本</param>
 <param name="len">每一行文本的最大字符串数量长度</param>
 <returns></returns>
 <remarks>
 假若长度分割落在单词内，则添加一个连接符，假如是空格或者标点符号，则不处理
 </remarks>
</member>
<member name="T:Microsoft.VisualBasic.Text.Parser.CharBuffer">
 <summary>
 A buffer list of the characters
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.Parser.CharBuffer.buffer">
 <summary>
 the current buffer data list
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Text.Parser.CharBuffer.GetChar(System.Int32)">
 <summary>
 get char from the buffer list via a given index value
 </summary>
 <param name="i">
 使用负数表示从尾到头
 </param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Text.Parser.CharBuffer.Size">
 <summary>
 get current size of the data in this char buffer object
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Text.Parser.CharBuffer.Last">
 <summary>
 get the last char in current buffer list data
 </summary>
 <returns></returns>
 <remarks>
 get the last char unsafe, this property may crashed the program if 
 the <see cref="F:Microsoft.VisualBasic.Text.Parser.CharBuffer.buffer"/> list data contains no elements. for get 
 the last char safely, use the <see cref="M:Microsoft.VisualBasic.Text.Parser.CharBuffer.GetLastOrDefault"/> 
 function.
 </remarks>
</member>
<member name="P:Microsoft.VisualBasic.Text.Parser.CharBuffer.isInteger">
 <summary>
 test if current chars is like the integer string pattern
 </summary>
 <returns></returns>
 <remarks>
 the negative value not works here, just test for the integer chars pattern
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Text.Parser.CharBuffer.StartsWith(System.String)">
 <summary>
 test if current char buffer is starts with a specific prefix string
 </summary>
 <param name="prefix"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.Parser.CharBuffer.Add(System.Char)">
 <summary>
 add a char into current buffer data list
 </summary>
 <param name="c"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.Parser.CharBuffer.Add(System.String)">
 <summary>
 add a collection of char into current buffer data list
 </summary>
 <param name="chars"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.Parser.CharBuffer.GetLastOrDefault">
 <summary>
 get the last char from current buffer list data safely, if the 
 internal buffer list has no element data, then this function 
 will returns nothing 
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.Parser.CharBuffer.Clear">
 <summary>
 clear the internal buffer list data
 </summary>
 
</member>
<member name="M:Microsoft.VisualBasic.Text.Parser.CharBuffer.Pop">
 <summary>
 populate out the last char from the internal buffer list
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.Parser.CharBuffer.PopAllChars">
 <summary>
 populate all chars in current object and then clear the buffer list
 </summary>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Text.Parser.CharBuffer.ToString">
 <summary>
 text
 </summary>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Text.Parser.CharBuffer.op_Implicit(System.String)~Microsoft.VisualBasic.Text.Parser.CharBuffer">
 <summary>
 Convert a string object to a char buffer
 </summary>
 <param name="str"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.Parser.CharBuffer.op_Equality(Microsoft.VisualBasic.Text.Parser.CharBuffer,System.String)">
 <summary>
 string equals?
 </summary>
 <param name="buf"></param>
 <param name="test"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.Parser.CharBuffer.op_Inequality(Microsoft.VisualBasic.Text.Parser.CharBuffer,System.String)">
 <summary>
 string not equals?
 </summary>
 <param name="buf"></param>
 <param name="test"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Text.Parser.CharBuffer.op_Equality(Microsoft.VisualBasic.Text.Parser.CharBuffer,System.Char)">
 <summary>
 test current char buffer size is 1 and also is equals to the given char?
 </summary>
 <param name="buf"></param>
 <param name="test"></param>
 <returns>
 this function returns false if the buffer size is not equals to 1
 if the single char in the given buffer is not equals to the given 
 <paramref name="test"/> char, then returns false.
 </returns>
</member>
<member name="T:Microsoft.VisualBasic.Text.Parser.CharPtr">
 <summary>
 Char enumerator
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Text.Parser.CharPtr.Remaining">
 <summary>
 查看还有多少字符没有被处理完
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.Parser.CharPtr.ToString">
 <summary>
 这个调试试图函数会将当前的读取位置给标记出来
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.Parser.CharPtr.op_Implicit(System.Text.StringBuilder)~Microsoft.VisualBasic.Text.Parser.CharPtr">
 <summary>
 construct an in-memory dataset
 </summary>
 <param name="str">the in-memory string data</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.Parser.CharPtr.op_Equality(Microsoft.VisualBasic.Text.Parser.CharPtr,System.String)">
 <summary>
 check of the string equals?
 </summary>
 <param name="str"></param>
 <param name="text"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.Parser.CharPtr.op_Like(Microsoft.VisualBasic.Text.Parser.CharPtr,System.String)">
 <summary>
 Check of the text equals?
 </summary>
 <param name="str">text1</param>
 <param name="text">text2</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.Parser.DelimiterParser.GetTokens(System.String)">
 <summary>
 非正则表达式命令行解析引擎
 </summary>
 <param name="cli">the commandline string</param>
 <returns></returns>
 <remarks>
 + 双引号表示一个完整的token
 + 空格为分隔符
 </remarks>
</member>
<member name="T:Microsoft.VisualBasic.Text.Parser.FormattedParser">
 <summary>
 Parser API for the well formatted documents.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Text.Parser.FormattedParser.FlagSplit(System.IO.StreamReader,System.Func{System.String,System.Boolean})">
 <summary>
 String collection tokens by a certain delimiter string element.
 </summary>
 <param name="s"></param>
 <param name="isFlag"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.Parser.FormattedParser.FlagSplit(System.Collections.Generic.IEnumerable{System.String},System.Func{System.String,System.Boolean})">
 <summary>
 String collection tokens by a certain delimiter string element.
 </summary>
 <param name="source"></param>
 <param name="isFlag">
 
 </param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.Parser.FormattedParser.CrossFields(System.String)">
 <summary>
 Example as: ------- ------ -----    ------- ------ -----   ---- --  --------   ----------- 
 </summary>
 <param name="s"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.Parser.FormattedParser.FieldParser(System.String,System.Int32[])">
 <summary>
 Parsing a line of string into several fields fragments based on the fields length.
 (假设表格之中的每一个字段都是等长的话, 则可以使用这个函数来进行解析)
 </summary>
 <param name="s">The input text line.</param>
 <param name="fieldLength">The text length of each field property value.</param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Text.Parser.FormattedParser.DoContinute">
 <summary>
 Condition for continue move the parser pointer.
 </summary>
 <param name="s"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.Parser.FormattedParser.ReadHead(System.String[],System.Int32@,Microsoft.VisualBasic.Text.Parser.FormattedParser.DoContinute)">
 <summary>
 Parsing the document head section from the document.
 </summary>
 <param name="buf"></param>
 <param name="offset">
 This function will returns the new offset value from this reference parameter.
 (从这里向调用者返回偏移量)
 </param>
 <param name="__isHead">Condition for continue move the parser pointer to the next line.</param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Text.Parser.HtmlParser.HtmlStrips">
 <summary>
 Html text document operations for a given html text
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Text.Parser.HtmlParser.HtmlStrips.GetHtmlComments(System.String)">
 <summary>
 将<paramref name="html"/>文本之中的注释部分的字符串拿出来
 </summary>
 <param name="html"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.Parser.HtmlParser.HtmlStrips.RemovesHtmlComments(System.Text.StringBuilder)">
 <summary>
 removes all of the html code comments from a given <paramref name="html"/> document.
 </summary>
 <param name="html"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.Parser.HtmlParser.HtmlStrips.GetLinks(System.String)">
 <summary>
 从html文本之中解析出所有的链接
 </summary>
 <param name="html$"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.Parser.HtmlParser.HtmlStrips.HTMLTitle(System.String)">
 <summary>
 Parsing the title text from the html inputs.
 </summary>
 <param name="html"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.Parser.HtmlParser.HtmlStrips.StripHTMLTags(System.String,System.Boolean)">
 <summary>
 Removes the html tags from the text string.
 </summary>
 <param name="s"></param>
 <returns>
 a plain text that removes all html format tags
 </returns>
 <remarks>
 (这个函数会移除所有的html标签)
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Text.Parser.HtmlParser.HtmlStrips.paragraph(System.String,System.Boolean)">
 <summary>
 
 </summary>
 <param name="html"></param>
 <param name="plainText">If this argument is value True, then all of the html format tag will be removes.</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.Parser.HtmlParser.HtmlStrips.TrimResponseTail(System.String)">
 <summary>
 有些时候后面可能会存在多余的vbCrLf，则使用这个函数去除
 </summary>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.Parser.HtmlParser.HtmlStrips.GetValue(System.String)">
 <summary>
 Gets the string value between two wrapper character.
 (获取两个尖括号之间的内容)
 </summary>
 <param name="html"></param>
 <returns></returns>
 <remarks>
 use this function for get the xml/html element tag value, example as:
 
 ' get "title &lt;b>aaa&lt;/b>"
 &lt;h1>title &lt;b>aaa&lt;/b>&lt;/h1>
 </remarks>
</member>
<member name="F:Microsoft.VisualBasic.Text.Parser.HtmlParser.HtmlStrips.LineFeed">
 <summary>
 The line break html tag in the html document. 
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Text.Parser.HtmlParser.HtmlStrips.HtmlLines(System.String,System.Boolean)">
 <summary>
 Split the html text into lines by tags: ``&lt;br>`` or ``&lt;br/>``
 </summary>
 <param name="html$"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.Parser.HtmlParser.HtmlStrips.RemovesJavaScript(System.String)">
 <summary>
 将<paramref name="html"/>中的``&lt;script>&lt;/script>``代码块删除
 </summary>
 <param name="html$"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.Parser.HtmlParser.HtmlStrips.RemovesCSSstyles(System.String)">
 <summary>
 Removes all of the ``&lt;style>`` css styles block from a given <paramref name="html"/> document.
 </summary>
 <param name="html"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.Parser.HtmlParser.HtmlStrips.RemovesImageLinks(System.String)">
 <summary>
 Removes all of the ``&lt;img>`` image links block from a given <paramref name="html"/> document.
 </summary>
 <param name="html"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Text.Parser.HtmlParser.TableParser">
 <summary>
 The string parser for the table html text block
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Text.Parser.HtmlParser.TableParser.GetTablesHTML(System.String,System.Boolean)">
 <summary>
 Parsing the html text betweens the tag ``&lt;table>&lt;/table>`` by using regex expression.
 </summary>
 <param name="html"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Text.Parser.HtmlParser.TableParser.GetRowsHTML(System.String,System.Boolean)">
 <summary>
 Parsing the html text betweens the tag ``&lt;tr>&lt;/tr>`` by using regex expression.
 </summary>
 <param name="table"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Text.Parser.HtmlParser.TableParser.GetColumnsHTML(System.String,System.Boolean)">
 <summary>
 The td tag is trimmed in this function.(请注意，在本函数之中，``&lt;td>``标签是被去除掉了的)
 </summary>
 <param name="row"></param>
 <returns></returns>
 
</member>
<member name="F:Microsoft.VisualBasic.Text.Parser.HtmlParser.TagAttributeParser.attributeParse">
 <summary>
 The regexp pattern for the attributes in a html tag.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Text.Parser.HtmlParser.TagAttributeParser.TagAttributes(System.String)">
 <summary>
 获取一个html标签之中的所有的attribute属性数据
 </summary>
 <param name="tag$"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.Parser.HtmlParser.TagAttributeParser.attr(System.String,System.String)">
 <summary>
 Get element attribute value
 </summary>
 <param name="html$"></param>
 <param name="attrName$"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.Parser.HtmlParser.TagAttributeParser.href(System.String,System.String)">
 <summary>
 Gets the link text in the html fragement text.
 </summary>
 <param name="html">A string that contains the url string pattern like: href="url_text"</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Text.Parser.HtmlParser.TagAttributeParser.src(System.String)">
 <summary>
 Parsing image source url from the img html tag.
 </summary>
 <param name="img"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.Parser.HtmlParser.TagAttributeParser.img(System.String)">
 <summary>
 parse a image tag
 </summary>
 <param name="html$"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Text.Parser.ParserValue`1">
 <summary>
 
 </summary>
 <typeparam name="T"></typeparam>
 <remarks>这个对象的用途和<see cref="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedValue`1"/>对象的用途是一致的，只不过差异在于所想要表达的寓意上面</remarks>
</member>
<member name="T:Microsoft.VisualBasic.Text.Parser.Scanner">
 <summary>
 模拟Java Scanner类功能的VB.NET类。
 注意：此类未实现Java Scanner的所有方法，仅提供核心功能。
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Text.Parser.Scanner.#ctor(System.IO.TextReader)">
 <summary>
 构造函数，基于TextReader创建VBNetScanner。
 </summary>
 <param name="reader">输入的TextReader对象</param>
</member>
<member name="M:Microsoft.VisualBasic.Text.Parser.Scanner.#ctor">
 <summary>
 从控制台标准输入创建VBNetScanner。
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Text.Parser.Scanner.#ctor(System.String)">
 <summary>
 从字符串创建VBNetScanner。
 </summary>
 <param name="input">输入的字符串</param>
</member>
<member name="M:Microsoft.VisualBasic.Text.Parser.Scanner.UseDelimiter(System.String)">
 <summary>
 设置分隔符（支持正则表达式）。
 </summary>
 <param name="pattern">分隔符的正则表达式模式</param>
 <returns>返回当前VBNetScanner实例，支持链式调用</returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.Parser.Scanner.HasNext">
 <summary>
 检查是否还有下一个令牌（使用当前分隔符）。
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Text.Parser.Scanner.Next">
 <summary>
 读取下一个令牌（字符串）。
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Text.Parser.Scanner.HasNextLine">
 <summary>
 检查是否还有下一行。
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Text.Parser.Scanner.NextLine">
 <summary>
 读取下一行内容。
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Text.Parser.Scanner.NextInt">
 <summary>
 读取下一个整数。
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Text.Parser.Scanner.HasNextInt">
 <summary>
 检查是否还有下一个整数。
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Text.Parser.Scanner.NextDouble">
 <summary>
 读取下一个双精度浮点数。
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Text.Parser.Scanner.HasNextDouble">
 <summary>
 检查是否还有下一个双精度浮点数。
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Text.Parser.Scanner.Close">
 <summary>
 关闭扫描器并释放资源。
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Text.Parser.Scanner.Dispose">
 <summary>
 释放资源。
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Text.Parser.Scanner.ReadNextLine">
 <summary>
 尝试读取下一行并按分隔符拆分。
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.Parser.TryParseOptions.Empty">
 <summary>
 Function should returns empty string when try parse failed.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.Parser.TryParseOptions.Nothing">
 <summary>
 Function should returns nothing when try parse failed.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.Parser.TryParseOptions.Source">
 <summary>
 Function should returns the source input when try parse failed.
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Text.Parser.ParserHelpers">
 <summary>
 Helpers for text parser
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Text.Patterns.CommonTagParser.maxLen">
 <summary>
 the max length of the sample names in char numbers
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Text.Patterns.CommonTagParser.MaxColumnIndex">
 <summary>
 the max length of the labels common parts
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Text.Patterns.CommonTagParser.LabelPrefix">
 <summary>
 get the max common prefixed label value
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Text.Patterns.CommonTagParser.Size">
 <summary>
 Get number of the input sample names
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.Patterns.CommonTagParser.RemoveLeadingNumbersAndSymbols(System.String)">
 <summary>
 removes leading number and symbols
 </summary>
 <param name="input"></param>
 <returns>
 1-B11 to B11
 B2 remains B2
 </returns>
</member>
<member name="T:Microsoft.VisualBasic.Text.Patterns.NamespaceDoc">
 <summary>
 text patterns and validations
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Text.Patterns.Regexp.op_LessThanOrEqual(Microsoft.VisualBasic.Text.Patterns.Regexp,System.String)">
 <summary>
 Grep target input <paramref name="text"/> by a specific regex <paramref name="pattern"/>.
 Match all of the sub string in target <paramref name="text"/> that matched the input regex <paramref name="pattern"/>.
 (即从目标字符串之中匹配出所有符合目标模式的字符串)
 </summary>
 <param name="pattern"></param>
 <param name="text$"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Text.Patterns.Regexp.op_BitwiseAnd(System.String,Microsoft.VisualBasic.Text.Patterns.Regexp)">
 <summary>
 求出目标字符串<paramref name="text"/>和<paramref name="pattern"/>的交集，即使用正则表达式来匹配目标字符串之中的子串
 </summary>
 <param name="text$"></param>
 <param name="pattern"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Text.Patterns.Regexp.op_BitwiseAnd(Microsoft.VisualBasic.Text.Patterns.Regexp,System.String)">
 <summary>
 求出目标字符串<paramref name="text"/>和<paramref name="pattern"/>的交集，即使用正则表达式来匹配目标字符串之中的子串
 </summary>
 <param name="text$"></param>
 <param name="pattern"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Text.Patterns.Regexp.op_Like(System.String,Microsoft.VisualBasic.Text.Patterns.Regexp)">
 <summary>
 Target input <paramref name="text"/> is equals to the regex <paramref name="pattern"/>?
 </summary>
 <param name="text$"></param>
 <param name="pattern"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.Patterns.Regexp.op_Like(Microsoft.VisualBasic.Text.Patterns.Regexp,System.String)">
 <summary>
 Target input <paramref name="text"/> is equals to the regex <paramref name="pattern"/>?
 </summary>
 <param name="text$"></param>
 <param name="pattern"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Text.Patterns.Validator.Validator">
 <summary>
 A library of string validators and sanitizers.
 
 > https://github.com/validatorjs/validator.js
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Text.Patterns.WildcardsExtension">
 <summary>
 Extensions to <see cref="T:System.String"/> by using wildcards to match string
 
 ###### A very simple wildcard match
 > https://github.com/picrap/WildcardMatch
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Text.Patterns.WildcardsExtension.WildcardMatch(System.String,System.String,System.Boolean)">
 <summary>
 Tells if the given string matches the given wildcard.
 Two wildcards are allowed: ``*`` and ``%``.
 
 + '*' matches any ZERO or more characters
 + '%' matches any single character
 </summary>
 <param name="wildcard">The wildcard.</param>
 <param name="s">The s.</param>
 <param name="ignoreCase">if set to <c>true</c> [ignore case].</param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Text.Patterns.WildcardsExtension.WildcardMatch(System.String,System.String,System.Int32,System.Int32,System.Boolean)">
 <summary>
 Internal matching algorithm.
 </summary>
 <param name="wildcard">The wildcard.</param>
 <param name="s">The s.</param>
 <param name="wildcardIndex">Index of the wildcard.</param>
 <param name="sIndex">Index of the s.</param>
 <param name="ignoreCase">if set to <c>true</c> [ignore case].</param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Text.Search.TextIndexing.cache">
 <summary>
 为了用于加速批量匹配计算的效率而生成的一个缓存对象
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.Search.TextIndexing.#ctor(System.String,System.Int32,System.Int32)">
 <summary>
 Creates a text index instance object for the statement fuzzy match in the whole text document.
 </summary>
 <param name="text"></param>
 <param name="min"></param>
 <param name="max"></param>
</member>
<member name="M:Microsoft.VisualBasic.Text.Search.TextIndexing.Found(System.String,System.Double,System.Int32)">
 <summary>
 
 </summary>
 <param name="keyword"></param>
 <param name="cutoff"></param>
 <param name="numPartition">每一个分区之中的元素的数量，负数表示不进行分区</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.Search.TextIndexing.Found(System.String,System.Int32)">
 <summary>
 
 </summary>
 <param name="keyword"></param>
 <param name="cutoff">表示出现连续的m匹配的片段的长度,-1表示所搜索的关键词片段的长度一半</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.Search.TextIndexing.IsMatch(System.String,System.Int32)">
 <summary>
 函数返回最长的匹配的个数，-1表示没有匹配
 </summary>
 <param name="m"></param>
 <param name="cutoff"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.Search.TextIndexing.FuzzyIndex(System.String,System.String,System.Int32,System.Int32,System.Int32)">
 <summary>
 
 </summary>
 <param name="text"></param>
 <param name="keyword"></param>
 <param name="Matches">
 The continues length of the matches, if this value is ZERO or negative value, then the function will using the expression len(keyword)/2 as the default value.
 </param>
 <param name="min"></param>
 <param name="max"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Text.Search.TextSegment">
 <summary>
 文本之中的一个片段
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Text.Search.TextSegment.Segment">
 <summary>
 当前的这个文本片段的字符串值
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Text.Search.TextSegment.Array">
 <summary>
 ASCII值
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Text.Search.TextSegment.Index">
 <summary>
 在原始文本之中的左端起始位置
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Text.Splitter">
 <summary>
 Split strings with support to multi-character, multi-lines Delimiter
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.Splitter.expression">
 <summary>
 Holds the string to split
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.Splitter.delimiter">
 <summary>
 Delimiter to split the expression with
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Text.Splitter.#ctor">
 <summary>
 Constrctor for The Splitter
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Text.Splitter.Split(System.String,System.String,System.Boolean,System.Int32,Microsoft.VisualBasic.CompareMethod)">
 <summary>
 这个是安全的函数，空值会返回空集合
 </summary>
 <param name="s"></param>
 <param name="delimiter"></param>
 <param name="isSingle"></param>
 <param name="count"></param>
 <param name="compare"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Text.Similarity.StringEqualityHelper">
 <summary>
 thresholds:
 
 + 0: text equals
 + 1: binary equals
 + (0, 1): similarity threshold
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.Similarity.StringEqualityHelper.threshold">
 <summary>
 + 0: text equals
 + 1: binary equals
 + (0, 1): similarity threshold
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Text.Similarity.StringEqualityHelper.#ctor(System.Double)">
 <summary>
 thresholds:
 
 + 0: text equals
 + 1: binary equals
 + (0, 1): similarity threshold
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Text.Similarity.DirectTextComparer">
 <summary>
 A wrapper of the <see cref="M:Microsoft.VisualBasic.StringHelpers.TextEquals(System.String,System.String,System.Boolean,System.Boolean)"/> function
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Text.Similarity.ISimilarity">
 <summary>
 Summary description for StringMatcher.
 </summary>
 
</member>
<member name="T:Microsoft.VisualBasic.Text.Similarity.Evaluations">
 <summary>
 text string similarity evaluation module
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Text.Similarity.Evaluations.Evaluate(System.String,System.String,System.Boolean,System.Double,Microsoft.VisualBasic.ComponentModel.Algorithm.DynamicProgramming.Levenshtein.DistResult@,System.Boolean)">
 <summary>
 两个字符串之间是通过单词的排布的相似度来比较相似度的
 </summary>
 <param name="s1"></param>
 <param name="s2"></param>
 <param name="ignoreCase"></param>
 <param name="cost"></param>
 <param name="dist"></param>
 <returns>
 A similarity score in value between [0,1]
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.Similarity.Evaluations.LevenshteinEvaluate(System.String,System.String,System.Boolean,System.Double,Microsoft.VisualBasic.ComponentModel.Algorithm.DynamicProgramming.Levenshtein.DistResult@,System.Boolean,Microsoft.VisualBasic.ComponentModel.DataStructures.GenericLambda{System.Char}.IEquals)">
 <summary>
 计算字符串，这个是直接通过计算字符而非像<see cref="M:Microsoft.VisualBasic.Text.Similarity.Evaluations.Evaluate(System.String,System.String,System.Boolean,System.Double,Microsoft.VisualBasic.ComponentModel.Algorithm.DynamicProgramming.Levenshtein.DistResult@,System.Boolean)"/>方法之中计算单词的
 </summary>
 <param name="s1$"></param>
 <param name="s2$"></param>
 <param name="ignoreCase"></param>
 <param name="cost"></param>
 <param name="dist"></param>
 <param name="checkChar">
 lambda function pointer for check two char is equals or not?
 </param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.Similarity.Evaluations.TokenOrders(System.String,System.String,System.Boolean)">
 <summary>
 以s1为准则，将s2进行比较，返回s2之中的单词在s1之中的排列顺序
 </summary>
 <param name="s1"></param>
 <param name="s2"></param>
 <returns>序列之中的-1表示s2之中的单词在s1之中不存在</returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.Similarity.Evaluations.IsOrdered(System.String[],System.String[],System.Boolean,System.Boolean)">
 <summary>
 查看<paramref name="s2"/>之中的字符串的顺序是否是在<paramref name="s1"/>之中按顺序排序的
 </summary>
 <param name="s1$"></param>
 <param name="s2$"></param>
 <param name="caseSensitive"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.Similarity.Evaluations.LevenshteinOrder``1(System.Collections.Generic.IEnumerable{``0},System.String,System.Func{``0,System.Collections.Generic.IEnumerable{System.String}},System.Boolean,System.Double,System.Double,System.Boolean,Microsoft.VisualBasic.ComponentModel.DataStructures.GenericLambda{System.Char}.IEquals)">
 <summary>
 Make text similariy sort in desc order
 </summary>
 <typeparam name="T"></typeparam>
 <param name="collection"></param>
 <param name="query"></param>
 <param name="cutoff">
 this text similarity cutoff will filter out some content from the result.
 </param>
 <param name="strlen_diff"></param>
 <returns>
 a sort collection result by the text similarity measurement. this result
 collection may has elements number less than the input <paramref name="collection"/> 
 elements number.
 </returns>
 <remarks>
 this function will removes the item inside the collection
 which its text similarity is smaller than the cutoff of given 
 <paramref name="query"/> text.
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Text.Similarity.Evaluations.StringSelection(System.String,System.Collections.Generic.IEnumerable{System.String},System.Double,System.Boolean,System.Boolean)">
 <summary>
 Get most similar string from the given <paramref name="collection"/>
 </summary>
 <param name="query">the text for the similarity measurement</param>
 <param name="collection">a given string collection for compares with the 
 given <paramref name="query"/> text string.</param>
 <param name="cutoff">the similarity score cutoff for the string filter</param>
 <param name="ignoreCase"></param>
 <param name="tokenBased"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.Levenshtein.LevExtensions.StripSymbol(System.String,System.String,System.Boolean)">
 <summary>
 将字符串之中的标点符号删除，只留下字母
 </summary>
 <param name="input$"></param>
 <param name="replaceAs$">将这些标点符号替换为目标字符串，默认为空格</param>
 <param name="stripMinusSign">是否将减号也替换掉，默认是不进行替换</param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Text.Levenshtein.LevenshteinString">
 <summary>
 The string like helper
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Text.Levenshtein.LevenshteinString.op_Like(System.String,Microsoft.VisualBasic.Text.Levenshtein.LevenshteinString)">
 <summary>
 String similarity compares
 </summary>
 <param name="s$"></param>
 <param name="subject"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Text.Levenshtein.LevenshteinString.op_Like(Microsoft.VisualBasic.Text.Levenshtein.LevenshteinString,System.String)">
 <summary>
 String similarity compares
 </summary>
 <param name="query"></param>
 <param name="s$"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Text.Levenshtein.LevenshteinString.op_Like(Microsoft.VisualBasic.Text.Levenshtein.LevenshteinString,Microsoft.VisualBasic.Text.Levenshtein.LevenshteinString)">
 <summary>
 String similarity compares
 </summary>
 <param name="query"></param>
 <param name="subject"></param>
 <returns></returns>
 
</member>
<member name="T:Microsoft.VisualBasic.Text.Levenshtein.LevenshteinTree">
 <summary>
 a text string similarity index
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Text.Levenshtein.LevenshteinTree.Query(System.String)">
 <summary>
 query the indexed string data via string similarity
 </summary>
 <param name="s"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.Levenshtein.LevenshteinTreeIndex.Query(System.String)">
 <summary>
 query the indexed data via string key similarity
 </summary>
 <param name="s"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.Xml.Extensions.FormatHTML(System.String)">
 <summary>
 使用这个函数将html文档进行格式化，请注意，目标html文档应该是符合xml语法的
 </summary>
 <param name="html$"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.Xml.Extensions.RemoveXmlComments(System.String)">
 <summary>
 这个函数可以将Xml/Html文本之中的注释数据进行删除
 </summary>
 <param name="xhtml"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Text.Xml.Extensions.CodePage(Microsoft.VisualBasic.Text.Xml.XmlEncodings)">
 <summary>
 Xml encoding to text encoding
 </summary>
 <param name="xmlEncoding"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.Xml.Extensions.TextEncoding(Microsoft.VisualBasic.Text.Xml.XmlEncodings)">
 <summary>
 Xml encoding to text encoding
 </summary>
 <param name="xmlEncoding"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.Xml.Extensions.GetXmlAttrValue(System.String,System.String)">
 <summary>
 get xml attribute value via regexp matches
 </summary>
 <param name="str"></param>
 <param name="Name"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.Xml.HtmlBuilder.AppendLine(System.Text.StringBuilder,System.Xml.Linq.XElement,System.Object[])">
 <summary>
 Appends a copy of the specified string followed by the default line terminator
 to the end of the current <see cref="T:System.Text.StringBuilder"/> object.
 </summary>
 <param name="sb"></param>
 <param name="html">The html string to append.</param>
 <returns></returns>
 <remarks>
 A reference to this instance after the append operation has completed.
 </remarks>
</member>
<member name="T:Microsoft.VisualBasic.Text.Xml.Linq.DataSetWriter`1">
 <summary>
 Write a very large dataset in Xml format
 </summary>
 <remarks>
 usually be used for dump the database table data to a xml file
 
 the output xml file format is compatible with the .NET DataSet xml format
 
 see also: https://docs.microsoft.com/en-us/dotnet/api/system.data.dataset.writexml?view=net-5.0
 
 example:
 
 ```vb
 Dim writer As New DataSetWriter(Of biocad_registryModel.molecule)("molecules.xml")
 
 For Each mol As biocad_registryModel.molecule In registry.molecule.all(Of biocad_registryModel.molecule)()
     Call writer.Write(mol)
 Next
 
 Call writer.Dispose()
 ```
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Text.Xml.Linq.DataSetWriter`1.#ctor(System.String,Microsoft.VisualBasic.Text.Xml.XmlEncodings)">
 <summary>
 Create a new xml dataset writer
 </summary>
 <param name="file"></param>
 <param name="encoding"></param>
</member>
<member name="T:Microsoft.VisualBasic.Text.Xml.Linq.DeserializeHandler`1">
 <summary>
 The xml deserialize helper
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.Xml.Linq.DeserializeHandler`1.Tname">
 <summary>
 Get type name that defined on the class type decoration with custom attributes:
 <see cref="T:System.Xml.Serialization.XmlTypeAttribute"/> or <see cref="T:System.Xml.Serialization.XmlRootAttribute"/>
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Text.Xml.Linq.DeserializeHandler`1.LoadXml(System.String,System.Type[])">
 <summary>
 This method have bugs when deal with the xml when it have 
 multiple xml namespace value
 </summary>
 <param name="xml"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.Xml.Linq.NodeIterator.GetArrayTemplate``1">
 <summary>
 可以将模板文本之中的``%s``替换为相应的Xml数组文本
 </summary>
 <typeparam name="T">
 在.NET的XML序列化之中，数组元素的类型名称首字母会自动的被转换为大写形式
 </typeparam>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.Xml.Linq.NodeIterator.IterateArrayNodes(System.String,System.String,System.Func{System.String,System.Boolean})">
 <summary>
 使用<see cref="M:System.Xml.XmlDocument.Load(System.IO.Stream)"/>方法加载XML文档依旧是一次性的全部加载所有的文本到内存之中，第一次加载效率会比较低
 则可以使用这个方法来加载非常大的XML文档
 </summary>
 <param name="path$"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.Xml.Linq.XmlStreamReader.ResolveXmlElement">
 <summary>
 Parse the file And return each of the child_node
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Text.Xml.Linq.Data">
 <summary>
 Using large xml file as Linq data source
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Text.Xml.Linq.Data.LoadXmlDocument(System.String,System.Func{System.String,System.String})">
 <summary>
 Load a specific xml file from a file location <paramref name="pathOrDoc"/>/ or 
 a xml text document data into a <see cref="T:System.Xml.XmlDocument"/> object.
 </summary>
 <param name="pathOrDoc"></param>
 <returns></returns>
 <remarks>
 using internally <see cref="M:System.Xml.Linq.XDocument.Load(System.IO.Stream)"/> to parse whole XML at once
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Text.Xml.Linq.Data.GetTypeName(System.Type,System.String)">
 <summary>
 Using <paramref name="default"/> string name or <see cref="P:System.Reflection.MemberInfo.Name"/>
 </summary>
 <param name="type"></param>
 <param name="default$">
 If this parameter value is <see cref="M:Microsoft.VisualBasic.StringHelpers.StringEmpty(System.String,System.Boolean,System.Boolean)"/>, then <see cref="P:System.Reflection.MemberInfo.Name"/> will be use as the xml node name.
 </param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.Xml.Linq.Data.GetNodeNameDefine(System.Type)">
 <summary>
 分别解析<see cref="T:System.Xml.Serialization.XmlTypeAttribute"/>，<see cref="T:System.Xml.Serialization.XmlRootAttribute"/>，如果这两个定义都不存在的话就返回<see cref="P:System.Reflection.MemberInfo.Name"/>
 </summary>
 <param name="type"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.Xml.Linq.Data.InternalIterates(System.String,System.String,System.Func{System.String,System.Boolean})">
 <summary>
 使用<see cref="T:System.Xml.XmlDocument"/>进行小文件的加载操作
 </summary>
 <param name="XML$"></param>
 <param name="nodeName$"></param>
 <param name="filter"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.Xml.Linq.Data.LoadXmlDataSet``1(System.String,System.String,System.String,System.Boolean,System.Func{System.String,System.Boolean},System.Boolean)">
 <summary>
 Only works for the xml file that contains a list or array of xml element, 
 and then this function using this list element as linq data source.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="XML$">超大的XML文件的文件路径</param>
 <param name="typeName">
 列表之中的节点在XML之中的tag标记名称，假若这个参数值为空的话，则会默认使用目标类型名称<see cref="P:System.Reflection.MemberInfo.Name"/>
 </param>
 <param name="xmlns">
 Using for the namespace replacement.
 (当这个参数存在的时候，目标命名空间申明将会被替换为空字符串，数据对象才会被正确的加载)
 </param>
 <param name="elementFilter">
 如果这个函数指针返回true, 则表示当前的数据元素节点需要被抛弃
 </param>
 <returns></returns>
 <remarks>
 (这个函数只建议在读取比较小的XML文件的时候使用，并且这个XML文件仅仅是一个数组或者列表的序列化结果)
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Text.Xml.Linq.Data.NodeInstanceBuilder``1(System.Collections.Generic.IEnumerable{System.String},System.String,System.String,System.Boolean,System.Type[])">
 <summary>
 从给定的文本之中利用反序列化从XML字符串构建出.NET对象
 </summary>
 <typeparam name="T"></typeparam>
 <param name="nodes"></param>
 <param name="replaceXmlns$"></param>
 <param name="xmlNode$">文件之中的节点名称</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.Xml.Linq.Data.LoadUltraLargeXMLDataSet``1(System.String,System.String,System.String,System.Func{System.Xml.Linq.XElement,System.Boolean},System.Func{System.String,System.String},System.Boolean,System.Type[],System.Boolean)">
 <summary>
 Apply on a ultra large size XML database, which its data size is greater than 1GB to 100GB or even more.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="path">文件路径</param>
 <param name="typeName">目标节点名称,默认是使用类型<typeparamref name="T"/>的名称</param>
 <param name="xmlns">``xmlns=...``,只需要给出等号后面的url即可</param>
 <param name="selector">
 在加载数据集的时候,过滤掉一些不使用的数据,可以节省很多内存以及减少数据的加载时间.
 因为后续的Xml反序列化操作在大数据集合下话费的时间会非常长
 </param>
 <returns></returns>
 <remarks>
 (这个函数是直接忽略掉根节点的名称以及属性的,使用这个函数只需要关注于需要提取的数据的节点名称即可)
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Text.Xml.Linq.Data.LoadUltraLargeXMLDataSet``1(System.IO.Stream,System.String,System.String,System.Func{System.Xml.Linq.XElement,System.Boolean},System.Func{System.String,System.String},System.Boolean,System.Type[],System.Boolean)">
 <summary>
 Apply on a ultra large size XML database, which its data size is greater than 1GB to 100GB or even more.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="s">The document stream data</param>
 <param name="typeName">目标节点名称,默认是使用类型<typeparamref name="T"/>的名称</param>
 <param name="xmlns">``xmlns=...``,只需要给出等号后面的url即可</param>
 <param name="selector">
 在加载数据集的时候,过滤掉一些不使用的数据,可以节省很多内存以及减少数据的加载时间.
 因为后续的Xml反序列化操作在大数据集合下话费的时间会非常长
 </param>
 <param name="preprocess">
 pre-processing the each xml document text block before parsed as the target clr object
 </param>
 <returns></returns>
 <remarks>
 (这个函数是直接忽略掉根节点的名称以及属性的,使用这个函数只需要关注于需要提取的数据的节点名称即可)
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Text.Xml.Linq.Data.LoadArrayNodes``1(System.String,System.String,System.String,System.Func{System.Xml.Linq.XElement,System.Boolean},System.Boolean,System.Boolean)">
 <summary>
 Parse xml element array from a given xml document text
 </summary>
 <typeparam name="T"></typeparam>
 <param name="documentText">the xml document text</param>
 <param name="typeName$"></param>
 <param name="xmlns$"></param>
 <param name="selector"></param>
 <param name="ignoreError"></param>
 <param name="tqdm"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.Xml.Linq.Data.IteratesArrayNodes(System.String,System.String,System.Func{System.Xml.Linq.XElement,System.Boolean},System.Boolean)">
 <summary>
 可以使用函数<see cref="M:Microsoft.VisualBasic.Text.Xml.Linq.Data.GetXmlNodeDoc(System.Xml.Linq.XElement)"/>来进行类型的转换操作
 </summary>
 <param name="path$"></param>
 <param name="typeName$"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Text.Xml.Linq.NamespaceIgnorantXmlTextReader">
 <summary>
 https://stackoverflow.com/questions/12590487/net-xml-deserialization-ignore-namespaces
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Text.Xml.Models.Coordinate">
 <summary>
 Improvements on the xml format layout compare with <see cref="T:System.Drawing.PointF"/> type.
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Text.Xml.Models.Href">
 <summary>
 Resource link data.
 </summary>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.Text.Xml.Models.Href.ResourceId">
 <summary>
 资源的名称
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Text.Xml.Models.Href.Value">
 <summary>
 The relative path of the target resource object in the file system.(资源对象在文件系统之中的相对路径)
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.Text.Xml.Models.Href.Comment">
 <summary>
 注释数据
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.Xml.Models.Href.GetFullPath(System.String)">
 <summary>
 获取<see cref="P:Microsoft.VisualBasic.Text.Xml.Models.Href.Value"></see>所指向的资源文件的完整路径
 </summary>
 <param name="DIR"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.Text.Xml.Models.ListOf`1">
 <summary>
 可以通过<see cref="M:Microsoft.VisualBasic.CollectionValueGetter.AsEnumerable``1(Microsoft.VisualBasic.Language.Value{``0[]})"/>拓展函数转换这个列表对象为枚举类型
 </summary>
 <typeparam name="T"></typeparam>
 
</member>
<member name="P:Microsoft.VisualBasic.Text.Xml.Models.ListOf`1.size">
 <summary>
 在这个列表之中的元素数量的长度
 </summary>
 <returns>auto generated list size</returns>
 <remarks>
 这个属性值会在进行XML序列化的时候自动生成，无需设置
 </remarks>
</member>
<member name="T:Microsoft.VisualBasic.Text.Xml.Models.XmlList`1">
 <summary>
 a general list model for export a collection of the clr object to a single xml file
 </summary>
 <typeparam name="T"></typeparam>
</member>
<member name="P:Microsoft.VisualBasic.Text.Xml.Models.XmlList`1.TypeComment">
 <summary>
 ReadOnly, Data model type tracking use Xml Comment.
 </summary>
 <returns></returns>
 <remarks>
 JSON存储的时候,这个属性会被自动忽略掉
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Text.Xml.Models.XmlList`1.op_Implicit(`0)~Microsoft.VisualBasic.Text.Xml.Models.XmlList{`0}">
 <summary>
 cast the scalar value to a list
 </summary>
 <param name="scalar"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Text.Xml.Models.Sequence">
 <summary>
 A numeric sequence model
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Text.Xml.Models.Sequence.range">
 <summary>
 [min, max]
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Text.Xml.Models.Sequence.n">
 <summary>
 将目标区间对象<see cref="P:Microsoft.VisualBasic.Text.Xml.Models.Sequence.range"/>平均划分为n个区间
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Text.Xml.Models.StringValue.value">
 <summary>
 A short text value without new line symbols
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Text.Xml.Models.LineValue">
 <summary>
 代码行的模型？
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Text.Xml.Models.NamedValue">
 <summary>
 A key-value pair data for xml
 </summary>
 <remarks>
 键值对集合的键值<see cref="P:Microsoft.VisualBasic.Text.Xml.Models.NamedValue.text"/>可能是一大段文本
 </remarks>
</member>
<member name="P:Microsoft.VisualBasic.Text.Xml.Models.NamedValue.name">
 <summary>
 The term category/key
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Text.Xml.Models.NamedValue.text">
 <summary>
 The term value
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.Xml.Models.NamedValue.#ctor(Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedValue{System.String})">
 <summary>
 get name and value from the given tuple
 </summary>
 <param name="namedValue"></param>
</member>
<member name="T:Microsoft.VisualBasic.Text.Xml.Models.Property">
 <summary>
 Property Info (Property Name and Property Value).
 </summary>
 <remarks>
 (和<see cref="T:Microsoft.VisualBasic.Text.Xml.Models.NamedValue"/>所不同的是，这个对象之中的键值对集合的键值都是小段字符串)
 </remarks>
</member>
<member name="P:Microsoft.VisualBasic.Text.Xml.Models.Property.name">
 <summary>
 The property name
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Text.Xml.Models.Property.value">
 <summary>
 The property value in text string type 
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Text.Xml.Models.Property.comment">
 <summary>
 Data annotation comment.
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Text.Xml.Models.NamedVector`1">
 <summary>
 在这里不实现<see cref="T:System.Collections.Generic.IEnumerable`1"/>是为了方便的实现XML序列化操作
 </summary>
 <typeparam name="T"></typeparam>
</member>
<member name="P:Microsoft.VisualBasic.Text.Xml.Models.NamedVector`1.attributes">
 <summary>
 在这里不使用字典是因为Xml序列化无法序列化字典对象
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Text.Xml.Models.PropertyValue">
 <summary>
 用于读写tsv/XML文件格式的键值对数据
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Text.Xml.Models.PropertyValue.Key">
 <summary>
 ID
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Text.Xml.Models.PropertyValue.Property">
 <summary>
 Property Name
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Text.Xml.Models.PropertyValue.Value">
 <summary>
 Value text
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.Xml.Models.PropertyValue.ImportsTsv(System.String,System.Boolean)">
 <summary>
 Imports the tsv file like:
 
 ```
 &lt;ID>&lt;tab>&lt;PropertyName>&lt;tab>&lt;Value>
 ```
 </summary>
 <param name="path$"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Text.Xml.Models.KeyValuePair">
 <summary>
 An object for the text file format xml data storage.(用于存储与XML文件之中的字符串键值对对象)
 </summary>
 <remarks>
 + 2016-05-24 为了更好的构建GCModeller项目的数据文档的格式，本类型对象不再继承自<see cref="T:Microsoft.VisualBasic.ComponentModel.Collection.Generic.KeyValuePairObject`2"/>类型
 </remarks>
 
</member>
<member name="T:Microsoft.VisualBasic.Text.Xml.Models.KeyValuePair.IKeyValuePair">
 <summary>
 Defines a key/value pair that can be set or retrieved.(特化的<see cref="T:Microsoft.VisualBasic.ComponentModel.Collection.Generic.IKeyValuePairObject`2"></see>字符串属性类型)
 </summary>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.Text.Xml.Models.KeyValuePair.Key">
 <summary>
 Gets the key in the key/value pair.
 </summary>
 <value></value>
 <returns></returns>
 <remarks>在这里可能用不了<see cref="T:System.Xml.Serialization.XmlAttributeAttribute"></see>自定义属性，因为其基本类型之中的Key和Value可以是任意的类型的，Attribute格式无法序列化复杂的数据类型</remarks>
</member>
<member name="M:Microsoft.VisualBasic.Text.Xml.Models.KeyValuePair.Equals(Microsoft.VisualBasic.Text.Xml.Models.KeyValuePair,System.Boolean)">
 <summary>
 
 </summary>
 <param name="obj"></param>
 <param name="strict">If strict is TRUE then the function of the string compares will case sensitive.</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.Text.Xml.Models.NumericVector">
 <summary>
 A <see cref="T:System.Double"/> type numeric sequence container
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Text.Xml.Models.NumericVector.name">
 <summary>
 可以用这个属性来简单的标记这个向量所属的对象名称
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Text.Xml.Models.NumericVector.vector">
 <summary>
 存储于XML文档之中的数据向量
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Text.Xml.Models.NumericVector.Xi(System.Int32)">
 <summary>
 Get/Set Element ``Xi``
 </summary>
 <param name="i"></param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Text.Xml.Models.NumericVector.Length">
 <summary>
 The vector length for counting the elements in <see cref="P:Microsoft.VisualBasic.Text.Xml.Models.NumericVector.vector"/> property.
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Text.Xml.Models.TermsVector">
 <summary>
 a collection of the string terms 
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Text.Xml.Models.XmlBuilder">
 <summary>
 Builder for XML and html
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Text.Xml.Models.XmlBuilder.#ctor">
 <summary>
 创建一个新的Xml文档构建工具，可以通过这个工具来构建出``Xml/Html``文档
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Text.Xml.Models.XmlBuilder.AddComment(System.String)">
 <summary>
 从当前文本位置处添加一行``Xml/Html``注释文本
 </summary>
 <param name="comment"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Text.Xml.OpenXml.ContentTypes">
 <summary>
 ``[Content_Types].xml``
 </summary>
 
</member>
<member name="M:Microsoft.VisualBasic.Text.Xml.XmlDeclaration.ToString">
 <summary>
 &lt;?xml version="{<see cref="F:Microsoft.VisualBasic.Text.Xml.XmlDeclaration.version"/>}" encoding="{<see cref="F:Microsoft.VisualBasic.Text.Xml.XmlDeclaration.encoding"/>}" standalone="{<see cref="F:Microsoft.VisualBasic.Text.Xml.XmlDeclaration.standalone"/>}"?>
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Text.Xml.XmlDoc">
 <summary>
 请使用<see cref="M:Microsoft.VisualBasic.Text.Xml.XmlDoc.ToString"/>方法获取修改之后的Xml文档
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Text.Xml.XmlDoc.xmlns">
 <summary>
 Xml namespace definitions
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.Xml.XmlDoc.#ctor(System.String)">
 <summary>
 Create a xml tools from xml document text.
 </summary>
 <param name="xml"></param>
</member>
<member name="M:Microsoft.VisualBasic.Text.Xml.XmlDoc.ToString">
 <summary>
 使用这个函数可以得到修改之后的Xml文档
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.Xml.XmlDoc.ToString(System.Boolean)">
 <summary>
 使用这个函数可以得到修改之后的Xml文档
 </summary>
 <param name="usingDefault_xmlns"><see cref="F:Microsoft.VisualBasic.Text.Xml.Xmlns.DefaultXmlns"/></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.Xml.XmlDoc.CreateObject``1(System.Boolean)">
 <summary>
 从新修改过的xml文档之中通过反序列化构建目标对象
 </summary>
 <typeparam name="T"></typeparam>
 <param name="usingDefault_xmlns"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.Xml.XmlDoc.SaveTo(System.String,System.Text.Encoding)">
 <summary>
 Me.ToString.SaveTo(Path, encoding)
 </summary>
 <param name="Path"></param>
 <param name="encoding"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.Xml.IXmlDocumentTree.GetAllChilds">
 <summary>
 获取当前节点内的所有直接的子节点
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.Xml.IXmlDocumentTree.GetAllChildsByNodeName(System.String)">
 <summary>
 得到当前节点内所有的目标名称的子节点
 </summary>
 <param name="nodename"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Text.Xml.IXmlNode">
 <summary>
 includes tree node and text node
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Text.Xml.XmlEntity">
 <summary>
 https://en.wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Text.Xml.XmlEntity.FindAllEscapeTokens(System.String)">
 <summary>
 Find all possible xml entity escape tokens from a given text string
 </summary>
 <param name="str"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.Xml.XmlEntity.StripInvalidUTF8Code(System.String)">
 <summary>
 Removes all of the invalid utf8 xml code from the given string.
 (使用这个函数删除xml文本字符串之中的无效的UTF8转义字符，这个函数对转义字符的大小写不敏感)
 </summary>
 <param name="str"></param>
 <returns></returns>
 <remarks>
 http://7is7.com/software/chars.html
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Text.Xml.XmlEntity.UnescapeHTML(System.String)">
 <summary>
 处理HTML之中的特殊符号的转义
 </summary>
 <param name="html"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Text.Xml.Xmlns">
 <summary>
 Xml namespace
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Text.Xml.Xmlns.DefaultXmlns">
 <summary>
 ``xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"``
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Text.Xml.Xmlns.xmlns">
 <summary>
 ``xmlns=...``
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Text.Xml.Xmlns.namespace">
 <summary>
 枚举所有``xmlns:&lt;type>``开始的属性
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.Xml.Xmlns.Set(System.String,System.String)">
 <summary>
 Set the value of a new xml namespace.(<paramref name="ns"/>命名空间参数不需要添加 xmlns: 前缀)
 </summary>
 <param name="ns"></param>
 <param name="value"></param>
</member>
<member name="M:Microsoft.VisualBasic.Text.Xml.Xmlns.RootParser(System.String)">
 <summary>
 The parser for the xml root node.
 </summary>
 <param name="root"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Text.Xml.Xmlns.WriteNamespace(System.Text.StringBuilder,System.Boolean)">
 <summary>
 
 </summary>
 <param name="xml"></param>
 <remarks>当前的这个对象是新值，需要替换掉文档里面的旧值</remarks>
</member>
<member name="T:Microsoft.VisualBasic.TextDoc">
 <summary>
 Extension helper function for the text documents
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.TextDoc.LoadTextDoc``1(System.String,System.Text.Encoding,System.Func{System.String,System.Text.Encoding,``0},System.Boolean)">
 <summary>
 默认是加载Xml文件的
 </summary>
 <typeparam name="T"></typeparam>
 <param name="file"></param>
 <param name="encoding"></param>
 <param name="parser">default is Xml parser</param>
 <param name="ThrowEx"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.TextDoc.LineIterators(System.String,Microsoft.VisualBasic.Text.Encodings,System.Boolean)">
 <summary>
 这个函数会自动判断所给定的数据是一个文件路径或者文本数据
 如果是文件路径则会返回该文本文件之中的所有的行数据
 反之将目标数据当作为文本返回所有文本行
 </summary>
 <param name="handle">
 + 当这个参数为文件路径的时候会返回<see cref="M:Microsoft.VisualBasic.Linq.JoinExtensions.IteratesALL``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}})"/>函数的结果
 + 当这个参数只是为文本字符串的时候，则会返回<see cref="M:Microsoft.VisualBasic.StringHelpers.LineTokens(System.String,System.Boolean,System.Boolean)"/>函数的结果
 </param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.TextDoc.TsvHeaders(System.String)">
 <summary>
 解析出TSV文件的头部并且生成index数据
 </summary>
 <param name="path$">``*.tsv``文件路径</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.TextDoc.SaveTSV(System.Collections.Generic.IEnumerable{Microsoft.VisualBasic.ComponentModel.IDMap},System.String,Microsoft.VisualBasic.Text.Encodings)">
 <summary>
 将IDmapping数据保存为tsv文件
 </summary>
 <param name="tsv"></param>
 <param name="path$"></param>
 <param name="encoding"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.TextDoc.ForEachChar(System.String,Microsoft.VisualBasic.Text.Encodings)">
 <summary>
 Enumerate all of the chars in the target text file.
 </summary>
 <param name="path"></param>
 <param name="encoding"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.TextDoc.OpenWriter(System.String,Microsoft.VisualBasic.Text.Encodings,System.String,System.Boolean,System.Int32)">
 <summary>
 Open text file writer, this function will auto handle all things.
 </summary>
 <param name="path"></param>
 <param name="encoding"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.TextDoc.IterateAllLines(System.String,Microsoft.VisualBasic.Text.Encodings,System.Boolean,System.Boolean,System.Boolean)">
 <summary>
 Reading a super large size text file through stream method.
 </summary>
 <param name="path"></param>
 <returns>不存在的文件会返回空集合</returns>
 <remarks>
 (通过具有缓存的流对象读取文本数据，使用迭代器来读取文件之中的所有的行，大文件推荐使用这个方法进行读取操作)
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.TextDoc.IterateAllLines(System.String,System.Text.Encoding,System.Boolean,System.Boolean,System.Boolean)">
 <summary>
 Reading a super large size text file through stream method.
 </summary>
 <param name="path"></param>
 <param name="tqdm_wrap">
 show tqdm progress bar for the file reading process when deal with a large file?
 </param>
 <returns>不存在的文件会返回空集合</returns>
 <remarks>
 (通过具有缓存的流对象读取文本数据，使用迭代器来读取文件之中的所有的行，大文件推荐使用这个方法进行读取操作)
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.TextDoc.ReadFirstLine(System.String,System.Text.Encoding)">
 <summary>
 Read the first line of the text in the file.
 </summary>
 <param name="path"></param>
 <param name="encoding">
 Parameter value is set to <see cref="P:Microsoft.VisualBasic.Text.TextEncodings.DefaultEncoding"/> if this parameter is not specific.
 </param>
 <returns>
 this function may returns empty string if the file is empty or not exists
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.TextDoc.SolveStream(System.String,Microsoft.VisualBasic.Text.Encodings,System.String)">
 <summary>
 自动进行判断解决所读取的数据源，当<paramref name="handle"/>为文件路径的时候，
 会读取文件内容，反之则会直接返回<paramref name="handle"/>的内容
 </summary>
 <param name="handle">The text content or file path string.(文本内容或者文件路径)</param>
 <returns>Always returns a text content.</returns>
 <remarks>
 不适用于大文本数据
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.TextDoc.ReadAllText(System.String,System.Text.Encoding,System.Boolean,System.Boolean)">
 <summary>
 This function just suite for read a small text file.
 </summary>
 <param name="path"></param>
 <param name="encoding">Default value is <see cref="P:System.Text.Encoding.UTF8"/></param>
 <param name="suppress">Suppress error message??</param>
 <returns></returns>
 <remarks>
 (这个函数只建议读取小文本文件的时候使用)
 </remarks>

</member>
<member name="M:Microsoft.VisualBasic.TextDoc.ReadAllLines(System.String,System.Text.Encoding,System.Boolean)">
 <summary>
 This function is recommend using for the small(probably smaller than 300MB) text file reading.
 </summary>
 <param name="path"></param>
 <param name="encoding">Default value is UTF8</param>
 <returns></returns>
 <remarks>
 (这个函数只建议读取小文本文件的时候使用)
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.TextDoc.SaveWithHTMLEncoding(System.String,System.String)">
 <summary>
 使用html文本的默认编码格式<see cref="F:Microsoft.VisualBasic.Text.Encodings.UTF8"/>来保存这个文本文件
 </summary>
 <param name="html$"></param>
 <param name="path$"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.TextDoc.SaveTo(System.String,System.String,System.Text.Encoding,System.Boolean,System.Boolean)">
 <summary>
 Write the text file data into a file which was specific by the <paramref name="path"></paramref> value,
 this function not append the new data onto the target file.
 </summary>
 <param name="path"></param>
 <param name="text"></param>
 <param name="encoding">这个函数会自动处理文本的编码的</param>
 <returns></returns>
 <remarks>
 default text encoding: utf-8(将目标文本字符串写入到一个指定路径的文件之中，但是不会在文件末尾追加新的数据)
 </remarks>

</member>
<member name="M:Microsoft.VisualBasic.TextDoc.SaveTo(System.Xml.Linq.XElement,System.String,System.Text.Encoding)">
 <summary>
 Save the inner text value of a xml element
 </summary>
 <param name="value"></param>
 <param name="path"></param>
 <param name="encoding"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.TextDoc.IsTextFile(System.String,System.Int32)">
 <summary>
 Determined that the target file is a text file or binary file?
 (判断是否是文本文件)
 </summary>
 <param name="path">文件全路径名称</param>
 <returns>是返回True，不是返回False</returns>
 <param name="chunkSize">文件检查的长度，假若在这个长度内都没有超过null的阈值数，则认为该文件为文本文件，默认区域长度为4KB</param>
 <remarks>2012年12月5日</remarks>

</member>
<member name="M:Microsoft.VisualBasic.TextDoc.SaveTo(System.Collections.Generic.IEnumerable{System.String},System.String,System.Text.Encoding,System.Char)">
 <summary>
 Save a collection of the text data in line by line
 </summary>
 <param name="array"></param>
 <param name="path">
 将目标字符串集合数据全部写入到文件之中，当所写入的文件位置之上没有父文件夹存在的时候，会自动创建文件夹
 </param>
 <param name="encoding"></param>
 <returns></returns>
 <remarks>
 这个函数是以For循环的方式来兼容大型数据集的文件写入操作的
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.TextDoc.SaveTo(System.Text.StringBuilder,System.String,System.Text.Encoding)">
 <summary>
 Save the text content in the <see cref="T:System.Text.StringBuilder"/> object into a text file.
 </summary>
 <param name="sb"></param>
 <param name="path"></param>
 <param name="encoding"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.XmlExtensions.SafeLoadXml``1(System.String,Microsoft.VisualBasic.Text.Encodings,System.Func{System.String,System.String})">
 <summary>
 这个函数主要是用作于Linq里面的Select语句拓展的，这个函数永远也不会报错，只会返回空值
 </summary>
 <typeparam name="T"></typeparam>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.XmlExtensions.LoadXml``1(System.String,System.Text.Encoding,System.Boolean,System.Func{System.String,System.String},System.Boolean)">
 <summary>
 Load class object from the exists Xml document.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="xmlFile">The path of the xml document.(XML文件的文件路径)</param>
 <param name="throwEx">
 If the deserialization operation have throw a exception, then this function should process this error automatically or just throw it?
 (当反序列化出错的时候是否抛出错误？假若不抛出错误，则会返回空值)
 </param>
 <param name="preprocess">
 The preprocessing on the xml document text, you can doing the text replacement or some trim operation from here.(Xml文件的预处理操作)
 </param>
 <param name="encoding">Default is <see cref="F:Microsoft.VisualBasic.IOExtensions.UTF8"/> text encoding.</param>
 <returns></returns>
 <remarks>(从文件之中加载XML之中的数据至一个对象类型之中)</remarks>
</member>
<member name="M:Microsoft.VisualBasic.XmlExtensions.LoadXml(System.String,System.Type,System.Text.Encoding,System.Boolean,System.Func{System.String,System.String},System.Boolean)">
 <summary>
 从文件之中加载XML之中的数据至一个对象类型之中
 </summary>
 <param name="xmlFile">XML文件的文件路径</param>
 <param name="ThrowEx">当反序列化出错的时候是否抛出错误？假若不抛出错误，则会返回空值</param>
 <param name="preprocess">Xml文件的预处理操作</param>
 <returns></returns>
 <remarks></remarks>
 <param name="encoding">Default is <see cref="F:Microsoft.VisualBasic.IOExtensions.UTF8"/> text encoding.</param>
</member>
<member name="M:Microsoft.VisualBasic.XmlExtensions.GetXml``1(``0,System.Boolean,Microsoft.VisualBasic.Text.Xml.XmlEncodings)">
 <summary>
 Serialization the target object type into a XML document.
 </summary>
 <typeparam name="T">
 The type of the target object data should be a class object.(目标对象类型必须为一个Class)
 </typeparam>
 <param name="obj"></param>
 <returns></returns>
 <remarks>(将一个类对象序列化为XML文档)</remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.XmlExtensions.WriteXML(System.Object,System.Type,System.IO.Stream@,Microsoft.VisualBasic.Text.Xml.XmlEncodings)">
 <summary>
 写入的文本文件的编码格式和XML的编码格式应该是一致的
 </summary>
 <param name="obj"></param>
 <param name="type"></param>
 <param name="out"></param>
 <param name="encoding"></param>
</member>
<member name="M:Microsoft.VisualBasic.XmlExtensions.SaveAsXml``1(``0,System.String,System.Boolean,Microsoft.VisualBasic.Text.Encodings,System.String)">
 <summary>
 Save the object as the XML document.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="obj"></param>
 <param name="saveXml"></param>
 <param name="throwEx"></param>
 <param name="encoding">VB.NET的XML文件的默认编码格式为``utf-16``</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.XmlExtensions.LoadFromXml``1(System.String,System.Boolean,System.Boolean,System.Type[])">
 <summary>
 Generate a specific type object from a xml document stream.(使用一个XML文本内容创建一个XML映射对象)
 </summary>
 <param name="Xml">This parameter value is the document text of the xml file, not the file path of the xml file.(是Xml文件的文件内容而非文件路径)</param>
 <param name="throwEx">Should this program throw the exception when the xml deserialization error happens?
 if False then this function will returns a null value instead of throw exception.
 (在进行Xml反序列化的时候是否抛出错误，默认抛出错误，否则返回一个空对象)</param>
 <returns></returns>
 <remarks>
 this function returns nothing if the error happended and 
 also set <paramref name="throwEx"/> to false.
 </remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.XmlExtensions.LoadFromXml(System.String,System.Type,System.Boolean,System.Boolean,System.Type[])">
 <summary>
 Generate a specific type object from a xml document stream.
 </summary>
 <param name="Xml">
 This parameter value is the document text of the xml file, 
 not the file path of the xml file.
 (是Xml文件的文件内容而非文件路径)</param>
 <param name="throwEx">Should this program throw the exception 
 when the xml deserialization error happens?
 if False then this function will returns a null value instead 
 of throw exception.
 (在进行Xml反序列化的时候是否抛出错误，默认抛出错误，否则返回一个空对象)
 </param>
 <returns></returns>
 <remarks>
 (使用一个XML文本内容创建一个XML映射对象)
 </remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.XmlExtensions.CreateObjectFromXmlFragment``1(System.String,System.Func{System.String,System.String},System.Boolean)">
 <summary>
 使用一个XML文本内容的一个片段创建一个XML映射对象
 </summary>
 <typeparam name="T"></typeparam>
 <param name="xml">是Xml文件的文件内容而非文件路径</param>
 <param name="ignoreXmlNs">
 ignores of the xml namespace delcaration attribute value by default,
 due to the reason of the input <paramref name="xml"/> text just a
 xml document fragment text.
 </param>
 <returns></returns>
 <remarks>
 the input <paramref name="xml"/> probably has no namespace attribute data
 inside the xml root tag, so the <see cref="T:Microsoft.VisualBasic.Text.Xml.Linq.NamespaceIgnorantXmlTextReader"/>
 will be used for parse the xml in this helper function?
 </remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.XmlExtensions.WriteXML(System.IO.StreamWriter,System.Xml.Linq.XElement)">
 <summary>
 Write a xml content as text into the target file data
 </summary>
 <param name="file">a text file writer</param>
 <param name="xml">xml literal</param>
</member>
<member name="T:Microsoft.VisualBasic.Extensions">
 <summary>
 Common extension methods library for convenient the programming job.
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.is_empty(Microsoft.VisualBasic.Language.Default.IsEmpty)">
 <summary>
 check of the given object is nothing or value is empty?
 </summary>
 <param name="obj"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.DescriptionValue``1(``0)">
 <summary>
 get description text value from <see cref="T:System.ComponentModel.DescriptionAttribute"/>.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="obj"></param>
 <returns></returns>
 <remarks>
 this function is used for get the description text value from the GetType value <see cref="T:System.Type"/> of 
 the given <paramref name="obj"/>. this function may not working for the reflection result value, 
 example as when <paramref name="obj"/> is <see cref="T:System.Reflection.PropertyInfo"/>, <see cref="T:System.Reflection.MethodInfo"/> or 
 something, due to the reason of gettype of these reflection object contains no description data in 
 .net framework.
 
 20240414 change the function name from ``Description`` to ``DescriptionValue`` due to the reason of
 the function name of Description will always overloads other extension method which is named Description.
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.Range(System.Collections.Generic.IEnumerable{System.Double},System.Double)">
 <summary>
 Create the numeric range from a numeric value collection
 </summary>
 <param name="data"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.Slice(Microsoft.VisualBasic.ComponentModel.Ranges.Model.DoubleRange,System.Int32)">
 <summary>
 将目标值域切割为等长递增的<paramref name="n"/>个值域
 </summary>
 <param name="range"></param>
 <param name="n%"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.MD5(System.String)">
 <summary>
 Get target string's md5 hash code
 </summary>
 <param name="s">
 any text data
 </param>
 <returns>
 a 32 bit md5 string in lower case, this function may returns empty hashcode string 
 if the given input string <paramref name="s"/> is empty.
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.Second``1(System.Collections.Generic.IEnumerable{``0},System.Boolean,``0)">
 <summary>
 Returns the second element in the source collection, if the collection 
 is nothing or elements count not enough, then will returns nothing if 
 the <paramref name="suppressError"/> option was opend, otherwise this 
 function will throw exception.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.Add``1(Microsoft.VisualBasic.Language.List{``0}@,``0[])">
 <summary>
 Adds the elements of the specified collection to the end of the List`1.
 (会自动跳过空集合，这个方法是安全的)
 </summary>
 <typeparam name="T"></typeparam>
 <param name="list"></param>
 <param name="value">The collection whose elements should be added to the end of the List`1.</param>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.Constrain``2(System.Collections.Generic.IEnumerable{``1})">
 <summary>
 Constrain the inherits class type into the base type.
 (基类集合与继承类的集合约束)
 </summary>
 <typeparam name="T">继承类向基类进行约束</typeparam>
 <typeparam name="Tbase">基类</typeparam>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.ToBoolean(System.Int64)">
 <summary>
 0 -> False
 1 -> True
 </summary>
 <param name="b"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.AddRange``1(System.Collections.Generic.Dictionary{System.String,``0}@,System.Collections.Generic.IEnumerable{Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedValue{``0}},System.Boolean)">
 <summary>
 
 </summary>
 <param name="table"></param>
 <param name="data"></param>
 <param name="replaceDuplicated">
 这个函数参数决定了在遇到重复的键名称的时候的处理方法：
 
 + 如果为真，则默认会用新的值来替换旧的值
 + 如果为False，则遇到重复的键名的时候会报错
 </param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.AddRange``2(System.Collections.Generic.Dictionary{``0,``1}@,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{``0,``1}},System.Boolean)">
 <summary>
 
 </summary>
 <typeparam name="TKey"></typeparam>
 <typeparam name="TValue"></typeparam>
 <param name="table"></param>
 <param name="data"></param>
 <param name="replaceDuplicated">
 这个函数参数决定了在遇到重复的键名称的时候的处理方法：
 
 + 如果为真，则默认会用新的值来替换旧的值
 + 如果为False，则遇到重复的键名的时候会报错
 </param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.DateToString(System.DateTime)">
 <summary>
 Format the datetime value in the format of yy/mm/dd hh:min
 </summary>
 <param name="dat"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.JoinBy(System.Collections.Generic.IEnumerable{System.String},System.String)">
 <summary>
 Join the string tokens with a given delimiter text.
 </summary>
 <param name="tokens">parts of the string tokens for make join</param>
 <param name="delimiter">
 the delimiter for make string join.
 </param>
 <returns>
 This is a safe function: if the source string collection is nothing, 
 then whistle function will returns a empty string instead of throw 
 exception.
 
 (a safe wrapper of <see cref="M:System.String.Join(System.Char,System.Object[])"/>)
 </returns>
 <remarks>
 这是一个安全的函数，当数组为空的时候回返回空字符串
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.JoinBy(System.Collections.Generic.IEnumerable{System.Int32},System.String)">
 <summary>
 <see cref="T:System.String"/>，这是一个安全的函数，当数组为空的时候回返回空字符串
 </summary>
 <param name="values"></param>
 <param name="delimiter"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.Invoke(System.Diagnostics.Process)">
 <summary>
 Invoke a folked system process object to execute a parallel task.
 (本方法会执行外部命令并等待其执行完毕，函数返回状态值)
 </summary>
 <param name="process"></param>
 <returns></returns>
 <remarks></remarks>

</member>
<member name="M:Microsoft.VisualBasic.Extensions.DriverRun(Microsoft.VisualBasic.ComponentModel.ITaskDriver,System.Boolean)">
 <summary>
 Run the driver in a new thread, NOTE: from this extension function calls, then run thread is already be started, 
 so that no needs of calling the method <see cref="M:System.Threading.Thread.Start"/> again.
 (使用线程的方式启动，在函数调用之后，线程是已经启动了的，所以不需要再次调用<see cref="M:System.Threading.Thread.Start"/>方法了)
 </summary>
 <param name="driver">The object which is implements the interface <see cref="T:Microsoft.VisualBasic.ComponentModel.ITaskDriver"/></param>
 <remarks>
 if the parameter <paramref name="sync"/> value is set to TRUE, then the given 
 task function <paramref name="driver"/> will be run in the caller thread, a
 caller thread will be blocked at this function in sync mode, this function will
 returns nothing
 
 otherwise if the parameter <paramref name="sync"/> value is set to FASLE by default,
 then the given task function <paramref name="driver"/> will be running in a new
 thread, the new allocated thread object will be returned from this function.
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.TryCount``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>
 Gets the element counts in the target data collection, if the collection object is nothing or empty
 then this function will returns ZERO, others returns Collection.Count.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="collection"></param>
 <returns>this is a safe function: this function returns zero 
 if the given input <paramref name="collection"/> object is nothing
 </returns>
 <remarks>(返回一个数据集合之中的元素的数目，
 假若这个集合是空值或者空的，则返回0，其他情况则返回Count拓展函数的结果)</remarks>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.Offset(System.Int32[]@,System.Int32)">
 <summary>
 All of the number value in the target array offset a integer value.
 </summary>
 <param name="array"></param>
 <param name="intOffset"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.Offset(System.Int64[]@,System.Int32)">
 <summary>
 All of the number value in the target array offset a integer value.
 </summary>
 <param name="array"></param>
 <param name="intOffset"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.InlineCopy``1(``0@,``0)">
 <summary>
 Value assignment to the target variable.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="var"></param>
 <param name="value"></param>
 <returns></returns>
 <remarks>(将<paramref name="value"/>参数里面的值赋值给<paramref name="var"/>参数然后返回<paramref name="value"/>)</remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.Extensions.ShadowCopy``1(``0,``0@,``0@)">
 <summary>
 Copy the source value directly to the target variable and then return the source value.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.ShadowCopy``1(``0,``0@,``0@,``0@)">
 <summary>
 Copy the source value directly to the target variable and then return the source value.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.ShadowCopy``1(``0,``0@,``0@,``0@,``0@)">
 <summary>
 Copy the source value directly to the target variable and then return the source value.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.ShadowCopy``1(``0,``0@,``0@,``0@,``0@,``0@)">
 <summary>
 Copy the source value directly to the target variable and then return the source value.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.ShadowCopy``1(``0,``0@,``0@,``0@,``0@,``0@,``0@)">
 <summary>
 Copy the source value directly to the target variable and then return the source value.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.ShadowCopy``1(``0,``0@,``0@,``0@,``0@,``0@,``0@,``0@)">
 <summary>
 Copy the source value directly to the target variable and then return the source value.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.ShadowCopy``1(``0,``0@,``0@,``0@,``0@,``0@,``0@,``0@,``0@)">
 <summary>
 Copy the source value directly to the target variable and then return the source value.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.ShadowCopy``1(``0,``0@,``0@,``0@,``0@,``0@,``0@,``0@,``0@,``0@)">
 <summary>
 Copy the source value directly to the target variable and then return the source value.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.ShadowCopy``1(``0,``0@,``0@,``0@,``0@,``0@,``0@,``0@,``0@,``0@,``0@)">
 <summary>
 Copy the source value directly to the target variable and then return the source value.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.ShadowCopy``1(``0,``0@,``0@,``0@,``0@,``0@,``0@,``0@,``0@,``0@,``0@,``0@)">
 <summary>
 Copy the source value directly to the target variable and then return the source value.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.ShadowCopy``1(``0,``0@,``0@,``0@,``0@,``0@,``0@,``0@,``0@,``0@,``0@,``0@,``0@)">
 <summary>
 Copy the source value directly to the target variable and then return the source value.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.ModifyValue``1(System.Reflection.PropertyInfo,``0,System.Func{System.Object,System.Object})">
 <summary>
 Modify target object property value using a <paramref name="valueModifier">specific value provider</paramref> and then return original instance object.
 (修改目标对象的属性之后返回目标对象)
 </summary>
 <typeparam name="T"></typeparam>
 <param name="obj"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.InsertOrUpdate``1(System.Collections.Generic.Dictionary{System.String,``0}@,``0)">
 <summary>
 Insert data or update the exists data in the dictionary, if the target object with <see cref="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.Repository.IKeyedEntity`1.Key"/> 
 is not exists in the dictionary, then will be insert, else the old value will be replaced with the parameter 
 value <paramref name="item"/>.
 (向字典对象之中更新或者插入新的数据，假若目标字典对象之中已经存在了一个数据的话，则会将原有的数据覆盖，并返回原来的数据)
 </summary>
 <typeparam name="T"></typeparam>
 <param name="dict"></param>
 <param name="item"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.Remove``1(System.Collections.Generic.Dictionary{System.String,``0}@,``0)">
 <summary>
 Remove target object from dictionary.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="dict"></param>
 <param name="item"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.ToVector``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}})">
 <summary>
 Merge the target array collection into one collection.(将目标数组的集合合并为一个数组)
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.Unlist``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}})">
 <summary>
 Empty list will be skip and ignored.
 (这是一个安全的方法，空集合会被自动跳过，并且这个函数总是返回一个集合不会返回空值)
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.MatrixToUltraLargeVector``1(System.Collections.Generic.IEnumerable{``0[]})">
 <summary>
 Merge the target array collection into one collection.
 (将目标数组的集合合并为一个数组，这个方法是提供给超大的集合的，即元素的数目非常的多的，即超过了<see cref="T:System.Int32"></see>的上限值)
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.AddRange``1(System.Collections.Generic.LinkedList{``0},System.Collections.Generic.IEnumerable{``0})">
 <summary>
 Add a linked list of a collection of specific type of data.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="list"></param>
 <param name="data"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.MatrixTranspose``1(System.Collections.Generic.IEnumerable{``0[]},System.Boolean)">
 <summary>
 矩阵转置： 将矩阵之中的元素进行行列位置的互换
 </summary>
 <typeparam name="T">矩阵之中的元素类型</typeparam>
 <param name="MAT">为了方便理解和使用，矩阵使用数组的数组来表示的</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.MatrixTransposeIgnoredDimensionAgreement``1(System.Collections.Generic.IEnumerable{``0[]},System.Boolean)">
 <summary>
 将矩阵之中的元素进行行列位置的互换，请注意，假若长度不一致的话，会按照最短的元素来转置，故而使用本函数可能会造成一些信息的丢失
 </summary>
 <typeparam name="T"></typeparam>
 <param name="MAT"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.SplitMV(System.String,System.String,System.Int32)">
 <summary>
 
 </summary>
 <param name="DIR">The source directory.</param>
 <param name="moveTo"></param>
 <param name="Split"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.IsNaNImaginary(System.Double)">
 <summary>
 The target parameter <paramref name="n"/> value is NaN or not a real number or not?
 </summary>
 <param name="n"></param>
 <returns></returns>
 <remarks>
 (判断目标实数是否为一个无穷数或者非计算的数字，产生的原因主要来自于除0运算结果或者达到了
 <see cref="T:System.Double"></see>的上限或者下限)
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.FuzzyMatching(System.String,System.String,System.Boolean,System.Double)">
 <summary>
 Fuzzy match two string, this is useful for the text query or searching.
 (请注意，这个函数是不会自动转换大小写的，如果是需要字符大小写不敏感，
 请先将query以及subject都转换为小写)
 </summary>
 <param name="query"></param>
 <param name="Subject"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.CheckDuplicated``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
 <summary>
 函数只返回有重复的数据
 </summary>
 <typeparam name="T"></typeparam>
 <typeparam name="TTag"></typeparam>
 <param name="source"></param>
 <param name="getKey"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.RemoveDuplicates``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
 <summary>
 移除重复的对象，这个函数是根据对象所生成的标签来完成的
 </summary>
 <typeparam name="T"></typeparam>
 <typeparam name="Tag"></typeparam>
 <param name="source"></param>
 <param name="getKey">得到对象的标签</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.TrimNull``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>
 Remove all of the null object in the target object collection.
 (这个是一个安全的方法，假若目标集合是空值，则函数会返回一个空的集合)
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <returns></returns>
 <remarks></remarks>

</member>
<member name="M:Microsoft.VisualBasic.Extensions.TrimNull(System.Collections.Generic.IEnumerable{System.String})">
 <summary>
 Remove all of the null object in the target object collection
 </summary>
 <param name="source"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.Shuffles``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>
 Return a collection with randomize element position in 
 <paramref name="source">the original collection</paramref>.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <returns></returns>
 <remarks>
 this method can be affected by the <see cref="M:Microsoft.VisualBasic.Math.RandomExtensions.SetSeed(System.Int32)"/> method.
 (从原有序序列中获取一个随机元素的序列)
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.SeqRandom(System.Int32)">
 <summary>
 Generates the shuffle index result
 </summary>
 <param name="n">the size of the index vector</param>
 <returns></returns>
 <remarks>
 1. generates a index vector in range 0:<paramref name="n"/>-1
 2. make index shuffles
 
 returns the shuffles result.
 
 (返回n长度的序列数值，这些序列数值是打乱顺序的，但是升序排序之后会得到1:<paramref name="n"/>的序列
 请注意，这个序列并不是随机数，而是将n长度的序列之中的元素打乱顺序的结果)
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.ToStringArray``1(System.Collections.Generic.IEnumerable{``0},System.String)">
 <summary>
 Convert target object type collection into a string array using
 the <see cref="M:Microsoft.VisualBasic.Scripting.InputHandler.ToString(System.Object,System.String,System.Boolean)"/> interface
 function.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <returns>A string array</returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.Swap``1(``0[]@,System.Int32,System.Int32)">
 <summary>
 swap two element in the array
 </summary>
 <typeparam name="T"></typeparam>
 <param name="array"></param>
 <param name="a%"></param>
 <param name="b%"></param>
 
</member>
<member name="M:Microsoft.VisualBasic.Extensions.Swap``1(``0@,``0@)">
 <summary>
 Swap the value in the two variables.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="obj1"></param>
 <param name="obj2"></param>
 <remarks></remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.Extensions.SwapItem``1(Microsoft.VisualBasic.Language.List{``0}@,``0,``0)">
 <summary>
 Swap the two item position in the target <paramref name="list">list</paramref>.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="list"></param>
 <param name="obj_1"></param>
 <param name="obj_2"></param>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.WriteAddress``1(System.Collections.Generic.IEnumerable{``0}@,System.Int32)">
 <summary>
 Add array location index value for the <see cref="T:Microsoft.VisualBasic.ComponentModel.IAddressOf"/> elements in the sequence.
 (为列表中的对象添加对象句柄值)
 </summary>
 <param name="source"></param>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.Sequence``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
 <summary>
 Gets the subscript index of a generic collection.(获取某一个集合的下标的集合)
 </summary>
 <typeparam name="T">集合中的元素为任意类型的</typeparam>
 <param name="source">目标集合对象</param>
 <returns>A integer array of subscript index of the target generic collection.</returns>
 <remarks></remarks>

</member>
<member name="M:Microsoft.VisualBasic.Extensions.Sequence(Microsoft.VisualBasic.ComponentModel.Ranges.Model.IntRange,System.Int32)">
 <summary>
 Alias of the linq function <see cref="M:System.Linq.Enumerable.Range(System.Int32,System.Int32)"/>
 </summary>
 <param name="range"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.ToDictionary``2(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{``0,``1}},System.Boolean)">
 <summary>
 将目标键值对对象的集合转换为一个字典对象
 </summary>
 <typeparam name="TKey"></typeparam>
 <typeparam name="TValue"></typeparam>
 <param name="source"></param>
 <param name="remoteDuplicates">当这个参数为False的时候，出现重复的键名会抛出错误，当为True的时候，有重复的键名存在的话，可能会丢失一部分的数据</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.ToArray(System.Drawing.Size,System.Boolean)">
 <summary>
 [height, width] or [rows, columns]
 </summary>
 <param name="size"></param>
 <param name="reverse">
 [width, height] or [columns, rows]
 </param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.ToArray(System.Drawing.SizeF,System.Boolean)">
 <summary>
 [height, width] or [rows, columns]
 </summary>
 <param name="size"></param>
 <param name="reverse">
 [width, height] or [columns, rows]
 </param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.Shell(System.String)">
 <summary>
 执行一个命令行语句，并返回一个IO重定向对象，以获取被执行的目标命令的标准输出
 </summary>
 <param name="CLI"></param>
 <returns></returns>
 <remarks></remarks>

</member>
<member name="M:Microsoft.VisualBasic.Extensions.π(System.Collections.Generic.IEnumerable{System.Double})">
 <summary>
 获取一个实数集合中所有元素的积
 </summary>
 <param name="source"></param>
 <returns></returns>
 <remarks></remarks>

</member>
<member name="M:Microsoft.VisualBasic.Extensions.Removes``1(Microsoft.VisualBasic.Language.List{``0}@,System.Collections.Generic.IEnumerable{``0})">
 <summary>
 Remove all of the element in the <paramref name="collection"></paramref> from target <paramref name="List">list</paramref>
 </summary>
 <typeparam name="T"></typeparam>
 <param name="List"></param>
 <param name="collection"></param>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.RemoveLast``1(System.Collections.Generic.List{``0}@)">
 <summary>
 Removes the last element in the List object.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="clrList"></param>
 <returns></returns>
 <remarks>
 (这个拓展函数同时兼容.NET框架的list类型以及sciBASIC之中的list类型)
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.RemoveLast``1(Microsoft.VisualBasic.Language.List{``0}@)">
 <summary>
 Removes the last element in the List object.
 (这个拓展函数同时兼容.NET框架的list类型以及sciBASIC之中的<see cref="T:Microsoft.VisualBasic.Language.List`1"/>类型)
 </summary>
 <typeparam name="T"></typeparam>
 <param name="list"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Extensions.RemoveFirst``1(Microsoft.VisualBasic.Language.List{``0}@)">
 <summary>
 Removes the first element and then returns the list
 </summary>
 <typeparam name="T"></typeparam>
 <param name="list"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.FileIO.Extensions">
 <summary>
 
 </summary>
 <remarks>
 <see cref="T:System.Text.Encoding"/>会和<see cref="T:Microsoft.VisualBasic.Text.Encodings"/>产生冲突，
 使用这个单独的拓展模块，但是位于不同的命名空间来解决这个问题。
 </remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.FileIO.Extensions.FlushAllLines``1(System.Collections.Generic.IEnumerable{``0},System.String,System.Text.Encoding)">
 <summary>
 Write all object into a text file by using its <see cref="T:System.Object"/> method.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="data"></param>
 <param name="saveTo"></param>
 <param name="encoding"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.FileIO.Extensions.OpenWriter(System.String,System.Text.Encoding,System.String,System.Boolean,System.Int32)">
 <summary>
 Open text file writer, this function will auto handle all things.
 </summary>
 <param name="path">假若路径是指向一个已经存在的文件，则原有的文件数据将会被清空</param>
 <param name="encoding"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.FileIO.NetFile.MapNetFile(System.String)">
 <summary>
 将网络文件映射为本地文件，这个可以同时兼容http或者本地文件路径
 </summary>
 <param name="url"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.FileIO.NetFile.GetMapPath(System.String)">
 <summary>
 网络文件转换为本地文件路径
 </summary>
 <param name="url"></param>
 <returns></returns>
 
</member>
<member name="T:Microsoft.VisualBasic.FileIO.FileModeDescriptor">
 <summary>
 Specifies how the operating system should open a file.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.FileIO.FileModeDescriptor.Open">
 <summary>
 (r) Specifies that the operating system should open an existing file. The ability
     to open the file is dependent on the value specified by the System.IO.FileAccess
     enumeration. A System.IO.FileNotFoundException exception is thrown if the file
     does not exist.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.FileIO.FileModeDescriptor.OpenOrCreate">
 <summary>
 (w) Specifies that the operating system should open a file if it exists; otherwise,
     a new file should be created. If the file is opened with FileAccess.Read, System.Security.Permissions.FileIOPermissionAccess.Read
     permission is required. If the file access is FileAccess.Write, System.Security.Permissions.FileIOPermissionAccess.Write
     permission is required. If the file is opened with FileAccess.ReadWrite, both
     System.Security.Permissions.FileIOPermissionAccess.Read and System.Security.Permissions.FileIOPermissionAccess.Write
     permissions are required.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.FileIO.FileModeDescriptor.Truncate">
 <summary>
 (w+) Specifies that the operating system should open an existing file. When the file
     is opened, it should be truncated so that its size is zero bytes. This requires
     System.Security.Permissions.FileIOPermissionAccess.Write permission. Attempts
     to read from a file opened with FileMode.Truncate cause an System.ArgumentException
     exception.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.FileIO.FileModeDescriptor.Append">
 <summary>
 (a+) Opens the file if it exists and seeks to the end of the file, or creates a new
     file. This requires System.Security.Permissions.FileIOPermissionAccess.Append
     permission. FileMode.Append can be used only in conjunction with FileAccess.Write.
     Trying to seek to a position before the end of the file throws an System.IO.IOException
     exception, and any attempt to read fails and throws a System.NotSupportedException
     exception.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.FileIO.CopyDirectoryAction.Copy(System.String,System.String,System.Boolean)">
 <summary>
 这个函数会在这个模块内被递归调用
 </summary>
 <param name="src">the file path of source directory.</param>
 <param name="destination">the file path of the target data directory.</param>
</member>
<member name="T:Microsoft.VisualBasic.FileIO.Directory">
 <summary>
 A wrapper object for the processing of relative file path. 
 </summary>
 <remarks>
 a local filesystem implementation for <see cref="T:Microsoft.VisualBasic.ApplicationServices.IFileSystemEnvironment"/>
 </remarks>
</member>
<member name="P:Microsoft.VisualBasic.FileIO.Directory.folder">
 <summary>
 当前的这个文件夹对象的文件路径
 </summary>
 <returns></returns>
 <remarks>
 it is the full name via the function <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)"/>
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.FileIO.Directory.#ctor(System.String,System.Boolean)">
 <summary>
 Construct a directory object from the specific Dir path value.
 </summary>
 <param name="directory">Target directory path</param>
 
</member>
<member name="M:Microsoft.VisualBasic.FileIO.Directory.FromLocalFileSystem(System.String)">
 <summary>
 Create a directory object
 </summary>
 <param name="dir"></param>
 <returns></returns>
 <remarks>
 this function will create target <paramref name="dir"/> if it is not exists 
 on your filesystem
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.FileIO.Directory.GetFullPath(System.String)">
 <summary>
 Gets the full path of the target file based on the path relative to this directory object.
 </summary>
 <param name="file">
 The relative path of the target file, and this parameter is 
 also compatible with absolute file path.
 (相对路径)</param>
 <returns></returns>
 <remarks>
 the given input <paramref name="file"/> should be inside current 
 directory location, the file path start with prefix / will also
 be treated as the relative path inside current directory on unix
 platform, due to the reason of path string combine operation:
 
 ```
 dir/file
 ```
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.FileIO.Directory.IsAbsolutePath(System.String,System.Boolean)">
 <summary>
 Determined that the input file path is a absolute path or not?
 </summary>
 <param name="file"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.FileIO.Directory.CopyTo(System.String,System.IProgress{System.String},System.Boolean)">
 <summary>
 将当前的这个文件夹之中的内容拷贝到<paramref name="target"/>目标文件夹
 </summary>
 <param name="target">The directory path of target folder.</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.FileIO.Directory.GetRelativePath(System.String)">
 <summary>
 get relative of the given <paramref name="file"/> path that relative to current workspace dir
 </summary>
 <param name="file"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.FileIO.Directory.CreateDirectory(System.String)">
 <summary>
 Creates a directory.
 </summary>
 <param name="junctionPoint">Name and location of the directory.</param>
 <remarks>
 Exceptions:
   T:System.ArgumentException:
     The directory name is malformed. For example, it contains illegal characters
     or is only white space.

   T:System.ArgumentNullException:
     directory is Nothing or an empty string.

   T:System.IO.PathTooLongException:
     The directory name is too long.

   T:System.NotSupportedException:
     The directory name is only a colon (:).

   T:System.IO.IOException:
     The parent directory of the directory to be created is read-only

   T:System.UnauthorizedAccessException:
     The user does not have permission to create the directory.
 </remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.FileIO.Directory.Close">
 <summary>
 Just do nothing for local filesystem
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.FileIO.Path.FilePath">
 <summary>
 A file path string component object
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.FileIO.Path.FilePath.Components">
 <summary>
 the file path components, parse by path string split by delimiter symbol ``/``.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.FileIO.Path.FilePath.FileName">
 <summary>
 the file basename, not file path
 </summary>
 <returns>
 file name with extension suffix
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.FileIO.Path.FilePath.ToString">
 <summary>
 get the canonical full path string
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.FileIO.Path.Includes">
 <summary>
 File includes search tools
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.FileIO.Path.Includes.Add(System.String)">
 <summary>
 Add includes directory into the search path.
 </summary>
 <param name="DIR"></param>
</member>
<member name="M:Microsoft.VisualBasic.FileIO.Path.Includes.GetPath(System.String)">
 <summary>
 Get the absolutely file path from the includes file's relative path.
 </summary>
 <param name="relPath"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.FileIO.Path.PathMatch.__pairs(System.String[],System.String[],System.Func{System.String,System.String})">
 <summary>
 <paramref name="paths1"/>的元素要比<paramref name="path2"/>多
 </summary>
 <param name="paths1"></param>
 <param name="path2"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.FileIO.TemporaryEnvironment">
 <summary>
 Workspace model
 
 在<see cref="M:Microsoft.VisualBasic.FileIO.TemporaryEnvironment.Dispose"/>的时候，文件夹会切换回来
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.FileIO.TemporaryEnvironment.#ctor(System.String)">
 <summary>
 如果不存在会创建目标文件夹
 </summary>
 <param name="newLocation"></param>
</member>
<member name="T:Microsoft.VisualBasic.FileIO.SymLinker.HardLink">
 <summary>
 Provides access to NTFS hard links in .Net.
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.FileIO.SymLinker.JunctionPoint">
 <summary>
 Provides access to NTFS junction points in .Net.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.FileIO.SymLinker.JunctionPoint.ERROR_NOT_A_REPARSE_POINT">
 <summary>
 The file or directory is not a reparse point.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.FileIO.SymLinker.JunctionPoint.ERROR_REPARSE_ATTRIBUTE_CONFLICT">
 <summary>
 The reparse point attribute cannot be set because it conflicts with an existing attribute.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.FileIO.SymLinker.JunctionPoint.ERROR_INVALID_REPARSE_DATA">
 <summary>
 The data present in the reparse point buffer is invalid.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.FileIO.SymLinker.JunctionPoint.ERROR_REPARSE_TAG_INVALID">
 <summary>
 The tag present in the reparse point buffer is invalid.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.FileIO.SymLinker.JunctionPoint.ERROR_REPARSE_TAG_MISMATCH">
 <summary>
 There is a mismatch between the tag specified in the request and the tag present in the reparse point.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.FileIO.SymLinker.JunctionPoint.FSCTL_SET_REPARSE_POINT">
 <summary>
 Command to set the reparse point data block.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.FileIO.SymLinker.JunctionPoint.FSCTL_GET_REPARSE_POINT">
 <summary>
 Command to get the reparse point data block.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.FileIO.SymLinker.JunctionPoint.FSCTL_DELETE_REPARSE_POINT">
 <summary>
 Command to delete the reparse point data base.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.FileIO.SymLinker.JunctionPoint.IO_REPARSE_TAG_MOUNT_POINT">
 <summary>
 Reparse point tag used to identify mount points and junction points.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.FileIO.SymLinker.JunctionPoint.NonInterpretedPathPrefix">
 <summary>
 This prefix indicates to NTFS that the path is to be treated as a non-interpreted
 path in the virtual file system.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.FileIO.SymLinker.JunctionPoint.REPARSE_DATA_BUFFER.ReparseTag">
 <summary>
 Reparse point tag. Must be a Microsoft reparse point tag.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.FileIO.SymLinker.JunctionPoint.REPARSE_DATA_BUFFER.ReparseDataLength">
 <summary>
 Size, in bytes, of the data after the Reserved member. This can be calculated by:
 (4 * sizeof(ushort)) + SubstituteNameLength + PrintNameLength +
 (namesAreNullTerminated ? 2 * sizeof(char) : 0);
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.FileIO.SymLinker.JunctionPoint.REPARSE_DATA_BUFFER.Reserved">
 <summary>
 Reserved; do not use.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.FileIO.SymLinker.JunctionPoint.REPARSE_DATA_BUFFER.SubstituteNameOffset">
 <summary>
 Offset, in bytes, of the substitute name string in the PathBuffer array.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.FileIO.SymLinker.JunctionPoint.REPARSE_DATA_BUFFER.SubstituteNameLength">
 <summary>
 Length, in bytes, of the substitute name string. If this string is null-terminated,
 SubstituteNameLength does not include space for the null character.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.FileIO.SymLinker.JunctionPoint.REPARSE_DATA_BUFFER.PrintNameOffset">
 <summary>
 Offset, in bytes, of the print name string in the PathBuffer array.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.FileIO.SymLinker.JunctionPoint.REPARSE_DATA_BUFFER.PrintNameLength">
 <summary>
 Length, in bytes, of the print name string. If this string is null-terminated,
 PrintNameLength does not include space for the null character.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.FileIO.SymLinker.JunctionPoint.REPARSE_DATA_BUFFER.PathBuffer">
 <summary>
 A buffer containing the unicode-encoded path string. The path string contains
 the substitute name string and print name string.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.FileIO.SymLinker.JunctionPoint.Create(System.String,System.String,System.Boolean)">
 <summary>
 Creates a junction point from the specified directory to the specified target directory.
 </summary>
 <remarks>
 Only works on NTFS.
 </remarks>
 <param name="junctionPoint">The junction point path</param>
 <param name="targetDir">The target directory</param>
 <param name="overwrite">If true overwrites an existing reparse point or empty directory</param>
 <exception cref="T:System.IO.IOException">Thrown when the junction point could not be created or when
 an existing directory was found and <paramref name="overwrite" /> if false</exception>
</member>
<member name="M:Microsoft.VisualBasic.FileIO.SymLinker.JunctionPoint.Delete(System.String)">
 <summary>
 Deletes a junction point at the specified source directory along with the directory itself.
 Does nothing if the junction point does not exist.
 </summary>
 <remarks>
 Only works on NTFS.
 </remarks>
 <param name="junctionPoint">The junction point path</param>
</member>
<member name="M:Microsoft.VisualBasic.FileIO.SymLinker.JunctionPoint.Exists(System.String)">
 <summary>
 Determines whether the specified path exists and refers to a junction point.
 </summary>
 <param name="path">The junction point path</param>
 <returns>True if the specified path represents a junction point</returns>
 <exception cref="T:System.IO.IOException">Thrown if the specified path is invalid
 or some other error occurs</exception>
</member>
<member name="M:Microsoft.VisualBasic.FileIO.SymLinker.JunctionPoint.GetTarget(System.String)">
 <summary>
 Gets the target of the specified junction point.
 </summary>
 <remarks>
 Only works on NTFS.
 </remarks>
 <param name="junctionPoint">The junction point path</param>
 <returns>The target of the junction point</returns>
 <exception cref="T:System.IO.IOException">Thrown when the specified path does not
 exist, is invalid, is not a junction point, or some other error occurs</exception>
</member>
<member name="T:Microsoft.VisualBasic.FileIO.SymLinker.SymbolicLink">
 <summary>
 
 </summary>
 <remarks>https://github.com/amd989/Symlinker</remarks>
</member>
<member name="F:Microsoft.VisualBasic.FileIO.SymLinker.SymbolicLink.shareModeAll">
 <summary>
 Read, Write, Delete
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.FileIO.SymLinker.SymbolicLink.symLinkTag">
 <summary>
 
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.IOExtensions">
 <summary>
 The extension API for system file io.
 </summary>
 <remarks>
 (IO函数拓展)
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.IOExtensions.OpenTextWriter(System.IO.Stream,System.Text.Encoding)">
 <summary>
 Open text writer interface from a given <see cref="T:System.IO.Stream"/> <paramref name="s"/>. 
 </summary>
 <param name="s"></param>
 <param name="encoding">By default is using <see cref="F:Microsoft.VisualBasic.IOExtensions.UTF8"/> text encoding.</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.IOExtensions.FlushStream(System.IO.Stream,System.String)">
 <summary>
 copy the data from the input <paramref name="stream"/> to 
 the target file which is specified by the parameter
 <paramref name="path"/>
 </summary>
 <param name="stream">
 必须要能够支持<see cref="P:System.IO.Stream.Length"/>，对于有些网络服务器的HttpResponseStream可能不支持
 <see cref="P:System.IO.Stream.Length"/>的话，这个函数将会报错
 </param>
 <param name="path$"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.IOExtensions.FlushTo(System.String,System.IO.StreamWriter,System.Boolean)">
 <summary>
 将指定的字符串的数据值写入到目标可写的输出流之中
 </summary>
 <param name="data$">所需要写入的字符串数据</param>
 <param name="out">输出流</param>
 
</member>
<member name="M:Microsoft.VisualBasic.IOExtensions.FixPath(System.String@)">
 <summary>
 为了方便在linux上面使用，这里会处理一下file://这种情况，请注意参数是ByRef引用的
 </summary>
 <param name="path$"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.IOExtensions.ReadVector(System.String)">
 <summary>
 Read target text file as a numeric vector, each line in the target text file should be a number, 
 so that if the target text file have n lines, then the returned vector have n elements.
 (这个文本文件之中的每一行都是一个数字，所以假设这个文本文件有n行，那么所返回的向量的长度就是n)
 </summary>
 <param name="path">The file path of the target text file.</param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.IOExtensions.OpenReadonly(System.String,System.Int32,System.Boolean)">
 <summary>
 <see cref="M:Microsoft.VisualBasic.IOExtensions.Open(System.String,System.IO.FileMode,System.Boolean,System.Boolean,System.Boolean,System.Boolean)"/> file with readonly parameter set to TRUE
 </summary>
 <param name="path"></param>
 <param name="retryOpen"></param>
 <param name="verbose"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.IOExtensions.Open(System.String,System.IO.FileMode,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
 <summary>
 Safe open a local file handle. Warning: this function is set to write mode by default, 
 if want using for read file, set <paramref name="doClear"/> to false!
 (打开本地文件指针，这是一个安全的函数，会自动创建不存在的文件夹。这个函数默认是写模式的)
 </summary>
 <param name="path">文件的路径</param>
 <param name="mode">File open mode, default is create a new file.(文件指针的打开模式)</param>
 <param name="doClear">
 By default is preserve all of the data in source file. Which means it is open for write 
 new file data by default. If want to append data or read file, set this argument to false.
 (写模式下默认将原来的文件数据清空)
 是否将原来的文件之中的数据清空？默认不是，否则将会以追加模式工作
 </param>
 <param name="aggressive">
 memory usage in aggressive mode? default config true means the function will try to 
 load all file data into memory when memory load config is max andalso if the file 
 size is greater than 2GB threshold.
 </param>
 <returns></returns>
 <remarks>
 这个函数只有在完全处于<see cref="F:System.IO.FileMode.Open"/>模式下，并且readonly为TRUE，这个时候才会有可能将所有原始数据一次性读取进入内存中
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.IOExtensions.ClearFileBytes(System.String)">
 <summary>
 将文件之中的所有数据都清空
 </summary>
 <param name="path"></param>
 
</member>
<member name="M:Microsoft.VisualBasic.IOExtensions.OpenReader(System.String,System.Text.Encoding)">
 <summary>
 Open a text file and returns its file handle.
 </summary>
 <param name="path"></param>
 <param name="encoding">使用系统默认的编码方案</param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.IOExtensions.ReadBinary(System.String)">
 <summary>
 <see cref="M:System.IO.File.ReadAllBytes(System.String)"/>, if the file is not exists
 on the filesystem, then a empty array will be return.
 </summary>
 <param name="path"></param>
 <returns>
 this method can not read data file when its size is greater 
 than or equals to 2GB size.
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.IOExtensions.FlushAllLines``1(System.Collections.Generic.IEnumerable{``0},System.String,Microsoft.VisualBasic.Text.Encodings)">
 <summary>
 Write all object into a text file by using its <see cref="T:System.Object"/> method.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="data"></param>
 <param name="saveTo"></param>
 <param name="encoding"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.IOExtensions.FlushStream(System.Collections.Generic.IEnumerable{System.Byte},System.String)">
 <summary>
 Save the binary data into the filesystem.
 </summary>
 <param name="buf">The binary bytes data of the target package's data.(目标二进制数据)</param>
 <param name="path">The saved file path of the target binary data chunk.(目标二进制数据包所要进行保存的文件名路径)</param>
 <returns></returns>
 <remarks>this function will truncates the target file and then save binary data into the file.
 (保存二进制数据包值文件系统)</remarks>

</member>
<member name="T:Microsoft.VisualBasic.PathExtensions">
 <summary>
 Search the path from a specific keyword.(通过关键词来推测路径)
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.PathExtensions.ChangeSuffix(System.String,System.String)">
 <summary>
 修改路径字符串之中的文件名后缀拓展名为<paramref name="newSuffix"/>指定的值。<paramref name="newSuffix"/>不需要添加小数点
 </summary>
 <param name="path$"></param>
 <param name="newSuffix$">新的文件拓展名，这个拓展名不带有小数点，例如需要修改为*.csv，则直接赋值csv即可</param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.PathExtensions.DeleteFile(System.String,System.Boolean,System.Boolean,System.Action{System.Object})">
 <summary>
 Execute file delete
 </summary>
 <param name="path">The file path or the directory path.</param>
 <param name="throwEx"></param>
 <param name="strictFile">
 this function is not allowed for delete a directory by default.
 </param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.PathExtensions.ExtensionSuffix(System.String)">
 <summary>
 returns a file extension suffix name in lower case.
 </summary>
 <param name="path">the file path string</param>
 <returns>
 returns a file extension suffix name in lower case, if there is 
 no extension name or path string is empty, then empty string 
 value will be returned.
 </returns>
 <remarks>
 this is a safe function, which mean the value Nothing will never 
 be returns from this function.
 
 (函数返回文件的拓展名后缀，请注意，这里的返回值是不会带有小数点的)
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.PathExtensions.ExtensionSuffix(System.String,System.String[])">
 <summary>
 Test if is there any given extension name is equals 
 to the extension name of the specific file 
 <paramref name="path"/>.
 </summary>
 <param name="path"></param>
 <param name="isAny">不带小数点的文件拓展名列表</param>
 <returns></returns>
 <remarks>
 case ignored
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.PathExtensions.DIR(System.IO.DirectoryInfo,System.String)">
 <summary>
 Combine directory path.(这个主要是用于生成文件夹名称)
 
 ###### Example usage
 
 ```vbnet
 Dim images As Dictionary(Of String, String) =
     (ls - l - {"*.png", "*.jpg", "*.gif"} &lt;= PlatformEngine.wwwroot.DIR("images")) _
     .ToDictionary(Function(file) file.StripAsId,
                   AddressOf FileName)
 ```
 </summary>
 <param name="d"></param>
 <param name="name"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.PathExtensions.MakeDir(System.String,System.Boolean)">
 <summary>
 Make directory
 </summary>
 <param name="DIR"></param>
</member>
<member name="M:Microsoft.VisualBasic.PathExtensions.EnumerateFiles(System.String,System.String[])">
 <summary>
 使用<see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFiles(System.String)"/>函数枚举
 **当前的**(不是递归的搜索所有的子文件夹)文件夹之中的
 所有的符合条件的文件路径
 </summary>
 <param name="dir">文件夹路径</param>
 <param name="keyword">
 Default is ``*.*`` for match any kind of files.
 (文件名进行匹配的关键词)
 </param>
 <returns>
 a collection of file full paths
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.PathExtensions.ListFiles(System.String,System.String[])">
 <summary>
 ```
 ls - l - r - pattern &lt;= DIR
 ```
 
 的简化拓展函数模式
 </summary>
 <param name="directory"></param>
 <param name="pattern">
 default filter is ``*.*``, which means select all files. 
 如果匹配的模式字符串是带有文件后缀名的，那么文件夹之中所有没有后缀名的文件都可能会被忽略掉
 </param>
 <returns>
 scan for all sub-folder in recursive mode.
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.PathExtensions.ReadDirectory(System.String,Microsoft.VisualBasic.FileIO.SearchOption)">
 <summary>
 这个函数是会直接枚举出所有的文件路径的
 </summary>
 <param name="DIR$"></param>
 <param name="[option]"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.PathExtensions.ListDirectory(System.String,Microsoft.VisualBasic.FileIO.SearchOption,System.Boolean)">
 <summary>
 Yield subfolders' FullName
 </summary>
 <param name="DIR">文件夹不存在，则返回空的列表</param>
 <param name="[option]"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.PathExtensions.TheFile(System.String,System.String,Microsoft.VisualBasic.FileIO.SearchOption,System.Boolean)">
 <summary>
 这个函数只会返回文件列表之中的第一个文件，故而需要提取某一个文件夹之中的某一个特定的文件，推荐使用这个函数（这个函数默认只查找第一级文件夹，不会进行递归搜索）
 </summary>
 <param name="DIR$"></param>
 <param name="keyword$"></param>
 <param name="opt"></param>
 <param name="wildcard">The <paramref name="keyword"/> parameter value is a wildcard.</param>
 <returns>当查找不到目标文件或者文件夹不存在的时候会返回空值</returns>
</member>
<member name="M:Microsoft.VisualBasic.PathExtensions.ToFileURL(System.String)">
 <summary>
 Gets the URL type file path.
 </summary>
 <param name="Path"></param>
 <returns></returns>
 <remarks>(获取URL类型的文件路径)</remarks>

</member>
<member name="F:Microsoft.VisualBasic.PathExtensions.ILLEGAL_PATH_CHARACTERS">
 <summary>
 枚举所有非法的路径字符
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.PathExtensions.NormalizePathString(System.String,System.Boolean,System.String)">
 <summary>
 将目标字符串之中的非法的字符替换为"_"符号以成为正确的文件名字符串。当参数<paramref name="alphabetOnly"/>为真的时候，意味着所有的非字母或者数字的字符都会被替换为下划线，默认为真
 </summary>
 <param name="str"></param>
 <param name="alphabetOnly">当本参数为真的时候，仅26个字母，0-9数字和下划线_以及小数点可以被保留下来</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.PathExtensions.Long2Short(System.String,System.String)">
 <summary>
 假设文件名过长发生在文件名和最后一个文件夹的路径之上
 </summary>
 <param name="path"></param>
 <returns></returns>
 <remarks>
 System.IO.PathTooLongException: The specified path, file name, or both are too long.
 The fully qualified file name must be less than 260 characters, and the directory name must be less than 248 characters.
 </remarks>
</member>
<member name="F:Microsoft.VisualBasic.PathExtensions.DriveLabel">
 <summary>
 + C:\
 + AB:\
 + AB2:\
 + etc...
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.PathExtensions.PathIllegal(System.String)">
 <summary>
 File path illegal?
 </summary>
 <param name="path"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.PathExtensions.FileLength(System.String)">
 <summary>
 Gets the file length, if the path is not exists, then returns -1.
 (安全的获取文件的大小，如果目标文件不存在的话会返回-1)
 </summary>
 <param name="path"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.PathExtensions.FileCopy(System.String,System.String)">
 <summary>
 Safe file copy operation.
 (请注意，<paramref name="copyTo"/>参数的字符串最末尾必须是``/``或者``\``才会被认作为目录路径)
 </summary>
 <param name="source$"></param>
 <param name="copyTo$">
 Can be file name or directory name.
 
 + If this paramter is a file path, then you can copy the 
   source file to another location with renamed.
 + If this parameter is a directory location, then you can 
   copy the source file to another location with the 
   identical file name.
 
 Please notice that, the directory path should end with 
 path seperator symbol: ``\`` or ``/``.
 </param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.PathExtensions.FileExists(System.String,System.Boolean)">
 <summary>
 Check if the target file object is exists on your file system or not.
 (这个函数也会自动检查目标<paramref name="path"/>参数是否为空)
 </summary>
 <param name="path"></param>
 <param name="ZERO_Nonexists">将0长度的文件也作为不存在</param>
 <returns>
 returns the file path check result:
 
 1. <paramref name="path"/> string is null or empty string: false
 2. file not exists: false
 3. file is zero length andalso <paramref name="ZERO_Nonexists"/> is config as true: false
 </returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.PathExtensions.DirectoryExists(System.String)">
 <summary>
 Determine that the target directory is exists on the file system or not?
 </summary>
 <param name="DIR"></param>
 <returns>
 1. for directory parameter <paramref name="DIR"/> is nothing or empty string: return false
 2. for directory not exists: return false
 </returns>
 <remarks>
 (判断文件夹是否存在)
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.PathExtensions.DirectoryName(System.String)">
 <summary>
 Get the directory its name of the target <paramref name="dir"/> directory
 </summary>
 <param name="dir$"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.PathExtensions.FileOpened(System.String)">
 <summary>
 Check if the file is opened by other code?(检测文件是否已经被其他程序打开使用之中)
 </summary>
 <param name="FileName">目标文件</param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.PathExtensions.BaseName(System.String,System.Boolean)">
 <summary>
 Gets the name of the target file or directory, if the target is a file, then the name without 
 the extension suffix name.
 (获取目标文件夹的名称或者文件的不包含拓展名的名称)
 </summary>
 <returns></returns>
 <remarks>
 ###### 2017-2-14 
 
 原先的函数是依靠系统的API来工作的，故而只能够工作于已经存在的文件之上，
 所以在这里为了更加方便的兼容文件夹或者文件路径，在这使用字符串的方法来
 进行截取
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.PathExtensions.ParentDirName(System.String)">
 <summary>
 Gets the name of the file's parent directory, returns value is a name, not path.
 (获取目标文件的父文件夹的文件夹名称，是名称而非路径)
 </summary>
 <param name="file"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.PathExtensions.ParentPath(System.String,System.Boolean)">
 <summary>
 Returns the directory path value of the parent directory.
 (这个函数是返回文件夹的路径而非名称，这个函数不依赖于系统的底层API，
 因为系统的底层API对于过长的文件名会出错)
 </summary>
 <param name="file"></param>
 <param name="full">
 http url should turn this parameter to false?
 </param>
 <returns></returns>
 <remarks>this function also could be used for handling of the http url location.
 这个函数不依赖于系统的底层API，因为系统的底层API对于过长的文件名会出错</remarks>
</member>
<member name="M:Microsoft.VisualBasic.PathExtensions.RelativePath(System.String)">
 <summary>
 Get the specific file system object its relative path to the application base directory.
 </summary>
 <param name="path"></param>
 <returns></returns>
 <remarks>
 (获取相对于本应用程序的目标文件的相对路径(请注意，所生成的相对路径之中的字符串最后是没有文件夹的分隔符\或者/的))
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.PathExtensions.RelativePath(System.String,System.String,System.Boolean,System.Boolean)">
 <summary>
 Gets the relative path of file system object <paramref name="pcTo"/> reference to the directory path <paramref name="pcFrom"/>.
 </summary>
 <param name="pcFrom">生成相对路径的参考文件夹</param>
 <param name="pcTo">所需要生成相对路径的目标文件系统对象的绝对路径或者相对路径</param>
 <param name="appendParent">是否将父目录的路径也添加进入相对路径之中？默认是</param>
 <returns>
 The relative path string of pcTo file object reference to directory pcFrom
 </returns>
 <remarks>
 (请注意，所生成的相对路径之中的字符串最后是没有文件夹的分隔符\或者/的)
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.PathExtensions.GetFullPath(System.String,System.Boolean)">
 <summary>
 Gets the full path of the specific file.
 </summary>
 <param name="file"></param>
 <returns></returns>
 <remarks>
 (为了兼容Linux，这个函数会自动替换路径之中的\为/符号)
 </remarks>
</member>
<member name="F:Microsoft.VisualBasic.PathExtensions.UNCprefixRegexp">
 <summary>
 regexp pattern for matches the UNC path prefix string.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.PathExtensions.CheckUNCNetworkPath(System.String)">
 <summary>
 Check of this given windows file path is in UNC full path style?
 </summary>
 <param name="path">
 check of this given path is a UNC path or not? UNC full path is a kind of network path 
 for smb network drive, example as \\192.168.3.1\XXX, the UNC path is prefixed with a 
 server ip address.
 </param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.PathExtensions.GetDirectoryFullPath(System.String,System.String)">
 <summary>
 Gets the full path of the specific directory. 
 </summary>
 <param name="dir"></param>
 <param name="stack">当程序出错误的时候记录进入日志的一个追踪目标参数，调试用</param>
 <returns></returns>
 <remarks>
 (这个函数为了兼容linux的文件系统，也会自动的将所有的``\``替换为``/``)
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.PathExtensions.TrimSuffix(System.String)">
 <summary>
 Removes the file extension name from the file path.
 </summary>
 <param name="file"></param>
 <returns></returns>
 <remarks>
 (去除掉文件的拓展名)
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.PathExtensions.TrimDIR(System.String)">
 <summary>
 Removes the last \ and / character in a directory path string.
 </summary>
 <param name="DIR"></param>
 <returns></returns>
 <remarks>
 (使用这个函数修剪文件夹路径之中的最后一个分隔符，以方便生成文件名)
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.PathExtensions.FileName(System.String)">
 <summary>
 返回``文件名称.拓展名``，对于文件夹路径而言，则是返回文件夹名称
 </summary>
 <param name="path"></param>
 <returns></returns>
 <remarks>
 这个函数为单纯的字符串解析函数，不依赖于文件系统的API
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.PathExtensions.SafeCopyTo(System.String,System.String)">
 <summary>
 进行安全的复制，出现错误不会导致应用程序崩溃，大文件不推荐使用这个函数进行复制
 </summary>
 <param name="source"></param>
 <param name="copyTo"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.SerializationIO.SaveAsTabularMapping(System.Collections.Generic.IEnumerable{Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedValue{System.String}},System.String,System.Boolean,System.String[],Microsoft.VisualBasic.Text.Encodings)">
 <summary>
 Save as a tsv file, with data format like: 
 
 ```
 <see cref="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedValue`1.Name"/>\t<see cref="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedValue`1.Value"/>\t<see cref="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedValue`1.Description"/>
 ```
 </summary>
 <param name="source"></param>
 <param name="path$"></param>
 <param name="encoding"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.SerializationIO.SolveListStream(System.String,System.Text.Encoding)">
 <summary>
 Get string collection from input file 
 </summary>
 <param name="path">allows plain text/string array json/xml</param>
 <param name="encoding"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.SerializationIO.DumpSerial(System.Collections.Generic.IEnumerable{System.Drawing.PointF},System.String,Microsoft.VisualBasic.Text.Encodings)">
 <summary>
 Save a given list of <see cref="T:System.Drawing.PointF"/> data into a csv file.
 </summary>
 <param name="points"></param>
 <param name="csv"></param>
 <param name="encoding"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.StreamHelper.CopyStream(System.IO.Stream,System.IO.Stream,System.Int32)">
 <summary>
 Download stream data from the http response.
 </summary>
 <param name="stream">
 Create from <see cref="M:Microsoft.VisualBasic.WebServiceUtils.GetRequestRaw(System.String,System.Boolean,System.String,System.Collections.Generic.Dictionary{System.String,System.String})"/>
 </param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.StreamHelper.PopulateBlocks(System.IO.Stream,System.Int32)">
 <summary>
 这个函数会重置流的指针位置
 </summary>
 <param name="buffer"></param>
 <param name="chunkSize%"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.StreamHelper.Write(System.IO.Stream,System.String,System.Text.Encoding)">
 <summary>
 write target string <paramref name="value"/> into the 
 given <paramref name="stream"/> in no size prefix and
 zero terminator.
 </summary>
 <param name="stream"></param>
 <param name="value">target string value to write into the given <paramref name="stream"/></param>
 <param name="encoding"></param>
</member>
<member name="M:Microsoft.VisualBasic.StreamHelper.ReadZEROBlock(System.IO.BinaryReader)">
 <summary>
 read current stream data until read a byte flag ZERO
 </summary>
 <param name="bin"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.StreamHelper.WriteLine(System.IO.Stream,System.String,System.Text.Encoding,System.String)">
 <summary>
 
 </summary>
 <param name="stream"></param>
 <param name="value"></param>
 <param name="encoding"></param>
 <param name="newLine"></param>
 <remarks>
 default use utf8 encoding
 </remarks>
</member>
<member name="T:Microsoft.VisualBasic.Math.Correlations.Correlations">
 <summary>
 计算两个数据向量之间的相关度的大小
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.Correlations.Correlations.JaccardIndex``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Func{System.Object,System.Object,System.Boolean})">
 <summary>
 The Jaccard index, also known as Intersection over Union and the Jaccard similarity coefficient 
 (originally coined coefficient de communauté by Paul Jaccard), is a statistic used for comparing 
 the similarity and diversity of sample sets. The Jaccard coefficient measures similarity between 
 finite sample sets, and is defined as the size of the intersection divided by the size of the 
 union of the sample sets.
 
 https://en.wikipedia.org/wiki/Jaccard_index
 </summary>
 <typeparam name="T"></typeparam>
 <param name="a"></param>
 <param name="b"></param>
 <param name="equal"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Correlations.Correlations.SW(System.Double[],System.Double[])">
 <summary>
 Sandelin-Wasserman similarity function.
 (假若所有的元素都是0-1之间的话，结果除以2可以得到相似度)
 </summary>
 <param name="x"></param>
 <param name="y"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Correlations.Correlations.JSD(System.Double[],System.Double[])">
 <summary>
 Jensen–Shannon divergence（J-S散度） is a method of measuring the similarity between two 
 probability distributions.
 It is based on the Kullback–Leibler divergence（K-L散度）, with some notable (and useful) 
 differences, including that it is symmetric and it is always a finite value.
 </summary>
 <param name="P"></param>
 <param name="Q"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Correlations.Correlations.KLD(System.Double[],System.Double[])">
 <summary>
 Kullback-Leibler divergence, <paramref name="x"/>和<paramref name="y"/>必须是等长的
 </summary>
 <param name="x"></param>
 <param name="y"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Correlations.Correlations.rankKendallTauBeta(System.Double[],System.Double[])">
 <summary>
 Provides rank correlation coefficient metrics Kendall tau
 </summary>
 <param name="x"></param>
 <param name="y"></param>
 <returns></returns>
 <remarks>
 https://github.com/felipebravom/RankCorrelation
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.Correlations.Correlations.kendallTauBeta(System.Double[],System.Double[])">
 <summary>
 Provides rank correlation coefficient metrics Kendall tau
 </summary>
 <param name="x"></param>
 <param name="y"></param>
 <returns></returns>
 <remarks>
 https://github.com/felipebravom/RankCorrelation
 </remarks>
</member>
<member name="F:Microsoft.VisualBasic.Math.Correlations.Correlations.TINY">
 <summary>
 will regularize the unusual case of complete correlation
 </summary>
 <remarks>
 A this tiny value for avoid divid ZERO
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.Correlations.Correlations.GetPearson(System.Double[],System.Double[],System.Double@,System.Double@,System.Double@,System.Double@,System.Double@,System.Boolean)">
 <summary>

 </summary>
 <param name="x"></param>
 <param name="y"></param>
 <param name="prob">p-value in R ``cor.test`` function.</param>
 <param name="prob2"></param>
 <param name="z">fisher's z trasnformation</param>
 <param name="df">degree of freedom</param>
 <param name="t">
 student's t probability
 </param>
 <returns></returns>
 <remarks>
 checked by Excel
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.Correlations.Correlations.TestStats(System.Double,System.Int32,System.Double@,System.Double@,System.Double@,System.Double@,System.Double@,System.Boolean)">
 <summary>
 
 </summary>
 <param name="cor"></param>
 <param name="n">should be the length of x or y vector</param>
 <param name="z"></param>
 <param name="pvalue"></param>
 <param name="prob2"></param>
 <param name="t"></param>
 <param name="df"></param>
 <param name="throwMaxIterError"></param>
 <remarks>
 Fisher's z 变换，主要用于皮尔逊相关系数的非线性修正上面。因为普通皮尔逊相关系数
 在0-1上并不服从正态分布，相关系数的绝对值越趋近1时，概率变得非常非常小。相关系数
 的分布非常像断了两头的正态分布。所以需要通过Fisherz-transformation对皮尔逊相
 关系数进行修正，使得满足正态分布。
 </remarks>
</member>
<member name="P:Microsoft.VisualBasic.Math.Correlations.Correlations.PearsonDefault">
 <summary>
 默认使用Pearson相似度
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Correlations.Correlations.GetPearson(System.Double[],System.Double[])">
 <summary>
 Pearson correlations
 </summary>
 <param name="x#"></param>
 <param name="y#"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Math.Correlations.Correlations.ICorrelation">
 <summary>
 相关性的计算分析函数
 </summary>
 <param name="X"></param>
 <param name="Y"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Correlations.Correlations.Spearman(System.Double[],System.Double[])">
 <summary>
 This method should not be used in cases where the data set is truncated; that is,
 when the Spearman correlation coefficient is desired for the top X records
 (whether by pre-change rank or post-change rank, or both), the user should use the
 Pearson correlation coefficient formula given above.
 (斯皮尔曼相关性)
 </summary>
 <param name="X"></param>
 <param name="Y"></param>
 <returns></returns>
 <remarks>
 https://en.wikipedia.org/wiki/Spearman%27s_rank_correlation_coefficient
 spearman rho checked!
 </remarks>

</member>
<member name="M:Microsoft.VisualBasic.Math.Correlations.Correlations.CorrelationMatrix(System.Collections.Generic.IEnumerable{Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedValue{System.Double[]}},Microsoft.VisualBasic.Math.Correlations.Correlations.ICorrelation)">
 <summary>
 输入的数据为一个对象属性的集合，默认的<paramref name="compute"/>计算方法为<see cref="M:Microsoft.VisualBasic.Math.Correlations.Correlations.GetPearson(System.Double[],System.Double[])"/>
 </summary>
 <param name="data">``[ID, properties]``</param>
 <param name="compute">
 Using pearson method as default if this parameter is nothing.
 (默认的计算形式为<see cref="M:Microsoft.VisualBasic.Math.Correlations.Correlations.GetPearson(System.Double[],System.Double[])"/>)
 </param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Correlations.DistanceMethods.chebyshev_distance(System.Double[],System.Double[])">
 <summary>
 Chebyshev distance:
 
 ```py
 # \underset{i}{\max}{(|P_{i}\ -\ Q_{i}|)}
 np.max(np.abs(p - q))
 ```
 </summary>
 <param name="p"></param>
 <param name="q"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Correlations.DistanceMethods.fidelity_distance(System.Double[],System.Double[])">
 <summary>
 Fidelity distance:
 
 ```py
 # 1-\sum\sqrt{P_{i}Q_{i}}
 1 - np.sum(np.sqrt(p * q))
 ```
 </summary>
 <param name="p"></param>
 <param name="q"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Correlations.DistanceMethods.harmonic_mean_distance(System.Double[],System.Double[])">
 <summary>
 Harmonic mean distance:
 
 ```py
 # 1-2\sum(\frac{P_{i}Q_{i}}{P_{i}+Q_{i}})
 1 - 2 * np.sum(p * q / (p + q))
 ```
 </summary>
 <param name="p"></param>
 <param name="q"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Correlations.DistanceMethods.EuclideanDistance(System.Collections.Generic.IEnumerable{System.Double})">
 <summary>
 多位坐标的欧几里得距离，与坐标点0进行比较
 </summary>
 <param name="vector"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.Correlations.DistanceMethods.EuclideanDistance(System.Byte[],System.Byte[])">
 <summary>
 
 </summary>
 <param name="a">Point A</param>
 <param name="b">Point B</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Correlations.DistanceMethods.EuclideanDistance(System.Double[],System.Double[])">
 <summary>
 Calculates the Euclidean Distance Measure between two data points
 </summary>
 <param name="X">An array with the values of an object or datapoint</param>
 <param name="Y">An array with the values of an object or datapoint</param>
 <returns>Returns the Euclidean Distance Measure Between Points X and Points Y</returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Math.Correlations.DistanceMethods.ManhattanDistance(System.Double[],System.Double[])">
 <summary>
 Calculates the Manhattan Distance Measure between two data points
 </summary>
 <param name="X">An array with the values of an object or datapoint</param>
 <param name="Y">An array with the values of an object or datapoint</param>
 <returns>Returns the Manhattan Distance Measure Between Points X and Points Y</returns>
 <remarks>
 Manhattan 距离：是Minkowski, q=1时的特例
 </remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.Math.Correlations.DistanceMethods.ManhattanDistance(Microsoft.VisualBasic.Math.IVector,Microsoft.VisualBasic.Math.IVector)">
 <summary>
 Calculates the Manhattan Distance Measure between two data points
 </summary>
 <param name="X">An array with the values of an object or datapoint</param>
 <param name="Y">An array with the values of an object or datapoint</param>
 <returns>Returns the Manhattan Distance Measure Between Points X and Points Y</returns>
 <remarks>
 Manhattan 距离：是Minkowski, q=1时的特例
 </remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.Math.Correlations.DistanceMethods.DistanceTo(Microsoft.VisualBasic.Math.IVector,Microsoft.VisualBasic.Math.IVector)">
 <summary>
 implements via <see cref="M:Microsoft.VisualBasic.Math.Correlations.DistanceMethods.EuclideanDistance(System.Byte[],System.Byte[])"/>
 </summary>
 <param name="a"></param>
 <param name="b"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Correlations.DistanceMethods.DistanceTo(Microsoft.VisualBasic.Math.IVector,System.Double[])">
 <summary>
 implements via <see cref="M:Microsoft.VisualBasic.Math.Correlations.DistanceMethods.EuclideanDistance(System.Byte[],System.Byte[])"/>
 </summary>
 <param name="a"></param>
 <param name="v"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Correlations.DistanceMethods.SquareDistance(System.Double[],System.Double[])">
 <summary>
 SUM((a - v) ^ 2)
 </summary>
 <param name="v"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Correlations.DistanceMethods.SquareDistance(Microsoft.VisualBasic.Math.IVector,System.Double[])">
 <summary>
 SUM((a - v) ^ 2)
 </summary>
 <param name="a"></param>
 <param name="v"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Correlations.DistanceMethods.SquareDistance(Microsoft.VisualBasic.Emit.Marshal.Span{System.Double},Microsoft.VisualBasic.Emit.Marshal.Span{System.Double})">
 <summary>
 Reduced Euclidean distance
 </summary>
 <remarks>
 SUM((x - y) ^ 2)
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.Correlations.DistanceMethods.SquareDistance(Microsoft.VisualBasic.Imaging.Layout2D,Microsoft.VisualBasic.Imaging.Layout2D)">
 <summary>
 Reduced Euclidean distance
 </summary>
 <remarks>
 SUM((x - y) ^ 2)
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.Correlations.DistanceMethods.BrayCurtis(System.Double[],System.Double[])">
 <summary>
 Bray-Curtis distance
 </summary>
 <param name="sample1"></param>
 <param name="sample2"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Math.Correlations.Ranking">
 <summary>
 A **ranking** is a relationship between a set of items such that, for any two items, 
 the first is either 'ranked higher than', 'ranked lower than' or 'ranked equal to' 
 the second. In mathematics, this is known as a weak order or total preorder of objects. 
 It is not necessarily a total order of objects because two different objects can have 
 the same ranking. The rankings themselves are totally ordered. For example, materials 
 are totally preordered by hardness, while degrees of hardness are totally ordered.
 
 > https://en.wikipedia.org/wiki/Ranking
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Math.Correlations.Ranking.Strategies">
 <summary>
 ###### Strategies for assigning rankings
 
 It is not always possible to assign rankings uniquely. For example, in a race 
 or competition two (or more) entrants might tie for a place in the ranking. 
 When computing an ordinal measurement, two (or more) of the quantities being 
 ranked might measure equal. In these cases, one of the strategies shown below 
 for assigning the rankings may be adopted. A common shorthand way to distinguish 
 these ranking strategies is by the ranking numbers that would be produced for 
 four items, with the first item ranked ahead of the second and third (which 
 compare equal) which are both ranked ahead of the fourth. 
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.Correlations.Ranking.Ranking``1(System.Collections.Generic.IEnumerable{``0},Microsoft.VisualBasic.Math.Correlations.Ranking.Strategies,System.Boolean)">
 <summary>
 函数返回与输入的序列中的元素相同顺序的排序的得分
 </summary>
 <typeparam name="C"></typeparam>
 <param name="list"></param>
 <param name="strategy"></param>
 <param name="desc"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Correlations.Ranking.ModifiedCompetitionRanking``1(System.Collections.Generic.IEnumerable{``0},System.Boolean)">
 <summary>
 ###### Modified competition ranking ("1334" ranking)
 
 Sometimes, competition ranking is done by leaving the gaps in the ranking numbers before the sets 
 of equal-ranking items (rather than after them as in standard competition ranking).[where?] The 
 number of ranking numbers that are left out in this gap remains one less than the number of items that 
 compared equal. Equivalently, each item's ranking number is equal to the number of items ranked equal 
 to it or above it. This ranking ensures that a competitor only comes second if they score higher than 
 all but one of their opponents, third if they score higher than all but two of their opponents, etc.
 
 Thus if A ranks ahead of B and C (which compare equal) which are both ranked head of D, then A gets 
 ranking number 1 ("first"), B gets ranking number 3 ("joint third"), C also gets ranking number 3 
 ("joint third") and D gets ranking number 4 ("fourth"). In this case, nobody would get ranking number 
 2 ("second") and that would be left as a gap.
 </summary>
 <typeparam name="C"></typeparam>
 <param name="list"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Correlations.Ranking.StandardCompetitionRanking``1(System.Collections.Generic.IEnumerable{``0},System.Boolean)">
 <summary>
 ###### Standard competition ranking ("1224" ranking)
 
 In competition ranking, items that compare equal receive the same ranking number, and then a gap 
 is left in the ranking numbers. The number of ranking numbers that are left out in this gap is 
 one less than the number of items that compared equal. Equivalently, each item's ranking number 
 is 1 plus the number of items ranked above it. This ranking strategy is frequently adopted for 
 competitions, as it means that if two (or more) competitors tie for a position in the ranking, 
 the position of all those ranked below them is unaffected (i.e., a competitor only comes second if 
 exactly one person scores better than them, third if exactly two people score better than them, 
 fourth if exactly three people score better than them, etc.).
 
 Thus if A ranks ahead of B and C (which compare equal) which are both ranked ahead of D, then A 
 gets ranking number 1 ("first"), B gets ranking number 2 ("joint second"), C also gets ranking 
 number 2 ("joint second") and D gets ranking number 4 ("fourth").
 </summary>
 <typeparam name="C"></typeparam>
 <param name="list"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Correlations.Ranking.DenseRanking``1(System.Collections.Generic.IEnumerable{``0},System.Boolean)">
 <summary>
 ###### Dense ranking ("1223" ranking)
 
 In dense ranking, items that compare equal receive the same ranking number, and the next item(s) 
 receive the immediately following ranking number. Equivalently, each item's ranking number is 1 
 plus the number of items ranked above it that are distinct with respect to the ranking order.
 
 Thus if A ranks ahead of B and C (which compare equal) which are both ranked ahead of D, then A 
 gets ranking number 1 ("first"), B gets ranking number 2 ("joint second"), C also gets ranking 
 number 2 ("joint second") and D gets ranking number 3 ("third").
 </summary>
 <typeparam name="C"></typeparam>
 <param name="list"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Correlations.Ranking.OrdinalRanking``1(System.Collections.Generic.IEnumerable{``0},System.Boolean)">
 <summary>
 ###### Ordinal ranking ("1234" ranking)
 
 In ordinal ranking, all items receive distinct ordinal numbers, including items that compare equal. 
 The assignment of distinct ordinal numbers to items that compare equal can be done at random, 
 or arbitrarily, but it is generally preferable to use a system that is arbitrary but consistent, 
 as this gives stable results if the ranking is done multiple times. An example of an arbitrary but 
 consistent system would be to incorporate other attributes into the ranking order (such as 
 alphabetical ordering of the competitor's name) to ensure that no two items exactly match.
 
 With this strategy, if A ranks ahead of B and C (which compare equal) which are both ranked ahead of D, 
 then A gets ranking number 1 ("first") and D gets ranking number 4 ("fourth"), and either B gets 
 ranking number 2 ("second") and C gets ranking number 3 ("third") or C gets ranking number 2 ("second") 
 and B gets ranking number 3 ("third").
 
 In computer data processing, ordinal ranking is also referred to as "row numbering".
 </summary>
 <typeparam name="C"></typeparam>
 <param name="list"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Correlations.Ranking.OrdinalRankingOrder``1(System.Collections.Generic.IEnumerable{``0},System.Boolean)">
 <summary>
 ###### Ordinal ranking ("1234" ranking)
 
 In ordinal ranking, all items receive distinct ordinal numbers, including items that compare equal. 
 The assignment of distinct ordinal numbers to items that compare equal can be done at random, 
 or arbitrarily, but it is generally preferable to use a system that is arbitrary but consistent, 
 as this gives stable results if the ranking is done multiple times. An example of an arbitrary but 
 consistent system would be to incorporate other attributes into the ranking order (such as 
 alphabetical ordering of the competitor's name) to ensure that no two items exactly match.
 
 With this strategy, if A ranks ahead of B and C (which compare equal) which are both ranked ahead of D, 
 then A gets ranking number 1 ("first") and D gets ranking number 4 ("fourth"), and either B gets 
 ranking number 2 ("second") and C gets ranking number 3 ("third") or C gets ranking number 2 ("second") 
 and B gets ranking number 3 ("third").
 
 In computer data processing, ordinal ranking is also referred to as "row numbering".
 </summary>
 <typeparam name="C"></typeparam>
 <param name="list"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Correlations.Ranking.FractionalRanking``1(System.Collections.Generic.IEnumerable{``0},System.Boolean)">
 <summary>
 ###### Fractional ranking ("1 2.5 2.5 4" ranking)
 
 Items that compare equal receive the same ranking number, which is the mean 
 of what they would have under ordinal rankings. Equivalently, the ranking 
 number of 1 plus the number of items ranked above it plus half the number 
 of items equal to it. This strategy has the property that the sum of the 
 ranking numbers is the same as under ordinal ranking. For this reason, it 
 is used in computing Borda counts and in statistical tests (see below).
 
 Thus if A ranks ahead of B and C (which compare equal) which are both ranked 
 ahead of D, then A gets ranking number 1 ("first"), B and C each get ranking 
 number 2.5 (average of "joint second/third") and D gets ranking number 4 
 ("fourth").
 
 Here is an example: Suppose you have the data set 1.0, 1.0, 2.0, 3.0, 3.0, 4.0, 5.0, 5.0, 5.0.
 The ordinal ranks are 1, 2, 3, 4, 5, 6, 7, 8, 9.
 For v = 1.0, the fractional rank is the average of the ordinal ranks: (1 + 2) / 2 = 1.5. 
 In a similar manner, for v = 5.0, the fractional rank is (7 + 8 + 9) / 3 = 8.0.
 Thus the fractional ranks are: 1.5, 1.5, 3.0, 4.5, 4.5, 6.0, 8.0, 8.0, 8.0
 </summary>
 <typeparam name="C"></typeparam>
 <param name="list"></param>
 <returns></returns>
</member>
<member name="F:Microsoft.VisualBasic.Math.Correlations.RankOrder`1.rank">
 <summary>
 排序之后得到的位置
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Math.Correlations.RankOrder`1.i">
 <summary>
 在序列之中原有的位置
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Math.Correlations.RankOrder`1.value">
 <summary>
 xi in the input data sequence
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.Correlations.RankOrder`1.Ranking(System.Collections.Generic.IEnumerable{Microsoft.VisualBasic.Math.Correlations.RankOrder{`0}},System.Boolean)">
 <summary>
 
 </summary>
 <param name="data"></param>
 <param name="desc"></param>
 <returns>
 i -> new order in new sequence after data sort
 </returns>
</member>
<member name="P:Microsoft.VisualBasic.Math.Ranking`1.Max">
 <summary>
 The sort direction
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Math.Ranking`1.Weight">
 <summary>
 默认不加权重
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Ranks.Best``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{Microsoft.VisualBasic.Math.Ranking{``0}})">
 <summary>
 
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <param name="Evaluate"></param>
 <returns>Ranks值最小的是认为最好的</returns>
</member>
<member name="T:Microsoft.VisualBasic.Math.Information.Entropy">
 <summary>
 信息熵越大表示所含信息量越多
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.Information.Entropy.ShannonEnt``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>
 计算出目标序列的香农信息熵
 </summary>
 <typeparam name="T"></typeparam>
 <param name="collection"></param>
 <returns></returns>
 <remarks>
 ###### 计算公式
 
 ```
 H(x) = E[ I(xi) ] 
      = E[ log(2, 1/p(xi)) ] 
      = -∑ p(xi)log(2, p(xi))  (i=1, 2, ..., n)
 ```
 
 其中，``x``表示随机变量，与之相对应的是所有可能输出的集合，定义为符号集，随机变量的输出用``x``表示。
 ``P(x)``表示输出概率函数。变量的不确定性越大，熵也就越大，把它搞清楚所需要的信息量也就越大.
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.Information.Entropy.ShannonEntropy(System.Collections.Generic.IEnumerable{System.Double})">
 <summary>
 Calculate entropy value.
 
 (直接从一个概率向量之中计算出香农信息熵)
 </summary>
 <param name="probs">Sum of this probability vector must equals to 1, Histogram array.</param>
 <returns></returns>
 <remarks><para>
 The input array is treated as histogram, i.e. its
 indexes are treated as values of stochastic function, but
 array values are treated as "probabilities" (total amount of
 hits).</para>
 
 <para>Sample usage:</para>
 <code>
 // create histogram array with 2 values of equal probabilities
 int[] histogram1 = new int[2] { 3, 3 };
 // calculate entropy
 double entropy1 = Statistics.Entropy( histogram1 );
 // output it (1.000)
 Console.WriteLine( "entropy1 = " + entropy1.ToString( "F3" ) );
 
 // create histogram array with 4 values of equal probabilities
 int[] histogram2 = new int[4] { 1, 1, 1, 1 };
 // calculate entropy
 double entropy2 = Statistics.Entropy( histogram2 );
 // output it (2.000)
 Console.WriteLine( "entropy2 = " + entropy2.ToString( "F3" ) );
 
 // create histogram array with 4 values of different probabilities
 int[] histogram3 = new int[4] { 1, 2, 3, 4 };
 // calculate entropy
 double entropy3 = Statistics.Entropy( histogram3 );
 // output it (1.846)
 Console.WriteLine( "entropy3 = " + entropy3.ToString( "F3" ) );
 </code>
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.Information.Entropy.Gini(System.Collections.Generic.IEnumerable{System.Double})">
 <summary>
 基尼系数的选择的标准就是每个子节点达到最高的纯度，即落在子节点中的所有观察都属于同一个分类，
 此时基尼系数最小，纯度最高，不确定度最小。
 
 基尼指数越大，说明不确定性就越大；基尼系数越小，不确定性越小，数据分割越彻底，越干净。
 </summary>
 <param name="p">
 the data probability
 </param>
 <returns></returns>
 
</member>
<member name="T:Microsoft.VisualBasic.Math.Information.EntropyScore">
 <summary>
 Unweighted entropy similarity
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.Information.EntropyScore.DiffEntropy(System.Collections.Generic.Dictionary{System.String,System.Double},System.Collections.Generic.Dictionary{System.String,System.Double})">
 <summary>
 Unweighted entropy similarity
 </summary>
 <param name="v1"></param>
 <param name="v2"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Math.Information.LempelZivComplexity">
 <summary>
 Lempel-Ziv复杂度（Lempel-Ziv Complexity, LZC）是一种用来衡量**序列（如字符串、时间序列等）结构化程度**或**随机性**的算法。
 它由以色列科学家Abraham Lempel和Jacob Ziv在1976年提出。其核心思想源于数据压缩领域——**一个序列的复杂度越高，它越难以被压缩**；
 反之，规律性强的序列则更容易被压缩。

 下面是一个表格，汇总了 Lempel-Ziv 复杂度的核心特性和应用领域：

 | 特性维度           | 说明                                                                 |
 | :---------------- | :------------------------------------------------------------------- |
 | **核心原理**       | 通过计算将序列分解为最少数量的**唯一子串**所需的步骤来衡量复杂度         |
 | **计算依据**       | 序列的可压缩性：越随机越难压缩，复杂度越高；越规则越易压缩，复杂度越低 |
 | **算法类型**       | 属于**无参数**算法，结果仅依赖于输入数据本身，无需预先设置参数                   |
 | **符号化方法**     | 通常先将原始数据（如时间序列）转换为符号序列（如二进制）再进行计算         |
 | **主要复杂度类型** | 被归类为**Ⅰ型复杂度**，其值通常随序列随机性的增加而增加                   |
 | **抗噪声能力**     | 经过改进的变体算法（如MEDLZC）展现出较好的抗噪声性能                      |
 | **应用领域**       | 神经科学（如脑电图分析）、故障诊断、生物医学信号处理、时间序列分析、水声信号处理 |

 ### 🧠 核心思想与直观理解

 Lempel-Ziv复杂度的核心思想是：**一个序列的复杂度，可以用构建它所需的最少“新花样”（即独特的、从未出现过的子串）的数量来衡量**。

 举个例子来理解：
 *   **序列 "00000000..."**：非常规则。从第二个字符开始，几乎都是在重复“0”这个已有的“花样”。因此，它的LZ复杂度会非常低。
 *   **序列 "0100110001110000..."**：有一些局部重复的块，但整体模式不如上一个规则。构建它需要更多新的“片段”，复杂度中等。
 *   **序列 "0110100011011110..."**：看起来非常随机，几乎每个新位置都可能需要一个新的“花样”。因此，它的LZ复杂度会很高。

 ### 📊 计算方法（基本步骤）

 计算一个序列S的Lempel-Ziv复杂度C(S)，其基本步骤如下：

 1.  **初始化**：创建一个空字典（或列表）D，用于记录已经出现过的独特子串。设置两个指针i=0和j=1，初始化复杂度计数器c=0。
 2.  **扫描与匹配**：从序列开头开始扫描。检查子串S[i:j]（从i到j-1）是否已经存在于字典D中。
     *   如果**存在**，则将j向右移动一位（扩展当前子串），继续检查更长的子串S[i:j]是否存在于D中。
     *   如果**不存在**，则意味着发现了一个新的独特子串。将这个新子串S[i:j]添加到字典D中，然后将复杂度计数器c加1。接着将指针i移动到当前位置j，并将j设置为i+1，从新的位置开始下一轮检查。
 3.  **循环与终止**：重复步骤2，直到指针j扫描完整个序列。
 4.  **归一化（可选）**：为了便于在不同长度的序列之间进行比较，有时会对复杂度进行归一化处理，例如除以序列长度n或n/log₂(n)等。

 其数学定义可以表述为：将一个字符串分割成最小数量的独特子串所需的次数。
 
 ### 🌐 主要应用领域

 Lempel-Ziv复杂度因其无需预设参数、计算相对高效的特点，在许多领域得到了应用：

 *   **神经科学与脑电图分析**：用于评估大脑活动的复杂性。例如，在麻醉过程中，大脑EEG信号的LZ复杂度会显著降低，反映了大脑信息处理能力的下降和意识的丧失。
 *   **故障诊断与特征提取**：在机械系统、电力系统或水力系统中，通过分析振动信号、电流信号等时间序列的LZ复杂度，可以检测系统的异常状态或故障模式。例如，有研究将其应用于**抽水蓄能机组**的故障诊断。
 *   **生物医学信号处理**：分析心率变异性、肌电信号等，以评估生理状态或疾病诊断。
 *   **时间序列分析**：适用于任何领域的时间序列，如金融数据、地震波、风速、温度等，用于衡量其随机性和结构性。
 *   **水声信号处理**：用于分析船舶辐射噪声等水下声学信号，进行特征提取和分类。

 ### ⚠️ 重要特性与局限性

 1.  **对随机性的敏感度**：LZC是一种**Ⅰ型复杂度**度量，其值通常随序列随机性的增加而增加。最大随机性的序列会具有很高的LZ复杂度。
 2.  **符号化过程的信息丢失**：标准的LZC算法通常需要先将连续值的时间序列**转换为符号序列（如二进制序列）**，这个过程中可能会丢失原始信号的一部分信息。为了克服这个缺点，研究者提出了许多改进算法，例如**余弦相似度Lempel-Ziv复杂度**，它利用余弦相似度来保留更多信息。
 3.  **单一尺度限制**：标准LZC只在单一尺度上衡量复杂度。然而，真实世界的信号往往在不同时间尺度上表现出不同的特性。为此，发展出了**多尺度Lempel-Ziv复杂度**、**复合多尺度Lempel-Ziv复杂度**等变体，以捕捉多尺度的复杂性信息。
 4.  **计算效率**：对于超长序列，计算LZC可能需要较多的计算资源。

 ### 💎 总结

 Lempel-Ziv复杂度是一个强大而直观的工具，它通过衡量序列的“不可压缩性”来量化其复杂性。虽然它最初为数据压缩而生，
 但其应用已远超越此领域，广泛应用于从神经科学到工业故障诊断的诸多方面。
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.Information.LempelZivComplexity.ComputeLZC(System.String)">
 <summary>
 计算二进制序列的Lempel-Ziv复杂度
 </summary>
 <param name="sequence">二进制序列（由'0'和'1'组成的字符串）</param>
 <returns>返回复杂度值c(n)和归一化复杂度C(n)</returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Information.LempelZivComplexity.ConvertToBinarySequence(System.Double[])">
 <summary>
 将数值序列转换为二进制序列（基于中值）用于LZC计算
 </summary>
 <param name="data">输入数值序列</param>
 <returns>二进制序列字符串</returns>
</member>
<member name="T:Microsoft.VisualBasic.Math.VBMath">
 <summary>
 Provides constants and static methods for trigonometric, logarithmic, and other
 common mathematical functions.To browse the .NET Framework source code for this
 type, see the Reference Source.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.VBMath.Clip(System.Double,System.Double)">
 <summary>
 Standard clamping of a value into a fixed range
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.VBMath.Clamp(System.Single,System.Single,System.Single)">
 <summary>
 返回范围内的一个数值。可以使用 clamp 函数将不断增加、减小或随机变化的数值限制在一系列的值中。
 </summary>
 <param name="x"></param>
 <param name="min"></param>
 <param name="max"></param>
 <returns></returns>
 <remarks>
 最小数值和最大数值指定返回值的范围。
 参数是值要钳制在范围内的属性或变量。
 如果参数位于最小数值和最大数值之间的数值范围内，则该函数将返回参数值。
 如果参数大于范围，该函数将返回最大数值。
 如果参数小于范围，该函数将返回最小数值。
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.VBMath.LeastCommonMultiple(System.Int32,System.Int32)">
 <summary>
 Function to calculate the Least Common Multiple (LCM)
 </summary>
 <param name="a"></param>
 <param name="b"></param>
 <returns></returns>
 <remarks>
 计算最小公倍数
 </remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.Math.VBMath.EuclidGcd(System.Int32,System.Int32)">
 <summary>
 Method which computes GCD of two numbers using Euclid's algorithm.
 </summary>
 <param name="a">First number.</param>
 <param name="b">Second number.</param>
 <returns>GCD of source numbers.</returns>
 <exception cref="T:System.ArgumentOutOfRangeException">Thrown when source numbers are out of range.</exception>
 <remarks>
 计算最大公约数
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.VBMath.SteinGcd(System.Int32,System.Int32)">
 <summary>
 Method which computes GCD of two numbers using Stein's algorithm.
 </summary>
 <param name="a">First number.</param>
 <param name="b">Second number.</param>
 <returns>GCD of source numbers.</returns>
 <exception cref="T:System.ArgumentOutOfRangeException">Thrown when source numbers are out of range.</exception>
 <remarks>
 计算最大公约数
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.VBMath.Log2(System.Double)">
 <summary>
 ``Math.Log(x, newBase:=2)``
 </summary>
 <param name="x#"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Math.VBMath.Factorial(System.Int32)">
 <summary>
 阶乘
 </summary>
 <param name="a"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.VBMath.Covariance(System.Double[],System.Double[])">
 <summary>
 Returns the covariance of two data vectors. </summary>
 <param name="a">	double[] of data </param>
 <param name="b">	double[] of data
 @return	the covariance of a and b, cov(a,b) </param>
</member>
<member name="M:Microsoft.VisualBasic.Math.VBMath.WeighedAverage(System.Collections.Generic.IEnumerable{System.Double},System.Double[])">
 <summary>
 请注意,<paramref name="data"/>的元素数量必须要和<paramref name="weights"/>的长度相等
 </summary>
 <param name="data"></param>
 <param name="weights">这个数组里面的值的和必须要等于1</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.VBMath.seq(Microsoft.VisualBasic.Language.Value{System.Double},System.Double,System.Double)">
 <summary>
 [Sequence Generation] Generate regular sequences. seq is a standard generic with a default method.
 </summary>
 <param name="From">
 the starting and (maximal) end values of the sequence. Of length 1 unless just from is supplied as an unnamed argument.
 </param>
 <param name="To">
 the starting and (maximal) end values of the sequence. Of length 1 unless just from is supplied as an unnamed argument.
 </param>
 <param name="By">number: increment of the sequence</param>
 <returns></returns>
 <remarks></remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.Math.VBMath.LogN(System.Double,System.Double)">
 <summary>
 以 N 为底的对数 ``LogN(X) = Log(X) / Log(N)`` 
 </summary>
 <param name="x"></param>
 <param name="N"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Math.VBMath.Max(System.Int32,System.Int32,System.Int32)">
 <summary>
 return the maximum of a, b and c </summary>
 <param name="a"> </param>
 <param name="b"> </param>
 <param name="c">
 @return </param>
 
</member>
<member name="M:Microsoft.VisualBasic.Math.VBMath.Max(System.Double,System.Double,System.Double)">
 <summary>
 return the maximum of a, b and c </summary>
 <param name="a"> </param>
 <param name="b"> </param>
 <param name="c">
 @return </param>
 
</member>
<member name="M:Microsoft.VisualBasic.Math.VBMath.Hypot(System.Double,System.Double)">
 <summary>
  sqrt(a^2 + b^2) without under/overflow.
 </summary>
 <param name="a"></param>
 <param name="b"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.VBMath.Pow2(System.Int32)">
 <summary>
 Calculates power of 2.
 </summary>
 
 <param name="power">Power to raise in.</param>
 
 <returns>Returns specified power of 2 in the case if power is in the range of
 [0, 30]. Otherwise returns 0.</returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Math.VBMath.Log2(System.Int32)">
 <summary>
 Get base of binary logarithm.
 </summary>
 
 <param name="x">Source integer number.</param>
 
 <returns>Power of the number (base of binary logarithm).</returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Math.VBMath.IsPowerOf2(System.Int32)">
 <summary>
 Checks if the specified integer is power of 2.
 </summary>
 
 <param name="x">Integer number to check.</param>
 
 <returns>Returns <b>true</b> if the specified number is power of 2.
 Otherwise returns <b>false</b>.</returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Math.VBMath.Sum(System.Collections.Generic.IEnumerable{System.Boolean})">
 <summary>
 Logical true values are regarded as one, false values as zero. For historical reasons, NULL is accepted and treated as if it were integer(0).
 </summary>
 <param name="bc"></param>
 <returns></returns>
 <remarks></remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.Math.VBMath.Sum(System.ValueTuple{System.Double,System.Double})">
 <summary>
 Sum all tuple members
 </summary>
 <param name="t"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.VBMath.Sum(System.ValueTuple{System.Double,System.Double,System.Double})">
 <summary>
 Sum all tuple members
 </summary>
 <param name="t"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.VBMath.Sum(System.ValueTuple{System.Double,System.Double,System.Double,System.Double})">
 <summary>
 Sum all tuple members
 </summary>
 <param name="t"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.VBMath.Sum(System.ValueTuple{System.Double,System.Double,System.Double,System.Double,System.Double})">
 <summary>
 Sum all tuple members
 </summary>
 <param name="t"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.VBMath.ProductALL(System.Collections.Generic.IEnumerable{System.Double})">
 <summary>
 计算出所有的数的乘积
 </summary>
 <param name="[in]"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.VBMath.ProductALL(System.Collections.Generic.IEnumerable{System.Int32})">
 <summary>
 计算出所有的数的乘积
 </summary>
 <param name="[in]"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Math.VBMath.ProductALL(System.Collections.Generic.IEnumerable{System.Int64})">
 <summary>
 计算出所有的数的乘积
 </summary>
 <param name="[in]"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Math.VBMath.SD(System.Collections.Generic.IEnumerable{System.Double},System.Boolean)">
 <summary>
 ## Standard Deviation
 
 In statistics, the standard deviation (SD, also represented by the Greek letter sigma σ or the Latin letter s) 
 is a measure that is used to quantify the amount of variation or dispersion of a set of data values. A low 
 standard deviation indicates that the data points tend to be close to the mean (also called the expected value) 
 of the set, while a high standard deviation indicates that the data points are spread out over a wider range of 
 values.
 
 > https://en.wikipedia.org/wiki/Standard_deviation
 </summary>
 <returns></returns>
 <remarks></remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.Math.VBMath.SD(System.Collections.Generic.IEnumerable{System.Int32})">
 <summary>
 Standard Deviation
 </summary>
 <returns></returns>
 <remarks></remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.Math.VBMath.SD(System.Collections.Generic.IEnumerable{System.Int64})">
 <summary>
 Standard Deviation
 </summary>
 <returns></returns>
 <remarks></remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.Math.VBMath.SD(System.Collections.Generic.IEnumerable{System.Single})">
 <summary>
 Standard Deviation
 </summary>
 <returns></returns>
 <remarks></remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.Math.VBMath.RMS(System.Collections.Generic.IEnumerable{System.Double})">
 <summary>
 Root mean square.
 </summary>
 <returns></returns>
 <remarks>
 (均方根)
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.VBMath.RSD(System.Collections.Generic.IEnumerable{System.Double})">
 <summary>
 ## relative standard deviation
 
 Relative standard deviation is a common formula 
 used in statistics and probability theory to determine
 a standardized measure of the ratio of the standard
 deviation to the mean. This formula is useful in
 various situations including when comparing your 
 own data to other related data and in financial 
 settings such as the stock market.
 
 Relative standard deviation, which also may be referred 
 to as RSD or the coefficient of variation, is used 
 to determine if the standard deviation of a set of 
 data is small or large when compared to the mean.
 In other words, the relative standard deviation can
 tell you how precise the average of your results is.
 This formula is most frequently used in chemistry, 
 statistics and other math-related settings but can 
 also be used in the business world when assessing
 finances and the stock market.
 
 The relative standard deviation Of a Set Of data can be
 depicted As either a percentage Or As a number. The 
 higher the relative standard deviation, the more spread 
 out the results are from the mean Of the data. On the
 other hand, a lower relative standard deviation means 
 that the measurement Of data Is more precise.
 
 (``相对标准偏差（RSD）= 标准偏差（SD）/ 计算结果的算术平均值（X）* 100%``)
 </summary>
 <param name="data"></param>
 <returns></returns>
 <remarks>
 RSD is also an alias of ``CV%``
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.VBMath.PoissonPDF(System.Int32,System.Double)">
 <summary>
 Returns the PDF value at x for the specified 
 Poisson distribution.
 </summary>
 
</member>
<member name="T:Microsoft.VisualBasic.Math.INumericMatrix">
 <summary>
 an abstract model of the numeric matrix object
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.INumericMatrix.ArrayPack(System.Boolean)">
 <summary>Copy the internal two-dimensional array.</summary>
 <returns>Two-dimensional array copy of matrix elements.
 </returns>
</member>
<member name="T:Microsoft.VisualBasic.Math.MatrixExtensions">
 <summary>
 This class contains methods that perform mathematical operations on matrices.
 Operations currently supported are matrix multiplication and scalar multiplication.
 
 @author Jean-Francois Larcher-Pelland
 </summary>
 
</member>
<member name="M:Microsoft.VisualBasic.Math.MatrixExtensions.MatrixMult(System.Double[][],System.Double[][])">
 <summary>
 Multiplies matrices <i>a</i> and <i>b</i> using the brute-force algorithm.
 </summary>
 <param name="a"> The matrix on the left. </param>
 <param name="b"> The matrix on the right. </param>
 <returns> The product of the two matrices. </returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.MatrixExtensions.ScalarMult(System.Double[][],System.Double)">
 <summary>
 Performs a scalar multiplication on matrix <i>a</i> using scalar value <i>b</i>.
 </summary>
 <param name="a"> The matrix to be multiplied. </param>
 <param name="b"> Scalar value used in the multiplication. </param>
 <returns> The result of the scalar multiplication. </returns>
</member>
<member name="T:Microsoft.VisualBasic.Math.NumberEqualityComparer">
 <summary>
 当两个数的误差值的绝对值小于阈值的时候认为两个数字相等
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Math.NumberEqualityComparer.DeltaTolerance">
 <summary>
 the threshold value
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.NumberEqualityComparer.#ctor(System.Double)">
 <summary>
 the threshold value
 </summary>
 <param name="tolerance"></param>
</member>
<member name="T:Microsoft.VisualBasic.Math.NumberGroups">
 <summary>
 Simple number vector grouping
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.NumberGroups.diff(System.Double[])">
 <summary>
 ### Lagged Differences
 
 Returns suitably lagged and iterated differences.
 </summary>
 <param name="x">
 a numeric vector Or matrix containing the values To be differenced.
 </param>
 <returns>
 for input vector element size is zero or else only one element inside, 
 a empty diff vector will be generated from this function
 </returns>
 <remarks>
 x1 - x0
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.NumberGroups.Min``1(System.Collections.Generic.IEnumerable{``0},``0)">
 <summary>
 计算出<paramref name="target"/>集合之众的与<paramref name="v"/>距离最小的元素
 （或者说是匹配度最高的元素）
 </summary>
 <typeparam name="T"></typeparam>
 <param name="target"></param>
 <param name="v"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.NumberGroups.BinarySearch(System.Collections.Generic.IEnumerable{System.Double},System.Double,Microsoft.VisualBasic.ComponentModel.DataStructures.GenericLambda{System.Double}.IEquals)">
 <summary>
 Returns ``-1`` means no search result
 </summary>
 <param name="seq"></param>
 <param name="target"></param>
 <param name="equals"></param>
 <returns>
 gets the index value of the <paramref name="target"/> number inside 
 the input source <paramref name="seq"/> where we find it.
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.NumberGroups.GroupByTree(System.Collections.Generic.IEnumerable{System.Double[]},System.Double)">
 <summary>
 implements the group by function via AVLTree for large scale data
 </summary>
 <param name="source"></param>
 <param name="offset"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.NumberGroups.GroupBy(System.Collections.Generic.IEnumerable{System.Double},System.Double)">
 <summary>
 将一维的数据按照一定的偏移量分组输出
 </summary>
 <param name="source"></param>
 <param name="offset"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.NumberGroups.GroupBy``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double},Microsoft.VisualBasic.ComponentModel.DataStructures.GenericLambda{System.Double}.IEquals)">
 <summary>
 
 </summary>
 <param name="source"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.NumberGroups.GroupByParallel``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double},Microsoft.VisualBasic.ComponentModel.DataStructures.GenericLambda{System.Double}.IEquals,System.Int32)">
 <summary>
 将一维的数据按照一定的偏移量分组输出
 </summary>
 <param name="source"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.NumberGroups.GroupBy``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double},System.Double)">
 <summary>
 将一维的数据按照一定的偏移量分组输出
 </summary>
 <param name="source"></param>
 <param name="offsets"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Math.NumberGroups.GroupBy(System.Collections.Generic.IEnumerable{System.Double},Microsoft.VisualBasic.ComponentModel.DataStructures.GenericLambda{System.Double}.IEquals)">
 <summary>
 将一维的数据按照一定的偏移量分组输出
 </summary>
 <param name="numbers"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.NumberGroups.GroupBy``1(System.Collections.Generic.IEnumerable{``0},Microsoft.VisualBasic.ComponentModel.DataStructures.GenericLambda{System.Double}.IEquals)">
 <summary>
 将一维的数据按照一定的偏移量分组输出
 </summary>
 <param name="numbers"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.NumberGroups.Groups``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
 <summary>
 按照相邻的两个数值是否在offset区间内来进行简单的分组操作
 </summary>
 <typeparam name="TagObject"></typeparam>
 <param name="source"></param>
 <param name="offset"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Math.IVector">
 <summary>
 The numeric vector model
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Math.IVector.Data">
 <summary>
 the vector data
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.NumeralSystem.Ulp(System.Double)">
 <summary>
 Unit in the Last Place, ulp
 </summary>
 <param name="value"></param>
 <returns></returns>
 <remarks>
 Math.ulp 是一个用于获取一个数的最小精度单位（Unit in the Last Place，ulp）的方法。
 这个方法在浮点数运算中非常有用，特别是在需要考虑数值精度和误差分析的场景。
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.NumeralSystem.TranslateDecimal(System.Int32,System.Char[])">
 <summary>
 A helper function for translate decimal number to the number of another kind of custom number system
 </summary>
 <param name="d"></param>
 <param name="alphabets"></param>
 <returns></returns>
 <remarks>
 将十进制数转换到另外的一个数进制
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.NumeralSystem.FindNthRoot(System.Double,System.Int32,System.Double)">
 <summary>
 Method which finds root of specific degree of number.
 </summary>
 <param name="number">Source number.</param>
 <param name="degree">Degree of root.</param>
 <param name="precision">Precision with which the calculations are performed. value should be in range (0,1).</param>
 <returns>Root of number.</returns>
 <exception cref="T:System.ArgumentOutOfRangeException">Thrown when values of degree or precision are out of range.</exception>
 <exception cref="T:System.ArgumentException">Thrown when root's degree is even for calculation with negative numbers.</exception>
 <remarks>
 开n次方
 </remarks>
</member>
<member name="T:Microsoft.VisualBasic.Math.Parallel.MatrixDotProduct">
 <summary>
 module for run matrix dot product in parallel
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Math.Percentage">
 <summary>
 分数，百分比
 </summary>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.Math.Percentage.Numerator">
 <summary>
 分子
 </summary>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.Math.Percentage.Denominator">
 <summary>
 分母
 </summary>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.Math.Percentage.Value">
 <summary>
 <see cref="P:Microsoft.VisualBasic.Math.Percentage.Numerator"></see>/<see cref="P:Microsoft.VisualBasic.Math.Percentage.Denominator"></see>
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.Percentage.#ctor(System.Double,System.Double)">
 <summary>
 <paramref name="n"/> / <paramref name="d"/>
 </summary>
 <param name="n"></param>
 <param name="d"></param>
</member>
<member name="M:Microsoft.VisualBasic.Math.Percentage.TryParse(System.String)">
 <summary>
 
 </summary>
 <param name="Text">``\d+[/]\d+ \(\d+[%]\)``</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.Math.Permutator">
 <summary>
 This class provides a method to randomize the contents of an array
 @author Salindor. Modified by O.Gonzalez-Recio in January 2010, to make 'temp' to be a list, instead a vector
 
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.Permutator.Permute(System.Int32[])">
 <summary>
 This function does all the work.  It randomizes the array into the new
 array it returns.  Granted if you were using this for real, you would
 most likely want to use something other than the default java randomizer.
 or you would at least want to seed it properly </summary>
 <param name="a"> the original array </param>
 <returns> the new shuffled array </returns>
</member>
<member name="T:Microsoft.VisualBasic.Math.PreciseRandom">
 <summary>
 主要针对的是非常小的小数（仅适用于Positive Number）
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Math.PreciseRandom.Epsilon">
 <summary>
 4.94065645841247E-324
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.PreciseRandom.#ctor(System.Single,System.Single,Microsoft.VisualBasic.Math.IRandomSeeds)">
 <summary>
 最小的精度为``<see cref="F:System.Double.Epsilon"/>=4.94065645841247E-324``
 </summary>
 <param name="digitMin">``10^?``</param>
 <param name="digitMax">``10^?``</param>
</member>
<member name="M:Microsoft.VisualBasic.Math.PreciseRandom.#ctor(System.Double,System.Double,Microsoft.VisualBasic.Math.IRandomSeeds)">
 <summary>
 
 </summary>
 <param name="from">最小的精度为<see cref="F:System.Double.Epsilon"/></param>
 <param name="[to]"></param>
</member>
<member name="M:Microsoft.VisualBasic.Math.PreciseRandom.NextNumber">
 <summary>
 获取一个在给定的小数位范围内的随机的数
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.PreciseRandom.NextDouble(Microsoft.VisualBasic.ComponentModel.Ranges.Model.DoubleRange)">
 <summary>
 这个方法可能只适用于很小的数，例如1e-100到1e-10这样子的
 </summary>
 <param name="range"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Math.IValueProvider">
 <summary>
 Generates a random number.
 (事实上这个函数指针的功能仅仅是返回一个实数，所以这里不仅仅是局限于随机数，也可以是一个固定值的实数)
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Math.IRandomSeeds">
 <summary>
 Tells the function how to generates a new random seed?
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Math.RandomExtensions">
 <summary>
 Some extension methods for <see cref="T:System.Random"/> for creating a few more kinds of random stuff.
 </summary>
 <remarks>Imports from https://github.com/rvs76/superbest-random.git </remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.Math.RandomExtensions.Next(System.Int32)">
 <summary>
 Returns a non-negative random integer that is less than the specified maximum.
 </summary>
 <param name="upbound">The exclusive upper bound of the random number to be generated. maxValue must
 be greater than or equal to 0.</param>
 <returns>A 32-bit signed integer that is greater than or equal to 0, and less than maxValue;
 that is, the range of return values ordinarily includes 0 but not maxValue. However,
 if maxValue equals 0, maxValue is returned.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.RandomExtensions.NextNumber">
 <summary>
 Returns a non-negative random <see cref="T:System.Int32"/>.
 </summary>
 <returns>
 A 32-bit signed integer that is greater than or equal to 0 and less than <see cref="F:System.Int32.MaxValue"/>.
 </returns>
 <remarks>
 <see cref="M:System.Random.Next"/>
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.RandomExtensions.Seed">
 <summary>
 A number used to calculate a starting value for the pseudo-random number sequence.
 If a negative number is specified, the absolute value of the number is used.
 </summary>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Math.RandomExtensions.SetSeed(System.Int32)">
 <summary>
 re-initialize of the random <see cref="P:Microsoft.VisualBasic.Math.RandomExtensions.seeds"/> object
 </summary>
 <param name="seed"></param>
 
</member>
<member name="M:Microsoft.VisualBasic.Math.RandomExtensions.randf(System.Double,System.Double)">
 <summary>
 返回<paramref name="min"/>到<paramref name="max"/>区间之内的一个和实数
 </summary>
 <param name="min"></param>
 <param name="max"></param>
 <returns></returns>
 
</member>
<member name="P:Microsoft.VisualBasic.Math.RandomExtensions.seeds">
 <summary>
 一般来说，在获取随机数的时候并不推荐重新构建一个新的随机数发生器
 可以在全局范围内重复使用这个随机数发生器
 不同的代码重复使用这个种子，这样子可以尽量的模拟出真正的随机行为
 </summary>
 <returns>
 A thread safe random value generator. No needs for synclock
 </returns>
 <remarks>
 the random seed value of this property value can 
 be reset by the <see cref="M:Microsoft.VisualBasic.Math.RandomExtensions.SetSeed(System.Int32)"/>
 method.
 </remarks>
</member>
<member name="F:Microsoft.VisualBasic.Math.RandomExtensions._seeds">
 <summary>
 make a new random generator for all thread
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.RandomExtensions.NextDouble">
 <summary>
 Returns a random floating-point number that is greater than or equal to 0.0,
 and less than 1.0.
 </summary>
 <returns>
 A double-precision floating point number that is greater than or equal to 0.0,
 and less than 1.0.
 </returns>
 <remarks>
 <see cref="M:System.Random.NextDouble"/>, GetNextUniformNumber()
 </remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.Math.RandomExtensions.NextInteger(System.Int32)">
 <summary>
 Returns a non-negative random integer that is less than the specified maximum.
 </summary>
 <param name="upper">
 The exclusive upper bound of the random number to be generated. maxValue must
 be greater than or equal to 0.</param>
 <returns>
 A 32-bit signed integer that is greater than or equal to 0, and less than maxValue;
 that is, the range of return values ordinarily includes 0 but not maxValue. However,
 if maxValue equals 0, maxValue is returned.
 </returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Math.RandomExtensions.NextInteger(System.Int32,System.Int32)">
 <summary>
 Returns a random integer that is within a specified range.
 </summary>
 <param name="min">The inclusive lower bound of the random number returned.</param>
 <param name="max">The exclusive upper bound of the random number returned. maxValue must be greater
 than or equal to minValue.</param>
 <returns>A 32-bit signed integer greater than or equal to minValue and less than maxValue;
 that is, the range of return values includes minValue but not maxValue. If minValue
 equals maxValue, minValue is returned.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.RandomExtensions.GetNextBetween(System.Random,System.Double,System.Double)">
 <summary>
 Returns a random floating-point number that is greater than or equal to min of the range,
 and less than the max of the range.
 </summary>
 <param name="r"></param>
 <param name="min#"></param>
 <param name="max#"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.RandomExtensions.GetRandomValue(Microsoft.VisualBasic.ComponentModel.Ranges.Model.DoubleRange)">
 <summary>
 Returns a random floating-point number that is greater than or equal to min of the range,
 and less than the max of the range.
 </summary>
 <param name="rng"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.RandomExtensions.NextDouble(System.Double,System.Double)">
 <summary>
 Returns a random floating-point number that is greater than or equal to min of the range,
 and less than the max of the range.
 </summary>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Math.RandomExtensions.NextDouble(System.Random,Microsoft.VisualBasic.ComponentModel.Ranges.Model.DoubleRange)">
 <summary>
 Returns a random floating-point number that is greater than or equal to min of the range,
 and less than the max of the range.
 </summary>
 <param name="rnd"></param>
 <param name="range"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Math.RandomExtensions.ExponentialRandomNumbers(System.Double,System.Int32)">
 <summary>
 np.random.exponential
 </summary>
 <param name="lambda"></param>
 <param name="size"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.RandomExtensions.NextGaussian(System.Random,System.Double,System.Double)">
 <summary>
 Generates normally distributed numbers. Each operation 
 makes two Gaussians for the price of one, and apparently 
 they can be cached or something for better performance, 
 but who cares.
 </summary>
 <param name="r"></param>
 <param name = "mu">Mean of the distribution</param>
 <param name = "sigma">Standard deviation</param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Math.RandomExtensions.NextTriangular(System.Random,System.Double,System.Double,System.Double)">
 <summary>
 Generates values from a triangular distribution.
 </summary>
 <remarks>
 See http://en.wikipedia.org/wiki/Triangular_distribution for a description of the triangular 
 probability distribution and the algorithm for generating one.
 </remarks>
 <param name="r"></param>
 <param name = "a">Minimum</param>
 <param name = "b">Maximum</param>
 <param name = "c">Mode (most frequent value)</param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Math.RandomExtensions.NextBoolean(System.Random)">
 <summary>
 Equally likely to return true or false. Uses <see cref="M:System.Random.Next(System.Int32)"/>.
 </summary>
 <returns></returns>
 <remarks>
 ```vbnet
 1 > 0 OR 0 > 0
 ```
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.RandomExtensions.Shuffle``1(System.Random,System.Collections.Generic.List{``0}@)">
 <summary>
 Shuffles a list in O(n) time by using the Fisher-Yates/Knuth algorithm.
 </summary>
 <param name="r"></param>
 <param name = "list"></param>
</member>
<member name="M:Microsoft.VisualBasic.Math.RandomExtensions.Shuffle``1(System.Random,``0[]@,System.Nullable{System.Int32})">
 <summary>
 Shuffles a list in O(n) time by using the Fisher-Yates/Knuth algorithm.
 </summary>
 <param name="r"></param>
 <param name = "list"></param>
</member>
<member name="M:Microsoft.VisualBasic.Math.RandomExtensions.Shuffle``1(System.Collections.Generic.List{``0}@)">
 <summary>
 makes the element inside the input list random orders
 </summary>
 <typeparam name="T"></typeparam>
 <param name="list"></param>
</member>
<member name="M:Microsoft.VisualBasic.Math.RandomExtensions.Shuffle``1(``0[]@)">
 <summary>
 makes the element inside the input list random orders
 </summary>
 <typeparam name="T"></typeparam>
 <param name="list"></param>
</member>
<member name="M:Microsoft.VisualBasic.Math.RandomExtensions.Shuffle(System.Random,System.Collections.IList@)">
 <summary>
 Shuffles a list in O(n) time by using the Fisher-Yates/Knuth algorithm.
 </summary>
 <param name="r"></param>
 <param name = "list"></param>
 
</member>
<member name="M:Microsoft.VisualBasic.Math.RandomExtensions.Permutation(System.Random,System.Int32,System.Int32)">
 <summary>
 Returns n unique random numbers in the range ``[1, n]``, inclusive. 
 This is equivalent to getting the first n numbers of some random permutation of the sequential 
 numbers from 1 to max. 
 
 Runs in ``O(k^2)`` time.
 </summary>
 <param name="rand"></param>
 <param name="n">Maximum number possible.(最大值)</param>
 <param name="k">How many numbers to return.(返回的数据的数目)</param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Math.ScaleMaps.TrimRanges(System.Double[],System.Double,System.Double)">
 <summary>
 Trims the data ranges, 
 if n in <paramref name="Dbl"/> vector is less than <paramref name="min"/>, then set n = min;
 else if n is greater than <paramref name="max"/>, then set n value to max, 
 else do nothing.
 </summary>
 <param name="Dbl"></param>
 <param name="min"></param>
 <param name="max"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.ScaleMaps.GenerateMapping(System.Collections.Generic.IEnumerable{System.Double},System.Int32,System.Int32)">
 <summary>
 Linear mappings the vector elements in to another scale within specifc range from parameter <paramref name="Level"></paramref>.
 (如果每一个数值之间都是相同的大小，则返回原始数据，因为最大值与最小值的差为0，无法进行映射的创建（会出现除0的错误）)
 </summary>
 <param name="data">Your input numeric vector.</param>
 <param name="Level">The scaler range.</param>
 <returns></returns>
 <remarks>为了要保持顺序，不能够使用并行拓展</remarks>
 <param name="offset">
 The default scaler range output is [1, <paramref name="Level"></paramref>], but you can modify this parameter 
 value for moving the range to [<paramref name="offset"></paramref>, <paramref name="Level"></paramref> + <paramref name="offset"></paramref>].
 (默认是 [1, <paramref name="Level"></paramref>]，
 当offset的值为0的时候，则为[0, <paramref name="Level"></paramref>-1]，
 当然这个参数也可以使其他的值)
 </param>
</member>
<member name="M:Microsoft.VisualBasic.Math.ScaleMaps.Log2Ranks(System.Collections.Generic.IEnumerable{System.Double},System.Int32)">
 <summary>
 apply of the log transform of the data and then run linear scale
 </summary>
 <param name="data"></param>
 <param name="Level"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.ScaleMaps.GenerateMapping(System.Collections.Generic.IEnumerable{System.Int32},System.Int32,System.Int32)">
 <summary>
 如果每一个数值之间都是相同的大小，则返回原始数据，因为最大值与最小值的差为0，无法进行映射的创建（会出现除0的错误）
 </summary>
 <param name="data"></param>
 <returns></returns>
 <remarks>为了要保持顺序，不能够使用并行拓展</remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.Math.ScaleMaps.Scale(System.Collections.Generic.IEnumerable{System.Double},System.Boolean,System.Boolean)">
 <summary>
 Function centers and/or scales the columns of a numeric matrix.
 </summary>
 <param name="data">numeric matrix</param>
 <param name="center">either a logical value or a numeric vector of length equal to the number of columns of x</param>
 <param name="isScale">either a logical value or a numeric vector of length equal to the number of columns of x</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.SIMD.Add.f64_op_add_f64_scalar(System.Double[],System.Double)">
 <summary>
 <paramref name="v1"/> + <paramref name="v2"/> or 
 <paramref name="v2"/> + <paramref name="v1"/>
 </summary>
 <param name="v1"></param>
 <param name="v2"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.SIMD.Add.f64_op_add_f64(System.Double[],System.Double[])">
 <summary>
 data unchecked add two f64 vector
 </summary>
 <param name="v1"></param>
 <param name="v2"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.SIMD.Divide.f64_op_divide_f64_scalar(System.Double[],System.Double)">
 <summary>
 <paramref name="v1"/> / <paramref name="v2"/>
 </summary>
 <param name="v1"></param>
 <param name="v2"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.SIMD.Divide.f64_op_divide_f64(System.Double[],System.Double[])">
 <summary>
 v1 / v2
 </summary>
 <param name="v1"></param>
 <param name="v2"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Math.SIMD.Exponent">
 <summary>
 implements the power operator in VB
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.SIMD.Exponent.f64_scalar_op_exponent_f64(System.Double,System.Double[])">
 <summary>
 <paramref name="v1"/> ^ <paramref name="v2"/>
 </summary>
 <param name="v1"></param>
 <param name="v2"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.SIMD.Exponent.f64_op_exponent_f64_scalar(System.Double[],System.Double)">
 <summary>
 <paramref name="v1"/> ^ <paramref name="v2"/>
 </summary>
 <param name="v1"></param>
 <param name="v2"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.SIMD.Exponent.f64_op_exponent_f64(System.Double[],System.Double[])">
 <summary>
 <paramref name="v1"/> ^ <paramref name="v2"/>
 </summary>
 <param name="v1"></param>
 <param name="v2"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.SIMD.Exponent.f64_exp(System.Double[])">
 <summary>
 exp(<paramref name="v"/>)
 </summary>
 <param name="v"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.SIMD.Multiply.f32_scalar_op_multiply_f32(System.Single,System.Single[])">
 <summary>
 <paramref name="v1"/> * <paramref name="v2"/> or 
 <paramref name="v2"/> * <paramref name="v1"/>
 </summary>
 <param name="v1"></param>
 <param name="v2"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.SIMD.Multiply.f64_scalar_op_multiply_f64(System.Double,System.Double[])">
 <summary>
 <paramref name="v1"/> * <paramref name="v2"/> or 
 <paramref name="v2"/> * <paramref name="v1"/>
 </summary>
 <param name="v1"></param>
 <param name="v2"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.SIMD.Multiply.f32_op_multiply_f32(System.Single[],System.Single[])">
 <summary>
 <paramref name="v1"/> * <paramref name="v2"/> or 
 <paramref name="v2"/> * <paramref name="v1"/>
 </summary>
 <param name="v1"></param>
 <param name="v2"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.SIMD.Multiply.f64_op_multiply_f64(System.Double[],System.Double[])">
 <summary>
 <paramref name="v1"/> * <paramref name="v2"/> or 
 <paramref name="v2"/> * <paramref name="v1"/>
 </summary>
 <param name="v1"></param>
 <param name="v2"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.SIMD.Subtract.f64_scalar_op_subtract_f64(System.Double,System.Double[])">
 <summary>
 <paramref name="v1"/> - <paramref name="v2"/>
 </summary>
 <param name="v1"></param>
 <param name="v2"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.SIMD.Subtract.f64_op_subtract_f64(System.Double[],System.Double[])">
 <summary>
 <paramref name="v1"/> - <paramref name="v2"/>
 </summary>
 <param name="v1"></param>
 <param name="v2"></param>
 <returns></returns>
</member>
<member name="F:Microsoft.VisualBasic.Math.SIMD.SIMDConfiguration.disable">
 <summary>
 no SIMD
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Math.SIMD.SIMDConfiguration.enable">
 <summary>
 use the new .netcore SIMD supports from ``System.Runtime.Intrinsics.X86``
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Math.SIMD.SIMDConfiguration.legacy">
 <summary>
 use the legacy supports of the SIMD from ``System.Numerics``
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Math.SIMD.SIMDConfiguration.auto">
 <summary>
 disable or SIMD **legacy** mode based on the vector size
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Math.SIMD.SIMDEnvironment">
 <summary>
 SIMD(Single Instruction Multiple Data)即单指令流多数据流，
 是一种采用一个控制器来控制多个处理器，同时对一组数据（又称“数据
 向量”）中的每一个分别执行相同的操作从而实现空间上的并行性的技术。
 简单来说就是一个指令能够同时处理多个数据。
 </summary>
 <remarks>
 在这个模块中的代码都不会进行安全检查，默认都是符合计算条件的
 </remarks>
</member>
<member name="P:Microsoft.VisualBasic.Math.SIMD.SIMDEnvironment.config">
 <summary>
 This option only works for .NET core runtime
 </summary>
 <returns></returns>
</member>
<member name="F:Microsoft.VisualBasic.Math.SIMD.SIMDEnvironment.countDouble">
 <summary>
 Vector(Of <see cref="T:System.Double"/>).Count
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Math.SIMD.SIMDEnvironment.countFloat">
 <summary>
 Vector(Of <see cref="T:System.Single"/>).Count
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Math.SIMD.SIMDEnvironment.countInteger">
 <summary>
 Vector(Of <see cref="T:System.Int32"/>).Count
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Math.Statistics.DataSample`1">
 <summary>
 Numeric value statics property.
 </summary>
 <typeparam name="T"></typeparam>
</member>
<member name="P:Microsoft.VisualBasic.Math.Statistics.DataSample`1.Mean">
 <summary>
 The sample average
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Math.Statistics.DataSample`1.SampleSize">
 <summary>
 The sample size
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Statistics.GroupBins`1.GroupBy(System.Collections.Generic.IEnumerable{`0})">
 <summary>
 将一维的数据按照一定的偏移量分组输出
 </summary>
 <param name="source"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Math.Statistics.IStatPvalue">
 <summary>
 a general abstract object model for statistics result which 
 contains p value information
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Math.Statistics.IStatPvalue.pValue">
 <summary>
 p value of current sample statistics result
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Math.Statistics.Linq.CPOLLicense">
 <summary>
 http://www.codeproject.com/Articles/42492/Using-LINQ-to-Calculate-Basic-Statistics
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.Statistics.Linq.EnumerableStatsCovariance.Covariance(System.Collections.Generic.IEnumerable{System.Nullable{System.Decimal}},System.Collections.Generic.IEnumerable{System.Nullable{System.Decimal}})">
 <summary>
 Computes the Covariance of a sequence of nullable System.Decimal values.
 </summary>
 <param name="source">A sequence of nullable System.Decimal values to calculate the Covariance of.</param>
 <param name="other"></param>
 <returns>The Covariance of the sequence of values, or null if the source sequence is
 empty or contains only values that are null.</returns>
</member>
<member name="T:Microsoft.VisualBasic.Math.Statistics.Linq.EnumerableStatsMedian">
 <summary>
 中位数计算拓展
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.Statistics.Linq.EnumerableStatsMedian.Median(System.Collections.Generic.IEnumerable{System.Nullable{System.Decimal}})">
 <summary>
 Computes the Median of a sequence of nullable System.Decimal values.
 </summary>
 <param name="source">A sequence of nullable System.Decimal values to calculate the Median of.</param>
 <returns>The Median of the sequence of values, or null if the source sequence is
 empty or contains only values that are null.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Statistics.Linq.EnumerableStatsMedian.Median(System.Collections.Generic.IEnumerable{System.Decimal})">
 <summary>
 Computes the Median of a sequence of System.Decimal values.
 </summary>
 <param name="source">A sequence of System.Decimal values to calculate the Median of.</param>
 <returns>
 The Median of the sequence of values.
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Statistics.Linq.EnumerableStatsMedian.Median(System.Collections.Generic.IEnumerable{System.Double})">
 <summary>
 Computes the Median of a sequence of <see cref="T:System.Double"/> values.
 </summary>
 <param name="source">
 A sequence of <see cref="T:System.Double"/> values to calculate the Median of.
 </param>
 <returns>The Median of the sequence of values.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Statistics.Linq.EnumerableStatsPearson.Pearson(System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
 <summary>
 Computes the Pearson of a sequence of System.Double values.
 </summary>
 <param name="source">A sequence of System.Double values to calculate the Pearson of.</param>
 <param name="other"></param>
 <returns>The Pearson of the sequence of values.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Statistics.Linq.EnumerableStatsPearson.Pearson(System.Collections.Generic.IEnumerable{System.Nullable{System.Single}},System.Collections.Generic.IEnumerable{System.Nullable{System.Single}})">
 <summary>
 Computes the Pearson of a sequence of nullable System.Single values.
 </summary>
 <param name="source">A sequence of nullable System.Single values to calculate the Pearson of.</param>
 <param name="other"></param>
 <returns>The Pearson of the sequence of values, or null if the source sequence is
 empty or contains only values that are null.</returns>
</member>
<member name="T:Microsoft.VisualBasic.Math.Statistics.Linq.EnumerableStatsVariance">
 <summary>
 make sqrt of the variance result will be the standard deviation
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Math.Trigonometric">
 <summary>
 三角函数拓展模块
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Math.Trigonometric.AtanPrecise">
 <summary>
 通过这个参数来控制计算精度，这个参数值越大，计算精度越高
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.Trigonometric.Atn(System.Double)">
 <summary>
 Taylor Atan
 </summary>
 <param name="x"></param>
 <returns></returns>
 <remarks>Atan测试没有问题</remarks>>
</member>
<member name="M:Microsoft.VisualBasic.Math.Trigonometric.ToCartesianPoint(System.ValueTuple{System.Double,System.Single},System.Boolean,System.Double,System.Double)">
 <summary>
 Polar to cartesian coordinate system point.(将极坐标转换为笛卡尔坐标系直角坐标系)
 </summary>
 <param name="polar">(半径, 角度)</param>
 <param name="fromDegree">alpha角度参数是否是度为单位，默认是真，即函数会在这里自动转换为弧度</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Trigonometric.GetAngleVector(System.Single,System.Double)">
 <summary>
 
 </summary>
 <param name="radian">``0 -> 2*<see cref="F:System.Math.PI"/>``</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Trigonometric.Angle(System.Drawing.PointF)">
 <summary>
 计算结果为角度
 </summary>
 <param name="p"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Math.Trigonometric.Distance(System.Drawing.Point,System.Drawing.Point)">
 <summary>
 Calculate the Euclidean distance between two points.
 </summary>
 <param name="a"></param>
 <param name="b"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Trigonometric.Distance(System.Drawing.PointF,System.Drawing.PointF)">
 <summary>
 Calculate the Euclidean distance between two points.
 </summary>
 <param name="a"></param>
 <param name="b"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Trigonometric.GetAngle(System.Drawing.Point,System.Drawing.Point)">
 <summary>
 计算两个点之间的线段的夹角
 </summary>
 <param name="p1"></param>
 <param name="p2"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Math.Trigonometric.MovePoint(System.Drawing.PointF,System.Double,System.Int32)">
 <summary>
 以当前的点为圆心，向<paramref name="angle"/>方向移动给定的距离
 </summary>
 <param name="distance#"></param>
 <param name="angle#"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Trigonometric.ToRadians(System.Double)">
 <summary>
 Converts an angle measured in degrees to an approximately
 equivalent angle measured in radians.  The conversion from
 degrees to radians is generally inexact.
 </summary>
 <param name="angdeg">   an angle, in degrees </param>
 <returns>  the measurement of the angle {@code angdeg}
          in radians.
 @since   1.2 </returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Math.Trigonometric.ToDegrees(System.Double)">
 <summary>
 Converts an angle measured in radians to an approximately
 equivalent angle measured in degrees.  The conversion from
 radians to degrees is generally inexact; users should
 <i>not</i> expect {@code cos(toRadians(90.0))} to exactly
 equal {@code 0.0}.
 </summary>
 <param name="angrad">   an angle, in radians </param>
 <returns>  the measurement of the angle {@code angrad}
          in degrees.
 @since   1.2 </returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Math.Trigonometric.Sec(System.Double)">
 <summary>
 Secant（正割） ``Sec(X) = 1 / Cos(X)`` 
 </summary>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Trigonometric.Cosec(System.Double)">
 <summary>
 Cosecant（余割） ``Cosec(X) = 1 / Sin(X)``
 </summary>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Trigonometric.Cotan(System.Double)">
 <summary>
 Cotangent（余切） ``Cotan(X) = 1 / Tan(X)``
 </summary>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Trigonometric.Arcsin(System.Double)">
 <summary>
 Inverse Sine（反正弦）  ``Arcsin(X) = Atn(X / Sqr(-X * X + 1))``
 </summary>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Trigonometric.Arccos(System.Double)">
 <summary>
 Inverse Cosine（反余弦）  ``Arccos(X) = Atn(-X / Sqr(-X * X + 1)) + 2 * Atn(1)``
 </summary>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Trigonometric.Arcsec(System.Double)">
 <summary>
 Inverse Secant（反正割）  ``Arcsec(X) = Atn(X / Sqr(X * X - 1)) + Sgn((X) - 1) * (2 * Atn(1))``
 </summary>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Trigonometric.Arccosec(System.Double)">
 <summary>
 Inverse Cosecant（反余割）  ``Arccosec(X) = Atn(X / Sqr(X * X - 1)) + (Sgn(X) - 1) * (2 * Atn(1))`` 
 </summary>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Trigonometric.Arccotan(System.Double)">
 <summary>
 Inverse Cotangent（反余切）  ``Arccotan(X) = Atn(X) + 2 * Atn(1)``
 </summary>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Trigonometric.HSin(System.Double)">
 <summary>
 Hyperbolic Sine（双曲正弦）  ``HSin(X) = (Exp(X) - Exp(-X)) / 2``  
 </summary>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Trigonometric.HCos(System.Double)">
 <summary>
 Hyperbolic Cosine（双曲余弦）  ``HCos(X) = (Exp(X) + Exp(-X)) / 2`` 
 </summary>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Trigonometric.HTan(System.Double)">
 <summary>
 Hyperbolic Tangent（双曲正切）  ``HTan(X) = (Exp(X) - Exp(-X)) / (Exp(X) + Exp(-X))`` 
 </summary>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Trigonometric.HSec(System.Double)">
 <summary>
 Hyperbolic Secant（双曲正割）  ``HSec(X) = 2 / (Exp(X) + Exp(-X))`` 
 </summary>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Trigonometric.HCosec(System.Double)">
 <summary>
 Hyperbolic Cosecant（双曲余割） ``HCosec(X) = 2 / (Exp(X) - Exp(-X))`` 
 </summary>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Trigonometric.HCotan(System.Double)">
 <summary>
 Hyperbolic Cotangent（双曲余切） ``HCotan(X) = (Exp(X) + Exp(-X)) / (Exp(X) - Exp(-X))`` 
 </summary>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Trigonometric.HArcsin(System.Double)">
 <summary>
 Inverse Hyperbolic Sine（反双曲正弦） ``HArcsin(X) = Log(X + Sqr(X * X + 1))`` 
 </summary>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Trigonometric.HArccos(System.Double)">
 <summary>
 Inverse Hyperbolic Cosine（反双曲余弦） ``HArccos(X) = Log(X + Sqr(X * X - 1))`` 
 </summary>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Trigonometric.Harctan(System.Double)">
 <summary>
 Inverse Hyperbolic Tangent（反双曲正切） ``HArctan(X) = Log((1 + X) / (1 - X)) / 2`` 
 </summary>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Trigonometric.HArcsec(System.Double)">
 <summary>
 Inverse Hyperbolic Secant（反双曲正割） ``HArcsec(X) = Log((Sqr(-X * X + 1) + 1) / X)`` 
 </summary>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Trigonometric.HArccosec(System.Double)">
 <summary>
 Inverse Hyperbolic Cosecant（反双曲余割） ``HArccosec(X) = Log((Sgn(X) * Sqr(X * X + 1) + 1) / X)`` 
 </summary>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Trigonometric.HArccotan(System.Double)">
 <summary>
 Inverse Hyperbolic Cotangent（反双曲余切）  ``HArccotan(X) = Log((X + 1) / (X - 1)) / 2`` 
 </summary>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Emit.Delegates.DataObjectVector">
 <summary>
 .net clr object vector data property ``get/set`` helper.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Emit.Delegates.DataObjectVector.data">
 <summary>
 the raw input pool data
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Emit.Delegates.DataObjectVector.properties">
 <summary>
 Using for expression tree compile to delegate by using <see cref="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.SchemaMaps.BindProperty`1"/>, 
 to makes the get/set invoke faster
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Emit.Delegates.DataObjectVector.RawArray">
 <summary>
 expose the internal clr array object to public directly.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Emit.Delegates.DataObjectVector.PropertyNames">
 <summary>
 get array of the clr property name
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Emit.Delegates.DataObjectVector.Evaluate(System.String)">
 <summary>
 Evaluate the clr object property, and get vector value exports in batch 
 </summary>
 <param name="name$">The property name, using the ``nameof`` operator to get the property name!</param>
 <returns>
 get an array of the property value. the array is generic.
 </returns>
</member>
<member name="T:Microsoft.VisualBasic.Emit.Delegates.DataValue`1">
 <summary>
 .NET object collection data property value ``get/set`` helper.
 </summary>
 <remarks>
 (将属性的<see cref="M:System.Reflection.PropertyInfo.SetValue(System.Object,System.Object)"/>编译为方法调用)
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Emit.Delegates.DelegateFactory.PropertySet``1(System.Type,System.String)">
 <summary>
 为指定类型的对象实例设置属性值，返回空值表名目标属性为一个只读属性或者写过程为私有访问类型
 </summary>
 <typeparam name="TProperty"></typeparam>
 <param name="source"></param>
 <param name="propertyName"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Emit.Delegates.TypeExtensions.CanBeAssignedFrom(System.Type,System.Type)">
 <summary>
 <paramref name="source"/>能否转换至<paramref name="destination"/>类型？
 </summary>
 <param name="destination"></param>
 <param name="source"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Emit.Delegates.TypeExtensions.ImplementInterface``1(System.Type)">
 <summary>
 目标类型<paramref name="source"/>是否实现了制定的接口类型？
 </summary>
 <param name="source"></param>
 <typeparam name="interfaceType">接口类型信息</typeparam>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Emit.Delegates.TypeExtensions.ImplementInterface(System.Type,System.Type)">
 <summary>
 目标类型<paramref name="source"/>是否实现了制定的接口类型？
 </summary>
 <param name="source"></param>
 <param name="interfaceType">接口类型信息</param>
 <returns></returns>
 <remarks>
 this function has a synlock cache of the type schema test result.
 </remarks>
</member>
<member name="T:Microsoft.VisualBasic.Emit.Marshal.UnsafeCopys`1">
 <summary>
 读取原始的内存数据的操作
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <param name="destination"></param>
 <param name="startIndex"></param>
 <param name="length"></param>
</member>
<member name="T:Microsoft.VisualBasic.Emit.Marshal.UnsafeWrite`1">
 <summary>
 向原始的内存数据执行写入操作的函数指针
 </summary>
 <typeparam name="T"></typeparam>
 <param name="destination"></param>
 <param name="startIndex"></param>
 <param name="source"></param>
 <param name="length"></param>
</member>
<member name="T:Microsoft.VisualBasic.Emit.Marshal.IntPtr`1">
 <summary>
 Unmanaged Memory pointer in VisualBasic language.(内存指针)
 </summary>
 <typeparam name="T"></typeparam>
 <remarks>只不过这个对象是封装了写内存操作的</remarks>
</member>
<member name="P:Microsoft.VisualBasic.Emit.Marshal.IntPtr`1.Scan0">
 <summary>
 The position in the memory region of the first byte for read.
 </summary>
 <returns>(第一个位置)</returns>
</member>
<member name="F:Microsoft.VisualBasic.Emit.Marshal.IntPtr`1.__writeMemory">
 <summary>
 ```vbnet
 Public Delegate Sub UnsafeWrite(Of T)(destination As T(), startIndex As Integer, source As System.IntPtr, length As Integer)
 ```
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Emit.Marshal.IntPtr`1.#ctor(System.IntPtr,System.Int32,Microsoft.VisualBasic.Emit.Marshal.UnsafeCopys{`0},Microsoft.VisualBasic.Emit.Marshal.UnsafeWrite{`0})">
 <summary>
 Make data unsafe copy in this constructor function
 </summary>
 <param name="p"></param>
 <param name="chunkSize"></param>
 <param name="unsafeCopys">
 ```vbnet
 Public Sub UnsafeCopys(Of <typeparamref name="T"/>)(source As <see cref="T:System.IntPtr"/>, destination As <typeparamref name="T"/>(), startIndex As <see cref="T:System.Int32"/>, length As <see cref="T:System.Int32"/>)
 ```
 </param>
 <param name="unsafeWrite">
 ```vbnet
 Public Sub UnsafeWrite(Of <typeparamref name="T"/>)(destination As <typeparamref name="T"/>(), startIndex As <see cref="T:System.Int32"/>, source As <see cref="T:System.IntPtr"/>, length As <see cref="T:System.Int32"/>)
 ```
 </param>
</member>
<member name="M:Microsoft.VisualBasic.Emit.Marshal.IntPtr`1.#ctor(`0[]@,System.Nullable{System.IntPtr})">
 <summary>
 方便进行数组操作的
 </summary>
 <param name="raw"></param>
 <param name="p"></param>
</member>
<member name="M:Microsoft.VisualBasic.Emit.Marshal.IntPtr`1.Write">
 <summary>
 Unsafe write memory
 </summary>
 
</member>
<member name="M:Microsoft.VisualBasic.Emit.Marshal.IntPtr`1.Write(System.IntPtr)">
 <summary>
 Please be carefull by using this method, if the memory region size of <see cref="P:Microsoft.VisualBasic.Emit.Marshal.IntPtr`1.Scan0"/> 
 in this memory pointer is larger than <paramref name="des"/>, this method will caused 
 exception.
 </summary>
 <param name="des"></param>
</member>
<member name="M:Microsoft.VisualBasic.Emit.Marshal.IntPtr`1.op_Addition(Microsoft.VisualBasic.Emit.Marshal.IntPtr{`0},System.Int32)">
 <summary>
 Move forward the current position of this memory pointer <paramref name="ptr"/> by a specific step <paramref name="d"/>
 </summary>
 <param name="ptr"></param>
 <param name="d"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Emit.Marshal.IntPtr`1.op_Subtraction(Microsoft.VisualBasic.Emit.Marshal.IntPtr{`0},System.Int32)">
 <summary>
 Move backward the current position of this memory pointer <paramref name="ptr"/> by a specific step <paramref name="d"/>
 </summary>
 <param name="ptr"></param>
 <param name="d"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Emit.Marshal.IntPtr`1.Dispose">
 <summary>
 write memory and release the memory pointer
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Emit.Marshal.MarshalExtensions">
 <summary>
 
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Emit.Marshal.MarshalExtensions.MarshalAs``1(System.IntPtr,System.Int32)">
 <summary>
 Read unmanaged memory using memory pointer.
 </summary>
 <typeparam name="T">
 <see cref="T:System.Int32"/>, <see cref="T:System.Char"/>, <see cref="T:System.Int16"/>, <see cref="T:System.Int64"/>, <see cref="T:System.Single"/>, <see cref="T:System.Byte"/>, <see cref="T:Microsoft.VisualBasic.Emit.Marshal.IntPtr"/>, <see cref="T:System.Double"/>
 </typeparam>
 <param name="p"></param>
 <returns></returns>
 <remarks>
 ```vbnet
 Public Shared Sub Copy(source As IntPtr, destination() As Integer, startIndex As Integer, length As Integer)
 Public Shared Sub Copy(source As IntPtr, destination() As Char, startIndex As Integer, length As Integer)
 Public Shared Sub Copy(source As IntPtr, destination() As Short, startIndex As Integer, length As Integer)
 Public Shared Sub Copy(source As IntPtr, destination() As Long, startIndex As Integer, length As Integer)
 Public Shared Sub Copy(source As IntPtr, destination() As Single, startIndex As Integer, length As Integer)
 Public Shared Sub Copy(source As IntPtr, destination() As Byte, startIndex As Integer, length As Integer)
 Public Shared Sub Copy(source As IntPtr, destination() As IntPtr, startIndex As Integer, length As Integer)
 Public Shared Sub Copy(source As IntPtr, destination() As Double, startIndex As Integer, length As Integer)
 ```
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Emit.Marshal.MarshalExtensions.MarshalAs``1(``0[]@,System.Nullable{System.IntPtr})">
 <summary>
 方便进行数组操作的一个函数
 </summary>
 <typeparam name="T"></typeparam>
 <param name="raw"></param>
 <param name="p"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Emit.Marshal.Pointer`1">
 <summary>
 <see cref="T:System.Array"/> index helper.
 </summary>
 <typeparam name="T"></typeparam>
 <remarks>
 (在数组的索引基础上封装了数组本身)
 </remarks>
</member>
<member name="F:Microsoft.VisualBasic.Emit.Marshal.Pointer`1.buffer">
 <summary>
 the in-memory dataset
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Emit.Marshal.Pointer`1.Current">
 <summary>
 <see cref="P:Microsoft.VisualBasic.Emit.Marshal.Pointer`1.Position"/> -> its current value
 </summary>
 <returns></returns>
 <remarks>
 当前的位置是指相对于当前的位置offset为0的位置就是当前的位置
 </remarks>
</member>
<member name="P:Microsoft.VisualBasic.Emit.Marshal.Pointer`1.Length">
 <summary>
 Memory block size
 </summary>
 <returns>buffer.Length</returns>
</member>
<member name="P:Microsoft.VisualBasic.Emit.Marshal.Pointer`1.UBound">
 <summary>
 返回指定维度的一个数组，最高可用的下标。
 </summary>
 <returns>
 <see cref="T:System.Int32"/>。 指定维度的下标可以包含的最大值。 如果 Array 只有一个元素， UBound ，则返回 0。 如果 Array 不包含任何元素，例如，如果它是零长度字符串，
 UBound 返回-1。</returns>
</member>
<member name="P:Microsoft.VisualBasic.Emit.Marshal.Pointer`1.Value(System.Int32)">
 <summary>
 相对于当前的指针的位置而言的
 </summary>
 <param name="p">相对于当前的位置的offset偏移量</param>
 <returns></returns>
 <remarks>
 这个属性并不会移动当前的指针的位置
 </remarks>
</member>
<member name="P:Microsoft.VisualBasic.Emit.Marshal.Pointer`1.RawBuffer">
 <summary>
 Raw memory of this pointer
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Emit.Marshal.Pointer`1.EndRead">
 <summary>
 Is read to end?
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Emit.Marshal.Pointer`1.Position">
 <summary>
 Current read position
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Emit.Marshal.Pointer`1.#ctor(`0[]@)">
 <summary>
 
 </summary>
 <param name="array"></param>
 <remarks>
 为了保持原来的对象引用，在这里就不进行ToArray数组复制来打破这种引用关系了
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Emit.Marshal.Pointer`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
 <summary>
 Create a collection wrapper from a <paramref name="source"/> buffer.
 </summary>
 <param name="source">The collection source buffer</param>
 <remarks>
 construct an in-memory dataset
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Emit.Marshal.Pointer`1.MoveNext">
 <summary>
 Pointer move to next and then returns is <see cref="P:Microsoft.VisualBasic.Emit.Marshal.Pointer`1.EndRead"/>
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Emit.Marshal.Pointer`1.PeekNext">
 <summary>
 获取得到下一个对象而不移动当前的内部指针
 </summary>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Emit.Marshal.Pointer`1.GetLeftsAll">
 <summary>
 获取当前指针位置后面的所有元素
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Emit.Marshal.Pointer`1.op_Explicit(Microsoft.VisualBasic.Emit.Marshal.Pointer{`0})~`0">
 <summary>
 获取得到当前的元素
 </summary>
 <param name="p"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Emit.Marshal.Pointer`1.op_LeftShift(Microsoft.VisualBasic.Emit.Marshal.Pointer{`0},System.Int32)">
 <summary>
 前移<paramref name="offset"/>个单位，然后返回值，这个和Peek的作用一样，不会改变指针位置
 </summary>
 <param name="p"></param>
 <param name="offset"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Emit.Marshal.Pointer`1.op_RightShift(Microsoft.VisualBasic.Emit.Marshal.Pointer{`0},System.Int32)">
 <summary>
 后移<paramref name="offset"/>个单位，然后返回值，这个和Peek的作用一样，不会改变指针位置
 </summary>
 <param name="p"></param>
 <param name="offset"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Emit.Marshal.Pointer`1.op_Addition(Microsoft.VisualBasic.Emit.Marshal.Pointer{`0},System.Int32)">
 <summary>
 Move steps and returns this pointer
 </summary>
 <param name="ptr"></param>
 <param name="d"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Emit.Marshal.Pointer`1.op_Subtraction(Microsoft.VisualBasic.Emit.Marshal.Pointer{`0},System.Int32)">
 <summary>
 move back current read position index
 </summary>
 <param name="ptr"></param>
 <param name="d"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Emit.Marshal.Pointer`1.op_UnaryPlus(Microsoft.VisualBasic.Emit.Marshal.Pointer{`0})">
 <summary>
 Pointer move to next and then returns the previous value
 </summary>
 <param name="ptr"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Emit.Marshal.Pointer`1.op_UnaryNegation(Microsoft.VisualBasic.Emit.Marshal.Pointer{`0})">
 <summary>
 The stack trace back operator.
 (指针的位置往回移动一个单位，然后返回原来的位置的元素的值)
 </summary>
 <param name="ptr"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Emit.Marshal.Byte">
 <summary>
 Represents a pointer to an 8-bit unsigned integer array.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Emit.Marshal.Byte.#ctor(System.IntPtr,System.Int32)">
 <summary>
 Represents a pointer to an 8-bit unsigned integer array.
 </summary>
 <param name="p">The start address location of the array in the memory</param>
 <param name="chunkSize">array length</param>
 <remarks>
 Make bytes data unsafe copy from a given memory location in this constructor
 </remarks>
</member>
<member name="T:Microsoft.VisualBasic.Emit.Marshal.Span`1">
 <summary>
 A simulation of system.span in .NET 5
 </summary>
 <typeparam name="T"></typeparam>
</member>
<member name="P:Microsoft.VisualBasic.Emit.Marshal.Span`1.Length">
 <summary>
 current span view size
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Emit.Marshal.Span`1.ArrayLength">
 <summary>
 the length of the entire array
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Emit.Marshal.Span`1.OffsetEnds">
 <summary>
 the offset ends in the raw input buffer
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Emit.Parameters.ParamLogUtility">
 <summary>
 Exception is a common issue in projects. To track this exception, we use error loggers 
 which only log the exception detail and some other information if you want to. 
 But hardly do we get any idea for which input set(parameters and its values) a 
 particular method is throwing the error.
 </summary>
 <remarks>
 https://www.codeproject.com/tips/795865/log-all-parameters-that-were-passed-to-some-method
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Emit.Parameters.ParamLogUtility.AcquireOrder(System.Object[])">
 <summary>
 这个方法要求传递进来的参数的顺序要和原函数的参数的顺序一致，故而不太推荐使用这个方法
 </summary>
 <param name="parameters"></param>
</member>
<member name="T:Microsoft.VisualBasic.DynamicType">
 <summary>
 Build dynamics clr runtime type
 </summary>
 <remarks>
 https://blog.wedport.co.uk/2020/06/10/generating-c-net-core-classes-at-runtime/
 </remarks>
</member>
<member name="F:Microsoft.VisualBasic.DynamicType.PropertyInfo.Name">
 <summary>
 the property name
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.DynamicType.PropertyInfo.PropertyType">
 <summary>
 the property data type
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.DynamicType.PropertyInfo.Description">
 <summary>
 [optional] the description text for tagged the <see cref="T:System.ComponentModel.DescriptionAttribute"/> value to current property.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.DynamicType.PropertyInfo.DisplayName">
 <summary>
 [optional] the name display string for tagged the <see cref="T:System.ComponentModel.DisplayNameAttribute"/> value to current property.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.DynamicType.Create(System.String,System.String)">
 <summary>
 
 </summary>
 <param name="name">the generated clr type name</param>
 <param name="asm_module">the assembly module name</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.DynamicType.AddDisplayName(System.Reflection.Emit.PropertyBuilder,System.String)">
 <summary>
 add <see cref="T:System.ComponentModel.DisplayNameAttribute"/>
 </summary>
 <param name="propertyBuilder"></param>
 <param name="display"></param>
</member>
<member name="M:Microsoft.VisualBasic.DynamicType.AddDescription(System.Reflection.Emit.PropertyBuilder,System.String)">
 <summary>
 add <see cref="T:System.ComponentModel.DescriptionAttribute"/>
 </summary>
 <param name="propertyBuilder"></param>
 <param name="desc"></param>
</member>
<member name="M:Microsoft.VisualBasic.DynamicType.CreateValidSymbolName(System.String)">
 <summary>
 A helper function for create a valid symbol name
 </summary>
 <param name="key"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.DynamicType.Create(System.Collections.Generic.Dictionary{System.String,System.Object})">
 <summary>
 Create dynamics object in debug view
 </summary>
 <param name="metadata"></param>
 <returns></returns>
 <remarks>
 the type object that generated at here has different class guid, for create array of the dynamics type object, 
 you should create the template dynamics clr type at first, and then set property value for each data in the 
 array seperately.
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.EnumHelpers.GetAllEnumFlags``1(``0)">
 <summary>
 Get array value from the input flaged enum <paramref name="value"/>.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.EnumHelpers.GetAllEnumFlags(System.Enum,System.Type)">
 <summary>
 Get array value from the input flaged enum <paramref name="enumValue"/>.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.EnumHelpers.Enums``1">
 <summary>
 Enumerate all of the enum values in the specific <see cref="T:System.Enum"/> type data.
 (只允许枚举类型，其他的都返回空集合)
 </summary>
 <typeparam name="T">泛型类型约束只允许枚举类型，其他的都返回空集合</typeparam>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.EnumHelpers.Description(System.Enum,System.String)">
 <summary>
 Get the description data from a enum type value, if the target have no 
 <see cref="T:System.ComponentModel.DescriptionAttribute"></see> attribute data
 then function will return the string value from the ToString() function.
 </summary>
 <param name="value"></param>
 <param name="deli">
 a delimiter string for join multiple flag enumeration value theirs enum string
 </param>
 <returns>
 this function always returns a non-null string value:
 
 for thoese enum member which it has been tagged with <see cref="T:System.ComponentModel.DescriptionAttribute"/>, 
 the description data string will returns from this function;
 otherwise the string value from the enum member its toString() function will be returned.
 </returns>
 <remarks>
 this extension function has an internal cache table for get the description
 text of a given enum value
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.MethodsExtension.TryInvoke``2(System.Func{``0,``1},``0,``1)">
 <summary>
 尝试将目标对象放入到函数指针之中来运行，运行失败的时候回返回<paramref name="default"/>默认值
 </summary>
 <typeparam name="T"></typeparam>
 <typeparam name="TOut"></typeparam>
 <param name="input"></param>
 <param name="proc"></param>
 <param name="[default]"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.MethodsExtension.Invoke``1(System.Reflection.MethodInfo)">
 <summary>
 Invoke a static method without parameters
 </summary>
 <typeparam name="T"></typeparam>
 <param name="method"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.MethodsExtension.Invoke(System.Reflection.MethodInfo)">
 <summary>
 Invoke a static method without parameters
 </summary>
 <param name="method"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.MethodsExtension.IsMethodOverridesOf(System.Reflection.MethodInfo,System.Type)">
 <summary>
 Does current <paramref name="method"/> is overrides from the base <paramref name="type"/>
 </summary>
 <param name="method"></param>
 <param name="type"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.EmitReflection">
 <summary>
 Some common used reflection operation extension at here.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.EmitReflection.IsNonParametric(System.Reflection.MethodInfo,System.Boolean)">
 <summary>
 这个方法的调用是否是不需要任何参数的？
 </summary>
 <param name="method"></param>
 <param name="optionalAsNone"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.EmitReflection.GetTypesHelper(System.Reflection.Assembly)">
 <summary>
 Try to handle for the bugs in VisualBasic language: 
 
 https://github.com/dotnet/roslyn/issues/23050
 </summary>
 <param name="assm"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.EmitReflection.RunApp(System.String,System.String,System.Boolean)">
 <summary>
 Run external [.NET] Program from RAM Memory
 </summary>
 <param name="app"></param>
 <param name="CLI"></param>
 <param name="cs">Going to running a c# program?</param>
 <remarks>
 http://www.codeproject.com/Tips/1108105/Run-external-NET-Program-from-RAM-Memory
 
 Run external app directly from RAM. You can load the specific file into a ``Byte[]`` Array 
 with a ``StreamReader()`` or even download it from WEB via a direct link provided. 
 If you loaded the file from disk, you can delete it if you want after it has been loaded 
 by a ``StreamReader()``.
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.EmitReflection.IsNumericType(System.Object)">
 <summary>
 Determines whether the specified value is of numeric type.
 </summary>
 <param name="o">The object to check.</param>
 <returns>
 true if o is a numeric type; otherwise, false.
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.EmitReflection.GetTypeElement(System.Type,System.Boolean)">
 <summary>
 得到集合类型的对象之中的元素类型
 </summary>
 <param name="type"></param>
 <param name="strict">
 if the given clr <paramref name="type"/> object is not a collection
 type, then this function will returns nothing if set this strict 
 parameter value to TRUE, otherwise returns the <paramref name="type"/>
 object itself is this strict parameter is set to value TRUE.
 </param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.EmitReflection.GetVersion(System.String)">
 <summary>

 </summary>
 <param name="Product">.NET EXE/DLL assembly path</param>
 <returns></returns>

</member>
<member name="M:Microsoft.VisualBasic.EmitReflection.ModuleVersion(System.Type)">
 <summary>
 Gets the <see cref="T:System.Reflection.AssemblyFileVersionAttribute"/> value from the type defined assembly.
 </summary>
 <param name="type"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.EmitReflection.GetVersion(System.Reflection.Assembly)">
 <summary>

 </summary>
 <param name="assm">.NET EXE/DLL assembly</param>
 <returns></returns>

</member>
<member name="M:Microsoft.VisualBasic.EmitReflection.IsModule(System.Type)">
 <summary>
 目标类型是不是VisualBasic之中的``Module``模块类型？
 </summary>
 <param name="type"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.EmitReflection.IsInheritsFrom(System.Type,System.Type,System.Boolean,System.Int32@)">
 <summary>
 Is type <paramref name="a"/> inherits from <paramref name="base"/> type?
 </summary>
 <param name="a">继承类型继承自基本类型，具备有基本类型的所有特性</param>
 <param name="base">基本类型</param>
 <param name="strict">
 + 这个参数是为了解决比较来自不同的assembly文件之中的相同类型的比较，但是这个可能会在类型转换出现一些BUG
 + 假若不严格要求的话，那么则两种类型相等的时候也会被算作为继承关系
 + 假若是非严格判断，那么对于泛型而言，只要基本类型也相等也会被判断为成立的继承关系，这个是为了<see cref="T:Microsoft.VisualBasic.Scripting.Activity"/>操作设计的
 
 </param>
 <param name="depth">类型继承的距离值，当这个值越大的时候，说明二者的继承越远，当进行函数重载判断的时候，选择这个距离值越小的越好</param>
 <returns></returns>
 <remarks>假若两个类型是来自于不同的assembly文件的话，即使这两个类型是相同的对象，也会无法判断出来</remarks>
</member>
<member name="M:Microsoft.VisualBasic.EmitReflection.Description``1">
 <summary>
 如果有<see cref="T:System.ComponentModel.DescriptionAttribute"/>标记，则会返回该标记的字符串数据，假若没有则只会返回类型的名称
 </summary>
 <typeparam name="T"></typeparam>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.EmitReflection.Description(System.Type)">
 <summary>
 如果有<see cref="T:System.ComponentModel.DescriptionAttribute"/>标记，则会返回该标记的字符串数据，假若没有则只会返回类型的名称
 </summary>
 <returns></returns>

</member>
<member name="M:Microsoft.VisualBasic.EmitReflection.GetReadWriteProperties(System.Type)">
 <summary>
 Gets all of the can read and write access property from a type define.
 </summary>
 <param name="type"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.EmitReflection.Collection2GenericIEnumerable(System.Type,System.Boolean)">
 <summary>
 Try convert the type specific collection data type into a generic enumerable collection data type.
 (尝试将目标集合类型转换为通用的枚举集合类型)
 </summary>
 <param name="type">The type specific collection data type.(特定类型的集合对象类型，当然也可以是泛型类型)</param>
 <returns>
 If the target data type is not a collection data type then the original data type 
 will be returns and the function displays a warning message.
 </returns>
 <remarks></remarks>

</member>
<member name="M:Microsoft.VisualBasic.EmitReflection.GetDelegateInvokeEntryPoint(System.Object)">
 <summary>
 Get the method reflection entry point for a anonymous lambda expression.
 (当函数返回Nothing的时候说明目标对象不是一个函数指针)
 </summary>
 <param name="obj"></param>
 <returns></returns>
 <remarks></remarks>

</member>
<member name="M:Microsoft.VisualBasic.EmitReflection.GetFullName(System.Reflection.MethodBase,System.Boolean)">
 <summary>
 Gets the full name of a method reflection meta data.
 </summary>
 <param name="method"></param>
 <param name="IncludeAssembly"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.EmitReflection.GetAttribute``1(System.Reflection.MemberInfo)">
 <summary>
 Get the specific type of custom attribute from a property.
 If the target custom attribute is not declared on the target, then this function returns nothing.
 (从一个属性对象中获取特定的自定义属性对象)
 </summary>
 <typeparam name="T">The type of the custom attribute.(自定义属性的类型)</typeparam>
 <param name="Property">Target property object.(目标属性对象)</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.EmitReflection.GetAttribute``1(System.Reflection.PropertyInfo)">
 <summary>
 Get the specific type of custom attribute from a property.
 (从一个属性对象中获取特定的自定义属性对象，找不到的话，就会返回空值)
 </summary>
 <typeparam name="T">The type of the custom attribute.(自定义属性的类型)</typeparam>
 <param name="Property">Target property object.(目标属性对象)</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.EmitReflection.CreateObject``1(System.Object[],System.Boolean,System.String)">
 <summary>

 </summary>
 <typeparam name="T"></typeparam>
 <param name="args">构造函数里面的参数信息</param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.ScriptMeta.API(System.Type,System.String,System.Boolean)">
 <summary>

 </summary>
 <param name="type"></param>
 <param name="[nameOf]"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ScriptMeta.Description``1(``0,System.String)">
 <summary>
 获取得到定义该类型成员之上的<see cref="T:System.ComponentModel.DescriptionAttribute"/>值或者默认定义
 </summary>
 <param name="m"></param>
 <param name="default$"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ScriptMeta.Usage(System.Reflection.MemberInfo)">
 <summary>
 Get object usage information
 </summary>
 <param name="m"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ScriptMeta.ExampleInfo(System.Reflection.MemberInfo)">
 <summary>
 Get example code of the <see cref="M:Microsoft.VisualBasic.ScriptMeta.Usage(System.Reflection.MemberInfo)"/>
 </summary>
 <param name="m"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ScriptMeta.NamespaceEntry(System.Type,System.Boolean)">
 <summary>
 Get the scripting namespace value from <see cref="T:Microsoft.VisualBasic.CommandLine.Reflection.Namespace"/>
 </summary>
 <param name="app"></param>
 <returns></returns>

</member>
<member name="M:Microsoft.VisualBasic.ValueReader.Get``2(System.Collections.Generic.ICollection{``0},System.String,System.Boolean)">
 <summary>
 出错会返回空集合
 </summary>
 <typeparam name="T"></typeparam>
 <typeparam name="TProperty"></typeparam>
 <param name="collection"></param>
 <param name="name">使用System.NameOf()操作符来获取</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ValueReader.GetValue(System.Type,System.Object,System.String)">
 <summary>
 只对属性有效，出错会返回空值
 </summary>
 <param name="obj"></param>
 <param name="Name"></param>
 <returns></returns>

</member>
<member name="M:Microsoft.VisualBasic.ValueReader.GetValue``1(System.Type,System.Object,System.String)">
 <summary>
 只对属性有效，出错会返回空值
 </summary>
 <param name="obj"></param>
 <param name="Name"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.SecurityString.AES.DecryptString(System.String)">
 <summary>
 
 </summary>
 <param name="text">密文数据的base64字符串</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.SecurityString.AES.EncryptData(System.String)">
 <summary>
 加密明文，然后使用base64字符串输出结果
 </summary>
 <param name="text"></param>
 <returns></returns>
 
</member>
<member name="T:Microsoft.VisualBasic.SecurityString.MD5Hash">
 <summary>
 Represents the abstract class from which all implementations of 
 the System.Security.Cryptography.MD5 hash algorithm inherit.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.SecurityString.MD5Hash.GetMd5Hash(System.String)">
 <summary>
 Calculate md5 hash value for the input string.
 </summary>
 <param name="input"></param>
 <returns>
 this function may returns empty hashcode string if the given <paramref name="input"/> string is empty.
 </returns>
 
</member>
<member name="M:Microsoft.VisualBasic.SecurityString.MD5Hash.GetHashCode(System.String)">
 <summary>
 Gets the hashcode of the input string. (<paramref name="input"/> => <see cref="M:Microsoft.VisualBasic.SecurityString.MD5Hash.GetMd5Hash(System.Byte[])"/> => <see cref="M:Microsoft.VisualBasic.SecurityString.MD5Hash.ToLong(System.String)"/>)
 </summary>
 <param name="input">任意字符串</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.SecurityString.MD5Hash.GetHashCode(System.Collections.Generic.IEnumerable{System.Byte})">
 <summary>
 Gets the hashcode of the input string.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.SecurityString.MD5Hash.ToLong(System.String)">
 <summary>
 Gets the hashcode of the md5 string.
 </summary>
 <param name="md5">计算所得到的MD5哈希值</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.SecurityString.MD5Hash.ToLong(System.Byte[])">
 <summary>
 CityHash algorithm for convert the md5 hash value as a <see cref="T:System.Int64"/> value.
 </summary>
 <param name="bytes">
 this input value should compute from <see cref="M:Microsoft.VisualBasic.SecurityString.Md5HashProvider.GetMd5Bytes(System.Byte[])"/>
 </param>
 <returns></returns>
 <remarks>
 http://stackoverflow.com/questions/9661227/convert-md5-to-long
 
 The very best solution I found (based on my needs... mix of speed and good hash function) is Google's CityHash. 
 The input can be any byte array including an MD5 result and the output is an unsigned 64-bit long.

 CityHash has a very good but Not perfect hash distribution, And Is very fast.

 I ported CityHash from C++ To C# In half an hour. A Java port should be straightforward too.

 Just XORing the bits doesn't give as good a distribution (though admittedly that will be very fast).

 I'm not familiar enough with Java to tell you exactly how to populate a long from a byte array 
 (there could be a good helper I'm not familiar with, or I could get some details of arithmetic 
 in Java wrong). 
 Essentially, though, you'll want to do something like this:

 ```
 Long a = md5[0] * 256 * md5[1] + 256 * 256 * md5[2] + 256 * 256 * 256 * md5[3];
 Long b = md5[4] * 256 * md5[5] + 256 * 256 * md5[6] + 256 * 256 * 256 * md5[7];
 Long result = a ^ b;
 ```
 
 Note I have made no attempt To deal With endianness. If you just care about a consistent hash value, 
 though, endianness should Not matter.
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.SecurityString.MD5Hash.StringToByteArray(System.String)">
 <summary>
 由于md5是大小写无关的，故而在这里都会自动的被转换为小写形式，所以调用这个函数的时候不需要在额外的转换了
 </summary>
 <param name="hex"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.SecurityString.MD5Hash.VerifyMd5Hash(System.String,System.String)">
 <summary>
 Verify a hash against a string. 
 </summary>
 <param name="input"></param>
 <param name="comparedHash"></param>
 <returns></returns>
 <remarks></remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.SecurityString.MD5Hash.VerifyFile(System.String,System.String)">
 <summary>
 校验两个文件的哈希值是否一致
 </summary>
 <param name="query"></param>
 <param name="subject"></param>
 <returns></returns>
 <remarks></remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.SecurityString.MD5Hash.GetFileMd5(System.String)">
 <summary>
 Get the md5 hash calculation value for a specific file.(获取文件对象的哈希值，请注意，当文件不存在或者文件的长度为零的时候，会返回空字符串)
 </summary>
 <param name="PathUri">The file path of the target file to be calculated.</param>
 <returns></returns>
 <remarks></remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.SecurityString.MD5Hash.SaltValue(System.String)">
 <summary>
 SHA256 8 bits salt value for the private key.
 </summary>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.SecurityString.MD5Hash.Sha256ByteString(System.Byte[],System.Char)">
 <summary>
 sha256 computed byte array in a readable format.
 </summary>
 <param name="array"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.SecurityString.MD5Hash.Fletcher32(System.Byte[],System.Int32,System.Int32)">
 <summary>
 Calculate the Fletcher32 checksum.
 </summary>
 <param name="bytes">the bytes data for verify</param>
 <param name="offset">initial offset</param>
 <param name="length">the message length (if odd, 0 is appended)</param>
 <returns></returns>
 <remarks>
 https://github.com/AKafakA/CSE5234_Group1/blob/ae055d2bb45be9ccf30bbf2bf9dfac4e6e982b1c/h2/src/main/org/h2/mvstore/DataUtils.java#L798
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.SecurityString.MD5Hash.GetSha1Hash(System.String)">
 <summary>
 # Generate SHA1 checksum of a file
 </summary>
 <param name="filePath"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.SecurityString.Md5HashProvider">
 <summary>
 并行化的需求
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.SecurityString.Md5HashProvider.GetMd5Hash(System.String)">
 <summary>
 calculate string md5 hashcode
 </summary>
 <param name="input"></param>
 <returns>
 this function may returns empty hashcode string if the given <paramref name="input"/> string is empty.
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.SecurityString.Md5HashProvider.GetMd5hashLong(System.Byte[])">
 <summary>
 <see cref="M:System.Security.Cryptography.HashAlgorithm.ComputeHash(System.Byte[])"/> -> <see cref="M:Microsoft.VisualBasic.SecurityString.MD5Hash.ToLong(System.Byte[])"/>
 </summary>
 <param name="input"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.SecurityString.Md5HashProvider.GetMd5Hash(System.Byte[])">
 <summary>
 Calculate the md5 hashcode based on the given <paramref name="input"/> data.
 </summary>
 <param name="input"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.SecurityString.SHA256">
 <summary>
 Derives a SHA256 key from a password using an extension of the PBKDF1 algorithm.
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.SecurityString.SHA256.#ctor(System.String,System.String)">
 <summary>
 
 </summary>
 <param name="password"></param>
 <param name="saltValue">8 Bytes</param>
</member>
<member name="M:Microsoft.VisualBasic.SecurityString.SHA256.DecryptString(System.String)">
 <summary>
 字符串的解密方法
 </summary>
 <param name="cipherText"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.SecurityString.SHA256.EncryptData(System.String)">
 <summary>
 Encrypt the plain text string.
 </summary>
 <param name="plainText"></param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.SecurityString.SHA256.CertificateSigned">
 <summary>
 The previous key of the sha256 encryption will be expired after the rebuild of this module,
 so that this method is not working on the statics data storage job.
 (在本模块进行重新编译之后，原有的密匙将会失效，故这个属性不适合于静态存储加密使用)
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.SecurityString.SHA256.GetDynamicsCertification``1">
 <summary>
 双重动态数据签名
 </summary>
 <typeparam name="T"></typeparam>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.SecurityString.SHA256.GetDynamicsCertification(System.Type)">
 <summary>
 双重动态数据签名
 </summary>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.SecurityString.TripleDES.#ctor(System.Byte[],System.Byte[])">
 <summary>
 
 </summary>
 <param name="key">24byte</param>
 <param name="iv">8byte</param>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.NumericFormatHelper">
 <summary>
 ###### ``C``货币

 ```vbnet
 2.5.ToString("C")
 ' ￥2.50
 ```

 ###### ``D``十进制数

 ```vbnet
 25.ToString("D5")
 ' 00025
 ```
 
 ###### ``E``科学型

 ```vbnet
 25000.ToString("E")
 ' 2.500000E+005
 ```
 
 ###### ``F``固定点

 ```vbnet
 25.ToString("F2")
 ' 25.00
 ```
 
 ###### ``G``常规

 ```vbnet
 2.5.ToString("G")
 ' 2.5
 ```

 ###### ``N``数字

 ```vbnet
 2500000.ToString("N")
 ' 2,500,000.00
 ```
 
 ###### ``X``十六进制

 ```vbnet
 255.ToString("X")
 ' FF
 ```
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.NumericFormatHelper.Decimal(System.Int32)">
 <summary>
 ``D&lt;n>``
 </summary>
 <param name="n%"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.NumericFormatHelper.Float(System.Int32)">
 <summary>
 ``F&lt;n>``
 </summary>
 <param name="n%"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.NumericFormatHelper.SafeToString(System.Double,System.String)">
 <summary>
 
 </summary>
 <param name="x#"></param>
 <param name="NaN_imaginary$">Default using R language style default numeric value</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.NumericFormatHelper.ToHexString(System.Int32)">
 <summary>
 转换为16进制
 </summary>
 <param name="this"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.PrimitiveParser">
 <summary>
 Simple type parser extension function for <see cref="T:System.String"/>
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.PrimitiveParser.Eval(System.String,System.Double)">
 <summary>
 Evaluate the given string expression as numeric value 
 </summary>
 <param name="expression$"></param>
 <param name="default#"></param>
 <returns></returns>
</member>
<member name="F:Microsoft.VisualBasic.PrimitiveParser.NumericPattern">
 <summary>
 用于匹配任意实数的正则表达式
 
 (这个正则表达式有一个bug，会匹配上一个单独的字母E)
 </summary>
 <remarks>
 这个表达式并不用于<see cref="M:Microsoft.VisualBasic.PrimitiveParser.IsNumeric(System.String,System.Boolean,System.Boolean)"/>, 但是其他的模块的代码可能会需要这个通用的表达式来做一些判断
 </remarks>
</member>
<member name="F:Microsoft.VisualBasic.PrimitiveParser.SimpleNumberPattern">
 <summary>
 just a pattern for the simple number, without the scientific notation pattern
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.PrimitiveParser.NaN">
 <summary>
 NA literal is comes from the Rscript environment
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.PrimitiveParser.IsSimpleNumber(System.String)">
 <summary>
 这个函数相较于<see cref="M:Microsoft.VisualBasic.PrimitiveParser.IsNumeric(System.String,System.Boolean,System.Boolean)"/>，仅仅做简单的数值格式判断
 </summary>
 <returns></returns>
 <remarks>is regex pattern of <see cref="F:Microsoft.VisualBasic.PrimitiveParser.SimpleNumberPattern"/></remarks>
</member>
<member name="M:Microsoft.VisualBasic.PrimitiveParser.IsNumeric(System.String,System.Boolean,System.Boolean)">
 <summary>
 Is this token value string is a number?
 </summary>
 <returns></returns>
 <remarks>
 这个函数会判断科学计数法等格式
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.PrimitiveParser.IsInteger(System.String,System.Int32,System.Boolean)">
 <summary>
 test the given string is in integer pattern?
 </summary>
 <param name="num"></param>
 <param name="offset"></param>
 <returns>
 this function will returns true if all of the char in 
 the <paramref name="num"/> string is number.
 </returns>
 <remarks>
 this function also checks for the negative integer/long value
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.PrimitiveParser.ParseInteger(System.String)">
 <summary>
 <see cref="T:System.Int32"/> text parser
 </summary>
 <param name="s"></param>
 <returns>
 this is a safe function: this function will never throw an exception
 when the given <paramref name="s"/> is not a valid integer string 
 value, the zero value will be return in such situation.
 </returns>
 
</member>
<member name="M:Microsoft.VisualBasic.PrimitiveParser.ParseLong(System.String)">
 <summary>
 <see cref="T:System.Int64"/> text parser
 </summary>
 <param name="s"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.PrimitiveParser.ParseDouble(System.String)">
 <summary>
 <see cref="T:System.Double"/> text parser. (这个是一个基于<see cref="M:Microsoft.VisualBasic.Scripting.Runtime.Casting.ParseNumeric(System.String)"/>的非常安全的字符串解析函数)
 </summary>
 <param name="s"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.PrimitiveParser.ParseSingle(System.String)">
 <summary>
 <see cref="T:System.Single"/> text parser
 </summary>
 <param name="s"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.PrimitiveParser.ParseDate(System.String)">
 <summary>
 <see cref="T:System.DateTime"/> text parser
 </summary>
 <param name="s"></param>
 <returns></returns>
 
</member>
<member name="F:Microsoft.VisualBasic.PrimitiveParser.booleans">
 <summary>
 Convert the string value into the boolean value, this is useful to the text format configuration file into data model.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.PrimitiveParser.IsBooleanFactor(System.String,System.Boolean)">
 <summary>
 目标字符串是否可以被解析为一个逻辑值
 </summary>
 <param name="token"></param>
 <param name="extendedLiteral">
 something other string factor example like ``yes`` or ``no``
 will also be interpreted as a valid logical factor string 
 if this parameter value is set to TRUE. default value of 
 this parameter is TRUE. 
 </param>
 <returns>
 A boolean logical factor value indicates that the given 
 string <paramref name="token"/> could be parsed as a boolean
 value literal or not.
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.PrimitiveParser.ParseBoolean(System.String)">
 <summary>
 Convert the string value into the boolean value, this is useful 
 to the text format configuration file into data model.
 (请注意，空值字符串为False，如果字符串不存在与单词表之中，则也是False)
 </summary>
 <param name="str">
 the string literal of the target boolean value to convert.
 </param>
 <returns>
 The boolean value which is parsed from the string literal
 </returns>
 <remarks>the empty string input will be treated as FALSE.</remarks>
</member>
<member name="M:Microsoft.VisualBasic.PrimitiveParser.ParseBoolean(System.Char)">
 <summary>
 Convert the logical char literal to boolean value
 </summary>
 <param name="ch"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.RegexExtensions.Replace(System.Text.RegularExpressions.Regex,System.Text.StringBuilder@,System.String,System.String)">
 <summary>
 A helper function for make sub-string replacement
 </summary>
 <param name="r"></param>
 <param name="str"></param>
 <param name="replacement"></param>
 <param name="stringCopy"></param>
</member>
<member name="M:Microsoft.VisualBasic.RegexExtensions.StartsWith(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
 <summary>
 Determines whether the beginning of this string instance matches the specified
 string.
 </summary>
 <param name="str">The string to compare.</param>
 <param name="pattern"></param>
 <param name="opt"></param>
 <returns>true if value matches the beginning of this string; otherwise, false.</returns>
</member>
<member name="M:Microsoft.VisualBasic.RegexExtensions.EndsWith(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
 <summary>
 Determines whether the end of this string instance matches the specified string pattern.
 </summary>
 <param name="str$"></param>
 <param name="pattern$"></param>
 <param name="opt"></param>
 <returns></returns>
</member>
<member name="F:Microsoft.VisualBasic.RegexExtensions.RegexPythonRawString">
 <summary>
 模拟python的raw字符串的正则表达式，多行的
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.RegexExtensions.NameOf">
 <summary>
 Name of <see cref="T:System.Text.RegularExpressions.RegexOptions"/>
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.RegexExtensions.NameOf.None">
 <summary>
 Specifies that no options are set. For more information about the default behavior
 of the regular expression engine, see the "Default Options" section in the Regular
 Expression Options topic.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.RegexExtensions.NameOf.IgnoreCase">
 <summary>
 Specifies case-insensitive matching. For more information, see the "Case-Insensitive
 Matching " section in the Regular Expression Options topic.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.RegexExtensions.NameOf.Multiline">
 <summary>
 Multiline mode. Changes the meaning of ^ and $ so they match at the beginning
 and end, respectively, of any line, and not just the beginning and end of the
 entire string. For more information, see the "Multiline Mode" section in the
 Regular Expression Options topic.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.RegexExtensions.NameOf.ExplicitCapture">
 <summary>
 Specifies that the only valid captures are explicitly named or numbered groups
 of the form (?&lt;name>…). This allows unnamed parentheses to act as noncapturing
 groups without the syntactic clumsiness of the expression (?:…). For more information,
 see the "Explicit Captures Only" section in the Regular Expression Options topic.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.RegexExtensions.NameOf.Compiled">
 <summary>
 Specifies that the regular expression is compiled to an assembly. This yields
 faster execution but increases startup time. This value should not be assigned
 to the System.Text.RegularExpressions.RegexCompilationInfo.Options property when
 calling the System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)
 method. For more information, see the "Compiled Regular Expressions" section
 in the Regular Expression Options topic.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.RegexExtensions.NameOf.Singleline">
 <summary>
 Specifies single-line mode. Changes the meaning of the dot (.) so it matches
 every character (instead of every character except \n). For more information,
 see the "Single-line Mode" section in the Regular Expression Options topic.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.RegexExtensions.NameOf.IgnorePatternWhitespace">
 <summary>
 Eliminates unescaped white space from the pattern and enables comments marked
 with #. However, this value does not affect or eliminate white space in character
 classes, numeric quantifiers, or tokens that mark the beginning of individual
 regular expression language elements. For more information, see the "Ignore White
 Space" section of the Regular Expression Options topic.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.RegexExtensions.NameOf.RightToLeft">
 <summary>
 Specifies that the search will be from right to left instead of from left to
 right. For more information, see the "Right-to-Left Mode" section in the Regular
 Expression Options topic.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.RegexExtensions.NameOf.ECMAScript">
 <summary>
 Enables ECMAScript-compliant behavior for the expression. This value can be used
 only in conjunction with the System.Text.RegularExpressions.RegexOptions.IgnoreCase,
 System.Text.RegularExpressions.RegexOptions.Multiline, and System.Text.RegularExpressions.RegexOptions.Compiled
 values. The use of this value with any other values results in an exception.For
 more information on the System.Text.RegularExpressions.RegexOptions.ECMAScript
 option, see the "ECMAScript Matching Behavior" section in the Regular Expression
 Options topic.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.RegexExtensions.NameOf.CultureInvariant">
 <summary>
 Specifies that cultural differences in language is ignored. For more information,
 see the "Comparison Using the Invariant Culture" section in the Regular Expression
 Options topic.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.RegexExtensions.EachValue(System.Text.RegularExpressions.MatchCollection)">
 <summary>
 Each match its value in the source match collection.
 </summary>
 <param name="m"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.RegexExtensions.ToArray(System.Text.RegularExpressions.MatchCollection)">
 <summary>
 Gets the matched strings from the regex match result as source
 </summary>
 <param name="source"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.RegexExtensions.ToArray``1(System.Text.RegularExpressions.MatchCollection,System.Func{System.String,``0})">
 <summary>
 Converts the <see cref="T:System.Text.RegularExpressions.Regex"/> string pattern match results to the objects.
 （这个函数是非并行化的，所以不需要担心会打乱顺序）
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <param name="[ctype]">The object parser</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.RegexExtensions.IsPattern(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
 <summary>
 The enitre string input equals to the pattern's matched.
 </summary>
 <param name="s"></param>
 <param name="pattern"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.RegexExtensions.IsPattern(System.String,System.Text.RegularExpressions.Regex)">
 <summary>
 The enitre string input equals to the pattern's matched.
 </summary>
 <param name="s"></param>
 <param name="pattern"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.RegexExtensions.PythonRawRegexp(System.String)">
 <summary>
 模拟python语言之中的从raw string构建正则表达式
 </summary>
 <param name="raw$"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.RegexExtensions.Locates(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
 <summary>
 函数返回以1为底的位置，当找不到的时候会返回零
 </summary>
 <param name="str$"></param>
 <param name="pattern$"></param>
 <param name="opt"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.StringBuilders">
 <summary>
 <see cref="T:System.Text.StringBuilder"/> helpers
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.StringBuilders.Replace(System.Text.StringBuilder,Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedValue{System.String}[])">
 <summary>
 批量进行替换操作
 </summary>
 <param name="sb"></param>
 <param name="replacements"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.StringBuilders.Replace(System.Text.StringBuilder,System.String,System.Func{System.String})">
 <summary>
 适用于更加复杂的结果值的产生的链式替换
 </summary>
 <param name="sb"></param>
 <param name="find$"></param>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.StringFormats.Format(System.Collections.Generic.IEnumerable{System.Double},System.String)">
 <summary>
 Format the given number collection with a given <paramref name="numberFormat"/> string.
 </summary>
 <param name="x"></param>
 <param name="numberFormat"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.StringFormats.Lanudry(System.Double)">
 <summary>
 对bytes数值进行格式自动优化显示
 </summary>
 <param name="bytes"></param>
 <returns>经过自动格式优化过后的大小显示字符串</returns>
</member>
<member name="M:Microsoft.VisualBasic.StringFormats.FormatTime(System.TimeSpan,System.Boolean,System.Boolean)">
 <summary>
 ``days, hh:mm:ss.ms``
 </summary>
 <param name="t"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.StringFormats.ReadableElapsedTime(System.TimeSpan,System.String,System.Int32)">
 <summary>
 convert the ms value to human readable string
 </summary>
 <param name="span"><see cref="P:System.TimeSpan.TotalMilliseconds"/></param>
 <param name="format"></param>
 <param name="round"></param>
 <returns>human readable time string, example as: 3.6s, 45min or 1.99h</returns>
 
</member>
<member name="M:Microsoft.VisualBasic.StringFormats.ReadableElapsedTime(System.Int64,System.String,System.Int32)">
 <summary>
 convert the ms value to human readable string
 </summary>
 <param name="microtime"><see cref="P:System.TimeSpan.TotalMilliseconds"/></param>
 <param name="format"></param>
 <param name="round"></param>
 <returns>human readable time string, example as: 3.6s, 45min or 1.99h</returns>
</member>
<member name="T:Microsoft.VisualBasic.StringHelpers">
 <summary>
 The extensions module for facilities the string operations.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.StringHelpers.TrimNull(System.String)">
 <summary>
 将字符串中的所有的<see cref="F:Microsoft.VisualBasic.Text.ASCII.NUL"/>给移除
 </summary>
 <param name="str"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.StringHelpers.First(System.Text.StringBuilder)">
 <summary>
 Get the first char of the target <see cref="T:System.Text.StringBuilder"/> 
 </summary>
 <param name="sb"></param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.StringHelpers.EmptyString">
 <summary>
 Using <see cref="F:System.String.Empty"/> as default value
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.StringHelpers.TrimNewLine(System.String,System.String)">
 <summary>
 Replace the <see cref="F:Microsoft.VisualBasic.Constants.vbCrLf"/> with the specific string.
 </summary>
 <param name="src"></param>
 <param name="replacement"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.StringHelpers.IsEmptyStringVector(System.String[],System.Boolean)">
 <summary>
 判断这个字符串数组之中的所有的元素都是空字符串？
 </summary>
 <param name="s$">字符串数组</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.StringHelpers.RNull(System.String)">
 <summary>
 Is text equals to the R nothing?
 </summary>
 <param name="c$"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.StringHelpers.AllEquals(System.Collections.Generic.IEnumerable{System.String},System.String)">
 <summary>
 all of the string in <paramref name="s"/> collection equals 
 to the scalar string <paramref name="str"/>?
 </summary>
 <param name="s"></param>
 <param name="str"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.StringHelpers.StringHashCode(System.String)">
 <summary>
 https://github.com/darkskyapp/string-hash
 </summary>
 <param name="s$"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.StringHelpers.MaxLengthString(System.Collections.Generic.IEnumerable{System.String},System.Boolean)">
 <summary>
 常用于gdi+绘图操作，和<see cref="M:Microsoft.VisualBasic.Imaging.IGraphics.MeasureString(System.String,Microsoft.VisualBasic.Imaging.Font)"/>共同使用
 </summary>
 <param name="source"></param>
 <returns>
 A string with max number of the chars counting result
 </returns>
 <param name="consolePrintWidth">
 set this parameter value to TRUE will treated the non-ascii char as two ascii char width.
 </param>
</member>
<member name="M:Microsoft.VisualBasic.StringHelpers.MaxLengthString``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.String},System.Boolean)">
 <summary>
 获取最大长度的字符串
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <param name="getString"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.StringHelpers.Strips(System.String,System.Collections.Generic.IEnumerable{System.String})">
 <summary>
 将<paramref name="replaces"/>列表之中的字符串都替换为空字符串
 </summary>
 <param name="s$"></param>
 <param name="replaces"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.StringHelpers.CharString(System.Collections.Generic.IEnumerable{System.Char})">
 <summary>
 将一个任意的目标字符集合转换为字符串对象
 </summary>
 <param name="chs"></param>
 <returns>
 this function will returns empty string if the given <paramref name="chs"/> collection data is nothing.
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.StringHelpers.FormatString(System.String,System.Object[])">
 <summary>
 Replaces the format item in a specified string with the string representation
 of a corresponding object in a specified array.
 </summary>
 <param name="s">A composite format string.</param>
 <param name="args">An object array that contains zero or more objects to format.</param>
 <returns>A copy of format in which the format items have been replaced by the string representation
 of the corresponding objects in args.</returns>
 
</member>
<member name="M:Microsoft.VisualBasic.StringHelpers.RepeatString(System.String,System.Int32)">
 <summary>
 this is to emulate what's evailable in PHP
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.StringHelpers.JoinBy``1(System.Collections.Generic.IEnumerable{``0},System.String,System.Func{``0,System.String})">
 <summary>
 Join and contact the text tokens with a specific <paramref name="delimiter"/> string.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="data"></param>
 <param name="delimiter"></param>
 <returns></returns>
 <remarks>
 Converts the object collection to string collection at first, 
 and then do <see cref="M:System.String.Join(System.Char,System.Object[])"/>
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.StringHelpers.GetTagValue(System.String,System.String,System.Boolean,System.Boolean)">
 <summary>
 Text parser for the format: ``tagName{<paramref name="delimiter"/>}value``
 </summary>
 <param name="s"></param>
 <param name="delimiter"></param>
 <param name="trim">Needs Removes all leading and trailing white-space characters from 
 the current <see cref="T:System.String"/> object.</param>
 <returns>
 this function will returns empty data if the given string is nothing
 </returns>
 
</member>
<member name="M:Microsoft.VisualBasic.StringHelpers.GetTagValue(System.String,System.String,System.String,System.Boolean)">
 <summary>
 Text parser for the format: ``tagName{<paramref name="delimiter"/>}value``
 </summary>
 <param name="s$"></param>
 <param name="delimiter$"></param>
 <param name="trim">Chars collection for <see cref="T:System.String"/> function</param>
 <param name="failureNoName"></param>
 <returns></returns>
</member>
<member name="F:Microsoft.VisualBasic.StringHelpers.empty_factor">
 <summary>
 NA, n/a, NULL, null, N/A, -
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.StringHelpers.TextEquals(System.String,System.String,System.Boolean,System.Boolean)">
 <summary>
 Shortcuts for method <see cref="T:System.String"/>
 (s1, s2, <see cref="F:System.StringComparison.OrdinalIgnoreCase"/>).
 </summary>
 <param name="s1"></param>
 <param name="s2"></param>
 <param name="null_equals">
 does the two string value should be equals when both two string is nothing?
 </param>
 <param name="empty_equals">
 does the two string value should be equals when both of them is a 
 literal of empty, example like '', NULL, NA, etc
 </param>
 <returns></returns>
 <remarks>
 the parameters configuration of <paramref name="empty_equals"/> and
 <paramref name="null_equals"/> is usually apply for the database
 cross-reference id equals test in bioinformatics area.
 </remarks>
</member>
<member name="F:Microsoft.VisualBasic.StringHelpers.RegexICSng">
 <summary>
 <see cref="F:System.Text.RegularExpressions.RegexOptions.IgnoreCase"/> + <see cref="F:System.Text.RegularExpressions.RegexOptions.Singleline"/> 
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.StringHelpers.RegexICMul">
 <summary>
 <see cref="F:System.Text.RegularExpressions.RegexOptions.IgnoreCase"/> + <see cref="F:System.Text.RegularExpressions.RegexOptions.Multiline"/> 
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.StringHelpers.StringEmpty(System.String,System.Boolean,System.Boolean)">
 <summary>
 <paramref name="s"/> Is Nothing, <see cref="M:System.String.IsNullOrEmpty(System.String)"/>, <see cref="M:System.String.IsNullOrWhiteSpace(System.String)"/>
 </summary>
 <param name="s">The input test string</param>
 <param name="whitespaceAsEmpty">
 and also treat the whitespace as empty?
 </param>
 <param name="testEmptyFactor">
 and also treat some NULL factor in R language as empty? 
 factor string will be tested, example like: 
 NA, n/a, NULL, null, N/A, -
 </param>
 <returns>
 this function returns TRUE if the string is empty,
 white space(if <paramref name="whitespaceAsEmpty"/>) 
 or factor of NULL literal(if
 <paramref name="testEmptyFactor"/>).
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.StringHelpers.NotEmpty(System.String,System.Boolean)">
 <summary>
 Not <see cref="M:Microsoft.VisualBasic.StringHelpers.StringEmpty(System.String,System.Boolean,System.Boolean)"/>
 </summary>
 <param name="s$"></param>
 <param name="whitespaceAsEmpty"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.StringHelpers.RemoveLast(System.Text.StringBuilder)">
 <summary>
 Call <see cref="M:System.Text.StringBuilder.Remove(System.Int32,System.Int32)"/>(<see cref="P:System.Text.StringBuilder.Length"/> - 1, 1) for removes the last character in the string sequence.
 </summary>
 <param name="s"></param>
 
</member>
<member name="M:Microsoft.VisualBasic.StringHelpers.Reverse(System.Text.StringBuilder@)">
 <summary>
 Returns a reversed version of String s.
 </summary>
 <param name="sb"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.StringHelpers.Reverse(System.String)">
 <summary>
 Returns a reversed version of String s.
 </summary>
 <param name="s"></param>
 <returns></returns>
 
</member>
<member name="P:Microsoft.VisualBasic.StringHelpers.NonStrictCompares">
 <summary>
 String compares with ignored chars' case.(忽略大小写为非严格的比较)
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.StringHelpers.Parts(System.String,System.Int32)">
 <summary>
 Split long text data into seperate lines by the specific <paramref name="len"/> value.
 </summary>
 <param name="s"></param>
 <param name="len"></param>
 <returns></returns>
 <remarks>Using for the Fasta sequence writer.</remarks>
</member>
<member name="F:Microsoft.VisualBasic.StringHelpers.REGEX_EMAIL">
 <summary>
 Regex expression for parsing E-Mail URL
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.StringHelpers.REGEX_URL">
 <summary>
 Regex exprression for parsing the http/ftp URL
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.StringHelpers.Count(System.String,System.Char)">
 <summary>
 Counts the specific char that appeared in the input string.
 </summary>
 <param name="str"></param>
 <param name="ch"></param>
 <returns>this functions returns zero if the given <paramref name="str"/> is null or empty.</returns>
 <remarks>
 (计数在字符串之中所出现的指定的字符的出现的次数)
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.StringHelpers.Count(System.Collections.Generic.IEnumerable{System.String},System.String,System.StringComparison)">
 <summary>
 计算目标字符串在序列之中出现的次数
 </summary>
 <param name="source"></param>
 <param name="target$"></param>
 <param name="method"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.StringHelpers.Count(System.String,System.String,Microsoft.VisualBasic.CompareMethod)">
 <summary>
 Count the phrase in <paramref name="text"/>
 </summary>
 <param name="text$"></param>
 <param name="phrase">the sub-string for count</param>
 <param name="method"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.StringHelpers.GetString(System.String,System.Char)">
 <summary>
 获取""或者其他字符所包围的字符串的值，请注意，假若只有一个<paramref name="wrapper"/>的话，
 字符串将不会进行任何处理
 </summary>
 <param name="s"></param>
 <param name="wrapper"></param>
 <returns></returns>
 <remarks></remarks>

</member>
<member name="M:Microsoft.VisualBasic.StringHelpers.GetStackValue(System.String,System.String,System.String)">
 <summary>
 Get sub string value from the region that between the <paramref name="left"/> and <paramref name="right"/>.
 </summary>
 <param name="str"></param>
 <param name="left"></param>
 <param name="right"></param>
 <returns></returns>
 <remarks>
 (这个函数是直接分别查找左右两边的定位字符串来进行切割的) 
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.StringHelpers.GetBetween(System.String,System.String,System.String)">
 <summary>
 和<see cref="M:Microsoft.VisualBasic.StringHelpers.GetStackValue(System.String,System.String,System.String)"/>相似，这个函数也是查找起始和终止字符串之间的字符串，
 但是这个函数是查找相邻的两个标记，而非像<see cref="M:Microsoft.VisualBasic.StringHelpers.GetStackValue(System.String,System.String,System.String)"/>函数一样
 直接查找字符串的两端的定位结果
 </summary>
 <param name="str$"></param>
 <param name="strStart$"></param>
 <param name="strEnd$"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.StringHelpers.FormatZero``1(``0,System.String)">
 <summary>
 在字符串前面填充指定长度的0字符序列，假若输入的字符串长度大于fill的长度，则不再进行填充
 </summary>
 <typeparam name="T">限定类型为字符串或者数值基础类型</typeparam>
 <param name="n"></param>
 <param name="fill"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.StringHelpers.Intersection(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{System.String}})">
 <summary>
 求交集
 </summary>
 <param name="source"></param>
 <returns></returns>
 <remarks></remarks>

</member>
<member name="M:Microsoft.VisualBasic.StringHelpers.Intersection(System.String[][])">
 <summary>
 求交集
 </summary>
 <returns></returns>
 <remarks></remarks>

</member>
<member name="M:Microsoft.VisualBasic.StringHelpers.MatchPattern(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
 <summary>
 Does this input string is matched by the specific regex expression?
 (判断所输入的整个字符串是否为进行判断的<paramref name="regex"/>模式，
 即使用正则表达式所匹配的结果字符串和所输入的字符串一致)
 </summary>
 <param name="str"></param>
 <param name="regex"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.StringHelpers.Match(System.Collections.Generic.IEnumerable{System.String},System.String,System.Text.RegularExpressions.RegexOptions)">
 <summary>
 Searches the specified input string for the first occurrence of the specified regular expression.
 </summary>
 <param name="input">The string to search for a match.</param>
 <param name="pattern">The regular expression pattern to match.</param>
 <param name="options"></param>
 <returns>empty string will be returns if the given input string is null or empty.</returns>
</member>
<member name="M:Microsoft.VisualBasic.StringHelpers.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
 <summary>
 Searches the specified input string for the first occurrence of the specified regular expression.
 </summary>
 <param name="input">The string to search for a match.</param>
 <param name="pattern">The regular expression pattern to match.</param>
 <param name="options"></param>
 <returns>empty string will be returns if the given input string is null or empty.</returns>
</member>
<member name="M:Microsoft.VisualBasic.StringHelpers.Match(System.Text.RegularExpressions.Match,System.String,System.Text.RegularExpressions.RegexOptions)">
 <summary>
 Get regex match value from the target input string.
 </summary>
 <param name="input"></param>
 <param name="pattern"></param>
 <param name="options"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.StringHelpers.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
 <summary>
 Regular expression pattern text token matches
 </summary>
 <param name="input$"></param>
 <param name="pattern$"></param>
 <param name="options"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.StringHelpers.SaveTo(System.Collections.Generic.IDictionary{System.String,System.String},System.String)">
 <summary>
 Save this string dictionary object as json file.
 </summary>
 <param name="dict"></param>
 <param name="path"></param>
 <returns></returns>
 <remarks>
 其实，对于字典类型是可以直接使用JSON序列化得到json字符串的，但是在这里是需要
 保存接口类型的对象，但是在这里不能够将接口类型进行json序列化，所以进行字符串
 的序列化然后拼接出json数据
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.StringHelpers.TokenCount(System.Collections.Generic.IEnumerable{System.String},System.Boolean)">
 <summary>
 Count the string value numbers.(请注意，这个函数是倒序排序的)
 </summary>
 <param name="tokens"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.StringHelpers.StringSplit(System.String,System.String,System.Boolean,System.Text.RegularExpressions.RegexOptions)">
 <summary>
 This method is used to replace most calls to the Java <see cref="M:System.String.Split(System.Char,System.Int32,System.StringSplitOptions)"/> method.
 </summary>
 <param name="source"></param>
 <param name="pattern"><see cref="T:System.Text.RegularExpressions.Regex"/> patterns</param>
 <param name="trimTrailingEmptyStrings"></param>
 <returns></returns>
 <remarks>
 this string parser function is a safe function: will returns an empty string 
 collection if the given <paramref name="source"/> string is empty or nothing.
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.StringHelpers.StringSplit(System.String,System.Text.RegularExpressions.Regex,System.Boolean)">
 <summary>
 This method is used to replace most calls to the Java <see cref="M:System.String.Split(System.Char,System.Int32,System.StringSplitOptions)"/> method.
 </summary>
 <param name="source"></param>
 <param name="pattern"><see cref="T:System.Text.RegularExpressions.Regex"/> patterns</param>
 <param name="trimTrailingEmptyStrings"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.StringHelpers.SplitBy(System.String,System.String,Microsoft.VisualBasic.CompareMethod)">
 <summary>
 Alias for <see cref="M:Microsoft.VisualBasic.Strings.Split(System.String,System.String,System.Int32,Microsoft.VisualBasic.CompareMethod)"/>
 </summary>
 <param name="str$"></param>
 <param name="deli$"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.StringHelpers.StringReplace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
 <summary>
 将正则匹配成功的字符串替换为指定的目标字符串：<paramref name="replaceAs"/>
 </summary>
 <param name="s">
 目标字符串
 </param>
 <param name="pattern">
 进行目标内容搜索的正则表达式字符串
 </param>
 <param name="replaceAs"></param>
 <param name="opt"></param>
 <returns></returns>
 <remarks>
 这个函数是一个安全的函数：对于空值字符串对象会直接返回一个长度为零的空字符串，不会返回空值。
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.StringHelpers.Split(System.Collections.Generic.IEnumerable{System.String},System.String,System.Boolean,System.Text.RegularExpressions.RegexOptions)">
 <summary>
 String collection tokenized by a certain delimiter string element.
 </summary>
 <param name="source"></param>
 <param name="delimiter">
 Using ``String.Equals`` or Regular expression function to determined this delimiter 
 </param>
 <returns>
 the <paramref name="delimiter"/> string will not be included in the
 result data set
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.StringHelpers.Split(System.Collections.Generic.IEnumerable{System.String},System.Predicate{System.String},System.Boolean)">
 <summary>
 这个函数适合将一个很大的数组进行分割
 </summary>
 <param name="source"></param>
 <param name="delimiterPredicate">分隔符断言，判断当前的对象是不是分隔符</param>
 <param name="includes"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.StringHelpers.Located(System.Collections.Generic.IEnumerable{System.String},System.String,System.Boolean,System.Boolean)">
 <summary>
 String compares using <see cref="T:System.String"/>, if the target value could not be located, 
 then -1 will be return from this function.
 </summary>
 <param name="collection"></param>
 <param name="text"></param>
 <param name="caseSensitive"></param>
 <param name="fuzzy">
 If fuzzy, then <see cref="M:Microsoft.VisualBasic.Strings.InStr(System.Int32,System.String,System.String,Microsoft.VisualBasic.CompareMethod)"/> will be used if ``String.Equals`` method have no result.
 </param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.StringHelpers.WildcardsLocated(System.Collections.Generic.IEnumerable{System.String},System.String,System.Boolean)">
 <summary>
 
 </summary>
 <param name="collection"></param>
 <param name="text">可以使用通配符</param>
 <param name="caseSensitive"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.StringHelpers.Lookup(System.Collections.Generic.IEnumerable{System.String},System.String,System.Boolean)">
 <summary>
 Search the string by keyword in a string collection. Unlike 
 search function <see cref="M:Microsoft.VisualBasic.StringHelpers.Located(System.Collections.Generic.IEnumerable{System.String},System.String,System.Boolean,System.Boolean)"/>
 using function <see cref="T:System.String"/> function to search 
 string, this function using <see cref="M:Microsoft.VisualBasic.Strings.InStr(System.String,System.String,Microsoft.VisualBasic.CompareMethod)"/>
 to search the keyword.
 (查找目标<paramref name="keyword"/>在输入的字符串序列之中的哪个下标元素中)
 </summary>
 <param name="source"></param>
 <param name="keyword"></param>
 <param name="caseSensitive"></param>
 <returns>返回第一个找到关键词的行数，没有找到则返回-1</returns>
</member>
<member name="M:Microsoft.VisualBasic.StringHelpers.EqualsAny(System.String,System.String[])">
 <summary>
 判断目标字符串是否与字符串参数数组之中的任意一个字符串相等，大小写不敏感，假若没有相等的字符串，则会返回空字符串，假若找到了相等的字符串，则会返回该字符串
 </summary>
 <param name="source"></param>
 <param name="compareTo"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.StringHelpers.InStrAny(System.String,System.String[])">
 <summary>
 test if any <paramref name="find"/> tokens is 
 inside the given <paramref name="text"/> 
 string.
 (查找到任意一个既返回位置，大小写不敏感)
 </summary>
 <param name="text"></param>
 <param name="find"></param>
 <returns>
 假若查找不到，则返回-1值，判断是否查找成功，可以使用 &lt;0 来完成，
 因为是通过InStr来完成的，所以查找成功的时候，最小的值是1，
 即字符串序列的第一个位置，也是元素0位置
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.StringHelpers.DistinctIgnoreCase(System.Collections.Generic.IEnumerable{System.String})">
 <summary>
 Removes the duplicated string from the source <paramref name="strings"/> collection 
 with string compare ignore case.
 </summary>
 <param name="strings"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.StringHelpers.LineTokens(System.String,System.Boolean,System.Boolean)">
 <summary>
 Line tokens. **=> Parsing the text into lines by using <see cref="F:Microsoft.VisualBasic.Constants.vbCr"/>, <see cref="F:Microsoft.VisualBasic.Constants.vbLf"/>**.
 </summary>
 <param name="s"></param>
 <returns></returns>
 <param name="trim">
 Set <see cref="T:System.Boolean"/> to avoid a reader bug in the csv data reader 
 </param>
 <param name="escape">
 是否需要将字符串之中的``\n``转义为换行之后再进行分割？默认不进行转义
 </param>
 <remarks>
 (函数对文本进行分行操作，由于在Windows(<see cref="F:Microsoft.VisualBasic.Constants.vbCrLf"/>)和
 Linux(<see cref="F:Microsoft.VisualBasic.Constants.vbCr"/>, <see cref="F:Microsoft.VisualBasic.Constants.vbLf"/>)平台上面所生成的文本文件的换行符有差异，
 所以可以使用这个函数来进行统一的分行操作)
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.StringHelpers.TextLast(System.String,System.String)">
 <summary>
 Does the <paramref name="token"/> is located at the last of <paramref name="s"/> text string.
 </summary>
 <param name="s$"></param>
 <param name="token$"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.StringHelpers.SubstringSpecial(System.String,System.Int32,System.Int32)">
 <summary>
 This method replaces the Java String.substring method when 'start' is a
	method call or calculated value to ensure that 'start' is obtained just once.
 </summary>
 <param name="self"></param>
 <param name="start"></param>
 <param name="[end]"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.StringHelpers.StartsWith(System.String,System.String,System.Int32)">
 <summary>
 This method is used to replace calls to the 2-arg Java String.startsWith method.
 </summary>
 <param name="self"></param>
 <param name="prefix"></param>
 <param name="toffset"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.StrUtils.Remove(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
 <summary>
 In a specified input string, replaces all strings that match a specified regular
 expression with a specified replacement string. Specified options modify the
 matching operation.
 </summary>
 <param name="s$">The string to search for a match.</param>
 <param name="pattern$">The regular expression pattern to match.</param>
 <param name="opts">
 A bitwise combination of the enumeration values that provide options for matching.
 (如果这个参数的值是<see cref="F:System.Text.RegularExpressions.RegexOptions.None"/>的话，则当前的这个函数不会使用正则进行查找)
 </param>
 <returns>
 A new string that is identical to the input string, except that the replacement
 string takes the place of each matched string. If pattern is not matched in the
 current instance, the method returns the current instance unchanged.
 </returns>
 
</member>
<member name="M:Microsoft.VisualBasic.StrUtils.LongestTag(System.String[])">
 <summary>
 从第一个字符开始，比较出最长的label串，注意，这个不是LCS问题
 </summary>
 <param name="labels$"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.StrUtils.CharCodes(System.Collections.Generic.IEnumerable{System.Char})">
 <summary>
 <see cref="M:Microsoft.VisualBasic.Strings.AscW(System.Char)"/>
 </summary>
 <param name="s"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.StrUtils.RandomASCIIString(System.Int32,System.Boolean,System.Random)">
 <summary>
 32-126
 </summary>
 <param name="len"></param>
 <param name="seed">默认是使用<see cref="P:Microsoft.VisualBasic.Math.RandomExtensions.seeds"/>来作为随机种子的</param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.StrUtils.InvariantCulture">
 <summary>
 <see cref="P:System.Globalization.CultureInfo.InvariantCulture"/>, Gets the System.Globalization.CultureInfo object that is culture-independent
 (invariant).
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.StrUtils.SplitWithSeparator(System.String,System.Char)">
 <summary>
 Split text with a separator char
 </summary>
 <param name="text">The text.</param>
 <param name="sep">The separator.</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.StrUtils.SplitWithSeparatorFromRight(System.String,System.Char)">
 <summary>
 Split text with a separator char
 </summary>
 <param name="text">The text.</param>
 <param name="sep">The separator.</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.StrUtils.SplitWithSpaces(System.String)">
 <summary>
 Splits the text with spaces.
 </summary>
 <param name="text">The text.</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.StrUtils.SplitIntoLines(System.String)">
 <summary>
 Splits the text into lines.
 </summary>
 <param name="text">The text.</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.StrUtils.AddWithDelim(System.String,System.String,System.String)">
 <summary>
 Concats two strings with a delimiter.
 </summary>
 <param name="s1">string 1</param>
 <param name="delim">delimiter</param>
 <param name="s2">string 2</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.StrUtils.ContactWithDelim(System.String,System.String,System.String)">
 <summary>
 Contacts the with delim.
 </summary>
 <param name="str1">The STR1.</param>
 <param name="delim">The delim.</param>
 <param name="str2">The STR2.</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.StrUtils.ContactWithDelimSkipEmpty(System.Collections.Generic.IEnumerable{System.String},System.String)">
 <summary>
 Contact with delim, delim is used after the first not Empty item
 </summary>
 <param name="items"></param>
 <param name="delim"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.StrUtils.ContactWithDelimSkipNull(System.Collections.Generic.IEnumerable{System.String},System.String)">
 <summary>
 Contact with delim, delim is used after the first not null item
 </summary>
 <param name="items"></param>
 <param name="delim"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.StrUtils.ContactWithDelimSkipSome(System.Collections.Generic.IEnumerable{System.String},System.String,System.String)">
 <summary>
 Contacts the items with delim skip some.
 </summary>
 <param name="items">The items.</param>
 <param name="delim">The delim.</param>
 <param name="skip">The skip.</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.StrUtils.ContactWithDelim(System.Collections.Generic.IEnumerable{System.String},System.String)">
 <summary>
 Contacts the items with delim.
 </summary>
 <param name="items">The items.</param>
 <param name="delim">The delim.</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.StrUtils.ContactWithDelim(System.Collections.Generic.IEnumerable{System.String},System.String,System.String)">
 <summary>
 Contacts the items with delim.
 </summary>
 <param name="items">The items.</param>
 <param name="delim">The delim.</param>
 <param name="initialValue">The initial value.</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.StrUtils.ContactWithDelim(System.Collections.Generic.IEnumerable{System.String},System.String,System.String,System.String)">
 <summary>
 Contacts the items with delim.
 </summary>
 <param name="items">The items.</param>
 <param name="delim">The delim.</param>
 <param name="initialValue">The initial value.</param>
 <param name="endValue">The end value.</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.StrUtils.ContactWithDelim``1(System.Collections.Generic.IEnumerable{``0},System.String)">
 <summary>
 Contacts the items with delim.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="items">The items.</param>
 <param name="delim">The delim.</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.StrUtils.ContactWithDelim``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String,System.String)">
 <summary>
 Contacts the items with delim.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="items">The items.</param>
 <param name="delim">The delim.</param>
 <param name="initialValue">The initial value.</param>
 <param name="endValue">The end value.</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.StrUtils.GetHeader(System.String,System.Int32)">
 <summary>
 Gets the header.
 </summary>
 <param name="text">The text.</param>
 <param name="length">The length.</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.StrUtils.GetSubStringBetween(System.String,System.Char,System.Char)">
 <summary>
 Get the sub string between 'ket' and 'bra'.
 </summary>
 <param name="text"></param>
 <param name="bra"></param>
 <param name="ket"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.StrUtils.GetLastSubStringBetween(System.String,System.Char,System.Char)">
 <summary>
 Get the sub string between 'ket' and 'bra'.
 </summary>
 <param name="text"></param>
 <param name="bra"></param>
 <param name="ket"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.StrUtils.StartWithUpperCase(System.String)">
 <summary>
 Starts with upper case.
 </summary>
 <param name="name">The name.</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.StrUtils.UpperCaseFirstChar(System.String)">
 <summary>
 Uppers the case of the first char.
 </summary>
 <param name="name">The name.</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.StrUtils.LowerCaseFirstChar(System.String)">
 <summary>
 Lowers the case of the first char.
 </summary>
 <param name="name">The name.</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.StrUtils.GetWords(System.String)">
 <summary>
 split text into words by space and newline chars, multiple spaces are treated as a single space.
 </summary>
 <param name="text"></param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.ValueTypes.DateTimeHelper.MonthList">
 <summary>
 List of month names and its <see cref="T:System.Int32"/> value in a year
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ValueTypes.DateTimeHelper.GetMonthInteger(System.String)">
 <summary>
 从全称或者简称解析出月份的数字
 </summary>
 <param name="mon">大小写不敏感</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ValueTypes.DateTimeHelper.FillDateZero(System.Int32)">
 <summary>
 00
 </summary>
 <param name="d"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.ValueTypes.DateTimeHelper.DateSeq(System.DateTime,System.DateTime)">
 <summary>
 枚举出在<paramref name="start"/>到<paramref name="ends"/>这个时间窗里面的所有日期，单位为天
 </summary>
 <param name="start"></param>
 <param name="ends"></param>
 <returns>返回值里面包含有起始和结束的日期</returns>
</member>
<member name="M:Microsoft.VisualBasic.ValueTypes.DateTimeHelper.YYMMDD(System.DateTime)">
 <summary>
 yyyy-mm-dd
 </summary>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ValueTypes.DateTimeHelper.UnixTimeStamp(System.DateTime)">
 <summary>
 Convert <see cref="T:System.DateTime"/> to unix time stamp
 </summary>
 <param name="time"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ValueTypes.DateTimeHelper.FromUnixTimeStamp(System.Int64)">
 <summary>
 将Unix时间戳转换为可读的日期
 </summary>
 <param name="unixDateTime"></param>
 <returns></returns>
</member>
<member name="F:Microsoft.VisualBasic.ValueTypes.DateTimeHelper.ZeroDate3">
 <summary>
 对于unix timestamp而言，这个日期是零
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.ValueTypes.DateTimeHelper.ReadableElapsedTime(System.Int64,System.String,System.Int32)">
 <summary>
 
 </summary>
 <param name="microtime">xxx ms</param>
 <param name="format"></param>
 <param name="round"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ValueTypes.DateTimeHelper.ToDate(System.String)">
 <summary>
 Parse date string in json value format.
 </summary>
 <param name="s">Where s Is a time value with offset</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.ValueTypes.RangeExtensions.Percentage(Microsoft.VisualBasic.ComponentModel.Ranges.Model.DoubleRange,System.Double)">
 <summary>
 ```
 d = <paramref name="value"/> - <see cref="P:Microsoft.VisualBasic.ComponentModel.Ranges.Model.DoubleRange.Min"/>
 p% = d / <see cref="P:Microsoft.VisualBasic.ComponentModel.Ranges.Model.DoubleRange.Length"/> * 100%
 ```
 </summary>
 <param name="range"></param>
 <param name="value#"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.ValueTypes.TimeSpanScale">
 <summary>
 时间单位
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.TupleHelper">
 <summary>
 Deconstruct of the tuple data via byref out
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.HttpGet">
 <summary>
 Tools for http get
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.HttpGet.GET(System.String,System.UInt16,System.Collections.Generic.Dictionary{System.String,System.String},System.String,System.Boolean,System.String,System.String,System.Boolean@,System.Boolean,System.Int64)">
 <summary>
 Get the html page content from a website request or a html file on the local filesystem.
 (同时支持http位置或者本地文件，失败或者错误会返回空字符串)
 </summary>
 <param name="url">web http request url or a file path handle</param>
 <param name="retry">发生错误的时候的重试的次数</param>
 <param name="timeoutSec">设置请求超时的时间长度，单位为秒</param>
 <returns>失败或者错误会返回空字符串</returns>
 <remarks>这个工具只适合于文本数据的传输操作</remarks>
 
</member>
<member name="P:Microsoft.VisualBasic.HttpGet.HttpRequestTimeOut">
 <summary>
 Request timeout unit in seconds.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.HttpGet.UrlGet(System.Net.HttpWebRequest,System.Boolean)">
 <summary>
 Perform a web url query request
 </summary>
 <param name="webrequest"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Net.Http.RequestBuilder.BuildParameters``1(``0)">
 <summary>
 Encoding a class object as url parameters.
 (当前的这个函数操作里面已经包含有了URL的编码工作了)
 </summary>
 <typeparam name="T"></typeparam>
 <param name="obj"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Net.Http.WebResult">
 <summary>
 The data structure for represents the search result of the Web search egine.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.WebResult.Title">
 <summary>
 Specifies the Title element of the result string. 
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.WebResult.BriefText">
 <summary>
 In short description of the link produced. 
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.WebResult.URL">
 <summary>
 Url that points to the Current result.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.WebResult.Update">
 <summary>
 Update time.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.WebResult.Site">
 <summary>
 Returns the root domain name.
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Net.Http.DataURI">
 <summary>
 Data URI scheme
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.DataURI.mime">
 <summary>
 File mime type
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.DataURI.base64">
 <summary>
 The base64 string
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Net.Http.DataURI.#ctor(System.String,System.String)">
 <summary>
 
 </summary>
 <param name="file"></param>
 <param name="codepage$">
 The chartset codepage name, by default is ``ASCII``.
 </param>
</member>
<member name="M:Microsoft.VisualBasic.Net.Http.DataURI.ToStream">
 <summary>
 <see cref="M:System.Convert.FromBase64String(System.String)"/>
 </summary>
 <returns>
 a <see cref="T:System.IO.MemoryStream"/>
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Net.Http.DataURI.SVGImage(System.String)">
 <summary>
 
 </summary>
 <param name="svg">
 the svg xml document text
 </param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Net.Http.DataURI.IsWellFormedUriString(System.String)">
 <summary>
 这个只能够从字符串的特征来初步判断是否是Data URI字符串
 </summary>
 <param name="str">``data:...``</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Net.Http.DataURI.ToString">
 <summary>
 Output this data uri string text
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Net.Http.HttpHeaderName">
 <summary>
 可在服务器响应中指定的 HTTP 标头。
 </summary>
 <remarks>
 inherits from <see cref="T:System.Net.HttpResponseHeader"/>
 </remarks>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HttpHeaderName.SetCookie">
 <summary>
 Set-Cookie 标头，指定提供给客户端的 Cookie 数据。
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Net.Http.HttpHeaderNameExtensions.ParseHeaderName(System.String)">
 <summary>
 因为可能存在比较多的自定义header，所以在这里不要直接使用字典的Add方法添加
 </summary>
 <param name="key"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Net.Http.HTTP_RFC">
 <summary>
 The following is a list of Hypertext Transfer Protocol (HTTP) response status codes. This includes codes from IETF internet standards 
 as well as other IETF RFCs, other specifications and some additional commonly used codes. The first digit of the status code specifies 
 one of five classes of response; the bare minimum for an HTTP client is that it recognises these five classes. The phrases used are the 
 standard examples, but any human-readable alternative can be provided. Unless otherwise stated, the status code is part of the HTTP/1.1 
 standard (RFC 7231).

 The Internet Assigned Numbers Authority (IANA) maintains the official registry Of HTTP status codes.

 Microsoft IIS sometimes uses additional Decimal Sub-codes To provide more specific information, but these are Not listed here.
 </summary>
 <remarks>
 20240410 
 
 some duplicated value http status code has been removed due to the reason of http server module use this 
 enum value for build a http status text dictionary will crashed due to the existed duplicated value.
 </remarks>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_CONTINUTE">
 <summary>
 100 Continue |
 This means that the server has received the request headers, And that the client should proceed To send the request body 
 (In the Case Of a request For which a body needs To be sent; For example, a POST request). If the request body Is large, 
 sending it To a server When a request has already been rejected based upon inappropriate headers Is inefficient. 
 To have a server check If the request could be accepted based On the request's headers alone, a client must send Expect: 
 100-continue as a header in its initial request and check if a 100 Continue status code is received in response before 
 continuing (or receive 417 Expectation Failed and not continue).
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_SWITCHING_PROTOCOLS">
 <summary>
 101 Switching Protocols |
 This means the requester has asked the server To switch protocols And the server Is acknowledging that it will Do so.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_PROCESSING">
 <summary>
 102 Processing (WebDAV; RFC 2518) |
 As a WebDAV request may contain many sub-requests involving file operations, it may take a long time to complete the request. 
 This code indicates that the server has received And Is processing the request, but no response Is available yet.[3] 
 This prevents the client from timing out And assuming the request was lost.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_OK">
 <summary>
 200 OK |
 Standard response For successful HTTP requests. The actual response will depend On the request method used. In a Get request, 
 the response will contain an entity corresponding To the requested resource. In a POST request, the response will contain an 
 entity describing Or containing the result Of the action.
 (由于可能会修改附带一些其他的元素据信息，所以只读属性不会使用简写的形式的，而是需要重新生成新的对象实例以防止数据污染)
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_CREATED">
 <summary>
 201 Created |
 The request has been fulfilled And resulted In a New resource being created.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_ACCEPTED">
 <summary>
 202 Accepted |
 The request has been accepted For processing, but the processing has Not been completed. The request might Or might Not eventually be acted upon, 
 As it might be disallowed When processing actually takes place.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_NON_AUTH_INFO">
 <summary>
 203 Non-Authoritative Information (since HTTP/1.1) |
 The server successfully processed the request, but Is returning information that may be from another source.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_NO_CONTENT">
 <summary>
 204 No Content |
 The server successfully processed the request, but Is Not returning any content.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_RESET_CONTENT">
 <summary>
 205 Reset Content |
 The server successfully processed the request, but Is Not returning any content. Unlike a 204 response, this response requires that the requester reset the document view.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_PARTIAL_CONTENT">
 <summary>
 206 Partial Content (RFC 7233) |
 The server Is delivering only part Of the resource (Byte serving) due To a range header sent by the client. 
 The range header Is used by HTTP clients To enable resuming Of interrupted downloads, Or split a download into multiple simultaneous streams.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_MULTI_STATUS">
 <summary>
 207 Multi-Status (WebDAV; RFC 4918) |
 The message body that follows Is an XML message And can contain a number Of separate response codes, depending On how many Sub-requests were made.[4]
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_ALREADY_REPORTED">
 <summary>
 208 Already Reported (WebDAV; RFC 5842) |
 The members Of a DAV binding have already been enumerated In a previous reply To this request, And are Not being included again.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_IM_USED">
 <summary>
 226 IM Used (RFC 3229) |
 The server has fulfilled a request For the resource, And the response Is a representation Of the result Of one Or more instance-manipulations applied To the current instance.[5]
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_MULTI_CHOICES">
 <summary>
 300 Multiple Choices |
 Indicates multiple options For the resource that the client may follow. It, For instance, could be used To present different 
 format options For video, list files With different extensions, Or word sense disambiguation.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_MOVED_PERMANENTLY">
 <summary>
 301 Moved Permanently |
 This And all future requests should be directed to the given URI.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_FOUND">
 <summary>
 302 Found |
 This Is an example of industry practice contradicting the standard. The HTTP/1.0 specification (RFC 1945) required the client 
 to perform a temporary redirect (the original describing phrase was "Moved Temporarily"),[6] but popular browsers implemented 
 302 with the functionality of a 303 See Other. Therefore, HTTP/1.1 added status codes 303 And 307 to distinguish between the 
 two behaviours.[7] However, some Web applications And frameworks use the 302 status code as if it were the 303.[8]
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_SEE_OTHER">
 <summary>
 303 See Other (since HTTP/1.1) |
 The response To the request can be found under another URI Using a Get method. When received In response To a POST (Or PUT/DELETE), 
 it should be assumed that the server has received the data And the redirect should be issued With a separate Get message.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_NOT_MODIFIED">
 <summary>
 304 Not Modified (RFC 7232) |
 Indicates that the resource has Not been modified since the version specified by the request headers If-Modified-Since Or If-None-Match. 
 This means that there Is no need To retransmit the resource, since the client still has a previously-downloaded copy.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_USE_PROXY">
 <summary>
 305 Use Proxy (since HTTP/1.1) |
 The requested resource Is only available through a proxy, whose address Is provided In the response. Many HTTP clients 
 (such As Mozilla[9] And Internet Explorer) Do Not correctly handle responses With this status code, primarily For security reasons.[10]
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_SWITCH_PROXY">
 <summary>
 306 Switch Proxy |
 No longer used. Originally meant "Subsequent requests should use the specified proxy."[11]
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_TEMP_REDIRECT">
 <summary>
 307 Temporary Redirect (since HTTP/1.1) |
 In this case, the request should be repeated with another URI; however, future requests should still use the original URI. 
 In contrast to how 302 was historically implemented, the request method Is Not allowed to be changed when reissuing the original request. 
 For instance, a POST request should be repeated using another POST request.[12]
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_PERMANENT_REDIRECT">
 <summary>
 308 Permanent Redirect (RFC 7538) |
 The request, and all future requests should be repeated Using another URI. 307 And 308 (As proposed) parallel the behaviours 
 Of 302 And 301, but Do Not allow the HTTP method To change. So, For example, submitting a form To a permanently redirected resource may Continue smoothly.[13]
 </summary>
 <remarks>
 20240417 andalso alias for
 
 308 Resume Incomplete (Google) |
 This code Is used In the Resumable HTTP Requests Proposal To Resume aborted PUT Or POST requests.[14]
 </remarks>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_BAD_REQUEST">
 <summary>
 400 Bad Request |
 The server cannot Or will Not process the request due To something that Is perceived To be a client Error (e.g., malformed request syntax, 
 invalid request message framing, Or deceptive request routing).[15]
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_UNAUTHORIZED">
 <summary>
 401 Unauthorized (RFC 7235) |
 Similar to 403 Forbidden, but specifically for use when authentication Is required And has failed Or has Not yet been provided. 
 The response must include a WWW-Authenticate header field containing a challenge applicable to the requested resource. 
 See Basic access authentication And Digest access authentication.(证书未认证)
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_PAYMENT_REQUIRED">
 <summary>
 402 Payment Required |
 Reserved for future use. The original intention was that this code might be used as part of some form of digital cash Or micropayment scheme, 
 but that has Not happened, And this code Is Not usually used. YouTube uses this status if a particular IP address has made excessive requests, 
 And requires the person to enter a CAPTCHA.[citation needed]
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_FORBIDDEN">
 <summary>
 403 Forbidden |
 The request was a valid request, but the server Is refusing To respond To it. Unlike a 401 Unauthorized response, authenticating will make no difference.
 (被封号了)
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_NOT_FOUND">
 <summary>
 404 Not Found |
 The requested resource could Not be found but may be available again In the future. Subsequent requests by the client are permissible.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_METHOD_NOT_ALLOWED">
 <summary>
 405 Method Not Allowed |
 A request was made Of a resource Using a request method Not supported by that resource; For example, 
 Using Get On a form which requires data To be presented via POST, Or Using PUT On a read-only resource.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_NOT_ACCEPTABLE">
 <summary>
 406 Not Acceptable |
 The requested resource Is only capable Of generating content Not acceptable according To the Accept headers sent In the request.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_PROXY_AUTH_REQUIRED">
 <summary>
 407 Proxy Authentication Required (RFC 7235) |
 The client must first authenticate itself With the proxy.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_REQUEST_TIMEOUT">
 <summary>
 408 Request Timeout |
 The server timed out waiting For the request. According To HTTP specifications: 
 "The client did not produce a request within the time that the server was prepared to wait. The client MAY repeat the request without modifications at any later time."
 (请求超时)
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_CONFLICT">
 <summary>
 409 Conflict |
 Indicates that the request could Not be processed because Of conflict In the request, such As an edit conflict In the Case Of multiple updates.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_GONE">
 <summary>
 410 Gone |
 Indicates that the resource requested Is no longer available And will Not be available again. 
 This should be used When a resource has been intentionally removed And the resource should be purged. 
 Upon receiving a 410 status code, the client should Not request the resource again In the future. 
 Clients such As search engines should remove the resource from their indices.[16] Most use cases 
 Do Not require clients And search engines To purge the resource, And a "404 Not Found" may be used instead.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_LENGTH_REQUIRED">
 <summary>
 411 Length Required |
 The request did Not specify the length Of its content, which Is required by the requested resource.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_PRECONDITION_FAILED">
 <summary>
 412 Precondition Failed (RFC 7232) |
 The server does Not meet one Of the preconditions that the requester put On the request.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_PAYLOAD_TOO_LARGE">
 <summary>
 413 Payload Too Large (RFC 7231) |
 The request Is larger than the server Is willing Or able To process. Called "Request Entity Too Large " previously.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_URI_TOO_LONG">
 <summary>
 414 Request-URI Too Long |
 The URI provided was too Long For the server To process. Often the result Of too much data being encoded As a query-String Of a Get request, In which Case it should be converted To a POST request.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_UNSUPPORTED_MEDIA_TYPE">
 <summary>
 415 Unsupported Media Type |
 The request entity has a media type which the server Or resource does Not support. For example, the client uploads an image As image/svg+xml, but the server requires that images use a different format.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_RANGE_NOT_SATISFIABLE">
 <summary>
 416 Requested Range Not Satisfiable (RFC 7233) |
 The client has asked For a portion Of the file (Byte serving), but the server cannot supply that portion. For example, If the client asked For a part Of the file that lies beyond the End Of the file.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_EXPECTATION_FAILED">
 <summary>
 417 Expectation Failed |
 The server cannot meet the requirements Of the Expect request-header field.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_IM_TEAPOT">
 <summary>
 418 I'm a teapot (RFC 2324) |
 This code was defined In 1998 As one Of the traditional IETF April Fools' jokes, in RFC 2324, Hyper Text Coffee Pot Control Protocol, 
 and is not expected to be implemented by actual HTTP servers. The RFC specifies this code should be returned by tea pots requested to brew coffee.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_AUTH_TIMEOUT">
 <summary>
 419 Authentication Timeout (Not in RFC 2616) |
 Not a part of the HTTP standard, 419 Authentication Timeout denotes that previously valid authentication has expired. 
 It Is used as an alternative to 401 Unauthorized in order to differentiate from otherwise authenticated clients being denied access to specific server resources.[citation needed]
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_METHOD_FAILURE">
 <summary>
 420 Method Failure (Spring Framework) |
 Not part of the HTTP standard, but defined by Spring in the HttpStatus class to be used when a method failed. This status code Is deprecated by Spring.
 </summary>
 <remarks>
 420 Enhance Your Calm (Twitter) |
 Not part of the HTTP standard, but returned by version 1 of the Twitter Search And Trends API when the client Is being rate limited.[17] 
 Other services may wish to implement the 429 Too Many Requests response code instead.
 </remarks>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_MISDIRECTED_REQUEST">
 <summary>
 421 Misdirected Request (HTTP/2) |
 The request was directed at a server that Is Not able To produce a response (For example because a connection reuse).[18]
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_UNPROCESSABLE_ENTITY">
 <summary>
 422 Unprocessable Entity (WebDAV; RFC 4918) |
 The request was well-formed but was unable To be followed due To semantic errors.[4]
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_LOCKED">
 <summary>
 423 Locked (WebDAV; RFC 4918) |
 The resource that Is being accessed Is locked.[4]
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_FAILED_DEPENDENCY">
 <summary>
 424 Failed Dependency (WebDAV; RFC 4918) |
 The request failed due To failure Of a previous request (e.g., a PROPPATCH).[4]
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_UPGRADE_REQUIRED">
 <summary>
 426 Upgrade Required |
 The client should switch To a different protocol such As TLS/1.0, given In the Upgrade header field.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_PRECONDITION_REQUIRED">
 <summary>
 428 Precondition Required (RFC 6585) |
 The origin server requires the request To be conditional. Intended To prevent "the 'lost update' problem, 
 where a client GETs a resource's state, modifies it, and PUTs it back to the server, when meanwhile a third party 
 has modified the state on the server, leading to a conflict."[19]
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_TOO_MANY_REQUEST">
 <summary>
 429 Too Many Requests (RFC 6585) |
 The user has sent too many requests In a given amount Of time. Intended For use With rate limiting schemes.[19]
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_REQUEST_HEADER_FIELDS_TOO_LARGE">
 <summary>
 431 Request Header Fields Too Large (RFC 6585) |
 The server Is unwilling To process the request because either an individual header field, Or all the header fields collectively, are too large.[19]
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_LOGIN_TIMEOUT">
 <summary>
 440 Login Timeout (Microsoft) |
 A Microsoft extension. Indicates that your session has expired.[20]
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_NO_RESPONSE">
 <summary>
 444 No Response (Nginx) |
 Used in Nginx logs to indicate that the server has returned no information to the client And closed the connection (useful as a deterrent for malware).
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_RETRY_WITH">
 <summary>
 449 Retry With (Microsoft) |
 A Microsoft extension. The request should be retried after performing the appropriate action.[21]
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_BLOCKED">
 <summary>
 450 Blocked by Windows Parental Controls (Microsoft) |
 A Microsoft extension. This Error Is given When Windows Parental Controls are turned On And are blocking access To the given webpage.[22]
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_LEGAL_UNAVAILABLE">
 <summary>
 451 Unavailable For Legal Reasons (Internet draft) |
 Defined in the internet draft "A New HTTP Status Code for Legally-restricted Resources".[23] 
 Intended to be used when resource access Is denied for legal reasons, e.g. censorship Or government-mandated blocked access. 
 A reference to the 1953 dystopian novel Fahrenheit 451, where books are outlawed.[24]
 </summary>
 <remarks>
 451 Redirect (Microsoft) |
 Used in Exchange ActiveSync if there either Is a more efficient server to use Or the server cannot access the users' mailbox.[25]
 The client Is supposed To re-run the HTTP Autodiscovery protocol To find a better suited server.[26]
 </remarks>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_REQUEST_HEADER_TOO_LARGE">
 <summary>
 494 Request Header Too Large (Nginx) |
 Nginx internal code similar To 431 but it was introduced earlier In version 0.9.4 (On January 21, 2011).[27][original research?]
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_CERT_ERROR">
 <summary>
 495 Cert Error (Nginx) |
 Nginx internal code used When SSL client certificate Error occurred To distinguish it from 4XX In a log And an Error page redirection.
 (在SSL层解密的时候错误，则为证书错误)
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_NO_CERT">
 <summary>
 496 No Cert (Nginx) |
 Nginx internal code used When client didn't provide certificate to distinguish it from 4XX in a log and an error page redirection.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_HTTP_TO_HTTPS">
 <summary>
 497 HTTP to HTTPS (Nginx) |
 Nginx internal code used For the plain HTTP requests that are sent To HTTPS port To distinguish it from 4XX In a log And an Error page redirection.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_TOKEN_INVALID">
 <summary>
 498 Token expired/invalid (Esri) |
 Returned by ArcGIS For Server. A code Of 498 indicates an expired Or otherwise invalid token.[28]
 (错误的参数信息)
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_CLOSED_REQUEST">
 <summary>
 499 Client Closed Request (Nginx) |
 Used in Nginx logs to indicate when the connection has been closed by client while the server Is still processing its request, making server unable to send a status code back.[29]
 </summary>
 <remarks>
 499 Token required (Esri) |
 Returned by ArcGIS For Server. A code Of 499 indicates that a token Is required (If no token was submitted).[28]
 </remarks>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_INTERNAL_SERVER_ERROR">
 <summary>
 500 Internal Server Error |
 A generic Error message, given When an unexpected condition was encountered And no more specific message Is suitable.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_NOT_IMPLEMENTED">
 <summary>
 501 Not Implemented |
 The server either does Not recognize the request method, Or it lacks the ability To fulfill the request. Usually this implies future availability (e.g., a New feature Of a web-service API).
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_BAD_GATEWAY">
 <summary>
 502 Bad Gateway |
 The server was acting As a gateway Or proxy And received an invalid response from the upstream server.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_SERVICE_UNAVAILABLE">
 <summary>
 503 Service Unavailable |
 The server Is currently unavailable (because it Is overloaded Or down For maintenance). Generally, this Is a temporary state.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_GATEWAY_TIMEOUT">
 <summary>
 504 Gateway Timeout |
 The server was acting As a gateway Or proxy And did Not receive a timely response from the upstream server.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_VERSION_NOT_SUPPORTED">
 <summary>
 505 HTTP Version Not Supported |
 The server does Not support the HTTP protocol version used In the request.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_NEGOTIATES">
 <summary>
 506 Variant Also Negotiates (RFC 2295) |
 Transparent content negotiation For the request results In a circular reference.[30]
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_INSUFFICIENT_STORAGE">
 <summary>
 507 Insufficient Storage (WebDAV; RFC 4918) |
 The server Is unable To store the representation needed To complete the request.[4]
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_LOOP_DETECTED">
 <summary>
 508 Loop Detected (WebDAV; RFC 5842) |
 The server detected an infinite Loop While processing the request (sent In lieu Of 208 Already Reported).
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_BANDWIDTH_LIMITED_EXCEEDED">
 <summary>
 509 Bandwidth Limit Exceeded (Apache bw/limited extension)[31] |
 This status code Is Not specified In any RFCs. Its use Is unknown.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_NOT_EXTENDED">
 <summary>
 510 Not Extended (RFC 2774) |
 Further extensions To the request are required For the server To fulfil it.[32]
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_NETWORK_AUTH_REQUIRED">
 <summary>
 511 Network Authentication Required (RFC 6585) |
 The client needs To authenticate To gain network access. Intended For use by intercepting proxies used To control access To the network 
 (e.g., "captive portals" used To require agreement To Terms Of Service before granting full Internet access via a Wi-Fi hotspot).[19]
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_UNKNOWN_ERROR">
 <summary>
 520 Unknown Error |
 This status code Is Not specified In any RFC And Is returned by certain services, For instance Microsoft Azure And CloudFlare servers: 
 "The 520 error is essentially a “catch-all” response for when the origin server returns something unexpected or something that is not 
 tolerated/interpreted (protocol violation or empty response)."[33]
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_CONNECTION_TIMEOUT">
 <summary>
 522 Origin Connection Time-out |
 This status code Is Not specified In any RFCs, but Is used by CloudFlare's reverse proxies to signal that a server connection timed out.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_READ_TIMEOUT_ERROR">
 <summary>
 598 Network read timeout error (Unknown) |
 This status code Is Not specified In any RFCs, but Is used by Microsoft HTTP proxies To signal a network read timeout behind the proxy To a client In front Of the proxy.[citation needed]
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.HTTP_RFC.RFC_CONNECT_TIMEOUT_ERROR">
 <summary>
 599 Network connect timeout error (Unknown) |
 This status code Is Not specified In any RFCs, but Is used by Microsoft HTTP proxies To signal a network connect timeout behind the proxy To a client In front Of the proxy.[citation needed]
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.JsonRPC.ErrorCode.ParserError">
 <summary>
 Invalid JSON was received by the server.
 An Error occurred On the server While parsing the JSON text.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.JsonRPC.ErrorCode.InvalidRequest">
 <summary>
 The JSON sent is not a valid Request object.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.JsonRPC.ErrorCode.MethodNotFound">
 <summary>
 The method does not exist / is not available.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.JsonRPC.ErrorCode.InvalidParams">
 <summary>
 Invalid method parameter(s).
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.MultipartForm.boundary">
 <summary>
 需要使用<see cref="P:System.Text.Encoding.ASCII"/>来进行编码
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Net.Http.MultipartForm.Add(System.String,System.String)">
 <summary>
 Add form data.(添加键值对数据)
 </summary>
 <param name="name$"></param>
 <param name="value$"></param>
 <remarks>
 字符串键值对是使用<see cref="P:System.Text.Encoding.UTF8"/>编码的
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Net.Http.MultipartForm.Add(System.String,System.Collections.Generic.IEnumerable{System.Byte},System.String,System.String)">
 <summary>
 添加文件或者数据包等
 </summary>
 <param name="name$"></param>
 <param name="buffer"></param>
 <remarks>
 
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Net.Http.MultipartForm.POST(System.String,System.Collections.Generic.Dictionary{System.String,System.String})">
 <summary>
 POST this multipart form package to a specific web <paramref name="api"/>
 </summary>
 <param name="api$"></param>
 <param name="headers"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Net.Http.sitemap">
 <summary>
 
 </summary>
 <remarks>
 ```
 xmlns="http://www.sitemaps.org/schemas/sitemap/0.9" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  xsi:schemaLocation="http://www.sitemaps.org/schemas/sitemap/0.9 http://www.sitemaps.org/schemas/sitemap/0.9/sitemap.xsd"
 ```
 </remarks>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.sitemap.xmlns">
 <summary>
 ```xml
 &lt;urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.sitemaps.org/schemas/sitemap/0.9 http://www.sitemaps.org/schemas/sitemap/0.9/sitemap.xsd">
 ```
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Net.Http.Base64Codec">
 <summary>
 Tools API for encoded the image into a base64 string.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Net.Http.Base64Codec.Base64String(System.String,System.Text.Encoding,System.Boolean)">
 <summary>
 将普通文本进行base64编码
 </summary>
 <param name="text"></param>
 <param name="encoding"></param>
 <param name="gzip">
 do gzip compression and then encoded as base64 string?
 </param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Net.Http.Base64Codec.DecodeBase64(System.String,System.Text.Encoding,System.Boolean,System.Boolean)">
 <summary>
 将base64字符串还原为原来的字符串文本
 </summary>
 <param name="base64">a base64 encoded text string data for make decode</param>
 <param name="encoding"></param>
 <param name="strict">
 throw exception when error occurs during base64 decode? this function will 
 returns empty string if not strict and exception happends. 
 </param>
 <returns>
 this function may returns empty string when the given base64 string is invalid 
 and case the base64 decoder error and set strict parameter to false.
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Net.Http.Base64Codec.ToBase64String(System.Collections.Generic.IEnumerable{System.Byte})">
 <summary>
 将任意的字节数据序列转换为base64字符串
 </summary>
 <param name="byts"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Net.Http.Base64Codec.GetImage(System.String,Microsoft.VisualBasic.Imaging.ImageFormats)">
 <summary>
 Function to Get Image from Base64 Encoded String
 </summary>
 <param name="Base64String"></param>
 <param name="format"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Net.Http.Base64Codec.Base64RawBytes(System.String)">
 <summary>
 将base64编码的字符串还原为原始的数据流
 </summary>
 <param name="base64"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Net.Http.Base64Codec.__getImageFromBase64(System.String,Microsoft.VisualBasic.Imaging.ImageFormats)">
 <summary>
 Function to Get Image from Base64 Encoded String
 </summary>
 <param name="base64String"></param>
 <param name="format"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Net.Http.Base64Codec.ToBase64String(Microsoft.VisualBasic.Imaging.Image,Microsoft.VisualBasic.Imaging.ImageFormats)">
 <summary>
 Convert the Image from Input to Base64 Encoded String
 </summary>
 <param name="img"></param>
 <returns>
 this function will returns empty string if the error happends
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Net.Http.Base64Codec.ToBase64String(Microsoft.VisualBasic.Imaging.Bitmap,Microsoft.VisualBasic.Imaging.ImageFormats)">
 <summary>
 Convert the Image from Input to Base64 Encoded String
 </summary>
 <returns></returns>
 
</member>
<member name="T:Microsoft.VisualBasic.Net.Http.GZipStreamHandler">
 <summary>
 请注意，这个模块是处理http请求或者响应之中的gzip压缩的数据，
 对于zip压缩的数据需要使用<see cref="T:Microsoft.VisualBasic.Net.Http.ZipStreamExtensions"/>模块之中的帮助函数来完成
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Net.Http.GZipStreamHandler.AddGzipMagic(System.Collections.Generic.IEnumerable{System.Byte})">
 <summary>
 如果得到的一个gzip压缩的数据块头部没有magic number的话，则使用这个方法手动的添加标记后再做解压缩
 </summary>
 <param name="data"></param>
 <returns>
 返回来的数据的头部多了两个gzip压缩流的magic字节
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Net.Http.GZipStreamHandler.UnGzipBase64(System.String)">
 <summary>
 Unzip the stream data in the <paramref name="base64"/> string.
 </summary>
 <param name="base64$"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Net.Http.GZipStreamHandler.UnGzipStream(System.IO.Stream)">
 <summary>
 将输入的流数据进行gzip解压缩
 </summary>
 <remarks>
 使用这个函数得到的结果需要注意进行<see cref="M:System.IDisposable.Dispose"/>,否则很容易造成内存泄漏
 </remarks>
 <param name="stream"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Net.Http.GZipStreamHandler.UnGzipStream(System.Collections.Generic.IEnumerable{System.Byte})">
 <summary>
 将输入的流数据进行gzip解压缩
 </summary>
 <remarks>
 使用这个函数得到的结果需要注意进行<see cref="M:System.IDisposable.Dispose"/>,否则很容易造成内存泄漏
 </remarks>
 <param name="stream"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Net.Http.GZipStreamHandler.GZipStream(System.IO.Stream,System.Boolean)">
 <summary>
 对所输入的流进行gzip压缩
 </summary>
 <param name="stream"></param>
 <param name="noMagic">
 omit the gzip magic number?
 </param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Net.Http.GZipStreamHandler.GZipAsBase64(System.Collections.Generic.IEnumerable{System.Byte},System.Boolean)">
 <summary>
 
 </summary>
 <param name="bytes"></param>
 <param name="noMagic">
 omit the gzip magic number?
 </param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Net.Http.GZipStreamHandler.GZipAsBase64(System.IO.Stream,System.Boolean)">
 <summary>
 将目标流对象之中的数据进行zip压缩，然后转换为base64字符串
 </summary>
 <param name="stream"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Net.Http.ZipStreamExtensions">
 <summary>
 zip magic header: 120, 218
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Net.Http.ZipStreamExtensions.TestZipMagic(System.Byte[])">
 <summary>
 test the zip magic header
 </summary>
 <param name="buffer"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Net.Http.ZipStreamExtensions.Zip(System.IO.Stream,System.Boolean)">
 <summary>
 zip stream compression
 </summary>
 <param name="stream"></param>
 <returns></returns>
 <remarks>
 this function will add the zlib magic header when 
 <paramref name="magicHeader"/> is set to true. [NOTE:
 the zlib compression result via the .NET library did
 not contains the zlib magic header.]
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Net.Http.ZipStreamExtensions.UnZipStream(System.Collections.Generic.IEnumerable{System.Byte},System.Boolean)">
 <summary>
 进行zlib数据流的zip解压缩
 
 > https://bbs.csdn.net/topics/392275364
 </summary>
 <param name="stream"></param>
 <param name="noMagic">
 does the given stream data not contains the ziplib magic header?
 
 default parameter value false means not contains, then the given stream data will be deflate directly.
 otherwise this function will try to populate out two bytes(zlib magic header) and then make stream 
 data decompression if the parameter value is TRUE.
 </param>
 <returns></returns>
 <remarks>
 ###### 2018-11-15 经过测试，没有bug，与zlibnet的测试结果一致
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Net.Http.ZipStreamExtensions.Deflate(System.IO.Stream)">
 <summary>
 Decompress.
 在这里应该是正确的跳过了deflate压缩算法标识字节的数据流
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Net.Http.URL">
 <summary>
 Parse the url components inside a given url string as clr object 
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.URL.query">
 <summary>
 the url query parameters
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.URL.hashcode">
 <summary>
 #....
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.URL.getArgumentVal(System.String)">
 <summary>
 get url query parameter
 </summary>
 <param name="query">
 the parameter name inside the url query list
 </param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Net.Http.UserAgent">
 <summary>
 List of user-agent that can be using in the http GET
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.UserAgent.UAheader">
 <summary>
 ``User-Agent``
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.WebResponseResult.html">
 <summary>
 the text content result data of the current web http request
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Net.Http.WebQuery`1">
 <summary>
 <typeparamref name="Context"/>类型参数应该是查询的term的数据类型, 而非返回的查询结果的数据类型
 </summary>
 <typeparam name="Context"></typeparam>
 <remarks>
 这个模块不会重复请求404状态的资源
 </remarks>
 
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.WebQuery`1.url404">
 <summary>
 404状态的资源列表
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Net.Http.WebQuery`1.offlineMode">
 <summary>
 是否是处于仅从缓存数据之中查找结果的离线模式
 </summary>
 <returns></returns>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.WebQuery`1.cache">
 <summary>
 原始请求结果数据的缓存文件夹,同时也可以用这个文件夹来存放错误日志
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Http.WebQuery`1.expired">
 <summary>
 the timespan length for test the cache is expired in time?
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Net.Http.WebQuery`1.#cctor">
 <summary>
 config default web query parameters:
 
 from cli: /@set sleep=3000;webquery.debug=TRUE
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Net.Http.WebQuery`1.#ctor(System.Func{`0,System.String},Microsoft.VisualBasic.Serialization.IToString{`0},Microsoft.VisualBasic.Serialization.IObjectBuilder,System.Func{System.String,System.String},System.String,System.Int32,System.Boolean)">
 <summary>
 
 </summary>
 <param name="url">请注意,查询词应该是被<see cref="M:Microsoft.VisualBasic.WebServiceUtils.UrlEncode(System.String,System.Boolean)"/>所转义过的</param>
 <param name="contextGuid"></param>
 <param name="parser"></param>
 <param name="prefix">
 如果查询的结果文件很多, 则缓存放在同一下文件夹下, 打开的效率会非常低,
 在这里使用这个函数来得到分组前缀用作为文件夹名,分组存放缓存数据
 </param>
 <param name="cache">
 A local <see cref="T:Microsoft.VisualBasic.FileIO.Directory"/> will be open for implements the 
 <see cref="T:Microsoft.VisualBasic.ApplicationServices.IFileSystemEnvironment"/> wrapper as cache.
 </param>
 <param name="interval"></param>
</member>
<member name="M:Microsoft.VisualBasic.Net.Http.WebQuery`1.#ctor(System.String,System.Int32,System.Boolean)">
 <summary>
 create workspace from a local filesystem
 </summary>
 <param name="cache"></param>
 <param name="interval"></param>
 <param name="offline"></param>
</member>
<member name="M:Microsoft.VisualBasic.Net.Http.WebQuery`1.IsNullKey(System.Object)">
 <summary>
 test if the given key is empty or nothing
 </summary>
 <param name="key"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Net.Http.WebQuery`1.queryText(System.Collections.Generic.IEnumerable{`0},System.String)">
 <summary>
 这个函数返回的是缓存的本地文件的路径列表
 </summary>
 <param name="query"></param>
 <param name="type">文件拓展名，可以不带有小数点</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Net.Http.WebQuery`1.queryTextImpl(System.String,System.String,System.String)">
 <summary>
 
 </summary>
 <param name="id"></param>
 <param name="url"></param>
 <param name="type">the file extension name, for indicate the file type, example as: *.txt</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Net.Http.WebQuery`1.runHttpGet(System.String,System.String,System.Boolean@)">
 <summary>
 
 </summary>
 <param name="cache_path">a relative cache path</param>
 <param name="url$"></param>
 <param name="hitCache"></param>
</member>
<member name="M:Microsoft.VisualBasic.Net.Http.WebQuery`1.Query``1(`0,System.String,System.Boolean@)">
 <summary>
 
 </summary>
 <typeparam name="T"></typeparam>
 <param name="context"></param>
 <param name="cacheType">缓存文件的文本格式拓展名</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Net.Http.WebQuery`1.Query``1(System.Collections.Generic.IEnumerable{`0},System.String,System.Boolean@)">
 <summary>
 
 </summary>
 <typeparam name="T"></typeparam>
 <param name="context"></param>
 <param name="cacheType">缓存文件的文本格式拓展名</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Net.Http.WebQuery`1.Dispose(System.Boolean)">
 <summary>
 Release and save the cache filesystem data handle
 </summary>
 <param name="disposing"></param>
</member>
<member name="T:Microsoft.VisualBasic.Net.Http.IHttpGet">
 <summary>
 the abstract model for the http proxy get request
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Net.Http.WebQueryModule`1.#ctor(System.String,System.Int32,System.Boolean)">
 <summary>
 
 </summary>
 <param name="cache">the cache directory path</param>
 <param name="interval"></param>
 <param name="offline"></param>
</member>
<member name="M:Microsoft.VisualBasic.Net.Http.WebQueryModule`1.doParseUrl(`0)">
 <summary>
 generate url for run data query
 </summary>
 <param name="context"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Net.Http.WebQueryModule`1.doParseObject(System.String,System.Type)">
 <summary>
 parse query text to data object
 </summary>
 <param name="html"></param>
 <param name="schema"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Net.Http.WebQueryModule`1.doParseGuid(`0)">
 <summary>
 生成缓存所使用的一个唯一标识符的生成函数
 </summary>
 <param name="context"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Net.Abstract.IServicesSocket">
 <summary>
 Socket listening object which is running at the server side asynchronous able multiple threading.
 (运行于服务器端上面的Socket监听对象，多线程模型)
 </summary>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.Net.Abstract.IServicesSocket.LocalPort">
 <summary>
 The server services listening on this local port.(当前的这个服务器对象实例所监听的本地端口号)
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Net.Abstract.IServicesSocket.Run">
 <summary>
 This server waits for a connection and then uses  asychronous operations to
 accept the connection, get data from the connected client,
 echo that data back to the connected client.
 It then disconnects from the client and waits for another client.(请注意，当服务器的代码运行到这里之后，代码将被阻塞在这里)
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Net.Abstract.IServicesSocket.Run(System.Net.IPEndPoint)">
 <summary>
 This server waits for a connection and then uses  asychronous operations to
 accept the connection, get data from the connected client,
 echo that data back to the connected client.
 It then disconnects from the client and waits for another client.(请注意，当服务器的代码运行到这里之后，代码将被阻塞在这里)
 </summary>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.Net.Abstract.IDataRequestHandler.ResponseHandler">
 <summary>
 This function pointer using for the data request handling of the data request from the client socket.
 (这个函数指针用于处理来自于客户端的请求)
 </summary>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.Net.DomainName.TLD">
 <summary>
 顶级域名
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Net.DomainParser">
 <summary>
 http://sub.domain.com/somefolder/index.html -> domain.com
 somedomain.info -> somedomain.info
 http://anotherdomain.org/home -> anotherdomain.org
 www.subdomain.anothersubdomain.maindomain.com/something/ -> maindomain.com
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Net.DomainParser.TryParse(System.String,System.Boolean)">
 <summary>
 解析错误会返回空字符串
 </summary>
 <param name="url"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Net.Protocols.ContentTypes.ContentType">
 <summary>
 MIME types / Internet Media Types
 </summary>
 
</member>
<member name="P:Microsoft.VisualBasic.Net.Protocols.ContentTypes.ContentType.Name">
 <summary>
 Type name or brief info
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Protocols.ContentTypes.ContentType.MIMEType">
 <summary>
 MIME Type / Internet Media Type
 </summary>
 <returns></returns>
 <remarks>
 example as:
 
 plain/text
 text/html
 </remarks>
</member>
<member name="P:Microsoft.VisualBasic.Net.Protocols.ContentTypes.ContentType.FileExt">
 <summary>
 File Extension
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Protocols.ContentTypes.ContentType.Details">
 <summary>
 More Details
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Net.Protocols.ContentTypes.ContentTypeAttribute">
 <summary>
 MIME types / Internet Media Types attribute data that tagged on the content generator class or module
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Net.Protocols.ContentTypes.ContentTypeAttribute.Type">
 <summary>
 Internet media type
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Protocols.ContentTypes.ContentTypeAttribute.Description">
 <summary>
 Type of format
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Net.Protocols.ContentTypes.ContentTypeAttribute.#ctor(System.String,System.String)">
 <summary>
 A media type (formerly known as MIME type) is a two-part identifier for file formats and format contents transmitted on the Internet. 
 The Internet Assigned Numbers Authority (IANA) is the official authority for the standardization and publication of these 
 classifications. Media types were originally defined in Request for Comments 2045 in November 1996 as a part of MIME (Multipurpose 
 Internet Mail Extensions) specification, for denoting type of email message content and attachments; hence the name MIME type. 
 Media types are also used by other internet protocols such as HTTP and document file formats such as HTML, for similar purpose.
 </summary>
 <param name="type">
 A media type consists of a type and a subtype, which is further structured into a tree. A media type can optionally define a 
 suffix and parameters:
 
 ```
 type "/" [tree "."] subtype ["+" suffix] *[";" parameter]
 ```
 
 The currently registered types are: ``application``, ``audio``, ``example``, ``font``, ``image``, ``message``, ``model``, 
 ``multipart``, ``text`` And ``video``.
 </param>
 <param name="description"></param>
</member>
<member name="T:Microsoft.VisualBasic.Net.Protocols.ContentTypes.MIME">
 <summary>
 MIME stands for "Multipurpose Internet Mail Extensions. It's a way of identifying files on the Internet according to their nature and format. 
 For example, using the ``Content-type`` header value defined in a HTTP response, the browser can open the file with the proper extension/plugin.
 (http://www.freeformatter.com/mime-types-list.html)
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Net.Protocols.ContentTypes.MIME.SuffixTable">
 <summary>
 枚举出所有已知的文件拓展名列表，Key全部都是小写的 (格式: ``.ext``)
 </summary>
 <returns></returns>
 <remarks>
 recommended use <see cref="M:Microsoft.VisualBasic.ApplicationServices.Utils.FileMimeType(System.String,System.Boolean)"/> to get this mime type data
 </remarks>
</member>
<member name="P:Microsoft.VisualBasic.Net.Protocols.ContentTypes.MIME.ContentTypes">
 <summary>
 根据类型来枚举，Key全部都是小写的
 </summary>
 <returns></returns>
</member>
<member name="F:Microsoft.VisualBasic.Net.Protocols.ContentTypes.MIME.Unknown">
 <summary>
 .*（ 二进制流，不知道下载文件类型）
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Net.Protocols.ContentTypes.MIME.UnknownType">
 <summary>
 ``application/octet-stream``
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Net.PingUtility">
 <summary>
 http://www.codeproject.com/Articles/18635/Ping-exe-replica-in-C
 
 Ping.exe replica in C# 2.0

 Stefan Prodan, 3 May 2007 CPOL
 Usage example of the System.Net.NetworkInformation.Ping.
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Net.PingUtility.Ping(System.Net.IPAddress,System.UInt32,System.IO.TextWriter,System.Int32,System.Boolean)">
 <summary>
 返回与目标远程机器之间的平均通信时间长度
 </summary>
 <param name="ip"></param>
 <param name="out">Default is console.</param>
 <param name="nTimes">By default is ping 4 times</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Net.AddressEnumerator.EnumerateAddress(System.String)">
 <summary>
 
 </summary>
 <param name="expression">
 Example as:
 
 ```
 192.168.100.*
 192.168.*.233
 192.1-120.*.*
 ```
 </param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Net.Tcp.IPv4.#ctor(System.String,System.String)">
 <summary>
 Specify IP address and netmask like: ``Dim ip As New IPv4("10.1.0.25","255.255.255.16")``
 </summary>
 <param name="symbolicIP"> </param>
 <param name="netmask"> </param>
</member>
<member name="M:Microsoft.VisualBasic.Net.Tcp.IPv4.checkNetMask">
 <summary>
 See if there are zeroes inside netmask, like: ``1111111101111`` 
 this Is illegal, throw exception if encountered. 
 Netmask should always have only ones, then only zeroes, 
 like: ``11111111110000``
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Net.Tcp.IPv4.InvalidNetmaskInitial">
 <summary>
 The first byte of netmask can not be less than 255
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Net.Tcp.IPv4.IPAddress">
 <summary>
 Get the IP in symbolic form, i.e. xxx.xxx.xxx.xxx
 
 @return
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Net.Tcp.IPv4.NumericIpToSymbolic(System.String,System.Boolean)">
 <summary>
 
 </summary>
 <param name="hexIp"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Net.Tcp.IPv4.NumericIpToSymbolic(System.Int32)">
 <summary>
 Get the IP in symbolic form, i.e. ``xxx.xxx.xxx.xxx``
 </summary>
 <param name="ip"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Net.Tcp.IPv4.NumericNetmaskToSymbolic(System.Int32)">
 <summary>
 Get the net mask in symbolic form, i.e. ``xxx.xxx.xxx.xxx``
 </summary>
 <param name="netMaskNumeric"></param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Tcp.IPv4.Netmask">
 <summary>
 Get the net mask in symbolic form, i.e. ``xxx.xxx.xxx.xxx``
 
 @return
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Net.Tcp.IPv4.GetCIDR(System.Int32,System.Int32)">
 <summary>
 Get the IP and netmask in CIDR form, i.e. ``xxx.xxx.xxx.xxx/xx``
 </summary>
 <param name="baseIPnumeric"></param>
 <param name="netmaskNumeric"></param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Tcp.IPv4.CIDR">
 <summary>
 Get the IP and netmask in CIDR form, i.e. xxx.xxx.xxx.xxx/xx
 
 @return
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Net.Tcp.IPv4.GetAvailableIPs(System.Nullable{System.Int32})">
 <summary>
 Get an arry of all the IP addresses available for the IP and netmask/CIDR
 given at initialization
 
 @return
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Net.Tcp.IPv4.hostAddressRange">
 <summary>
 Range of hosts
 
 @return
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Net.Tcp.IPv4.numberOfHosts">
 <summary>
 Returns number of hosts available in given range
 </summary>
 <returns> number of hosts </returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.Tcp.IPv4.WildcardMask">
 <summary>
 The XOR of the netmask
 </summary>
 <returns> wildcard mask in text form, i.e. 0.0.15.255 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Net.Tcp.IPv4.contains(System.String)">
 <summary>
 Checks if the given IP address contains in subnet
 </summary>
 <param name="IPaddress">
 @return </param>
</member>
<member name="M:Microsoft.VisualBasic.Net.Tcp.IPv4.contains(Microsoft.VisualBasic.Net.Tcp.IPv4)">
 <summary>
 Does this IP range contains the specific child?
 </summary>
 <param name="child"></param>
 <returns></returns>
</member>
<member name="F:Microsoft.VisualBasic.Net.Tcp.IPUtils.RegexIPAddress">
 <summary>
 ``\A(25[0-5]|2[0-4]\d|[0-1]?\d?\d)(\.(25[0-5]|2[0-4]\d|[0-1]?\d?\d)){3}\z``
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Net.Tcp.IPUtils.GetGeoAddress(System.String)">
 <summary>
 IPv4 address to long
 </summary>
 <param name="IPAddress"></param>
 <returns></returns>
 <remarks>
 > http://www.codeproject.com/Articles/28363/How-to-convert-IP-address-to-country-name
 
 #### How do I convert an IP address to an IP number?
 
 IP address (IPV4) is divided into four sub-blocks. Each sub-block has a different weight number, 
 each powered by 256. The IP number is being used in the database because it is efficient to search 
 between a range of numbers in the database.
 
 The beginning IP number and the ending IP number are calculated based on the following formula:
 
 ```
 IP Number = 16777216*w + 65536*x + 256*y + z (1)
 ```
 
 where:
 
 ```
 IP Address = w.x.y.z
 ```
 
 For example, if the IP address is ``202.186.13.4``, then its IP number is ``3401190660`` based on the above formula.
 
 ```
 IP Address = 202.186.13.4
 ```
 
 So, ``w = 202, x = 186, y = 13`` and ``z = 4``
 
 ```
 IP Number = 16777216*202 + 65536*186 + 256*13 + 4
           = 3388997632 + 12189696 + 3328 + 4
           = 3401190660
 ```
 
 To reverse the IP number to the IP address:
 
 ```
 w = int ( IP Number / 16777216 ) % 256
 x = int ( IP Number / 65536 ) % 256
 y = int ( IP Number / 256 ) % 256
 z = int ( IP Number ) % 256
 ```
 
 where, ``%`` is the mod operator and int returns the integer part of the division.
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Net.Tcp.TCPExtensions.ConnectSocket(System.String,System.Int32)">
 <summary>
 假若不能成功的建立起连接的话，则会抛出错误
 </summary>
 <param name="server"></param>
 <param name="port"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="F:Microsoft.VisualBasic.Net.Tcp.TCPExtensions.MAX_PORT">
 <summary>
 系统tcp/udp端口数最大是65535
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Net.Tcp.TCPExtensions.GetFirstAvailablePort(System.Int32)">
 <summary>
 Get the first available TCP port on this local machine.
 (获取第一个可用的端口号，请注意，在高并发状态下可能会出现端口被占用的情况，
 所以这时候建议将<paramref name="BEGIN_PORT"/>设置为-1，则本函数将会尝试使用随机数来分配可用端口，从而避免一些系统崩溃的情况产生)
 </summary>
 <param name="BEGIN_PORT">Check the local port available from this port value.(从这个端口开始检测)</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Net.Tcp.TCPExtensions.PortIsUsed">
 <summary>
 获取操作系统已用的端口号
 </summary>
 <returns></returns>
 <remarks>
 not supported on linux
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Net.Tcp.TCPExtensions.PortIsAvailable(System.Int32)">
 <summary>
 检查指定端口是否已用
 </summary>
 <param name="port"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Net.IPEndPoint">
 <summary>
 The object of <see cref="T:System.Net.IPEndPoint"/> can not be Xml serialization.
 </summary>
 <remarks>
 (系统自带的<see cref="T:System.Net.IPEndPoint"></see>不能够进行Xml序列化)
 </remarks>
</member>
<member name="P:Microsoft.VisualBasic.Net.IPEndPoint.guid">
 <summary>
 Guid value of this portal information on the server registry.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.IPEndPoint.ipAddress">
 <summary>
 IPAddress of the services instance.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.IPEndPoint.port">
 <summary>
 Data port of the services instance.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.IPEndPoint.IsValid">
 <summary>
 格式是否正确
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Net.IPEndPoint.#ctor">
 <summary>
 This parameterless constructor is required for the xml serialization.(XML序列化所需要的)
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Net.IPEndPoint.#ctor(System.String,System.Int32)">
 <summary>

 </summary>
 <param name="IPAddress">
 IPAddress string using for create object using 
 method <see cref="M:System.Net.IPAddress.Parse(System.String)"/>
 </param>
 <param name="Port"><see cref="P:System.Net.IPEndPoint.Port"/></param>
</member>
<member name="M:Microsoft.VisualBasic.Net.IPEndPoint.#ctor(System.String)">
 <summary>

 </summary>
 <param name="str">Required format string: ``IPAddress:Port``</param>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Net.IPEndPoint.GetIPEndPoint">
 <summary>
 Convert this networking end point DDM into the <see cref="T:System.Net.IPEndPoint"/>
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Net.LANTools">
 <summary>
 http://www.codeproject.com/Tips/358946/Retrieving-IP-and-MAC-addresses-for-a-LAN
 </summary>
 <code>
 ' Get my PC IP address
 Call Console.WriteLine("My IP : {0}", GetIPAddress())
 
 ' Get My PC MAC address
 Call Console.WriteLine("My MAC: {0}", GetMacAddress())
 
 ' Get all devices on network
 Dim all As Dictionary(Of IPAddress, PhysicalAddress) = GetAllDevicesOnLAN()
 For Each kvp As KeyValuePair(Of IPAddress, PhysicalAddress) In all
     Console.WriteLine("IP : {0}" &amp; vbLf &amp; " MAC {1}", kvp.Key, kvp.Value)
 Next
 </code>
</member>
<member name="T:Microsoft.VisualBasic.Net.LANTools.MIB_IPNETROW">
 <summary>
 MIB_IPNETROW structure returned by GetIpNetTable
 DO NOT MODIFY THIS STRUCTURE.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Net.LANTools.GetIpNetTable(System.IntPtr,System.Int32@,System.Boolean)">
 <summary>
 GetIpNetTable external method
 </summary>
 <param name="pIpNetTable"></param>
 <param name="pdwSize"></param>
 <param name="bOrder"></param>
 <returns></returns>
</member>
<member name="F:Microsoft.VisualBasic.Net.LANTools.ERROR_INSUFFICIENT_BUFFER">
 <summary>
 Error codes GetIpNetTable returns that we recognise
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Net.LANTools.GetAllDevicesOnLAN">
 <summary>
 Get the IP and MAC addresses of all known devices on the LAN
 </summary>
 <remarks>
 1) This table is not updated often - it can take some human-scale time 
    to notice that a device has dropped off the network, or a new device
    has connected.
 2) This discards non-local devices if they are found - these are multicast
    and can be discarded by IP address range.
 </remarks>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Net.LANTools.GetIPAddress">
 <summary>
 Gets the IP address of the current PC
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Net.LANTools.GetMacAddress">
 <summary>
 Gets the MAC address of the current PC.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Net.LANTools.IsMulticast(System.Net.IPAddress)">
 <summary>
 Returns true if the specified IP address is a multicast address
 </summary>
 <param name="ip"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Net.WebClient.WebClient.OpenSaveStream">
 <summary>
 open save stream
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Net.WebClient.wget">
 <summary>
 命令行下的下载程序组件
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Net.WebClient.wget.#ctor(System.String,System.String,System.Collections.Generic.Dictionary{System.String,System.String})">
 <summary>
 Create a new file download task
 </summary>
 <param name="url">The remote resource to download.</param>
 <param name="save">The file save location</param>
</member>
<member name="M:Microsoft.VisualBasic.Net.WebClient.wget.Run">
 <summary>
 Run the file download task
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Net.WebClient.wget.ReportRequest(System.Net.WebRequest,System.Net.WebResponse,System.String)">
 <summary>
 Do task summary
 </summary>
 <param name="req"></param>
 <param name="resp"></param>
</member>
<member name="M:Microsoft.VisualBasic.Net.WebClient.wget.Download(System.String,System.String,System.Collections.Generic.Dictionary{System.String,System.String},System.Boolean)">
 <summary>
 执行有详细进度信息显示的文件下载操作, 如果只需要调用一个单纯的文件下载函数, 
 请使用<see cref="M:Microsoft.VisualBasic.WebServiceUtils.DownloadFile(System.String,System.String,System.String,System.String,System.Int32,System.Net.DownloadProgressChangedEventHandler,System.String,System.Int32,System.Boolean,System.String)"/>拓展函数
 </summary>
 <param name="url$"></param>
 <param name="save$"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Net.WebClient.wgetTask">
 <summary>
 提供一些比较详细的数据信息和事件处理
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Net.WebClient.wgetTask.currentSize">
 <summary>
 Size that has been downloaded
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Net.WebClient.wgetTask.totalSize">
 <summary>
 Total size of the file that has to be downloaded
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Net.WebClient.wgetTask.downloadSpeed">
 <summary>
 KB/sec
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Net.WebClient.wgetTask.isDownloading">
 <summary>
 Client status
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Net.WebClient.wgetTask.#ctor(System.String,System.String,System.Collections.Generic.Dictionary{System.String,System.String})">
 <summary>
 
 </summary>
 <param name="downloadUrl"></param>
 <param name="saveFile">
 Module will create a new <see cref="T:System.IO.FileStream"/> that writes to this desired download path
 </param>
</member>
<member name="T:Microsoft.VisualBasic.WebServiceUtils">
 <summary>
 The extension module for web services works.
 </summary>

</member>
<member name="P:Microsoft.VisualBasic.WebServiceUtils.Protocols">
 <summary>
 Web protocols enumeration
 </summary>
 <returns></returns>
</member>
<member name="F:Microsoft.VisualBasic.WebServiceUtils.URLPattern">
 <summary>
 regex pattern for http url
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.WebServiceUtils.UrlLinkPattern">
 <summary>
 regex pattern for any kind of url protocol
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.WebServiceUtils.isURL(System.String)">
 <summary>
 Determine that is this uri string is a network location?
 (判断这个uri字符串是否是一个网络位置)
 </summary>
 <param name="url"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.WebServiceUtils.isFilePath(System.String,System.Boolean)">
 <summary>
 is the file path in the url data or a unix file path?
 </summary>
 <param name="url"></param>
 <param name="includeWindowsFs">
 and also test for the windows file path pattern?
 </param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.WebServiceUtils.IsURLPattern(System.String)">
 <summary>
 is a web location?
 </summary>
 <param name="str"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.WebServiceUtils.BuildReqparm(System.Collections.Generic.Dictionary{System.String,System.String})">
 <summary>
 Build the request parameters for the HTTP POST
 </summary>
 <param name="dict"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.WebServiceUtils.BuildReqparm(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}})">
 <summary>
 Build the request parameters for the HTTP POST
 </summary>
 <param name="data"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.WebServiceUtils.IsSocketPortOccupied(System.Exception)">
 <summary>
 Only one usage of each socket address (protocol/network address/port) Is normally permitted
 </summary>
 <param name="ex"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.WebServiceUtils.ParseUrlQueryParameters(System.String[],System.Boolean)">
 <summary>
 Create a parameter dictionary from the request parameter tokens.
 (请注意，字典的key默认为转换为小写的形式)
 </summary>
 <param name="tokens">
 元素的个数必须要大于1，因为从url里面解析出来的元素之中第一个元素是url本身，则不再对url做字典解析
 </param>
 <returns>
 ###### 2016-11-21
 因为post可能会传递数组数据进来，则这个时候就会出现重复的键名，则已经不再适合字典类型了，这里改为返回<see cref="T:System.Collections.Specialized.NameValueCollection"/>
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.WebServiceUtils.QueryStringParameters(System.String,System.Boolean)">
 <summary>
 不像<see cref="M:Microsoft.VisualBasic.WebServiceUtils.PostUrlDataParser(System.String,System.Boolean)"/>函数，这个函数不会替换掉转义字符，并且所有的Key都已经被默认转换为小写形式的了
 </summary>
 <param name="url">URL parameters</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.WebServiceUtils.BuildUrlData(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}},System.Boolean,System.Boolean)">
 <summary>
 生成URL请求的参数
 </summary>
 <param name="data"></param>
 <param name="escaping">是否进行对value部分的字符串数据进行转义</param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.WebServiceUtils.BuildArgs(System.String[][])">
 <summary>
 Build the url query arguments string
 </summary>
 <param name="params"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.WebServiceUtils.UrlDecode(System.String)">
 <summary>
 在服务器端对URL进行解码还原
 </summary>
 <param name="s"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.WebServiceUtils.UrlEncode(System.String,System.Boolean)">
 <summary>
 进行url编码，将特殊字符进行转码
 </summary>
 <param name="s"></param>
 <param name="jswhitespace">
 空格符号默认被转义为``+``, 如果这个参数为真的话,则空格会被转义为``%20``
 </param>
 <returns></returns>
 <remarks>
 A extension method wrapper for <see cref="M:System.Net.WebUtility.UrlEncode(System.String)"/>
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.WebServiceUtils.UrlPathEncode(System.String)">
 <summary>
 编码整个URL，这个函数会自动截取出query string parameter部分，然后对截取出来的query string parameter进行编码
 </summary>
 <param name="s"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.WebServiceUtils.PostUrlDataParser(System.String,System.Boolean)">
 <summary>
 假若你的数据之中包含有SHA256的加密数据，则非常不推荐使用这个函数进行解析。因为请注意，这个函数会替换掉一些转义字符的，所以会造成一些非常隐蔽的BUG
 </summary>
 <param name="data">转义的时候大小写无关</param>
 <returns></returns>

</member>
<member name="M:Microsoft.VisualBasic.WebServiceUtils.GetRequest(System.String,System.String[][])">
 <summary>
 GET http request
 </summary>
 <param name="strUrl$"></param>
 <param name="args"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.WebServiceUtils.GetRequest(System.String,System.Boolean,System.String)">
 <summary>
 GET http request
 </summary>
 <param name="url"></param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.WebServiceUtils.Proxy">
 <summary>
 Example for xx-net tool:
 
 ```
 http://127.0.0.1:8087/
 ```
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.WebServiceUtils.GetRequestRaw(System.String,System.Boolean,System.String,System.Collections.Generic.Dictionary{System.String,System.String})">
 <summary>
 GET http request
 </summary>
 <param name="url"></param>
 <param name="https"></param>
 <param name="userAgent">
 
 fix a bug for github API:
 
 Protocol violation using Github api
 
 You need to set UserAgent like this:
 webRequest.UserAgent = "YourAppName"
 Otherwise it will give The server committed a protocol violation. Section=ResponseStatusLine Error.
 </param>
 <returns>
 this function returns a stream object that produced by
 <see cref="M:System.Net.HttpWebResponse.GetResponseStream"/>
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.WebServiceUtils.PostRequest(System.String,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}},System.Boolean)">
 <summary>
 POST http request
 </summary>
 <param name="url"></param>
 <param name="params"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.WebServiceUtils.PostRequest(System.String,System.String[][])">
 <summary>
 POST http request
 </summary>
 <param name="url"></param>
 <param name="params"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.WebServiceUtils.WebClient">
 <summary>
 A wrapper web client for set a longer operation timeout
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.WebServiceUtils.POST(System.String,System.Collections.Specialized.NameValueCollection,System.Collections.Generic.Dictionary{System.String,System.String},System.String,System.String,Microsoft.VisualBasic.Text.Encodings,System.Int32,System.Int32,System.Boolean)">
 <summary>
 POST http request for get html.
 (请注意，假若<paramref name="params"/>之中含有字符串数组的话，则会出错，这个时候需要使用
 <see cref="M:Microsoft.VisualBasic.WebServiceUtils.POST(System.String,System.Collections.Generic.Dictionary{System.String,System.String[]},System.String,System.String,System.String,System.Boolean,System.String@)"/>方法)
 </summary>
 <param name="url$"></param>
 <param name="params"></param>
 <param name="Referer"></param>
 <returns>
 this function will returns nothing if the http error happends.
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.WebServiceUtils.POSTFile(System.String,System.Byte[],System.String,System.String,System.Int32,System.Boolean)">
 <summary>
 通过post上传文件
 </summary>
 <param name="url$"></param>
 <param name="name$"></param>
 <param name="referer$"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.WebServiceUtils.POST(System.String,System.Collections.Generic.Dictionary{System.String,System.String[]},System.String,System.String,System.String,System.Boolean,System.String@)">
 <summary>
 POST http request for get html
 </summary>
 <param name="url$"></param>
 <param name="data"></param>
 <param name="Referer$"></param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.WebServiceUtils.DefaultUA">
 <summary>
 设置默认的http请求的user-agent，默认为Google Chrome的UA字符串
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.WebServiceUtils.DownloadFile(System.String,System.String,System.String,System.String,System.Int32,System.Net.DownloadProgressChangedEventHandler,System.String,System.Int32,System.Boolean,System.String)">
 <summary>
 download the file from <paramref name="strUrl"></paramref> to <paramref name="save">local file</paramref>.
 </summary>
 <param name="strUrl"></param>
 <param name="save">The file path of the file saved</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.WebServiceUtils.GetDownload(System.String,System.String)">
 <summary>
 Download file from http request and save to a specific location.
 (使用GET方法下载文件)
 </summary>
 <param name="url"></param>
 <param name="savePath"></param>
 <returns></returns>

</member>
<member name="F:Microsoft.VisualBasic.WebServiceUtils.MicrosoftDNS">
 <summary>
 Microsoft DNS Server
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.WebServiceUtils.GetMyIPAddress">
 <summary>
 获取我的公网IP地址，假若没有连接互联网的话则会返回局域网IP地址
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.WebServiceUtils.LocalIPAddress">
 <summary>
 Gets the IP address of this local machine.
 (获取本机对象的IP地址，请注意这个属性获取得到的仅仅是本机在局域网内的ip地址，
 假若需要获取得到公网IP地址，还需要外部服务器的帮助才行)
 </summary>
 <value></value>
 <returns></returns>
 <remarks>
 becareful, this property may produce IPV6 address if avaiable
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.WebServiceUtils.getIPAddressInternal">
 <summary>
 Request an external server and then returns the ip address from the server side.
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Globals">
 <summary>
 global constants
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Globals.Scan0">
 <summary>
 The first element in a collection.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Globals.null">
 <summary>
 Nothing
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Globals.unixEpocUtc">
 <summary>
 the start time of the unix time stamp
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Globals.message(System.Object[])">
 <summary>
 Diagnostic Messages
 
 Generate a diagnostic message from its arguments.
 </summary>
 <param name="msg">	
 zero Or more objects which can be coerced to character 
 (And which are pasted together with no separator) Or 
 (for message only) a single condition object.
 </param>
</member>
<member name="T:Microsoft.VisualBasic.Language.LanguageAPI">
 <summary>
 The VisualBasic language syntax helper API.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Language.LanguageAPI.defaultAssert">
 <summary>
 The default value assertor. If target object assert result is nothing or empty, then this function will returns True.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Language.LanguageAPI.Default``1(``0,System.Predicate{System.Object})">
 <summary>
 simulate the ``%||%`` operator in R language.
 
 模拟R语言之中的``%||%``操作符
 
 ```R
 `%||%` &lt;- function(x, y) if (is.null(x)) y else x
 
 NULL %||% 123
 # 123
 
 233 %||% 123
 # 233
 ```
 </summary>
 <typeparam name="T"></typeparam>
 <param name="x"></param>
 <param name="isNothing"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.LanguageAPI.AsDefault``1(``0,System.Predicate{System.Object})">
 <summary>
 Using this value as the default value for this <typeparamref name="T"/> type.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="x"></param>
 <param name="[If]"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.LanguageAPI.When``1(``0,System.Boolean)">
 <summary>
 Value Or Default When .... is true
 </summary>
 <typeparam name="T"></typeparam>
 <param name="[default]"></param>
 <param name="expression"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Language.LanguageAPI.Let``1(``0)">
 <summary>
 Helper for update the value property of <see cref="T:Microsoft.VisualBasic.Language.Value`1"/>
 
 ```vbnet
 Call Let$(<see cref="T:Microsoft.VisualBasic.Language.Value`1"/> = x)
 ```
 </summary>
 <typeparam name="T"></typeparam>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.LanguageAPI.Self``1">
 <summary>
 My self: <see cref="M:Microsoft.VisualBasic.Language.LanguageAPI.ByRef``1(``0)"/>
 </summary>
 <typeparam name="T"></typeparam>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.LanguageAPI.ByRef``1(``0)">
 <summary>
 Extension method for VisualBasic ``With`` anonymous variable syntax source reference helper
 </summary>
 <typeparam name="T"></typeparam>
 <param name="x"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Language.LanguageAPI.IsNothing``1(``0)">
 <summary>
 Extension method for VisualBasic ``With`` anonymous variable syntax for determine that source reference is nothing or not?
 </summary>
 <typeparam name="T"></typeparam>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.LanguageAPI.TryCastArray``1(Microsoft.VisualBasic.Language.Variant{``0,``0[]})">
 <summary>
 确保总是返回一个目标类型的数组
 </summary>
 <typeparam name="T"></typeparam>
 <param name="var"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.LanguageAPI.TryCastArray``1(Microsoft.VisualBasic.Language.Variant{``0[],``0})">
 <summary>
 确保总是返回一个目标类型的数组
 </summary>
 <typeparam name="T"></typeparam>
 <param name="var"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Language.C.CLangStringFormatProvider">
 <summary>
 Provides C like format print
 </summary>
 <remarks>https://github.com/mlnlover11/SharpLua</remarks>
</member>
<member name="M:Microsoft.VisualBasic.Language.C.CLangStringFormatProvider.IsPositive(System.Object,System.Boolean)">
 <summary>
 Determines whether the specified value is positive.
 </summary>
 <param name="Value">The value.</param>
 <param name="ZeroIsPositive">if set to true treats 0 as positive.</param>
 <returns>
 true if the specified value is positive; otherwise, false.
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.C.CLangStringFormatProvider.ToUnsigned(System.Object)">
 <summary>
 Converts the specified values boxed type to its correpsonding unsigned
 type.
 </summary>
 <param name="Value">The value.</param>
 <returns>A boxed numeric object whos type is unsigned.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.C.CLangStringFormatProvider.ToInteger(System.Object,System.Boolean)">
 <summary>
 Converts the specified values boxed type to its correpsonding integer
 type.
 </summary>
 <param name="Value">The value.</param>
 <returns>A boxed numeric object whos type is an integer type.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.C.CLangStringFormatProvider.ReplaceMetaChars(System.String)">
 <summary>
 Replaces the string representations of meta chars with their corresponding
 character values..(替换掉转义字符)
 </summary>
 <param name="input">The input.</param>
 <returns>A string with all string meta chars are replaced</returns>
 <remarks>
 this function is a safe function, empty string will be returns is the given 
 input string is nothing
 </remarks>
</member>
<member name="F:Microsoft.VisualBasic.Language.C.CLangStringFormatProvider.Formats">
 <summary>
 %[parameter][flags][width][.precision][length]type
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Language.C.CLangStringFormatProvider.sprintf(System.String,System.Object[])">
 <summary>
 Format string like C
 </summary>
 <param name="format"></param>
 <param name="parameters"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Language.C.CString">
 <summary>
 This class provides the ability to simulate various classic C string functions
	which don't have exact equivalents in the .NET Framework.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Language.C.CString.Decode(System.String,System.Boolean)">
 <summary>
 decode of the meta char inside the given format string
 </summary>
 <param name="s"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.C.CString.ChangeCharacter(System.String,System.Int32,System.Char)">
 <summary>
 This method allows replacing a single character in a string, to help convert
 C++ code where a single character in a character array is replaced.
 </summary>
 <param name="sourcestring"></param>
 <param name="charindex"></param>
 <param name="changechar"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Language.C.CString.IsXDigit(System.Char)">
 <summary>
 This method simulates the classic C string function 'isxdigit' (and 'iswxdigit').
 </summary>
 <param name="character"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Language.C.CString.StrChr(System.String,System.Char)">
 <summary>
 This method simulates the classic C string function 'strchr' (and 'wcschr').
 </summary>
 <param name="stringtosearch"></param>
 <param name="chartofind"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Language.C.CString.StrRChr(System.String,System.Char)">
 <summary>
 This method simulates the classic C string function 'strrchr' (and 'wcsrchr').
 </summary>
 <param name="stringtosearch"></param>
 <param name="chartofind"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Language.C.CString.StrStr(System.String,System.String)">
 <summary>
 This method simulates the classic C string function 'strstr' (and 'wcsstr').
 </summary>
 <param name="stringtosearch"></param>
 <param name="stringtofind"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Language.C.CString.__tokensHelper.StrTok(System.String,System.String)">
 <summary>
 This method simulates the classic C string function 'strtok' (and 'wcstok').
 Note that the .NET string 'Split' method cannot be used to simulate 'strtok' since
 it doesn't allow changing the delimiters between each token retrieval.
 </summary>
 <param name="stringtotokenize"></param>
 <param name="delimiters"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.C.CString.StrTok(System.String,System.String)">
 <summary>
 This method simulates the classic C string function 'strtok' (and 'wcstok').
 Note that the .NET string 'Split' method cannot be used to simulate 'strtok' since
 it doesn't allow changing the delimiters between each token retrieval.
 </summary>
 <param name="stringtotokenize"></param>
 <param name="delimiters"></param>
 <returns></returns>
</member>
<member name="F:Microsoft.VisualBasic.Language.C.File.SEEK_SET">
 <summary>
 Specifies the beginning of a stream.(文件开头)
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Language.C.File.SEEK_CUR">
 <summary>
 Specifies the current position within a stream.(当前位置)
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Language.C.File.SEEK_END">
 <summary>
 Specifies the end of a stream.(文件结束)
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Language.C.File.fprintf(System.IO.StreamWriter,System.String,System.Object[])">
 <summary>
 print data to file
 </summary>
 <param name="fp">a file pointer</param>
 <param name="format">string format for the print</param>
 <param name="args"></param>
</member>
<member name="T:Microsoft.VisualBasic.Language.C.RandomNumbers">
 <summary>
 This class provides the ability to simulate the behavior of the C/C++ functions for 
	generating random numbers, using the .NET Framework <see cref="T:System.Random"/> class.
	
	+ ``rand`` converts to the parameterless overload of NextNumber
	+ ``random`` converts to the single-parameter overload of NextNumber
	+ ``randomize`` converts to the parameterless overload of Seed
	+ ``srand`` converts to the single-parameter overload of Seed
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Language.C.RandomNumbers.r">
 <summary>
 use thread local for may thread safe
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Language.C.RandomNumbers.rand">
 <summary>
 <see cref="M:System.Random.Next"/>.(线程安全的函数)
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.C.RandomNumbers.random(System.Int32)">
 <summary>
 <see cref="M:System.Random.Next(System.Int32)"/>.(线程安全的函数)
 </summary>
 <param name="ceiling"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Language.C.Vector">
 <summary>
 std::vector helper for C++ language
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Language.C.Vector.Resize``1(System.Collections.Generic.List{``0}@,System.Int32,``0,System.Boolean)">
 <summary>
 Resize a vector list
 </summary>
 <typeparam name="T"></typeparam>
 <param name="list"></param>
 <param name="len">the new size of the target <paramref name="list"/></param>
 <param name="fill">
 fill this default value is the given list its original size is smaller than the <paramref name="len"/> new size.
 </param>
 <param name="preserved">
 preserved the original element values inside the list?
 </param>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.Arrays.fill``1(``0[]@,``0)">
 <summary>
 fill and set all elements in target array 
 <paramref name="a"/> with a specific value
 <paramref name="val"/>.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="a"></param>
 <param name="val"></param>
 <remarks>
 this function will not break the given vector its class reference
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.Arrays.subList``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32)">
 <summary>
 Returns a view of the portion of this list between the specified fromIndex, inclusive, 
 and toIndex, exclusive. (If fromIndex and toIndex are equal, the returned list is empty.) 
 The returned list is backed by this list, so non-structural changes in the returned 
 list are reflected in this list, and vice-versa. The returned list supports all of the 
 optional list operations supported by this list.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="list"></param>
 <param name="fromIndex%">low endpoint (inclusive) of the subList</param>
 <param name="toIndex%">high endpoint (exclusive) of the subList</param>
 <returns>a view of the specified range within this list</returns>
 
</member>
<member name="T:Microsoft.VisualBasic.Language.Java.Collections">
 <summary>
 This class consists exclusively of static methods that operate on or return
 collections.  It contains polymorphic algorithms that operate on
 collections, "wrappers", which return a new collection backed by a
 specified collection, and a few other odds and ends.
 
 &lt;p>The methods of this class all throw a <tt>NullPointerException</tt>
 if the collections or class objects provided to them are null.
 
 &lt;p>The documentation for the polymorphic algorithms contained in this class
 generally includes a brief description of the <i>implementation</i>.  Such
 descriptions should be regarded as <i>implementation notes</i>, rather than
 parts of the <i>specification</i>.  Implementors should feel free to
 substitute other algorithms, so long as the specification itself is adhered
 to.  (For example, the algorithm used by <tt>sort</tt> does not have to be
 a mergesort, but it does have to be <i>stable</i>.)
 
 &lt;p>The "destructive" algorithms contained in this [Class], that is, the
 algorithms that modify the collection on which they operate, are specified
 to throw <tt>UnsupportedOperationException</tt> if the collection does not
 support the appropriate mutation primitive(s), such as the <tt>set</tt>
 method.  These algorithms may, but are not required to, throw this
 exception if an invocation would have no effect on the collection.  For
 example, invoking the <tt>sort</tt> method on an unmodifiable list that is
 already sorted may or may not throw <tt>UnsupportedOperationException</tt>.
 
 &lt;p>This class is a member of the
 <a href="{@docRoot}/../technotes/guides/collections/index.html">
 Java Collections Framework</a>.
 
 @author  Josh Bloch
 @author  Neal Gafter </summary>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.Collections.binarySearch``1(``0[],``0)">
 <summary>
 Searches the specified list for the specified object using the binary
 search algorithm.  The list must be sorted into ascending order
 according to the Comparable natural ordering of its
 elements (as by the #sort(List) method) prior to making this
 call.  If it is not sorted, the results are undefined.  If the list
 contains multiple elements equal to the specified object, there is no
 guarantee which one will be found.
 
 &lt;p>This method runs in log(n) time for a "random access" list (which
 provides near-constant-time positional access).  If the specified list
 does not implement the RandomAccess interface and is large,
 this method will do an iterator-based binary search that performs
 O(n) link traversals and O(log n) element comparisons.
 </summary>
 <typeparam name="T">the class of the objects in the list</typeparam>
 <param name="list"> the list to be searched. </param>
 <param name="key"> the key to be searched for. </param>
 <returns> the index of the search key, if it is contained in the list;
         otherwise, &lt;tt>(-(&lt;i>insertion point&lt;/i>) - 1)&lt;/tt>.  The
         &lt;i>insertion point&lt;/i> is defined as the point at which the
         key would be inserted into the list: the index of the first
         element greater than the key, or &lt;tt>list.size()&lt;/tt> if all
         elements in the list are less than the specified key.  Note
         that this guarantees that the return value will be &gt;= 0 if
         and only if the key is found. 
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.Collections.get``1(System.Collections.Generic.IEnumerator{``0},System.Int32)">
 <summary>
 Gets the ith element from the given list by repositioning the specified
 list listIterator.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.Collections.binarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
 <summary>
 Searches the specified list for the specified object using the binary
 search algorithm.  The list must be sorted into ascending order
 according to the specified comparator (as by the
 #sort(List, Comparator) sort(List, Comparator)
 method), prior to making this call.  If it is
 not sorted, the results are undefined.  If the list contains multiple
 elements equal to the specified object, there is no guarantee which one
 will be found.
 
 &lt;p>This method runs in log(n) time for a "random access" list (which
 provides near-constant-time positional access).  If the specified list
 does not implement the RandomAccess interface and is large,
 this method will do an iterator-based binary search that performs
 O(n) link traversals and O(log n) element comparisons.
 </summary>
 <typeparam name="T">the class of the objects in the list</typeparam>
 <param name="list"> the list to be searched. </param>
 <param name="key"> the key to be searched for. </param>
 <param name="c"> the comparator by which the list is ordered.
         A <tt>null</tt> value indicates that the elements'
         Comparable natural ordering should be used. </param>
 <returns> the index of the search key, if it is contained in the list;
         otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The
         <i>insertion point</i> is defined as the point at which the
         key would be inserted into the list: the index of the first
         element greater than the key, or <tt>list.size()</tt> if all
         elements in the list are less than the specified key.  Note
         that this guarantees that the return value will be &gt;= 0 if
         and only if the key is found. </returns>
</member>
<member name="T:Microsoft.VisualBasic.Language.Java.JavaMath">
 <summary>
 The class {@code Math} contains methods for performing basic
 numeric operations such as the elementary exponential, logarithm,
 square root, and trigonometric functions.
 
 Unlike some of the numeric methods of class
 {@code StrictMath}, all implementations of the equivalent
 functions of class {@code Math} are not defined to return the
 bit-for-bit same results.  This relaxation permits
 better-performing implementations where strict reproducibility is
 not required.
 
 By default many of the {@code Math} methods simply call
 the equivalent method in {@code StrictMath} for their
 implementation.  Code generators are encouraged to use
 platform-specific native libraries or microprocessor instructions,
 where available, to provide higher-performance implementations of
 {@code Math} methods.  Such higher-performance
 implementations still must conform to the specification for
 {@code Math}.
 
 The quality of implementation specifications concern two
 properties, accuracy of the returned result and monotonicity of the
 method.  Accuracy of the floating-point {@code Math} methods is
 measured in terms of _ulps_, units in the last place.  For a
 given floating-point format, an #ulp(double) ulp of a
 specific real number value is the distance between the two
 floating-point values bracketing that numerical value.  When
 discussing the accuracy of a method as a whole rather than at a
 specific argument, the number of ulps cited is for the worst-case
 error at any argument.  If a method always has an error less than
 0.5 ulps, the method always returns the floating-point number
 nearest the exact result; such a method is _correctly
 rounded_.  A correctly rounded method is generally the best a
 floating-point approximation can be; however, it is impractical for
 many floating-point methods to be correctly rounded.  Instead, for
 the {@code Math} [Class], a larger error bound of 1 or 2 ulps is
 allowed for certain methods.  Informally, with a 1 ulp error bound,
 when the exact result is a representable number, the exact result
 should be returned as the computed result; otherwise, either of the
 two floating-point values which bracket the exact result may be
 returned.  For exact results large in magnitude, one of the
 endpoints of the bracket may be infinite.  Besides accuracy at
 individual arguments, maintaining proper relations between the
 method at different arguments is also important.  Therefore, most
 methods with more than 0.5 ulp errors are required to be
 _semi-monotonic_: whenever the mathematical function is
 non-decreasing, so is the floating-point approximation, likewise,
 whenever the mathematical function is non-increasing, so is the
 floating-point approximation.  Not all approximations that have 1
 ulp accuracy will automatically meet the monotonicity requirements.
 
 
 The platform uses signed two's complement integer arithmetic with
 int and long primitive types.  The developer should choose
 the primitive type to ensure that arithmetic operations consistently
 produce correct results, which in some cases means the operations
 will not overflow the range of values of the computation.
 The best practice is to choose the primitive type and algorithm to avoid
 overflow. In cases where the size is {@code int} or {@code long} and
 overflow errors need to be detected, the methods {@code addExact},
 {@code subtractExact}, {@code multiplyExact}, and {@code toIntExact}
 throw an {@code ArithmeticException} when the results overflow.
 For other arithmetic operations such as divide, absolute value,
 increment, decrement, and negation overflow occurs only with
 a specific minimum or maximum value and should be checked against
 the minimum or maximum as appropriate.
 
 @author  unascribed
 @author  Joseph D. Darcy
 @since   JDK1.0
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Language.Java.JavaMath.E">
 <summary>
 The {@code double} value that is closer than any other to
 _e_, the base of the natural logarithms.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Language.Java.JavaMath.PI">
 <summary>
 The {@code double} value that is closer than any other to
 _pi_, the ratio of the circumference of a circle to its
 diameter.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.sin(System.Double)">
 <summary>
 Returns the trigonometric sine of an angle.  Special cases:
 + If the argument is NaN or an infinity, then the
 result is NaN.
 + If the argument is zero, then the result is a zero with the
 same sign as the argument.
 
 The computed result must be within 1 ulp of the exact result.
 Results must be semi-monotonic.
 </summary>
 <param name="a">   an angle, in radians. </param>
 <returns>  the sine of the argument. </returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.cos(System.Double)">
 <summary>
 Returns the trigonometric cosine of an angle. Special cases:
 + If the argument is NaN or an infinity, then the
 result is NaN.
 
 The computed result must be within 1 ulp of the exact result.
 Results must be semi-monotonic.
 </summary>
 <param name="a">   an angle, in radians. </param>
 <returns>  the cosine of the argument. </returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.tan(System.Double)">
 <summary>
 Returns the trigonometric tangent of an angle.  Special cases:
 + If the argument is NaN or an infinity, then the result
 is NaN.
 + If the argument is zero, then the result is a zero with the
 same sign as the argument.
 
 The computed result must be within 1 ulp of the exact result.
 Results must be semi-monotonic.
 </summary>
 <param name="a">   an angle, in radians. </param>
 <returns>  the tangent of the argument. </returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.asin(System.Double)">
 <summary>
 Returns the arc sine of a value; the returned angle is in the
 range -_pi_/2 through _pi_/2.  Special cases:
 + If the argument is NaN or its absolute value is greater
 than 1, then the result is NaN.
 + If the argument is zero, then the result is a zero with the
 same sign as the argument.
 
 The computed result must be within 1 ulp of the exact result.
 Results must be semi-monotonic.
 </summary>
 <param name="a">   the value whose arc sine is to be returned. </param>
 <returns>  the arc sine of the argument. </returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.acos(System.Double)">
 <summary>
 Returns the arc cosine of a value; the returned angle is in the
 range 0.0 through _pi_.  Special case:
 + If the argument is NaN or its absolute value is greater
 than 1, then the result is NaN.
 
 The computed result must be within 1 ulp of the exact result.
 Results must be semi-monotonic.
 </summary>
 <param name="a">   the value whose arc cosine is to be returned. </param>
 <returns>  the arc cosine of the argument. </returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.atan(System.Double)">
 <summary>
 Returns the arc tangent of a value; the returned angle is in the
 range -_pi_/2 through _pi_/2.  Special cases:
 + If the argument is NaN, then the result is NaN.
 + If the argument is zero, then the result is a zero with the
 same sign as the argument.
 
 The computed result must be within 1 ulp of the exact result.
 Results must be semi-monotonic.
 </summary>
 <param name="a">   the value whose arc tangent is to be returned. </param>
 <returns>  the arc tangent of the argument. </returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.toRadians(System.Double)">
 <summary>
 Converts an angle measured in degrees to an approximately
 equivalent angle measured in radians.  The conversion from
 degrees to radians is generally inexact.
 </summary>
 <param name="angdeg">   an angle, in degrees </param>
 <returns>  the measurement of the angle {@code angdeg}
          in radians.
 @since   1.2 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.toDegrees(System.Double)">
 <summary>
 Converts an angle measured in radians to an approximately
 equivalent angle measured in degrees.  The conversion from
 radians to degrees is generally inexact; users should
 _not_ expect {@code cos(toRadians(90.0))} to exactly
 equal {@code 0.0}.
 </summary>
 <param name="angrad">   an angle, in radians </param>
 <returns>  the measurement of the angle {@code angrad}
          in degrees.
 @since   1.2 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.exp(System.Double)">
 <summary>
 Returns Euler's number _e_ raised to the power of a
 {@code double} value.  Special cases:
 + If the argument is NaN, the result is NaN.
 + If the argument is positive infinity, then the result is
 positive infinity.
 + If the argument is negative infinity, then the result is
 positive zero.
 
 The computed result must be within 1 ulp of the exact result.
 Results must be semi-monotonic.
 </summary>
 <param name="a">   the exponent to raise _e_ to. </param>
 <returns>  the value _e_{@code a},
          where _e_ is the base of the natural logarithms. </returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.log(System.Double)">
 <summary>
 Returns the natural logarithm (base _e_) of a {@code double}
 value.  Special cases:
 + If the argument is NaN or less than zero, then the result
 is NaN.
 + If the argument is positive infinity, then the result is
 positive infinity.
 + If the argument is positive zero or negative zero, then the
 result is negative infinity.
 
 The computed result must be within 1 ulp of the exact result.
 Results must be semi-monotonic.
 </summary>
 <param name="a">   a value </param>
 <returns>  the value ln {@code a}, the natural logarithm of
          {@code a}. </returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.log10(System.Double)">
 <summary>
 Returns the base 10 logarithm of a {@code double} value.
 Special cases:
 
 + If the argument is NaN or less than zero, then the result
 is NaN.
 + If the argument is positive infinity, then the result is
 positive infinity.
 + If the argument is positive zero or negative zero, then the
 result is negative infinity.
 +  If the argument is equal to 10<sup>_n_</sup> for
 integer _n_, then the result is _n_.
 
 
 The computed result must be within 1 ulp of the exact result.
 Results must be semi-monotonic.
 </summary>
 <param name="a">   a value </param>
 <returns>  the base 10 logarithm of  {@code a}.
 @since 1.5 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.sqrt(System.Double)">
 <summary>
 Returns the correctly rounded positive square root of a
 {@code double} value.
 Special cases:
 + If the argument is NaN or less than zero, then the result
 is NaN.
 + If the argument is positive infinity, then the result is positive
 infinity.
 + If the argument is positive zero or negative zero, then the
 result is the same as the argument.
 Otherwise, the result is the {@code double} value closest to
 the true mathematical square root of the argument value.
 </summary>
 <param name="a">   a value. </param>
 <returns>  the positive square root of {@code a}.
          If the argument is NaN or less than zero, the result is NaN. </returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.IEEEremainder(System.Double,System.Double)">
 <summary>
 Computes the remainder operation on two arguments as prescribed
 by the IEEE 754 standard.
 The remainder value is mathematically equal to
 ``f1 - f2`` x _n_,
 where _n_ is the mathematical integer closest to the exact
 mathematical value of the quotient {@code f1/f2}, and if two
 mathematical integers are equally close to {@code f1/f2},
 then _n_ is the integer that is even. If the remainder is
 zero, its sign is the same as the sign of the first argument.
 Special cases:
 + If either argument is NaN, or the first argument is infinite,
 or the second argument is positive zero or negative zero, then the
 result is NaN.
 + If the first argument is finite and the second argument is
 infinite, then the result is the same as the first argument.
 </summary>
 <param name="f1">   the dividend. </param>
 <param name="f2">   the divisor. </param>
 <returns>  the remainder when {@code f1} is divided by
          {@code f2}. </returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.ceil(System.Double)">
 <summary>
 Returns the smallest (closest to negative infinity)
 {@code double} value that is greater than or equal to the
 argument and is equal to a mathematical  java.lang.[Integer]. Special cases:
 + If the argument value is already equal to a
 mathematical integer, then the result is the same as the
 argument.  + If the argument is NaN or an infinity or
 positive zero or negative zero, then the result is the same as
 the argument.  + If the argument value is less than zero but
 greater than -1.0, then the result is negative zero. Note
 that the value of {@code sys.ceil(x)} is exactly the
 value of {@code -Math.floor(-x)}.
 
 </summary>
 <param name="a">   a value. </param>
 <returns>  the smallest (closest to negative infinity)
          floating-point value that is greater than or equal to
          the argument and is equal to a mathematical  java.lang.[Integer]. </returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.floor(System.Double)">
 <summary>
 Returns the largest (closest to positive infinity)
 {@code double} value that is less than or equal to the
 argument and is equal to a mathematical  java.lang.[Integer]. Special cases:
 + If the argument value is already equal to a
 mathematical integer, then the result is the same as the
 argument.  + If the argument is NaN or an infinity or
 positive zero or negative zero, then the result is the same as
 the argument.
 </summary>
 <param name="a">   a value. </param>
 <returns>  the largest (closest to positive infinity)
          floating-point value that less than or equal to the argument
          and is equal to a mathematical  java.lang.[Integer]. </returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.atan2(System.Double,System.Double)">
 <summary>
 Returns the angle _theta_ from the conversion of rectangular
 coordinates ({@code x}, {@code y}) to polar
 coordinates (r, _theta_).
 This method computes the phase _theta_ by computing an arc tangent
 of {@code y/x} in the range of -_pi_ to _pi_. Special
 cases:
 + If either argument is NaN, then the result is NaN.
 + If the first argument is positive zero and the second argument
 is positive, or the first argument is positive and finite and the
 second argument is positive infinity, then the result is positive
 zero.
 + If the first argument is negative zero and the second argument
 is positive, or the first argument is negative and finite and the
 second argument is positive infinity, then the result is negative zero.
 + If the first argument is positive zero and the second argument
 is negative, or the first argument is positive and finite and the
 second argument is negative infinity, then the result is the
 {@code double} value closest to _pi_.
 + If the first argument is negative zero and the second argument
 is negative, or the first argument is negative and finite and the
 second argument is negative infinity, then the result is the
 {@code double} value closest to -_pi_.
 + If the first argument is positive and the second argument is
 positive zero or negative zero, or the first argument is positive
 infinity and the second argument is finite, then the result is the
 {@code double} value closest to _pi_/2.
 + If the first argument is negative and the second argument is
 positive zero or negative zero, or the first argument is negative
 infinity and the second argument is finite, then the result is the
 {@code double} value closest to -_pi_/2.
 + If both arguments are positive infinity, then the result is the
 {@code double} value closest to _pi_/4.
 + If the first argument is positive infinity and the second argument
 is negative infinity, then the result is the {@code double}
 value closest to 3*_pi_/4.
 + If the first argument is negative infinity and the second argument
 is positive infinity, then the result is the {@code double} value
 closest to -_pi_/4.
 + If both arguments are negative infinity, then the result is the
 {@code double} value closest to -3*_pi_/4.
 
 The computed result must be within 2 ulps of the exact result.
 Results must be semi-monotonic.
 </summary>
 <param name="y">   the ordinate coordinate </param>
 <param name="x">   the abscissa coordinate </param>
 <returns>  the _theta_ component of the point
          (_r_, _theta_)
          in polar coordinates that corresponds to the point
          (_x_, _y_) in Cartesian coordinates. </returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.pow(System.Double,System.Double)">
 <summary>
 Returns the value of the first argument raised to the power of the
 second argument. Special cases:
 
 + If the second argument is positive or negative zero, then the
 result is 1.0.
 + If the second argument is 1.0, then the result is the same as the
 first argument.
 + If the second argument is NaN, then the result is NaN.
 + If the first argument is NaN and the second argument is nonzero,
 then the result is NaN.
 
 + If
 
 + the absolute value of the first argument is greater than 1
 and the second argument is positive infinity, or
 + the absolute value of the first argument is less than 1 and
 the second argument is negative infinity,
 
 then the result is positive infinity.
 
 + If
 
 + the absolute value of the first argument is greater than 1 and
 the second argument is negative infinity, or
 + the absolute value of the
 first argument is less than 1 and the second argument is positive
 infinity,
 
 then the result is positive zero.
 
 + If the absolute value of the first argument equals 1 and the
 second argument is infinite, then the result is NaN.
 
 + If
 
 + the first argument is positive zero and the second argument
 is greater than zero, or
 + the first argument is positive infinity and the second
 argument is less than zero,
 
 then the result is positive zero.
 
 + If
 
 + the first argument is positive zero and the second argument
 is less than zero, or
 + the first argument is positive infinity and the second
 argument is greater than zero,
 
 then the result is positive infinity.
 
 + If
 
 + the first argument is negative zero and the second argument
 is greater than zero but not a finite odd integer, or
 + the first argument is negative infinity and the second
 argument is less than zero but not a finite odd integer,
 
 then the result is positive zero.
 
 + If
 
 + the first argument is negative zero and the second argument
 is a positive finite odd integer, or
 + the first argument is negative infinity and the second
 argument is a negative finite odd integer,
 
 then the result is negative zero.
 
 + If
 
 + the first argument is negative zero and the second argument
 is less than zero but not a finite odd integer, or
 + the first argument is negative infinity and the second
 argument is greater than zero but not a finite odd integer,
 
 then the result is positive infinity.
 
 + If
 
 + the first argument is negative zero and the second argument
 is a negative finite odd integer, or
 + the first argument is negative infinity and the second
 argument is a positive finite odd integer,
 
 then the result is negative infinity.
 
 + If the first argument is finite and less than zero
 
 +  if the second argument is a finite even integer, the
 result is equal to the result of raising the absolute value of
 the first argument to the power of the second argument
 
 + if the second argument is a finite odd integer, the result
 is equal to the negative of the result of raising the absolute
 value of the first argument to the power of the second
 argument
 
 + if the second argument is finite and not an integer, then
 the result is NaN.
 
 
 + If both arguments are integers, then the result is exactly equal
 to the mathematical result of raising the first argument to the power
 of the second argument if that result can in fact be represented
 exactly as a {@code double} value.
 
 (In the foregoing descriptions, a floating-point value is
 considered to be an integer if and only if it is finite and a
 fixed point of the method #ceil ceil or,
 equivalently, a fixed point of the method {@link #floor
 floor}. A value is a fixed point of a one-argument
 method if and only if the result of applying the method to the
 value is equal to the value.)
 
 The computed result must be within 1 ulp of the exact result.
 Results must be semi-monotonic.
 </summary>
 <param name="a">   the base. </param>
 <param name="b">   the exponent. </param>
 <returns>  the value {@code a}<sup>{@code b}</sup>. </returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.random">
 <summary>
 Returns a {@code double} value with a positive sign, greater
 than or equal to {@code 0.0} and less than {@code 1.0}.
 Returned values are chosen pseudorandomly with (approximately)
 uniform distribution from that range.
 
 When this method is first called, it creates a single new
 pseudorandom-number generator, exactly as if by the expression
 
 <blockquote>{@code new java.util.Random()}</blockquote>
 
 This new pseudorandom-number generator is used thereafter for
 all calls to this method and is used nowhere else.
 
 This method is properly synchronized to allow correct use by
 more than one thread. However, if many threads need to generate
 pseudorandom numbers at a great rate, it may reduce contention
 for each thread to have its own pseudorandom-number generator.
 </summary>
 <returns>  a pseudorandom {@code double} greater than or equal
 to {@code 0.0} and less than {@code 1.0}. </returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.addExact(System.Int32,System.Int32)">
 <summary>
 Returns the sum of its arguments,
 throwing an exception if the result overflows an {@code int}.
 </summary>
 <param name="x"> the first value </param>
 <param name="y"> the second value </param>
 <returns> the result </returns>
 <exception cref="T:System.ArithmeticException"> if the result overflows an int
 @since 1.8 </exception>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.addExact(System.Int64,System.Int64)">
 <summary>
 Returns the sum of its arguments,
 throwing an exception if the result overflows a {@code long}.
 </summary>
 <param name="x"> the first value </param>
 <param name="y"> the second value </param>
 <returns> the result </returns>
 <exception cref="T:System.ArithmeticException"> if the result overflows a long
 @since 1.8 </exception>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.subtractExact(System.Int32,System.Int32)">
 <summary>
 Returns the difference of the arguments,
 throwing an exception if the result overflows an {@code int}.
 </summary>
 <param name="x"> the first value </param>
 <param name="y"> the second value to subtract from the first </param>
 <returns> the result </returns>
 <exception cref="T:System.ArithmeticException"> if the result overflows an int
 @since 1.8 </exception>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.subtractExact(System.Int64,System.Int64)">
 <summary>
 Returns the difference of the arguments,
 throwing an exception if the result overflows a {@code long}.
 </summary>
 <param name="x"> the first value </param>
 <param name="y"> the second value to subtract from the first </param>
 <returns> the result </returns>
 <exception cref="T:System.ArithmeticException"> if the result overflows a long
 @since 1.8 </exception>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.multiplyExact(System.Int32,System.Int32)">
 <summary>
 Returns the product of the arguments,
 throwing an exception if the result overflows an {@code int}.
 </summary>
 <param name="x"> the first value </param>
 <param name="y"> the second value </param>
 <returns> the result </returns>
 <exception cref="T:System.ArithmeticException"> if the result overflows an int
 @since 1.8 </exception>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.multiplyExact(System.Int64,System.Int64)">
 <summary>
 Returns the product of the arguments,
 throwing an exception if the result overflows a {@code long}.
 </summary>
 <param name="x"> the first value </param>
 <param name="y"> the second value </param>
 <returns> the result </returns>
 <exception cref="T:System.ArithmeticException"> if the result overflows a long
 @since 1.8 </exception>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.incrementExact(System.Int32)">
 <summary>
 Returns the argument incremented by one, throwing an exception if the
 result overflows an {@code int}.
 </summary>
 <param name="a"> the value to increment </param>
 <returns> the result </returns>
 <exception cref="T:System.ArithmeticException"> if the result overflows an int
 @since 1.8 </exception>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.incrementExact(System.Int64)">
 <summary>
 Returns the argument incremented by one, throwing an exception if the
 result overflows a {@code long}.
 </summary>
 <param name="a"> the value to increment </param>
 <returns> the result </returns>
 <exception cref="T:System.ArithmeticException"> if the result overflows a long
 @since 1.8 </exception>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.decrementExact(System.Int32)">
 <summary>
 Returns the argument decremented by one, throwing an exception if the
 result overflows an {@code int}.
 </summary>
 <param name="a"> the value to decrement </param>
 <returns> the result </returns>
 <exception cref="T:System.ArithmeticException"> if the result overflows an int
 @since 1.8 </exception>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.decrementExact(System.Int64)">
 <summary>
 Returns the argument decremented by one, throwing an exception if the
 result overflows a {@code long}.
 </summary>
 <param name="a"> the value to decrement </param>
 <returns> the result </returns>
 <exception cref="T:System.ArithmeticException"> if the result overflows a long
 @since 1.8 </exception>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.negateExact(System.Int32)">
 <summary>
 Returns the negation of the argument, throwing an exception if the
 result overflows an {@code int}.
 </summary>
 <param name="a"> the value to negate </param>
 <returns> the result </returns>
 <exception cref="T:System.ArithmeticException"> if the result overflows an int
 @since 1.8 </exception>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.negateExact(System.Int64)">
 <summary>
 Returns the negation of the argument, throwing an exception if the
 result overflows a {@code long}.
 </summary>
 <param name="a"> the value to negate </param>
 <returns> the result </returns>
 <exception cref="T:System.ArithmeticException"> if the result overflows a long
 @since 1.8 </exception>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.toIntExact(System.Int64)">
 <summary>
 Returns the value of the {@code long} argument;
 throwing an exception if the value overflows an {@code int}.
 </summary>
 <param name="value"> the long value </param>
 <returns> the argument as an int </returns>
 <exception cref="T:System.ArithmeticException"> if the {@code argument} overflows an int
 @since 1.8 </exception>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.floorDiv(System.Int32,System.Int32)">
 <summary>
 Returns the largest (closest to positive infinity)
 {@code int} value that is less than or equal to the algebraic quotient.
 There is one special case, if the dividend is the
  Integer#MIN_VALUE  java.lang.[Integer].MIN_VALUE"/> and the divisor is {@code -1},
 then integer overflow occurs and
 the result is equal to the {@code  java.lang.[Integer].MIN_VALUE}.
 
 Normal integer division operates under the round to zero rounding mode
 (truncation).  This operation instead acts under the round toward
 negative infinity (floor) rounding mode.
 The floor rounding mode gives different results than truncation
 when the exact result is negative.
 
   + If the signs of the arguments are the same, the results of
       {@code floorDiv} and the {@code /} operator are the same.  
       For example, {@code floorDiv(4, 3) == 1} and {@code (4 / 3) == 1}.
   + If the signs of the arguments are different,  the quotient is negative and
       {@code floorDiv} returns the integer less than or equal to the quotient
       and the {@code /} operator returns the integer closest to zero.
       For example, {@code floorDiv(-4, 3) == -2},
       whereas {@code (-4 / 3) == -1}.
 </summary>
 <param name="x"> the dividend </param>
 <param name="y"> the divisor </param>
 <returns> the largest (closest to positive infinity)
 {@code int} value that is less than or equal to the algebraic quotient. </returns>
 <exception cref="T:System.ArithmeticException"> if the divisor {@code y} is zero </exception>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.floorDiv(System.Int64,System.Int64)">
 <summary>
 Returns the largest (closest to positive infinity)
 {@code long} value that is less than or equal to the algebraic quotient.
 There is one special case, if the dividend is the
  Long#MIN_VALUE java.lang.[Long].MIN_VALUE"/> and the divisor is {@code -1},
 then integer overflow occurs and
 the result is equal to the {@code java.lang.[Long].MIN_VALUE}.
 
 Normal integer division operates under the round to zero rounding mode
 (truncation).  This operation instead acts under the round toward
 negative infinity (floor) rounding mode.
 The floor rounding mode gives different results than truncation
 when the exact result is negative.
 
 For examples, see  #floorDiv(int, int)"/>.
 </summary>
 <param name="x"> the dividend </param>
 <param name="y"> the divisor </param>
 <returns> the largest (closest to positive infinity)
 {@code long} value that is less than or equal to the algebraic quotient. </returns>
 <exception cref="T:System.ArithmeticException"> if the divisor {@code y} is zero </exception>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.floorMod(System.Int32,System.Int32)">
 <summary>
 Returns the floor modulus of the {@code int} arguments.
 
 The floor modulus is {@code x - (floorDiv(x, y) * y)},
 has the same sign as the divisor {@code y}, and
 is in the range of {@code -abs(y) &lt; r &lt; +abs(y)}.
 
 
 The relationship between {@code floorDiv} and {@code floorMod} is such that:
 
   + {@code floorDiv(x, y) * y + floorMod(x, y) == x}
 
 
 The difference in values between {@code floorMod} and
 the {@code %} operator is due to the difference between
 {@code floorDiv} that returns the integer less than or equal to the quotient
 and the {@code /} operator that returns the integer closest to zero.
 
 Examples:
 
   + If the signs of the arguments are the same, the results
       of {@code floorMod} and the {@code %} operator are the same.   
       
       + {@code floorMod(4, 3) == 1};   and {@code (4 % 3) == 1} 
       
   + If the signs of the arguments are different, the results differ from the {@code %} operator. 
      
      + {@code floorMod(+4, -3) == -2};   and {@code (+4 % -3) == +1}  
      + {@code floorMod(-4, +3) == +2};   and {@code (-4 % +3) == -1}  
      + {@code floorMod(-4, -3) == -1};   and {@code (-4 % -3) == -1 }  
      
    
 
 
 If the signs of arguments are unknown and a positive modulus
 is needed it can be computed as {@code (floorMod(x, y) + abs(y)) % abs(y)}.
 </summary>
 <param name="x"> the dividend </param>
 <param name="y"> the divisor </param>
 <returns> the floor modulus {@code x - (floorDiv(x, y) * y)} </returns>
 <exception cref="T:System.ArithmeticException"> if the divisor {@code y} is zero </exception>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.floorMod(System.Int64,System.Int64)">
 <summary>
 Returns the floor modulus of the {@code long} arguments.
 
 The floor modulus is {@code x - (floorDiv(x, y) * y)},
 has the same sign as the divisor {@code y}, and
 is in the range of {@code -abs(y) &lt; r &lt; +abs(y)}.
 
 
 The relationship between {@code floorDiv} and {@code floorMod} is such that:
 
   + {@code floorDiv(x, y) * y + floorMod(x, y) == x}
 
 
 For examples, see  #floorMod(int, int)"/>.
 </summary>
 <param name="x"> the dividend </param>
 <param name="y"> the divisor </param>
 <returns> the floor modulus {@code x - (floorDiv(x, y) * y)} </returns>
 <exception cref="T:System.ArithmeticException"> if the divisor {@code y} is zero </exception>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.abs(System.Int32)">
 <summary>
 Returns the absolute value of an {@code int} value.
 If the argument is not negative, the argument is returned.
 If the argument is negative, the negation of the argument is returned.
 
 Note that if the argument is equal to the value of
  Integer#MIN_VALUE"/>, the most negative representable
 {@code int} value, the result is that same value, which is
 negative.
 </summary>
 <param name="a">   the argument whose absolute value is to be determined </param>
 <returns>  the absolute value of the argument. </returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.abs(System.Int64)">
 <summary>
 Returns the absolute value of a {@code long} value.
 If the argument is not negative, the argument is returned.
 If the argument is negative, the negation of the argument is returned.
 
 Note that if the argument is equal to the value of
  Long#MIN_VALUE"/>, the most negative representable
 {@code long} value, the result is that same value, which
 is negative.
 </summary>
 <param name="a">   the argument whose absolute value is to be determined </param>
 <returns>  the absolute value of the argument. </returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.abs(System.Single)">
 <summary>
 Returns the absolute value of a {@code float} value.
 If the argument is not negative, the argument is returned.
 If the argument is negative, the negation of the argument is returned.
 Special cases:
 + If the argument is positive zero or negative zero, the
 result is positive zero.
 + If the argument is infinite, the result is positive infinity.
 + If the argument is NaN, the result is NaN.
 In other words, the result is the same as the value of the expression:
 {@code Float.intBitsToFloat(0x7fffffff &amp; Float.floatToIntBits(a))}
 </summary>
 <param name="a">   the argument whose absolute value is to be determined </param>
 <returns>  the absolute value of the argument. </returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.abs(System.Double)">
 <summary>
 Returns the absolute value of a {@code double} value.
 If the argument is not negative, the argument is returned.
 If the argument is negative, the negation of the argument is returned.
 Special cases:
 + If the argument is positive zero or negative zero, the result
 is positive zero.
 + If the argument is infinite, the result is positive infinity.
 + If the argument is NaN, the result is NaN.
 In other words, the result is the same as the value of the expression:
 {@code java.lang.[Double].longBitsToDouble((Double.doubleToLongBits(a)&lt;&lt;1)>>>1)}
 </summary>
 <param name="a">   the argument whose absolute value is to be determined </param>
 <returns>  the absolute value of the argument. </returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.max(System.Int32,System.Int32)">
 <summary>
 Returns the greater of two {@code int} values. That is, the
 result is the argument closer to the value of
  Integer#MAX_VALUE"/>. If the arguments have the same value,
 the result is that same value.
 </summary>
 <param name="a">   an argument. </param>
 <param name="b">   another argument. </param>
 <returns>  the larger of {@code a} and {@code b}. </returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.max(System.Int64,System.Int64)">
 <summary>
 Returns the greater of two {@code long} values. That is, the
 result is the argument closer to the value of
  Long#MAX_VALUE"/>. If the arguments have the same value,
 the result is that same value.
 </summary>
 <param name="a">   an argument. </param>
 <param name="b">   another argument. </param>
 <returns>  the larger of {@code a} and {@code b}. </returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.min(System.Int32,System.Int32)">
 <summary>
 Returns the smaller of two {@code int} values. That is,
 the result the argument closer to the value of
  Integer#MIN_VALUE"/>.  If the arguments have the same
 value, the result is that same value.
 </summary>
 <param name="a">   an argument. </param>
 <param name="b">   another argument. </param>
 <returns>  the smaller of {@code a} and {@code b}. </returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.min(System.Int64,System.Int64)">
 <summary>
 Returns the smaller of two {@code long} values. That is,
 the result is the argument closer to the value of
  Long#MIN_VALUE"/>. If the arguments have the same
 value, the result is that same value.
 </summary>
 <param name="a">   an argument. </param>
 <param name="b">   another argument. </param>
 <returns>  the smaller of {@code a} and {@code b}. </returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.sinh(System.Double)">
 <summary>
 Returns the hyperbolic sine of a {@code double} value.
 The hyperbolic sine of _x_ is defined to be
 (_e<sup>x</sup> - e<sup>-x</sup>_)/2
 where _e_ is  Math#E Euler's number"/>.
 
 Special cases:
 
 
 + If the argument is NaN, then the result is NaN.
 
 + If the argument is infinite, then the result is an infinity
 with the same sign as the argument.
 
 + If the argument is zero, then the result is a zero with the
 same sign as the argument.
 
 
 
 The computed result must be within 2.5 ulps of the exact result.
 </summary>
 <param name="x"> The number whose hyperbolic sine is to be returned. </param>
 <returns>  The hyperbolic sine of {@code x}.
 @since 1.5 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.cosh(System.Double)">
 <summary>
 Returns the hyperbolic cosine of a {@code double} value.
 The hyperbolic cosine of _x_ is defined to be
 (_e<sup>x</sup> + e<sup>-x</sup>_)/2
 where _e_ is  Math#E Euler's number"/>.
 
 Special cases:
 
 
 + If the argument is NaN, then the result is NaN.
 
 + If the argument is infinite, then the result is positive
 infinity.
 
 + If the argument is zero, then the result is {@code 1.0}.
 
 
 
 The computed result must be within 2.5 ulps of the exact result.
 </summary>
 <param name="x"> The number whose hyperbolic cosine is to be returned. </param>
 <returns>  The hyperbolic cosine of {@code x}.
 @since 1.5 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.tanh(System.Double)">
 <summary>
 Returns the hyperbolic tangent of a {@code double} value.
 The hyperbolic tangent of _x_ is defined to be
 (_e<sup>x</sup> - e<sup>-x</sup>_)/(_e<sup>x</sup> + e<sup>-x</sup>_),
 in other words, {@link Math#sinh
 sinh(_x_)}/ Math#cosh cosh(_x_)"/>.  Note
 that the absolute value of the exact tanh is always less than
 1.
 
 Special cases:
 
 
 + If the argument is NaN, then the result is NaN.
 
 + If the argument is zero, then the result is a zero with the
 same sign as the argument.
 
 + If the argument is positive infinity, then the result is
 {@code +1.0}.
 
 + If the argument is negative infinity, then the result is
 {@code -1.0}.
 
 
 
 The computed result must be within 2.5 ulps of the exact result.
 The result of {@code tanh} for any finite input must have
 an absolute value less than or equal to 1.  Note that once the
 exact result of tanh is within 1/2 of an ulp of the limit value
 of 1, correctly signed {@code 1.0} should be returned.
 </summary>
 <param name="x"> The number whose hyperbolic tangent is to be returned. </param>
 <returns>  The hyperbolic tangent of {@code x}.
 @since 1.5 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.Expm1(System.Double)">
 <summary>
 Returns _e_<sup>x</sup> -1.  Note that for values of
 _x_ near 0, the exact sum of
 {@code expm1(x)} + 1 is much closer to the true
 result of _e_<sup>x</sup> than {@code exp(x)}.
 
 Special cases:
 
 + If the argument is NaN, the result is NaN.
 
 + If the argument is positive infinity, then the result is
 positive infinity.
 
 + If the argument is negative infinity, then the result is
 -1.0.
 
 + If the argument is zero, then the result is a zero with the
 same sign as the argument.
 
 
 
 The computed result must be within 1 ulp of the exact result.
 Results must be semi-monotonic.  The result of
 {@code expm1} for any finite input must be greater than or
 equal to {@code -1.0}.  Note that once the exact result of
 _e_<sup>{@code x}</sup> - 1 is within 1/2
 ulp of the limit value -1, {@code -1.0} should be
 returned.
 </summary>
 <param name="x">   the exponent to raise _e_ to in the computation of
              _e_<sup>{@code x}</sup> -1. </param>
 <returns>  the value _e_<sup>{@code x}</sup> - 1.
 @since 1.5 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.log1p(System.Double)">
 <summary>
 Returns the natural logarithm of the sum of the argument and 1.
 Note that for small values {@code x}, the result of
 {@code log1p(x)} is much closer to the true result of ln(1
 + {@code x}) than the floating-point evaluation of
 {@code log(1.0+x)}.
 
 Special cases:
 
 
 
 + If the argument is NaN or less than -1, then the result is
 NaN.
 
 + If the argument is positive infinity, then the result is
 positive infinity.
 
 + If the argument is negative one, then the result is
 negative infinity.
 
 + If the argument is zero, then the result is a zero with the
 same sign as the argument.
 
 
 
 The computed result must be within 1 ulp of the exact result.
 Results must be semi-monotonic.
 </summary>
 <param name="x">   a value </param>
 <returns> the value ln({@code x} + 1), the natural
 log of {@code x} + 1
 @since 1.5 </returns>
 <remarks>http://www.johndcook.com/csharp_log_one_plus_x.html</remarks>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.JavaMath.log1m(System.Double)">
 <summary>
 Computes log(1-x) without losing precision for small values of x.
 </summary>
 
</member>
<member name="T:Microsoft.VisualBasic.Language.Java.LogTricks">
 <summary>
 @author Marc Suchard
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Language.Java.MathUtils">
 <summary>
 Handy utility functions which have some Mathematical relavance.
 
 @author Matthew Goode
 @author Alexei Drummond
 @author Gerton Lunter
 @version $Id: MathUtils.java,v 1.13 2006/08/31 14:57:24 rambaut Exp $
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.MathUtils.randomChoice(System.Double[])">
 <summary>
 Chooses one category if a cumulative probability distribution is given 
 </summary>
 <param name="cf"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.MathUtils.randomChoicePDF(System.Double[])">
 <param name="pdf">
            array of unnormalized probabilities </param>
 <returns> a sample according to an unnormalized probability distribution </returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.MathUtils.getNormalized(System.Double[])">
 <param name="array">
            to normalize </param>
 <returns> a new double array where all the values sum to 1. Relative ratios
         are preserved. </returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.MathUtils.getTotal(System.Double[],System.Int32,System.Int32)">
 <param name="array">
            entries to be summed </param>
 <param name="start">
            start position </param>
 <param name="end">
            the index of the element after the last one to be included </param>
 <returns> the total of a the values in a range of an array </returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.MathUtils.getTotal(System.Double[])">
 <param name="array">
            to sum over </param>
 <returns> the total of the values in an array </returns>
</member>
<member name="P:Microsoft.VisualBasic.Language.Java.MathUtils.Seed">
 <summary>
 Access a default instance of this class, access is synchronized
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.MathUtils.nextByte">
 <summary>
 Access a default instance of this class, access is synchronized
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.MathUtils.nextBoolean">
 <summary>
 Access a default instance of this class, access is synchronized
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.MathUtils.nextBytes(System.SByte[])">
 <summary>
 Access a default instance of this class, access is synchronized
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.MathUtils.nextGaussian">
 <summary>
 Access a default instance of this class, access is synchronized
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.MathUtils.randomLogDouble">
 <returns> log of random variable in [0,1] </returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.MathUtils.nextExponential(System.Double)">
 <summary>
 Access a default instance of this class, access is synchronized
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.MathUtils.nextInverseGaussian(System.Double,System.Double)">
 <summary>
 Access a default instance of this class, access is synchronized
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.MathUtils.uniform(System.Double,System.Double)">
 
 <param name="low"> </param>
 <param name="high"> </param>
 <returns> uniform between low and high </returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.MathUtils.shuffle(System.Int32[])">
 <summary>
 Shuffles an array.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.MathUtils.shuffle(System.Int32[],System.Int32)">
 <summary>
 Shuffles an array. Shuffles numberOfShuffles times
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.MathUtils.shuffled(System.Int32)">
 <summary>
 Returns an array of shuffled indices of length l.
 </summary>
 <param name="l">
            length of the array required. </param>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.MathUtils.permute(System.Int32[])">
 <summary>
 Permutes an array.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.MathUtils.permuted(System.Int32)">
 <summary>
 Returns a uniform random permutation of 0,...,l-1
 </summary>
 <param name="l">
            length of the array required. </param>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.MathUtils.hypot(System.Double,System.Double)">
 <summary>
 Returns sqrt(a^2 + b^2) without under/overflow.
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Language.Java.NamespaceDoc">
 <summary>
 Helper for translate ``Java`` source file to VB.NET source file.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Language.Java.Reflection.GetConstructor(System.Type)">
 <summary>
 Gets the default class constructor
 
 ```vbnet
 Dim o As New &lt;<paramref name="type"/>>()
 ```
 </summary>
 <param name="type"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Language.Perl.ExceptionHandle">
 <summary>
 Syntax supports for perl language like exception handler
 
 ```vbnet
 Dim value = func() or die("message")
 ```
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Language.Perl.ExceptionHandle.Default(System.Object)">
 <summary>
 Returns True means test failure(<paramref name="obj"/> is nothing or empty!)
 </summary>
 <param name="obj"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Perl.ExceptionHandle.op_BitwiseOr(System.Object,Microsoft.VisualBasic.Language.Perl.ExceptionHandle)">
 <summary>
 Perl like exception handler syntax for testing the result is failure or not?
 </summary>
 <param name="result"></param>
 <param name="h"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Language.Perl.Functions">
 <summary>
 
 </summary>
 <remarks>
 ##### last
 
 The ``last`` command Is Like the ``break`` statement In C (As used In loops); **it immediately exits the Loop In question**. 
 If the ``LABEL`` Is omitted, the command refers To the innermost enclosing Loop. The last EXPR form, available starting 
 In Perl 5.18.0, allows a label name To be computed at run time, And Is otherwise identical To last ``LABEL``. 
 
 **The Continue block, If any, Is Not executed**
 (Perl里面的``last``关键词相当于vb里面的``Exit Do``或者``Exit For``)
 
 匹配：``m/&lt;regexp>/`` (还可以简写为 /&lt;regexp>/, 略去 m)
 替换：``s/&lt;pattern>/&lt;replacement>/``
 转化：``tr/&lt;pattern>/&lt;replacemnt>/``
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Language.Perl.Functions.Push``1(``0[]@,``0)">
 <summary>
 Treats ARRAY as a stack by appending the values of LIST to the end of ARRAY. The length of ARRAY 
 increases by the length of LIST. Has the same effect as
 
 ```perl
 for my $value (LIST) {
     $ARRAY[++$#ARRAY] = $value;
 }
 ```
 
 but Is more efficient. Returns the number of elements in the array following the completed push.
 Starting with Perl 5.14, an experimental feature allowed push to take a scalar expression. 
 This experiment has been deemed unsuccessful, And was removed as of Perl 5.24.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="array"></param>
 <param name="x"></param>
 
</member>
<member name="M:Microsoft.VisualBasic.Language.Perl.Functions.Push``1(``0[]@,System.Collections.Generic.IEnumerable{``0})">
 <summary>
 Treats ARRAY as a stack by appending the values of LIST to the end of ARRAY. The length of ARRAY 
 increases by the length of LIST. Has the same effect as
 
 ```perl
 for my $value (LIST) {
     $ARRAY[++$#ARRAY] = $value;
 }
 ```
 
 but Is more efficient. Returns the number of elements in the array following the completed push.
 Starting with Perl 5.14, an experimental feature allowed push to take a scalar expression. 
 This experiment has been deemed unsuccessful, And was removed as of Perl 5.24.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="array"></param>
 <param name="LIST"></param>
</member>
<member name="M:Microsoft.VisualBasic.Language.Perl.Functions.Pop``1(``0[]@)">
 <summary>
 ##### pop ARRAY
 
 **pop**
 Pops And returns the last value of the array, shortening the array by one element.
 
 Returns the undefined value If the array Is empty, although this may also happen at 
 other times. If ARRAY Is omitted, pops the @ARGV array In the main program, but the 
 @_ array In subroutines, just Like shift.
 
 Starting with Perl 5.14, an experimental feature allowed pop to take a scalar expression. 
 This experiment has been deemed unsuccessful, And was removed as of Perl 5.24.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="array"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Perl.Functions.system(System.String)">
 <summary>
 Does exactly the same thing as exec, except that a fork is done first and the parent process waits for the 
 child process to exit. Note that argument processing varies depending on the number of arguments. If there 
 is more than one argument in LIST, or if LIST is an array with more than one value, starts the program 
 given by the first element of the list with arguments given by the rest of the list. If there is only one 
 scalar argument, the argument is checked for shell metacharacters, and if there are any, the entire argument 
 is passed to the system's command shell for parsing (this is /bin/sh -c on Unix platforms, but varies on 
 other platforms). If there are no shell metacharacters in the argument, it is split into words and passed 
 directly to execvp , which is more efficient. On Windows, only the system PROGRAM LIST syntax will reliably 
 avoid using the shell; system LIST , even with more than one element, will fall back to the shell if the 
 first spawn fails.
 Perl will attempt To flush all files opened For output before any operation that may Do a fork, but this 
 may Not be supported On some platforms (see perlport). To be safe, you may need To Set $ ($AUTOFLUSH In 
 English) Or Call the autoflush method Of IO:Handle on any open handles.
 The return value Is the exit status of the program as returned by the wait call. To get the actual exit 
 value, shift right by eight (see below). See also exec. This Is Not what you want to use to capture the 
 output from a command; for that you should use merely backticks Or qx//, as described in `STRING` in perlop. 
 Return value of -1 indicates a failure to start the program Or an error of the wait(2) system call 
 (inspect $! for the reason).
 If you 'd like to make system (and many other bits of Perl) die on error, have a look at the autodie pragma.
 Like exec, system allows you to lie to a program about its name if you use the system PROGRAM LIST syntax. 
 Again, see exec.
 </summary>
 <param name="CLI"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Perl.Functions.chomp(System.String@)">
 <summary>
 This safer version of chop removes any trailing string that corresponds to the current value of ``$/`` 
 (also known as ``$INPUT_RECORD_SEPARATOR`` in the English module). It returns the total number of characters 
 removed from all its arguments. It's often used to remove the newline from the end of an input record 
 when you're worried that the final record may be missing its newline. When in paragraph mode (``$/ = ''`` ), 
 it removes all trailing newlines from the string. When in slurp mode (``$/ = undef`` ) or fixed-length 
 record mode (``$/`` is a reference to an integer or the like; see perlvar), chomp won't remove anything.
 </summary>
 <param name="s"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Perl.Functions.chomp(System.Collections.Generic.IEnumerable{System.String}@)">
 <summary>
 If you chomp a ``list`` or ``array``, each element is chomped, and the total number of characters removed is returned.
 </summary>
 <param name="source"></param>
</member>
<member name="M:Microsoft.VisualBasic.Language.Perl.Functions.chomp(System.Collections.Generic.Dictionary{System.String,System.String}@)">
 <summary>
 If ``VARIABLE`` is a hash, it chomps the hash's values, but not its keys, resetting the each iterator 
 in the process.
 
 You can actually chomp anything that's an ``lvalue``, including an assignment:
 
 ```perl
 chomp(my $cwd = `pwd`);
 chomp(my $answer = &lt;STDIN>);
 ```
 </summary>
 <param name="hash"></param>
</member>
<member name="M:Microsoft.VisualBasic.Language.Perl.Functions.chomp(Microsoft.VisualBasic.ComponentModel.Collection.Dictionary{Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedValue{System.String}}@)">
 <summary>
 If ``VARIABLE`` is a hash, it chomps the hash's values, but not its keys, resetting the each iterator 
 in the process.
 
 You can actually chomp anything that's an ``lvalue``, including an assignment:
 
 ```perl
 chomp(my $cwd = `pwd`);
 chomp(my $answer = &lt;STDIN>);
 ```
 </summary>
 <param name="hash"></param>
</member>
<member name="M:Microsoft.VisualBasic.Language.Python.Collection.slice``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Int32,System.Int32)">
 <summary>
 将序列之中的指定区域的内容取出来
 </summary>
 <typeparam name="T"></typeparam>
 <param name="[set]"></param>
 <param name="start"></param>
 <param name="[stop]">
 可以接受负数，如果为负数，则表示终止的下标为长度将去这个stop值的结果，即从后往前数
 </param>
 <param name="[step]"></param>
 <returns></returns>
 <remarks>
 20210810 test success by kdtree
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Language.Python.Collection.SpanSlice``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Int32)">
 <summary>
 Forms a slice out of the current span starting at a specified index for a specified length.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="span"></param>
 <param name="start">The index at which to begin this slice.</param>
 <param name="length">The desired length for the slice.</param>
 <returns></returns>
 
</member>
<member name="T:Microsoft.VisualBasic.Language.Python.NamedTuple">
 <summary>
 ``namedtuple()`` Factory Function for Tuples with Named Fields
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Language.Python.NamespaceDoc">
 <summary>
 Helper for translate ``Python`` source file to VB.NET source file.
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Language.Python.re">
 <summary>
 This module provides regular expression matching operations similar to those found in Perl. ``re`` module in the python language.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Language.Python.re.Match.ToString">
 <summary>
 <see cref="P:System.Text.RegularExpressions.Capture.Value"/>
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Python.re.FindAll(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
 <summary>
 Return all non-overlapping matches of pattern in string, as a list of strings. The string is scanned left-to-right, and matches are returned in the order found. 
 If one or more groups are present in the pattern, return a list of groups; this will be a list of tuples if the pattern has more than one group. 
 Empty matches are included in the result unless they touch the beginning of another match.
 </summary>
 <param name="pattern">这个会首先被分行然后去除掉python注释</param>
 <param name="input"></param>
 <param name="options"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Python.re.__trimComment(System.String)">
 <summary>
 假设所有的注释都是由#和一个空格开始起始的 ``# ``
 </summary>
 <param name="s"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Language.UnixBash.CowsayTricks">
 <summary>
 Cowsay tricks for showing your message more friendly.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Language.UnixBash.CowsayTricks.NormalCow">
 <summary>
 Normal cow
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Language.UnixBash.CowsayTricks.DeadCow">
 <summary>
 The cow in dead face
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Language.UnixBash.CowsayTricks.RunCowsay(System.String,System.Boolean)">
 <summary>
 Show cowsay with a specific input message on your console screen. you can using /dead to change its face.
 </summary>
 <param name="msg"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Language.UnixBash.CowsayTricks.__msgbox(System.String)">
 <summary>
 Creates the message box to display the message for the cow on the console.
 </summary>
 <param name="msg"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Language.UnixBash.FileSystem.File">
 <summary>
 Asbtract file IO model
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Language.UnixBash.FileSystem.FileHandle">
 <summary>
 文件系统对象的句柄
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Language.UnixBash.FileSystem.FileHandle.IsHTTP">
 <summary>
 Determined that is this filename is a network location.
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Language.UnixBash.PS1">
 <summary>
 PS (Prompt Sign)
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Language.UnixBash.PS1.H">
 <summary>
 ``\H`` 完整的主机名称
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Language.UnixBash.PS1.hl">
 <summary>
 ``\h`` 仅取主机名称的第一个名字
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Language.UnixBash.PS1.#ctor(System.String)">
 <summary>
 
 </summary>
 <param name="ps1"></param>
 <remarks>
 Example as:
 
 ```vbnet
 ' Fedora 12
 PS1='[\u@\h \w \A #\#]\$ '
 ```
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Language.UnixBash.PS1.Fedora12">
 <summary>
 Fedora 12 PS1 variable of the bash shell: ``[\u@\h \w \A #\#]\$ ``
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.UnixBash.PS1.ToString">
 <summary>
 Display the commandline prompt.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.UnixBash.PS1.n">
 <summary>
 ``\#`` 下达的第几个指令。
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.UnixBash.PS1.r">
 <summary>
 ``\$`` 提示字符，如果是``root``时，提示字符为``#``，否则就是``$``。
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.UnixBash.PS1.T">
 <summary>
 ``\T`` 显示时间, 12 小时的时间格式!
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.UnixBash.PS1.tl">
 <summary>
 ``\t`` 显示时间, 为 24 小时格式, 如: ``HH:MM:SS``
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.UnixBash.PS1.A">
 <summary>
 ``\A`` 显示时间, 24小时格式: ``HH:MM``
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.UnixBash.PS1.u">
 <summary>
 ``\u`` 目前使用者的账号名称
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.UnixBash.PS1.v">
 <summary>
 ``\v`` ``BASH``的版本信息
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.UnixBash.PS1.wl">
 <summary>
 ``\w`` 完整的工作目录名称。家目录会以``~``取代
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.UnixBash.PS1.W">
 <summary>
 ``\W`` 利用``<see cref="M:Microsoft.VisualBasic.PathExtensions.BaseName(System.String,System.Boolean)"/>``取得工作目录名称，所以仅会列出最后一个目录名。
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.UnixBash.PS1.d">
 <summary>
 ``\d`` 代表日期, 格式为``Weekday Month Date``, 例如``Mon Aug 1``
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Language.UnixBash.ShellSyntax">
 <summary>
 VB.NET language shell syntax supports exports
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Language.UnixBash.ShellSyntax.ls">
 <summary>
 ``ls -l -ext("*.xml") &lt;= DIR``,  The filesystem search proxy
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Language.UnixBash.ShellSyntax.l">
 <summary>
 Long name(DIR+fiename), if not only file name.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Language.UnixBash.ShellSyntax.r">
 <summary>
 递归的搜索
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Language.UnixBash.ShellSyntax.lsDIR">
 <summary>
 Searching the directory, if this parameter is not presents, then returns search file.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.UnixBash.ShellSyntax.wildcards(System.String[])">
 <summary>
 可以使用这个来限定文件或者文件夹对象的搜索范围
 </summary>
 <param name="__wildcards">可以为文件拓展或者对文件名的通配符的表达式，假若这个是空的，则会默认搜索所有文件*.*</param>
 <returns></returns>
</member>
<member name="F:Microsoft.VisualBasic.Language.UnixBash.Search.opts">
 <summary>
 The search options
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Language.UnixBash.Search.op_Subtraction(Microsoft.VisualBasic.Language.UnixBash.Search,Microsoft.VisualBasic.Language.UnixBash.SearchOpt)">
 <summary>
 Add a search options
 </summary>
 <param name="ls"></param>
 <param name="l"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.UnixBash.Search.op_Subtraction(Microsoft.VisualBasic.Language.UnixBash.Search,System.String[])">
 <summary>
 Add a set of wildcards patterns for path match
 </summary>
 <param name="ls"></param>
 <param name="wildcards$"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Language.UnixBash.Search.op_Subtraction(Microsoft.VisualBasic.Language.UnixBash.Search,System.String)">
 <summary>
 Add wildcard pattern for path match
 </summary>
 <param name="ls"></param>
 <param name="wildcards$"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.UnixBash.Search.op_LessThan(Microsoft.VisualBasic.Language.UnixBash.Search,System.String)">
 <summary>
 Search the files in the specific directory
 </summary>
 <param name="ls"></param>
 <param name="DIR"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Language.UnixBash.Search.op_LessThanOrEqual(Microsoft.VisualBasic.Language.UnixBash.Search,System.String)">
 <summary>
 Search the files in the specific directory
 </summary>
 <param name="ls"></param>
 <param name="directory"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.UnixBash.Search.DoFileNameGreps(Microsoft.VisualBasic.Language.UnixBash.Search,System.Collections.Generic.IEnumerable{System.String})">
 <summary>
 make file path list filtering
 </summary>
 <param name="ls">the filter options</param>
 <param name="files">a collection of the file path</param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Language.UnixBash.wildcardsCompatible">
 <summary>
 Using regular expression to find a match on the file name.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Language.UnixBash.wildcardsCompatible.usingRegexp">
 <summary>
 Using the regexp engine instead of the wildcard match engine?
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Language.UnixBash.wildcardsCompatible.opt">
 <summary>
 Windows系统上面文件路径不区分大小写，但是Linux、Mac系统却区分大小写
 所以使用这个来保持对Windows文件系统的兼容性
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Language.UnixBash.wildcardsCompatible.IsMatch(System.String)">
 <summary>
 Linux/Mac系统不支持Windows系统的通配符，所以在这里是用正则表达式来保持代码的兼容性
 </summary>
 <param name="path"></param>
 <returns></returns>
</member>
<member name="F:Microsoft.VisualBasic.Language.UnixBash.SearchOpt.Options.Directory">
 <summary>
 List directories, not files listing.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Language.UnixBash.SearchOpt.Options.Recursive">
 <summary>
 递归搜索所有的文件夹
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Language.UnixBash.FileDelete">
 <summary>
 ``rm -rf /*``
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Language.UnixBash.TextAPI.grep">
 <summary>
 grep (global search regular expression(RE) and print out the line
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Language.UnixBash.TextAPI.f">
 <summary>
 Text source of the grep operation is a file.
 </summary>
 <returns></returns>
</member>
<member name="F:Microsoft.VisualBasic.Language.UnixBash.GrepOptions.a">
 <summary>
 将 binary 文件以 text 文件的方式搜寻数据
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Language.UnixBash.GrepOptions.c">
 <summary>
 计算找到 '搜寻字符串' 的次数
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Language.UnixBash.GrepOptions.i">
 <summary>
 忽略大小写的不同，所以大小写视为相同
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Language.UnixBash.GrepOptions.n">
 <summary>
 顺便输出行号
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Language.UnixBash.GrepOptions.v">
 <summary>
 反向选择，亦即显示出没有 '搜寻字符串' 内容的那一行！
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Language.UnixBash.GrepRegx">
 <summary>
 grep -acinv * "pattern" &lt;= "filename or text" |
 grep -acinv * "pattern" &lt;&lt; "filename"
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Language.UnixBash.tree">
 <summary>
 ```bash
 ``tree | awk -F: '{print '}|tail -n1``
 # 865 directories, 7957 files
 ```
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Language.AssertEqualsExtensions.All``1(Microsoft.VisualBasic.Language.Vectorization.Vector{``0})">
 <summary>
 Assert that all of the elements in target vector match the test conditions
 </summary>
 <typeparam name="T"></typeparam>
 <param name="vector"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.AssertEqualsExtensions.Any``1(Microsoft.VisualBasic.Language.Vectorization.Vector{``0})">
 <summary>
 Assert that any of the elements in target vector match the test conditions
 </summary>
 <typeparam name="T"></typeparam>
 <param name="vector"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.AssertAll`1.op_Equality(Microsoft.VisualBasic.Language.AssertAll{`0},`0)">
 <summary>
 Does the elements in this vector all equals to a specific value <paramref name="x"/>?
 </summary>
 <param name="assert"></param>
 <param name="x"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Language.AssertAny`1.op_Equality(Microsoft.VisualBasic.Language.AssertAny{`0},`0)">
 <summary>
 Does the elements in this vector all equals to a specific value <paramref name="x"/>?
 </summary>
 <param name="assert"></param>
 <param name="x"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Language.Indexer.Indexing(System.Object)">
 <summary>
 Generates the vector elements index collection.
 </summary>
 <param name="args"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Language.LanguageExtensions">
 <summary>
 <see cref="T:Microsoft.VisualBasic.Language.List`1"/> initizlize syntax supports
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Language.LanguageExtensions.Add``1(Microsoft.VisualBasic.Language.List{Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedValue{``0}},System.String,``0,System.String)">
 <summary>
 New List From syntax supports
 
 ```
 {Name, value, Description?}
 ```
 </summary>
 
</member>
<member name="M:Microsoft.VisualBasic.Language.LanguageExtensions.Add(Microsoft.VisualBasic.Language.List{Microsoft.VisualBasic.ComponentModel.Ranges.Model.IntRange},System.String)">
 <summary>
 From {"1,100", "100,1000", "200,500"}
 </summary>
 <param name="list"></param>
 <param name="range$"></param>
 
</member>
<member name="T:Microsoft.VisualBasic.Language.LinqAPI">
 <summary>
 Language syntax extension for the Linq expression in VisualBasic language
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Language.LinqAPI.#ctor">
 <summary>
 2016-10-21
 在这里被设计成Class而不是Module是为了防止和Linq拓展之中的函数产生冲突
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Language.LinqAPI.MakeList``1">
 <summary>
 Initializes a new instance of the <see cref="M:Microsoft.VisualBasic.Language.LanguageAPI.list(Microsoft.VisualBasic.Language.ArgumentReference[])"/>`1 class that
 contains elements copied from the specified collection and has sufficient capacity
 to accommodate the number of elements copied.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Language.LinqAPI.Exec``1">
 <summary>
 Execute a linq expression. Creates an array from a <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
 </summary>
 <typeparam name="T"></typeparam>
 <returns>An array that contains the elements from the input sequence.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.LinqAPI.Exec``2(System.Collections.Generic.IEnumerable{``0})">
 <summary>
 
 </summary>
 <typeparam name="T">Is the type of linq source</typeparam>
 <typeparam name="V">Is the type of value output</typeparam>
 <param name="source"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.LinqAPIHelpers.CountHelper`1.op_LessThanOrEqual(Microsoft.VisualBasic.Language.LinqAPIHelpers.CountHelper{`0},System.Collections.Generic.IEnumerable{`0})">
 <summary>
 判断序列计数是否相等
 </summary>
 <param name="h"></param>
 <param name="source"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.LinqAPIHelpers.ListHelper`1.op_LessThanOrEqual(Microsoft.VisualBasic.Language.LinqAPIHelpers.ListHelper{`0},System.Collections.Generic.IEnumerable{`0})">
 <summary>
 Initializes a new instance of the <see cref="M:Microsoft.VisualBasic.Language.LanguageAPI.list(Microsoft.VisualBasic.Language.ArgumentReference[])"/>`1 class that
 contains elements copied from the specified collection and has sufficient capacity
 to accommodate the number of elements copied.
 </summary>
 <param name="linq">The collection whose elements are copied to the new list.</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.LinqAPIHelpers.ListHelper`1.op_LessThanOrEqual(Microsoft.VisualBasic.Language.LinqAPIHelpers.ListHelper{`0},System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{`0}})">
 <summary>
 Initializes a new instance of the <see cref="M:Microsoft.VisualBasic.Language.LanguageAPI.list(Microsoft.VisualBasic.Language.ArgumentReference[])"/>`1 class that
 contains elements copied from the specified collection and has sufficient capacity
 to accommodate the number of elements copied.
 </summary>
 <param name="linq">The collection whose elements are copied to the new list.</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.LinqAPIHelpers.ListHelper`1.op_LessThanOrEqual(Microsoft.VisualBasic.Language.LinqAPIHelpers.ListHelper{`0},System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{`0}}})">
 <summary>
 Initializes a new instance of the <see cref="M:Microsoft.VisualBasic.Language.LanguageAPI.list(Microsoft.VisualBasic.Language.ArgumentReference[])"/>`1 class that
 contains elements copied from the specified collection and has sufficient capacity
 to accommodate the number of elements copied.
 </summary>
 <param name="linq">The collection whose elements are copied to the new list.</param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Language.LinqAPIHelpers.ExecHelper`1">
 <summary>
 Execute a linq expression. Creates an array from a <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
 </summary>
 <typeparam name="T"></typeparam>
</member>
<member name="M:Microsoft.VisualBasic.Language.LinqAPIHelpers.ExecHelper`1.op_LessThanOrEqual(Microsoft.VisualBasic.Language.LinqAPIHelpers.ExecHelper{`0},System.Collections.Generic.IEnumerable{`0})">
 <summary>
 Creates an array from a <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
 </summary>
 <param name="cls"></param>
 <param name="linq">
 An <see cref="T:System.Collections.Generic.IEnumerable`1"/> to create an array from.
 </param>
 <returns>An array that contains the elements from the input sequence.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.LinqAPIHelpers.ExecHelper`1.op_LessThanOrEqual(Microsoft.VisualBasic.Language.LinqAPIHelpers.ExecHelper{`0},System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{`0}})">
 <summary>
 Creates an array from a <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
 </summary>
 <param name="cls"></param>
 <param name="linq">
 An <see cref="T:System.Collections.Generic.IEnumerable`1"/> to create an array from.
 </param>
 <returns>An array that contains the elements from the input sequence.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.LinqAPIHelpers.FirstOrDefaultHelper`1.op_LessThanOrEqual(Microsoft.VisualBasic.Language.LinqAPIHelpers.FirstOrDefaultHelper{`0},System.Collections.Generic.IEnumerable{`0})">
 <summary>
 Exec <see cref="T:System.Collections.Generic.IEnumerable`1"/>.DefaultFirst extension method.
 </summary>
 <param name="cls"></param>
 <param name="linq"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Language.LinqAPIHelpers.ToArrayHelper`2">
 <summary>
 Execute a linq expression. Creates an array from a <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
 </summary>
 <typeparam name="T"></typeparam>
</member>
<member name="M:Microsoft.VisualBasic.Language.LinqAPIHelpers.ToArrayHelper`2.op_LessThanOrEqual(Microsoft.VisualBasic.Language.LinqAPIHelpers.ToArrayHelper{`0,`1},System.Func{`0,`1})">
 <summary>
 Exec ToArray
 </summary>
 <param name="cls"></param>
 <param name="linq"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.LinqAPIHelpers.ToArrayHelper`2.op_LessThanOrEqual(Microsoft.VisualBasic.Language.LinqAPIHelpers.ToArrayHelper{`0,`1},System.Func{`0,System.Int32,`1})">
 <summary>
 Exec ToArray
 </summary>
 <param name="cls"></param>
 <param name="linq"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Language.List`1">
 <summary>
 Represents a strongly typed list of objects that can be accessed by index. Provides
 methods to search, sort, and manipulate lists.To browse the .NET Framework source
 code for this type, see the Reference Source.
 (加强版的<see cref="T:System.Collections.Generic.List`1"/>)
 </summary>
 <typeparam name="T">The type of elements in the list.</typeparam>
</member>
<member name="P:Microsoft.VisualBasic.Language.List`1.Last">
 <summary>
 The last elements in the collection <see cref="T:Microsoft.VisualBasic.Language.List`1"/>
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Language.List`1.First">
 <summary>
 The first elements in the collection <see cref="T:Microsoft.VisualBasic.Language.List`1"/>
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Language.List`1.Item(System.Object)">
 <summary>
 
 </summary>
 <param name="args">同时支持boolean和integer</param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Language.List`1.Item(Microsoft.VisualBasic.ComponentModel.IAddress{System.Int32})">
 <summary>
 This indexer property is using for the ODEs-system computing.
 (这个是为了ODEs计算模块所准备的一个数据接口)
 </summary>
 <param name="address"></param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Language.List`1.Item(System.Int32)">
 <summary>
 Can accept negative number as the index value, negative value means ``<see cref="P:System.Collections.Generic.List`1.Count"/> - n``, 
 example as ``list(-1)``: means the last element in this list: ``list(list.Count -1)``
 </summary>
 <param name="index%"></param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Language.List`1.Item(Microsoft.VisualBasic.Language.i32)">
 <summary>
 Can accept negative number as the index value, negative value means ``<see cref="P:System.Collections.Generic.List`1.Count"/> - n``, 
 example as ``list(-1)``: means the last element in this list: ``list(list.Count -1)``
 </summary>
 <param name="index"></param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Language.List`1.Item(System.String)">
 <summary>
 Using a index vector expression to select/update many elements from this list collection.
 </summary>
 <param name="exp$">
 + ``1``, index=1
 + ``1:8``, index=1, count=8
 + ``1->8``, index from 1 to 8
 + ``8->1``, index from 8 to 1
 + ``1,2,3,4``, index=1 or  2 or 3 or 4
 </param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Language.List`1.Item(System.Predicate{`0})">
 <summary>
 Select all of the elements from this list collection is any of them match the condition expression: <paramref name="where"/>
 </summary>
 <param name="[where]"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.List`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
 <summary>
 Initializes a new instance of the <see cref="T:Microsoft.VisualBasic.Language.List`1"/> class that
 contains elements copied from the specified collection and has sufficient capacity
 to accommodate the number of elements copied.
 </summary>
 <param name="source">The collection whose elements are copied to the new list.</param>
 <remarks>
 (这是一个安全的构造函数，假若输入的参数为空值，则只会创建一个空的列表，而不会抛出错误)
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Language.List`1.#ctor(`0[])">
 <summary>
 Initializes a new instance of the <see cref="T:Microsoft.VisualBasic.Language.List`1"/> class that
 contains elements copied from the specified collection and has sufficient capacity
 to accommodate the number of elements copied.
 </summary>
 <param name="x">The collection whose elements are copied to the new list.</param>
 
</member>
<member name="M:Microsoft.VisualBasic.Language.List`1.#ctor">
 <summary>
 Initializes a new instance of the Microsoft VisualBasic language <see cref="T:Microsoft.VisualBasic.Language.List`1"/> class 
 that is empty and has the default initial capacity.
 </summary>
 
</member>
<member name="M:Microsoft.VisualBasic.Language.List`1.#ctor(System.Int32)">
 <summary>
 Initializes a new instance of the <see cref="T:Microsoft.VisualBasic.Language.List`1"/> class that
 is empty and has the specified initial capacity.
 </summary>
 <param name="capacity">The number of elements that the new list can initially store.</param>
 
</member>
<member name="M:Microsoft.VisualBasic.Language.List`1.PopAll">
 <summary>
 Pop all of the elements value in to array from the list object 
 and then clear all of the <see cref="T:Microsoft.VisualBasic.Language.List`1"/> data.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.List`1.op_Addition(Microsoft.VisualBasic.Language.List{`0},`0)">
 <summary>
 Adds an object to the end of the <see cref="T:Microsoft.VisualBasic.Language.List`1"/>.
 </summary>
 <param name="list"></param>
 <param name="x">
 The object to be added to the end of the <see cref="T:Microsoft.VisualBasic.Language.List`1"/>. 
 The value can be null for reference types.
 </param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.List`1.op_Addition(Microsoft.VisualBasic.Language.List{`0},Microsoft.VisualBasic.Language.Value{`0})">
 <summary>
 Adds an object to the end of the <see cref="T:Microsoft.VisualBasic.Language.List`1"/>.
 </summary>
 <param name="list"></param>
 <param name="x">
 The object to be added to the end of the <see cref="T:Microsoft.VisualBasic.Language.List`1"/>. 
 The value can be null for reference types.
 </param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Language.List`1.op_Addition(`0,Microsoft.VisualBasic.Language.List{`0})">
 <summary>
 Adds an object to the begin of the <see cref="T:Microsoft.VisualBasic.Language.List`1"/>.
 </summary>
 <param name="list"></param>
 <param name="x">The object to be added to the end of the <see cref="T:Microsoft.VisualBasic.Language.List`1"/>. The
 value can be null for reference types.</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.List`1.op_Multiply(Microsoft.VisualBasic.Language.List{`0},System.Int32)">
 <summary>
 
 </summary>
 <param name="list"></param>
 <param name="n">
 If parameter <paramref name="n"/> equals to ZERO, then just 
 <see cref="M:System.Collections.Generic.List`1.Clear"/> the list contents and keeps the object 
 reference.
 </param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.List`1.op_Subtraction(Microsoft.VisualBasic.Language.List{`0},`0)">
 <summary>
 Removes the first occurrence of a specific object from the <see cref="T:Microsoft.VisualBasic.Language.List`1"/>.
 </summary>
 <param name="list"></param>
 <param name="x">The object to remove from the <see cref="T:Microsoft.VisualBasic.Language.List`1"/>. The value can
 be null for reference types.</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.List`1.op_Addition(Microsoft.VisualBasic.Language.List{`0},System.Collections.Generic.IEnumerable{`0})">
 <summary>
 Adds the elements of the specified collection to the end of the <see cref="T:Microsoft.VisualBasic.Language.List`1"/>.
 </summary>
 <param name="list"></param>
 <param name="vals"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.List`1.op_Addition(Microsoft.VisualBasic.Language.List{`0},Microsoft.VisualBasic.Language.List{`0})">
 <summary>
 Append <paramref name="list2"/> to the end of <paramref name="list1"/>
 </summary>
 <param name="list1"></param>
 <param name="list2"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.List`1.op_Addition(Microsoft.VisualBasic.Language.List{`0},System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{`0}})">
 <summary>
 Adds the elements of the specified collection to the end of the <see cref="T:Microsoft.VisualBasic.Language.List`1"/>.
 </summary>
 <param name="list"></param>
 <param name="vals"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.List`1.op_Addition(System.Collections.Generic.IEnumerable{`0},Microsoft.VisualBasic.Language.List{`0})">
 <summary>
 Adds the elements of the specified collection to the begining of the <paramref name="list"/> <see cref="T:Microsoft.VisualBasic.Language.List`1"/>.
 (output = <paramref name="vals"/> contract <paramref name="list"/>)
 (这个操作符并不会修改所输入的两个原始序列的内容)
 </summary>
 <param name="vals"></param>
 <param name="list"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.List`1.op_Subtraction(Microsoft.VisualBasic.Language.List{`0},System.Collections.Generic.IEnumerable{`0})">
 <summary>
 批量的从目标列表之中移除<paramref name="removes"/>集合之中的对象
 </summary>
 <param name="list"></param>
 <param name="removes"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.List`1.op_Subtraction(Microsoft.VisualBasic.Language.List{`0},System.Int32)">
 <summary>
 <see cref="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)"/>
 </summary>
 <param name="list"></param>
 <param name="index"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.List`1.op_Subtraction(`0[],Microsoft.VisualBasic.Language.List{`0})">
 <summary>
 从输入的向量数组之中移除掉列表之中的指定元素，然后返回<paramref name="vector"/>的剩余元素
 </summary>
 <param name="vector"></param>
 <param name="list"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.List`1.op_Explicit(Microsoft.VisualBasic.Language.List{`0})~`0[]">
 <summary>
 将这个列表对象隐式转换为向量数组
 </summary>
 <param name="list"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Language.List`1.op_Exponent(Microsoft.VisualBasic.Language.List{`0},System.Func{`0,System.Boolean})">
 <summary>
 Find a item in the <see cref="T:Microsoft.VisualBasic.Language.List`1"/>
 </summary>
 <param name="list"></param>
 <param name="find"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.List`1.op_Inequality(Microsoft.VisualBasic.Language.List{`0},System.Int32)">
 <summary>
 Elements count not equals to a specific number?
 </summary>
 <param name="list"></param>
 <param name="count%"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.List`1.op_GreaterThanOrEqual(Microsoft.VisualBasic.Language.List{`0},System.Int32)">
 <summary>
 Elements count is greater than or equals to a specific number?
 </summary>
 <param name="list"></param>
 <param name="count%"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.List`1.op_LessThanOrEqual(Microsoft.VisualBasic.Language.List{`0},System.Int32)">
 <summary>
 Elements count is less than or equals to a specific number?
 </summary>
 <param name="list"></param>
 <param name="count%"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.List`1.op_Equality(Microsoft.VisualBasic.Language.List{`0},System.Int32)">
 <summary>
 Assert that the element counts of this list object is equals to a specifc number?
 </summary>
 <param name="list"></param>
 <param name="count%"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.List`1.op_Equality(Microsoft.VisualBasic.Language.List{`0},System.Collections.Generic.IEnumerable{`0})">
 <summary>
 <see cref="M:System.Linq.Enumerable.SequenceEqual``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})"/>
 </summary>
 <param name="list"></param>
 <param name="collection"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.List`1.op_GreaterThan(Microsoft.VisualBasic.Language.List{`0},System.Int32)">
 <summary>
 <see cref="P:System.Collections.Generic.List`1.Count"/> of <paramref name="list"/> &gt; <paramref name="n"/>
 </summary>
 <param name="list"></param>
 <param name="n%"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.List`1.ReverseIterator">
 <summary>
 反向的枚举出当前列表之中的所有元素
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.List`1.ValuesEnumerator">
 <summary>
 Enums all of the elements in this collection list object by return a value reference type
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.List`1.Pop(System.Boolean)">
 <summary>
 Get the <see cref="P:Microsoft.VisualBasic.Language.List`1.Last"/> element value and then removes the last element.
 </summary>
 <returns>
 
 </returns>
</member>
<member name="T:Microsoft.VisualBasic.Language.Rapply">
 <summary>
 Helper for implements ``lapply`` and ``sapply`` liked operations from R language
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Language.Vectorization.BooleanVector">
 <summary>
 <see cref="T:System.Boolean"/> Array
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Language.Vectorization.BooleanVector.True">
 <summary>
 Only one boolean value ``True`` in the array list
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Language.Vectorization.BooleanVector.False">
 <summary>
 Only one boolean value ``False`` in the array list
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Vectorization.BooleanVector.Sum(Microsoft.VisualBasic.Language.Vectorization.BooleanVector)">
 <summary>
 
 </summary>
 <param name="b"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Vectorization.BooleanVector.op_Concatenate(System.Boolean,Microsoft.VisualBasic.Language.Vectorization.BooleanVector)">
 <summary>
 And
 </summary>
 <param name="x"></param>
 <param name="y"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Language.Vectorization.BooleanVector.op_Concatenate(Microsoft.VisualBasic.Language.Vectorization.BooleanVector,Microsoft.VisualBasic.Language.Vectorization.BooleanVector)">
 <summary>
 X AndAlso Y
 </summary>
 <param name="x"></param>
 <param name="y"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Language.Vectorization.BooleanVector.op_OnesComplement(Microsoft.VisualBasic.Language.Vectorization.BooleanVector)">
 <summary>
 将逻辑向量之中的每一个逻辑值都进行翻转
 </summary>
 <param name="x"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Language.Vectorization.BooleanVector.op_Explicit(Microsoft.VisualBasic.Language.Vectorization.BooleanVector)~System.Boolean">
 <summary>
 x(0)
 </summary>
 <param name="x"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Language.Vectorization.BooleanVector.op_BitwiseOr(Microsoft.VisualBasic.Language.Vectorization.BooleanVector,System.Boolean[])">
 <summary>
 x Or Y
 </summary>
 <param name="x"></param>
 <param name="y"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Language.Vectorization.BooleanVector.op_BitwiseOr(Microsoft.VisualBasic.Language.Vectorization.BooleanVector,Microsoft.VisualBasic.Language.Vectorization.BooleanVector)">
 <summary>
 x Or Y
 </summary>
 <param name="x"></param>
 <param name="y"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Language.Vectorization.BooleanVector.op_Explicit(Microsoft.VisualBasic.Language.Vectorization.BooleanVector)~System.Boolean[]">
 <summary>
 <see cref="M:Microsoft.VisualBasic.Extensions.ToArray(System.Drawing.Size,System.Boolean)"/>
 </summary>
 <param name="x"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Language.Vectorization.Extensions.Add``1(Microsoft.VisualBasic.Language.Vectorization.Vector{``0},``0)">
 <summary>
 Dynamics add a element into the target array.(注意：不推荐使用这个函数来频繁的向数组中添加元素，这个函数会频繁的分配内存，效率非常低)
 </summary>
 <typeparam name="T"></typeparam>
 <param name="x"></param>
 <param name="obj"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Language.Vectorization.VectorSchemaProvider">
 <summary>
 Schema provider of the <see cref="T:Microsoft.VisualBasic.Language.Vectorization.VectorShadows`1"/>
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Language.Vectorization.VectorSchemaProvider.operatorsUnary">
 <summary>
 单目运算符无重名的问题
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Language.Vectorization.VectorSchemaProvider.operatorsBinary">
 <summary>
 双目运算符重载会带来重名运算符的问题
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Language.Vectorization.VectorSchemaProvider.methods">
 <summary>
 The overloads function
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Language.Vectorization.VectorSchemaProvider.GetDynamicMemberNames">
 <summary>
 Returns property names and function names
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Vectorization.VectorSchemaProvider.TryGetMember(System.Dynamic.GetMemberBinder)">
 <summary>
 Property Get
 </summary>
 <param name="binder"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Vectorization.VectorSchemaProvider.TrySetMember(System.Dynamic.SetMemberBinder)">
 <summary>
 Property Set
 </summary>
 <param name="binder"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Vectorization.VectorSchemaProvider.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[])">
 <summary>
 Function invoke
 </summary>
 <param name="binder"></param>
 <param name="args"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Vectorization.VectorSchemaProvider.Concatenate(System.Type,System.Boolean@)">
 <summary>
 Fix for &amp; operator not defined!
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Vectorization.VectorSchemaProvider.Like(System.Type,System.Boolean@)">
 <summary>
 Fix for Like operator not defined in Linq.
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Language.Vectorization.Strings">
 <summary>
 The <see cref="T:System.String"/> module contains procedures used to perform string operations.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Language.Vectorization.Strings.Len(System.Collections.Generic.IEnumerable{System.String})">
 <summary>
 Returns an integer containing either the number of characters in a string or 
 the nominal number of bytes required to store a variable.
 </summary>
 <param name="strings">
 Any valid String expression or variable name. If Expression is of type Object, 
 the Len function returns the size as it will be written to the file by the 
 FilePut function.
 </param>
 <returns>
 Returns an integer containing either the number of characters in a string or 
 the nominal number of bytes required to store a variable.
 </returns>
</member>
<member name="P:Microsoft.VisualBasic.Language.Vectorization.StringVector.Len">
 <summary>
 Returns the length of each strings
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Vectorization.StringVector.IsPattern(Microsoft.VisualBasic.Language.Vectorization.StringVector,System.String,System.Text.RegularExpressions.RegexOptions)">
 <summary>
 批量执行判断目标字符串集合中的每一个字符串元素都是符合目标匹配模式的
 </summary>
 <param name="strings"></param>
 <param name="pattern$"></param>
 <param name="opt"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Vectorization.StringVector.op_Implicit(System.String)~Microsoft.VisualBasic.Language.Vectorization.StringVector">
 <summary>
 
 </summary>
 <param name="expression">a,b,c,d,e</param>
 <returns></returns>
 
</member>
<member name="T:Microsoft.VisualBasic.Language.Vectorization.Vector`1">
 <summary>
 VB.NET object collection
 </summary>
 <typeparam name="T"></typeparam>
</member>
<member name="F:Microsoft.VisualBasic.Language.Vectorization.Vector`1.buffer">
 <summary>
 Array that hold the .NET object in this collection
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Language.Vectorization.Vector`1.Length">
 <summary>
 Gets the element counts in this vector collection
 </summary>
 <returns></returns>
 
</member>
<member name="P:Microsoft.VisualBasic.Language.Vectorization.Vector`1.IsScalar">
 <summary>
 current vector size is one element?
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Language.Vectorization.Vector`1.Array">
 <summary>
 请注意，这个属性是直接返回内部数组的引用，所以对这个属性的数组内的元素的修改将会直接修改这个向量的值
 如果不希望将内部引用进行修改，请使用迭代器或者<see cref="M:System.Linq.Enumerable.ToArray``1(System.Collections.Generic.IEnumerable{``0})"/> Linq拓展
 </summary>
 <returns></returns>
 <remarks>
 <see cref="F:Microsoft.VisualBasic.Language.Vectorization.Vector`1.buffer"/>
 </remarks>
 
</member>
<member name="P:Microsoft.VisualBasic.Language.Vectorization.Vector`1.Last">
 <summary>
 The last elements in the collection <see cref="T:Microsoft.VisualBasic.Language.List`1"/>
 </summary>
 <returns></returns>
 
</member>
<member name="P:Microsoft.VisualBasic.Language.Vectorization.Vector`1.First">
 <summary>
 The first elements in the collection <see cref="T:Microsoft.VisualBasic.Language.List`1"/>
 </summary>
 <returns></returns>
 
</member>
<member name="P:Microsoft.VisualBasic.Language.Vectorization.Vector`1.Item(System.Object)">
 <summary>
 
 </summary>
 <param name="args">同时支持boolean和integer</param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Language.Vectorization.Vector`1.Item(Microsoft.VisualBasic.ComponentModel.IAddress{System.Int32})">
 <summary>
 This indexer property is using for the ODEs-system computing.
 (这个是为了ODEs计算模块所准备的一个数据接口)
 </summary>
 <param name="address"></param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Language.Vectorization.Vector`1.Item(System.Int32)">
 <summary>
 Direct get the element in the array by its index.
 </summary>
 <param name="index%"></param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Language.Vectorization.Vector`1.Item(System.String)">
 <summary>
 Using a index vector expression to select/update many elements from this list collection.
 </summary>
 <param name="exp$">
 + ``1``, index=1
 + ``1:8``, index=1, count=8
 + ``1->8``, index from 1 to 8
 + ``8->1``, index from 8 to 1
 + ``1,2,3,4``, index=1 or  2 or 3 or 4
 </param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Language.Vectorization.Vector`1.Item(Microsoft.VisualBasic.ComponentModel.Ranges.Model.IntRange)">
 <summary>
 Get subset of the collection by using a continues index
 </summary>
 <param name="range"></param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Language.Vectorization.Vector`1.Item(System.Collections.Generic.IEnumerable{System.Int32})">
 <summary>
 Gets subset of the collection by using a discontinues index
 </summary>
 <param name="indices"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Vectorization.Vector`1.Subset(System.Collections.Generic.IEnumerable{System.Boolean})">
 <summary>
 从当前的向量序列之中进行向量子集的截取
 </summary>
 <param name="booleans"></param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Language.Vectorization.Vector`1.Item(System.Predicate{`0})">
 <summary>
 Select all of the elements from this list collection is any of them match the condition expression: <paramref name="where"/>
 </summary>
 <param name="[where]"></param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Language.Vectorization.Vector`1.Item(System.Collections.Generic.IEnumerable{System.Boolean})">
 <summary>
 Select elements by logical condiction result.
 </summary>
 <param name="booleans"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Vectorization.Vector`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
 <summary>
 构建一个新的向量对象，这个向量对象只提供基本的数据存储和访问模型，并没有提供高级的动态处理和模式解析的操作
 </summary>
 <param name="data"></param>
 
</member>
<member name="M:Microsoft.VisualBasic.Language.Vectorization.Vector`1.Which(System.Func{`0,System.Boolean})">
 <summary>
 get the index vector where the element test assert success
 </summary>
 <param name="assert"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Vectorization.Vector`1.op_Explicit(Microsoft.VisualBasic.Language.Vectorization.Vector{`0})~`0[]">
 <summary>
 没用？？？
 </summary>
 <param name="v"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Vectorization.Vector`1.op_Concatenate(Microsoft.VisualBasic.Language.Vectorization.Vector{`0},Microsoft.VisualBasic.Language.Vectorization.Vector{`0})">
 <summary>
 Append the elements in vector <paramref name="a"/> with all of the elements in vector <paramref name="b"/> directly.
 Union two collection directly without <see cref="M:System.Linq.Enumerable.Distinct``1(System.Collections.Generic.IEnumerable{``0})"/> operation.
 (请注意，使用<see cref="T:Microsoft.VisualBasic.ComponentModel.DataStructures.Set"/>集合对象的Union功能会去除重复，而这个操作符则是直接进行合并取``并集``而不去重)
 </summary>
 <param name="a"></param>
 <param name="b"></param>
 <returns></returns>
 
</member>
<member name="T:Microsoft.VisualBasic.Language.Vectorization.VectorShadows`1">
 <summary>
 Vectorization programming language feature for VisualBasic
 </summary>
 <typeparam name="T"></typeparam>
</member>
<member name="F:Microsoft.VisualBasic.Language.Vectorization.VectorShadows`1.linq">
 <summary>
 无参数的属性
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Language.Vectorization.VectorShadows`1.Item(System.String)">
 <summary>
 get property value
 </summary>
 <param name="exp$"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Vectorization.VectorShadows`1.As``1">
 <summary>
 get the vector value copy
 </summary>
 <typeparam name="V"></typeparam>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Vectorization.VectorShadows`1.GetMapName(System.String)">
 <summary>
 
 </summary>
 <param name="name"></param>
 <returns>
 this function returns nothing if has no name mapping
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Vectorization.VectorShadows`1.GetDynamicMemberNames">
 <summary>
 Returns property names and function names
 </summary>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Language.Vectorization.VectorShadows`1.GetDataProperties">
 <summary>
 get all property names
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Vectorization.VectorShadows`1.GetJson">
 <summary>
 Vector array json string
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Vectorization.VectorShadows`1.CreateVector(System.Collections.IEnumerable,System.Type)">
 <summary>
 Create a generic vector for a specific .NET <paramref name="type"/>
 </summary>
 <param name="data"></param>
 <param name="type"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Vectorization.VectorShadows`1.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)">
 <summary>
 Property Get
 </summary>
 <param name="binder"></param>
 <param name="result"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Vectorization.VectorShadows`1.TryGetMember(System.String,System.Object@)">
 <summary>
 大小写不敏感
 </summary>
 <param name="name$"></param>
 <param name="result"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Vectorization.VectorShadows`1.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)">
 <summary>
 Property Set
 </summary>
 <param name="binder"></param>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Vectorization.VectorShadows`1.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)">
 <summary>
 Function invoke
 </summary>
 <param name="binder"></param>
 <param name="args"></param>
 <param name="result"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Vectorization.VectorShadows`1.op_Concatenate(Microsoft.VisualBasic.Language.Vectorization.VectorShadows{`0},System.Object)">
 <summary>
 Fix for &amp; operator not defined!
 </summary>
 <param name="vector"></param>
 <param name="obj"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Vectorization.VectorShadows`1.op_Like(Microsoft.VisualBasic.Language.Vectorization.VectorShadows{`0},System.Object)">
 <summary>
 Fix for Like operator not defined in Linq.
 </summary>
 <param name="vector"></param>
 <param name="obj"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Language.NamespaceDoc">
 <summary>
 The VisualBasic.NET language addons
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Language.ArgumentReference">
 <summary>
 ``[name => value]`` tuple
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Language.ArgumentReference.op_Equality(Microsoft.VisualBasic.Language.ArgumentReference,System.Object)">
 <summary>
 Argument variable value assign
 </summary>
 <param name="var">The argument name</param>
 <param name="value">argument value</param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Language.Runtime">
 <summary>
 Runtime helper
 
 ```vbnet
 Imports VB = Microsoft.VisualBasic.Language.Runtime
 
 With New VB
     ' ...
 End With
 ```
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Language.Runtime.Argument(System.String)">
 <summary>
 Language syntax supports for argument list
 </summary>
 <param name="name$"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Language.FormatHelpers">
 <summary>
 ``<see cref="M:Microsoft.VisualBasic.Language.C.CLangStringFormatProvider.sprintf(System.String,System.Object[])"/>`` syntax helpers
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Language.FormatHelpers.StartsWith(Microsoft.VisualBasic.Language.Value{System.String},System.Char)">
 <summary>
 Determines whether the beginning of this string instance matches the specified
 string.
 </summary>
 <param name="str"></param>
 <param name="c">The string to compare.</param>
 <returns>true if value matches the beginning of this string; otherwise, false.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.FormatHelpers.Trim(Microsoft.VisualBasic.Language.Value{System.String},System.Char[])">
 <summary>
 Removes all leading and trailing occurrences of a set of characters specified
 in an array from the current string.
 </summary>
 <param name="str"></param>
 <param name="c">An array of Unicode characters to remove, or null.</param>
 <returns>
 The string that remains after all occurrences of the characters in the trimChars
 parameter are removed from the start and end of the current string. If trimChars
 is null or an empty array, white-space characters are removed instead. If no
 characters can be trimmed from the current instance, the method returns the current
 instance unchanged.
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.FormatHelpers.Split(Microsoft.VisualBasic.Language.Value{System.String},System.String,System.Boolean,System.Boolean)">
 <summary>
 Returns a zero-based, one-dimensional array containing a specified number of
 substrings.
 </summary>
 <param name="str">Required. String expression containing substrings And delimiters.</param>
 <param name="deli">
 Optional. Any single character used to identify substring limits. If Delimiter
 Is omitted, the space character (" ") Is assumed to be the delimiter.
 </param>
 <param name="ignoreCase"></param>
 <param name="regexp"></param>
 <returns>
 String array. If Expression Is a zero-length string (""), 
 Split returns a single-element array containing a zero-length 
 string. If Delimiter Is a zero-length string, Or if it does 
 Not appear anywhere in Expression, Split returns a single-element
 array containing the entire Expression string.
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.FormatHelpers.Split(Microsoft.VisualBasic.Language.Value{System.String},System.Char,System.StringSplitOptions)">
 <summary>
 Splits a string into substrings based on a specified delimiting character and,
 optionally, options.
 </summary>
 <param name="str"></param>
 <param name="deli">A character that delimits the substrings in this string.</param>
 <param name="options">
 A bitwise combination of the enumeration values that specifies whether to trim
 substrings and include empty substrings.
 </param>
 <returns>An array whose elements contain the substrings from this instance that are delimited
 by separator.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.FormatHelpers.xFormat(System.String)">
 <summary>
 ``<see cref="M:Microsoft.VisualBasic.Language.C.CLangStringFormatProvider.sprintf(System.String,System.Object[])"/>`` extensions
 </summary>
 <param name="s"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.FormatHelpers.StringFormat(System.String[])">
 <summary>
 Synax like ``"formats" &lt;= {args}.xFormat`` 
 Format by <see cref="M:Microsoft.VisualBasic.Language.C.CLangStringFormatProvider.sprintf(System.String,System.Object[])"/>
 </summary>
 <param name="args"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Language.FormatHelper">
 <summary>
 ``<see cref="M:Microsoft.VisualBasic.Language.C.CLangStringFormatProvider.sprintf(System.String,System.Object[])"/>`` reference
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Language.Values.ByRefValueExtensions.Split(Microsoft.VisualBasic.Language.Value{System.String},System.Char[])">
 <summary>
 Splits a string into substrings that are based on the 
 characters in the separator array.
 </summary>
 <param name="s"></param>
 <param name="delimiter">
 A character array that delimits the substrings in this string, 
 an empty array that contains no delimiters, Or null.
 </param>
 <returns>An array whose elements contain the substrings from this 
 instance that are delimited by one Or more characters in separator. 
 For more information, see the Remarks section.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Values.ByRefValueExtensions.First(Microsoft.VisualBasic.Language.Value{System.String})">
 <summary>
 get the first char
 </summary>
 <param name="str"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Values.ByRefValueExtensions.StartsWith(Microsoft.VisualBasic.Language.Value{System.String},System.String)">
 <summary>
 Determines whether the beginning of this string instance matches the specified
 string.
 </summary>
 <param name="str"></param>
 <param name="substr">The string to compare.</param>
 <returns>true if value matches the beginning of this string; otherwise, false.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Values.ByRefValueExtensions.CreateDelegate(Microsoft.VisualBasic.Language.Value{System.Reflection.MethodInfo},System.Type)">
 <summary>
 Creates a delegate of the specified type from this method.
 </summary>
 <param name="methodInfo"></param>
 <param name="delegateType">The type of the delegate to create.</param>
 <returns>The delegate for this method.</returns>
</member>
<member name="T:Microsoft.VisualBasic.Language.Values.Clones">
 <summary>
 Some extension for copy a collection object.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Language.Values.Clones.Clone``2(System.Collections.Generic.IDictionary{``0,``1})">
 <summary>
 Creates a new dictionary
 </summary>
 <typeparam name="T"></typeparam>
 <typeparam name="V"></typeparam>
 <param name="table"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Language.Default.BinaryAssert`1">
 <summary>
 + Test of A eqauls to B?
 </summary>
 <typeparam name="T"></typeparam>
 <param name="x"></param>
 <param name="y"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Language.Default.IsEmpty">
 <summary>
 Apply on the structure type that assert the object is null or not.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Language.Default.IsEmpty.IsEmpty">
 <summary>
 Does current object has any value inside?
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Language.Default.Default`1">
 <summary>
 The default value
 </summary>
 <typeparam name="T"></typeparam>
</member>
<member name="F:Microsoft.VisualBasic.Language.Default.Default`1.value">
 <summary>
 The default value for <see cref="P:Microsoft.VisualBasic.Language.Default.Default`1.DefaultValue"/>
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Language.Default.Default`1.lazy">
 <summary>
 假若生成目标值的时间比较久，可以将其申明为Lambda表达式，这样子可以进行惰性加载
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Language.Default.Default`1.constructor">
 <summary>
 与<see cref="F:Microsoft.VisualBasic.Language.Default.Default`1.lazy"/>不同的是，这个会一直产生新的数据
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Language.Default.Default`1.assert">
 <summary>
 asset that if target value is null? If this function returns true when 
 test on the object, means object value is missing or null, then default 
 value <see cref="P:Microsoft.VisualBasic.Language.Default.Default`1.DefaultValue"/> will be returns.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Language.Default.Default`1.GetNumericAssert(System.Object)">
 <summary>
 这个判断函数优化了对数字类型的判断
 </summary>
 <param name="n"></param>
 <returns></returns>
 <remarks>
 在VB之中，数值类型在未赋值的状态下默认值为零，意味着此时该数值的值为空
 但是不清楚这样子判断是否会出现bug？
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Language.Default.Default`1.#ctor(System.Func{`0},System.Predicate{System.Object},System.Boolean)">
 <summary>
 
 </summary>
 <param name="populator"></param>
 <param name="assert"></param>
 <param name="isLazy">
 + 如果这个参数为true，则表示表达式为lazy加载，只会执行一次
 + 反之当这个参数为false的时候，则表达式会不断的产生新的值
 </param>
</member>
<member name="M:Microsoft.VisualBasic.Language.Default.Default`1.op_Addition(Microsoft.VisualBasic.Language.Default.Default{`0},System.Predicate{System.Object})">
 <summary>
 Add handler
 </summary>
 <param name="[default]"></param>
 <param name="assert"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Language.Default.Default`1.op_BitwiseOr(`0,Microsoft.VisualBasic.Language.Default.Default{`0})">
 <summary>
 if <see cref="F:Microsoft.VisualBasic.Language.Default.Default`1.assert"/> is true, then will using default <see cref="F:Microsoft.VisualBasic.Language.Default.Default`1.value"/>, 
 otherwise, return the source <paramref name="obj"/>.
 </summary>
 <param name="obj"></param>
 <param name="[default]"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Language.Default.Default`1.op_BitwiseOr(Microsoft.VisualBasic.Language.Default.Default{`0},Microsoft.VisualBasic.Language.Default.Default{`0})">
 <summary>
 这个操作符允许链式计算默认值：
 
 A OR B OR C OR x OR y OR z
 </summary>
 <param name="x"></param>
 <param name="y"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Default.DefaultExtensions.Split(Microsoft.VisualBasic.Language.Default.DefaultString,System.String,System.Boolean,System.Boolean)">
 <summary>
 Returns a zero-based, one-dimensional array containing a specified number of
 substrings.
 </summary>
 <param name="str">Required. String expression containing substrings And delimiters.</param>
 <param name="deli">
 Optional. Any single character used to identify substring limits. If Delimiter
 Is omitted, the space character (" ") Is assumed to be the delimiter.
 </param>
 <param name="ignoreCase"></param>
 <param name="regexp"></param>
 <returns>
 String array. If Expression Is a zero-length string (""), 
 Split returns a single-element array containing a zero-length 
 string. If Delimiter Is a zero-length string, Or if it does 
 Not appear anywhere in Expression, Split returns a single-element
 array containing the entire Expression string.
 </returns>
</member>
<member name="T:Microsoft.VisualBasic.Language.Default.DefaultString">
 <summary>
 <see cref="T:Microsoft.VisualBasic.CommandLine.CommandLine"/> optional value helper data model
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Language.Default.DefaultString.DefaultValue">
 <summary>
 The optional argument value that read from <see cref="T:Microsoft.VisualBasic.CommandLine.CommandLine"/> 
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Language.Default.DefaultString.IsEmpty">
 <summary>
 <see cref="P:Microsoft.VisualBasic.Language.Default.DefaultString.DefaultValue"/> is empty?
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Default.DefaultString.LoadJson``1">
 <summary>
 如果文件不存在或者文本内容为空，则函数返回空值
 </summary>
 <typeparam name="T"></typeparam>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Default.DefaultString.op_BitwiseOr(Microsoft.VisualBasic.Language.Default.DefaultString,System.String)">
 <summary>
 If <paramref name="value"/> is empty then returns <paramref name="default"/>, 
 else returns <paramref name="value"/> itself.
 </summary>
 <param name="value"></param>
 <param name="default$"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Default.DefaultString.op_BitwiseOr(Microsoft.VisualBasic.Language.Default.DefaultString,System.Int32)">
 <summary>
 Get a <see cref="T:System.Int32"/> value or using default <see cref="T:System.Int32"/> value.
 </summary>
 <param name="value"></param>
 <param name="x%"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Language.f64">
 <summary>
 <see cref="T:System.Double"/>
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Language.f64.op_LessThan(System.Double,Microsoft.VisualBasic.Language.f64)">
 <summary>
 n &lt; value &lt;= n2
 假若n 大于value，则返回最大值，上面的表达式肯定不成立
 </summary>
 <param name="n"></param>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.f64.op_Subtraction(System.Double,Microsoft.VisualBasic.Language.f64)">
 <summary>
 值相减
 </summary>
 <param name="a"></param>
 <param name="b"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Language.i32">
 <summary>
 Alias of <see cref="T:System.Int32"/>
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Language.i32.Hex">
 <summary>
 转换为16进制
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Language.i32.Oct">
 <summary>
 转换为8进制
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.i32.GetHexInteger(System.String)">
 <summary>
 将16进制的数字转换为10进制数
 </summary>
 <param name="hex$"></param>
 <returns></returns>
 <remarks>
 因为直接使用vb的<see cref="M:Microsoft.VisualBasic.Conversion.Val(System.Char)"/>函数转换，在Linux上面可能会出错，所以需要在这里用.NET自己的方法来转换
 </remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.Language.i32.CompareTo(System.Object)">
 <summary>
 Compare <see cref="T:Microsoft.VisualBasic.Language.i32"/> or <see cref="T:System.Int32"/>
 </summary>
 <param name="obj"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.i32.op_LessThan(System.Int32,Microsoft.VisualBasic.Language.i32)">
 <summary>
 n &lt; value &lt;= n2
 假若n 大于value，则返回最大值，上面的表达式肯定不成立
 </summary>
 <param name="n"></param>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.i32.op_LessThan(Microsoft.VisualBasic.Language.i32,System.Int32)">
 <summary>
 ``x.value &lt; n``
 </summary>
 <param name="x"></param>
 <param name="n"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.i32.op_GreaterThan(Microsoft.VisualBasic.Language.i32,System.Int32)">
 <summary>
 ``x.value > n``
 </summary>
 <param name="x"></param>
 <param name="n"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.i32.op_Subtraction(System.Int32,Microsoft.VisualBasic.Language.i32)">
 <summary>
 正常的减法四则运算
 </summary>
 <param name="x%"></param>
 <param name="n"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.i32.op_Division(Microsoft.VisualBasic.Language.i32,System.Int32)">
 <summary>
 value / b
 </summary>
 <param name="x"></param>
 <param name="b"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.i32.op_Implicit(System.Int32)~Microsoft.VisualBasic.Language.i32">
 <summary>
 必须要overloads这个方法，否则会出现无法将Value(Of Integer)转换为int的错误
 </summary>
 <param name="n"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.i32.op_UnaryNegation(Microsoft.VisualBasic.Language.i32)">
 <summary>
 value -= 1
 </summary>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.i32.op_UnaryPlus(Microsoft.VisualBasic.Language.i32)">
 <summary>
 Auto increment value with step 1 and then returns the previous value.
 </summary>
 <param name="x"></param>
 <returns>自增1然后返回之前的值</returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.i32.op_Addition(Microsoft.VisualBasic.Language.i32,System.Int32)">
 <summary>
 位移<paramref name="n"/>个单位然后返回位移之后的结果值
 
 + 对于<see cref="T:Microsoft.VisualBasic.Language.i32"/>类型而言，其更加侧重于迭代器中的位移，所以这个加法运算是符合
   ```vbnet
   x += n
   ```
 + 但是对于<see cref="T:Microsoft.VisualBasic.Language.f64"/>类型而言，其更加侧重于模型计算，所以其加法不符合上述的语法，
 不会修改源变量的值，返回的是一个单纯的<see cref="T:System.Double"/>值类型
 </summary>
 <param name="x"></param>
 <param name="n%"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.i32.op_Addition(System.Int32,Microsoft.VisualBasic.Language.i32)">
 <summary>
 <paramref name="n"/> + <see cref="P:Microsoft.VisualBasic.Language.Value`1.Value"/>
 </summary>
 <param name="n"></param>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Language.Numeric">
 <summary>
 Defines a generalized type-specific comparison method that a value type or class
 implements to order or sort its instances.
 </summary>
 <remarks>

 Summary:

     Compares the current instance with another object of the same type and returns
     an integer that indicates whether the current instance precedes, follows, or
     occurs in the same position in the sort order as the other object.

 Returns:

     A value that indicates the relative order of the objects being compared. The
     return value has these meanings:

     1. Value Meaning Less than zero
        This instance precedes obj in the sort order.

     2. Zero
        This instance occurs in the same position in the sort order as obj.

     3. Greater than zero
        This instance follows obj in the sort order.

 Exceptions:

   T:System.ArgumentException:
     obj is not the same type as this instance.
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Language.Numeric.MaxIndex``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>
 *<see cref="M:Microsoft.VisualBasic.Language.Numeric.MaxIndex``1(System.Collections.Generic.IEnumerable{``0})"/>* The max element its index in the source collection.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <returns>
 A zero-based index offset for the item with max value, -1 means empty collection
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Numeric.Equals``1(``0,``0)">
 <summary>
 =
 </summary>
 <typeparam name="T"></typeparam>
 <param name="a"></param>
 <param name="b"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Numeric.LessThan``1(``0,``0)">
 <summary>
 &lt;
 </summary>
 <typeparam name="T"></typeparam>
 <param name="a"></param>
 <param name="b"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Numeric.GreaterThan``1(``0,``0)">
 <summary>
 a > b
 </summary>
 <typeparam name="T"></typeparam>
 <param name="a"></param>
 <param name="b"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Numeric.LessThanOrEquals``1(``0,``0)">
 <summary>
 ``<paramref name="a"/> &lt;= <paramref name="b"/>``
 </summary>
 <typeparam name="T"></typeparam>
 <param name="a"></param>
 <param name="b"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Numeric.GreaterThanOrEquals``1(``0,``0)">
 <summary>
 =>
 </summary>
 <typeparam name="T"></typeparam>
 <param name="a"></param>
 <param name="b"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Numeric.NextInteger(System.Random,System.Int32)">
 <summary>
 <see cref="M:Microsoft.VisualBasic.ListExtensions.Random``1(``0[])"/> get next integer in the specific range <paramref name="max"/>
 </summary>
 <param name="rnd"></param>
 <param name="max"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Language.Pointer">
 <summary>
 Type of <see cref="T:System.Int32"/> pointer class to the <see cref="T:System.Array"/> class.
 (<see cref="T:System.Int32"/>类型，一般用来进行数组操作的)
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Language.Pointer.index">
 <summary>
 Current read position
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Language.Pointer.step">
 <summary>
 指针移动的步进值
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Language.Pointer.#ctor(System.Int32)">
 <summary>
 Construct a pointer class and then assign a initial <see cref="T:System.Int32"/> value.
 (构造一个指针对象，并且赋值其初始值)
 </summary>
 <param name="n">The initial value.</param>
</member>
<member name="M:Microsoft.VisualBasic.Language.Pointer.#ctor">
 <summary>
 Creates a new <see cref="T:System.Int32"/> type pointer object in VisualBasic with its initial value is ZERO.(构造一个初始值为零的整形数指针对象)
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Language.Pointer.op_LessThan(Microsoft.VisualBasic.Language.Pointer,System.Int32)">
 <summary>
 ``<see cref="F:Microsoft.VisualBasic.Language.Pointer.index"/> &lt; <paramref name="n"/>``
 </summary>
 <param name="x"></param>
 <param name="n"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Pointer.op_LeftShift(Microsoft.VisualBasic.Language.Pointer,System.Int32)">
 <summary>
 移动n，然后返回之前的数值
 </summary>
 <param name="x"></param>
 <param name="n"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Pointer.op_UnaryPlus(Microsoft.VisualBasic.Language.Pointer)">
 <summary>
 Automatically increasing self +1 and then returns the previous value.(自增1，然后返回之前的数值)
 </summary>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Pointer.op_UnaryNegation(Microsoft.VisualBasic.Language.Pointer)">
 <summary>
 自减1，然后返回之前的数值
 </summary>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Pointer.op_LessThanOrEqual(Microsoft.VisualBasic.Language.Pointer,System.Int32)">
 <summary>
 Less than or equals
 </summary>
 <param name="x"></param>
 <param name="n"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Pointer.op_GreaterThanOrEqual(Microsoft.VisualBasic.Language.Pointer,System.Int32)">
 <summary>
 Greater than or equals
 </summary>
 <param name="x"></param>
 <param name="n"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Language.Record">
 <summary>
 Data record type in VisualBasic
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Language.Record.op_Equality(Microsoft.VisualBasic.Language.Record,Microsoft.VisualBasic.Language.Record)">
 <summary>
 Make check of the value equals?
 </summary>
 <param name="a"></param>
 <param name="b"></param>
 <returns></returns>
 
</member>
<member name="T:Microsoft.VisualBasic.Language.Value`1">
 <summary>
 You can applying this data type into a dictionary object to makes the mathematics calculation more easily.
 </summary>
 <typeparam name="T"></typeparam>
</member>
<member name="T:Microsoft.VisualBasic.Language.Value`1.IValueOf">
 <summary>
 This object have a <see cref="P:Microsoft.VisualBasic.Language.Value`1.IValueOf.Value"/> property for stores its data
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Language.Value`1.IValueOf.Value">
 <summary>
 value property for this object stores its data
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Language.Value`1.HasValue">
 <summary>
 Gets a value indicating whether the current System.Nullable`1 object has a valid
 value of its underlying type.
 </summary>
 <returns>true if the current System.Nullable`1 object has a value; false if the current
 System.Nullable`1 object has no value.</returns>
</member>
<member name="P:Microsoft.VisualBasic.Language.Value`1.Index(System.Object)">
 <summary>
 Get data from <see cref="P:Microsoft.VisualBasic.Language.Value`1.Value"/> through its index method
 </summary>
 <param name="key"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Value`1.GetValueOrDefault">
 <summary>
 Retrieves the value of the current System.Nullable`1 object, or the object's
 default value.
 </summary>
 <returns>The value of the System.Nullable`1.Value property if the System.Nullable`1.HasValue
 property is true; otherwise, the default value of the current System.Nullable`1
 object. The type of the default value is the type argument of the current System.Nullable`1
 object, and the value of the default value consists solely of binary zeroes.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Value`1.GetValueOrDefault(`0)">
 <summary>
 Retrieves the value of the current System.Nullable`1 object, or the specified
 default value.
 </summary>
 <param name="defaultValue">A value to return if the System.Nullable`1.HasValue property is false.</param>
 <returns>The value of the System.Nullable`1.Value property if the System.Nullable`1.HasValue
 property is true; otherwise, the defaultValue parameter.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Value`1.Equals(System.Object)">
 <summary>
 Indicates whether the current System.Nullable`1 object is equal to a specified
 object.
 </summary>
 <param name="other">An object.</param>
 <returns>true if the other parameter is equal to the current System.Nullable`1 object;
 otherwise, false. This table describes how equality is defined for the compared
 values: Return ValueDescriptiontrueThe System.Nullable`1.HasValue property is
 false, and the other parameter is null. That is, two null values are equal by
 definition.-or-The System.Nullable`1.HasValue property is true, and the value
 returned by the System.Nullable`1.Value property is equal to the other parameter.falseThe
 System.Nullable`1.HasValue property for the current System.Nullable`1 structure
 is true, and the other parameter is null.-or-The System.Nullable`1.HasValue property
 for the current System.Nullable`1 structure is false, and the other parameter
 is not null.-or-The System.Nullable`1.HasValue property for the current System.Nullable`1
 structure is true, and the value returned by the System.Nullable`1.Value property
 is not equal to the other parameter.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Value`1.Equals(`0)">
 <summary>
 Value equals of <see cref="P:Microsoft.VisualBasic.Language.Value`1.Value"/>
 </summary>
 <param name="other"></param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Language.Value`1.Value">
 <summary>
 The object value with a specific type define.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Value`1.#ctor(`0)">
 <summary>
 Creates an reference value object with the specific object value
 </summary>
 <param name="value"></param>
</member>
<member name="M:Microsoft.VisualBasic.Language.Value`1.#ctor">
 <summary>
 Value is Nothing
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Language.Value`1.IsNothing">
 <summary>
 Is the <see cref="P:Microsoft.VisualBasic.Language.Value`1.Value"/> is nothing.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Value`1.ToString">
 <summary>
 Display <see cref="P:Microsoft.VisualBasic.Language.Value`1.Value"/> ``ToString()`` function value.
 </summary>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Language.Value`1.GetJson">
 <summary>
 Get json string of the <see cref="P:Microsoft.VisualBasic.Language.Value`1.Value"/>.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Value`1.op_UnaryPlus(Microsoft.VisualBasic.Language.Value{`0})">
 <summary>
 Gets the <see cref="P:Microsoft.VisualBasic.Language.Value`1.Value"/> property value.
 </summary>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Value`1.op_Equality(Microsoft.VisualBasic.Language.Value{`0},`0)">
 <summary>
 Inline value assignment: ``Dim s As String = Value(Of String) = var``
 </summary>
 <param name="value"></param>
 <param name="o"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Value`1.op_Equality(`0,Microsoft.VisualBasic.Language.Value{`0})">
 <summary>
 value equals?
 </summary>
 <param name="o"></param>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Language.Value`1.op_Like(Microsoft.VisualBasic.Language.Value{`0},System.Type)">
 <summary>
 Type match operator, this may consider inherits of base type and interface implementation.
 </summary>
 <param name="o"></param>
 <param name="type"></param>
 <returns></returns>
 <remarks>
 Unlike this operation its behavior, the Variant type its type match operator 
 is a type exactly match operation.
 </remarks>
</member>
<member name="T:Microsoft.VisualBasic.Language.Value">
 <summary>
 Variable model in VisualBasic
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Language.Value.Trace">
 <summary>
 这个变量所在的函数的位置记录
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Language.Value.IsNumeric">
 <summary>
 Is a numeric type?
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Language.Variant`2">
 <summary>
 Union type of <typeparamref name="A"/> and <typeparamref name="B"/>
 </summary>
 <typeparam name="A"></typeparam>
 <typeparam name="B"></typeparam>
</member>
<member name="M:Microsoft.VisualBasic.Language.Variant`2.GetUnderlyingType">
 <summary>
 <see cref="T:System.Void"/> will be returns if the value data is nothing!
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Language.Variant`2.VA">
 <summary>
 TryCast to <typeparamref name="A"/>
 </summary>
 <returns></returns>
 <remarks>
 direct cast of <see cref="P:Microsoft.VisualBasic.Language.Value`1.Value"/> to <typeparamref name="A"/>
 </remarks>
</member>
<member name="P:Microsoft.VisualBasic.Language.Variant`2.VB">
 <summary>
 TryCast to <typeparamref name="B"/>
 </summary>
 <returns></returns>
 <remarks>
 direct cast of <see cref="P:Microsoft.VisualBasic.Language.Value`1.Value"/> to <typeparamref name="B"/>
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Language.Variant`2.TryCast``1">
 <summary>
 do direct cast of <see cref="P:Microsoft.VisualBasic.Language.Value`1.Value"/>
 </summary>
 <typeparam name="T"></typeparam>
 <returns>
 this function will returns nothing if the value that holds in 
 this object is nothing
 </returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Language.Variant`2.op_Like(Microsoft.VisualBasic.Language.Variant{`0,`1},System.Type)">
 <summary>
 请注意Like是直接进行比较，不会比较继承关系链的？
 </summary>
 <param name="var">
 为空值的时候，仅当<paramref name="type"/>是Nothing的时候才会返回真
 </param>
 <param name="type"></param>
 <returns></returns>
 <remarks>
 this operator deal with the null reference error safely
 </remarks>
</member>
<member name="T:Microsoft.VisualBasic.LICENSE">
 <summary>
 Information about this VisualBasic App framework code module.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.LICENSE.GPL3">
<summary>
  Looks up a localized string similar to                     GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. &lt;http://fsf.org/&gt;
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away yo [rest of string was truncated]&quot;;.
</summary>
</member>
<member name="M:Microsoft.VisualBasic.LICENSE.GithubRepository">
 <summary>
 https://github.com/xieguigang/sciBASIC
 </summary>
 
</member>
<member name="T:Microsoft.VisualBasic.NamespaceDoc">
 <summary>
 The ``sciBASIC#`` framework library core runtime.
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.Abstract">
 <summary>
 Delegate function pointer interface for scripting internal.
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.Abstract.GetValue">
 <summary>
 Gets the variable value from runtime.
 </summary>
 <param name="var$"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.Abstract.SetValue">
 <summary>
 Set the variable value to the variable.
 </summary>
 <param name="var$"></param>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.Abstract.FunctionEvaluate">
 <summary>
 How to make a function calls.(这个是在已经知道了确切的函数对象的前体下才会使用这个进行调用)
 </summary>
 <param name="func$">The function name in the scripting runtime</param>
 <param name="args"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.Abstract.LoadObject">
 <summary>
 在脚本编程之中将用户输入的字符串数据转换为目标类型的方法接口
 </summary>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.Activity">
 <summary>
 Display the object instance object json from the type definition by using <see cref="T:System.Activator"/>.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.Activity.DisplayType(System.Type)">
 <summary>
 请注意，所需要进行显示的类型必须要Public类型的，假若该目标类型在Module之中，请保证Module也是Public访问的
 </summary>
 <param name="type"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.Activity.Active(System.Type)">
 <summary>
 Display the json of the target type its instance object.
 </summary>
 <param name="type"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Scripting.Activity.ActiveObject(System.Type)">
 <summary>
 与<see cref="M:System.Activator.CreateInstance(System.Type)"/>所不同的是，这个函数还会对属性进行一些Demo值得赋值操作
 </summary>
 <param name="type"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.Activity.__active(System.Type)">
 <summary>
 Creates the example instance object for the example
 </summary>
 <param name="type"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.Activity.__activeList(System.Type)">
 <summary>
 + <see cref="T:System.Collections.Generic.List`1"/>
 + <see cref="T:Microsoft.VisualBasic.Language.List`1"/>(会统一返回这种类型)
 </summary>
 <param name="type"></param>
 <returns></returns>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.Expressions.Aggregates.Mean">
 <summary>
 the average value
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.Expressions.IAggregate">
 <summary>
 Aggregate a numeric vector as a scalar numeric value
 </summary>
 <param name="data">
 a numeric vector, should contains at least one element
 </param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.Expressions.Aggregate">
 <summary>
 Helper module for get lambda function by scripting text
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.Expressions.Aggregate.GetAggregateFunction(System.String)">
 <summary>
 Get ``Aggregate`` function by term.
 </summary>
 <param name="name">
 + max
 + min
 + average
 </param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Scripting.Expressions.Aggregate.GetAggregateFunction(Microsoft.VisualBasic.Scripting.Expressions.Aggregates)">
 <summary>
 Get ``Aggregate`` function by term.
 </summary>
 <param name="aggregate"></param>
 <returns>
 A lambda function for aggregate a numeric vector
 </returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Scripting.Expressions.Aggregate.GetAggregateFunction2(Microsoft.VisualBasic.Scripting.Expressions.Aggregates)">
 <summary>
 Helper function for get lambda function by scripting text for two number parameter
 </summary>
 <param name="aggregate">
 + max
 + min
 + average
 + sum
 + median
 </param>
 <returns>
 a lambda function implements of interface y = f(a,b)
 </returns>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.Expressions.ArrayIndex">
 <summary>
 Expression text helper for vector index
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.Expressions.ArrayIndex.AsVector(System.String)">
 <summary>
 表达式字符串只允许：``1, 2, 3, 4, 5``
 </summary>
 <param name="exp$"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.Expressions.ArrayIndex.TranslateIndex(System.String)">
 <summary>
 Translate the vector expression into a intger index vector
 </summary>
 <param name="exp$">
 + ``1``, index=1
 + ``1:8``, index=1, count=8
 + ``1->8``, index from 1 to 8
 + ``8->1``, index from 8 to 1
 + ``1,2,3,4``, index=1 or  2 or 3 or 4
 </param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.Expressions.Selector">
 <summary>
 The property value selector
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.Expressions.Selector.Select(System.Collections.IEnumerable,System.Type,System.String)">
 <summary>
 Select property value from target source collection by using a specific property name
 </summary>
 <param name="source"></param>
 <param name="type"></param>
 <param name="propertyName$"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.Expressions.Selector.Select``1(System.Collections.IEnumerable,System.Type,System.String)">
 <summary>
 Select property value from target source collection by using a specific property name and with a specific type casting constraint.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <param name="type"></param>
 <param name="propertyName$"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.Expressions.Selector.Select``2(System.Collections.Generic.IEnumerable{``0},System.String)">
 <summary>
 Select all of the object elements their a specific property value and convert to a specific value type.
 (将对象类型之中的某一个属性筛选出来，然后转换为指定的数据类型)
 </summary>
 <typeparam name="T"></typeparam>
 <typeparam name="V"></typeparam>
 <param name="source"></param>
 <param name="propertyName$">
 If the property name is ``$`` expression, that it means makes a type casting on it self.
 (如果属性名称为``$``，即引用自身，则这个函数的作用只是进行强制的``CType``类型转换)
 </param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.Expressions.Selector.Selector`1">
 <summary>
 The object value selector function pointer template
 </summary>
 <typeparam name="T"></typeparam>
 <param name="property$"></param>
 <param name="type"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.Expressions.Selector.Select``1(System.Collections.Generic.IEnumerable{``0},System.String,Microsoft.VisualBasic.Scripting.Expressions.Selector.Selector{``0})">
 <summary>
 Where selector.(这个函数之中只有数字和字符串的比较)
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <param name="expression$">
 ###### propertyName operator value
 
 1. ``a = b``
 2. ``a > b``
 3. ``a &lt; b``
 4. ``a => b``
 5. ``a &lt;= b``
 4. ``a IN b``
 
 ``$``符号表示对象自身
 </param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.Expressions.StringInterpolation">
 <summary>
 简单的字符串插值引擎，可以用来调试字符串表达式的处理结果
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.Expressions.StringInterpolation.VariablePattern">
 <summary>
 允许下换线，点号，ASCII字母，以及数字作为标识符
 
 ```
 $var
 $obj.property
 $obj.property.value.method.etc
 ```
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.Expressions.StringInterpolation.GetValue(System.Collections.Generic.Dictionary{System.String,System.String})">
 <summary>
 不存在的键名会自动返回空字符串
 </summary>
 <param name="resource"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.Expressions.StringInterpolation.Interpolate(System.String,System.Func{System.String,System.String},System.Boolean,System.Boolean)">
 <summary>
 对于<paramref name="getValue"/>方法而言，是不需要``$``前缀了的
 </summary>
 <param name="expr$">
 只有当变量的值不为空值的时候才会进行替换，但是当<paramref name="nullAsEmpty"/>为真的时候会被强行替换为空字符串进行替换
 </param>
 <param name="getValue">Get string value of the variable in the expression.</param>
 <param name="escape">
 是否需要进行对\t\n这类字符的转义操作？假若是路径字符串，则不推荐开启这个选项了，因为路径的分隔符很容易引起误转义...
 </param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.Expressions.StringInterpolation.Interpolate(System.Text.StringBuilder@,System.Func{System.String,System.String},System.Boolean,System.Boolean)">
 <summary>
 在解析出variable之后，variable前面的``$``是会被清除掉的，所以variable的source <paramref name="getValue"/>里面的变量名称应该是没有``$``前缀的
 </summary>
 <param name="sb"></param>
 <param name="getValue"></param>
 <param name="nullAsEmpty">只有当变量的值不为空值的时候才会进行替换，但是当<paramref name="nullAsEmpty"/>为真的时候会被强行替换为空字符串进行替换</param>
 <param name="escape"></param>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ExternalCall">
 <summary>
 Shell object for the external script running.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ExternalCall.host">
 <summary>
 脚本宿主的可执行文件的路径
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ExternalCall.#ctor(System.String,System.String)">
 <summary>
 
 </summary>
 <param name="host">The program its file name to run the script</param>
 <param name="ext">File extension name of this type of script</param>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ExternalCall.Run(System.String,System.Collections.Specialized.NameValueCollection)">
 <summary>
 
 </summary>
 <param name="script">The script content</param>
 <param name="args"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ExternalCall.Shell(System.String,System.Collections.Specialized.NameValueCollection)">
 <summary>
 
 </summary>
 <param name="path">The script file path</param>
 <param name="args"></param>
 <returns></returns>
 <remarks>Perl脚本测试通过！</remarks>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShellValue">
 <summary>
 Script shell result.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShellValue.STD_OUT">
 <summary>
 Standard output on the console
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShellValue.STD_ERR">
 <summary>
 Standard error
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShellValue.state">
 <summary>
 Process exit code
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShellValue.GetObject``1(System.Func{System.String,``0})">
 <summary>
 Parsing object from the standard output
 </summary>
 <typeparam name="T"></typeparam>
 <param name="parser">Object parser</param>
 <returns></returns>
 
</member>
<member name="T:Microsoft.VisualBasic.Scripting.InputHandler">
 <summary>
 Handles the input text string from commandline or scripting, dealing with the 
 conversion of this input string to .NET object in a more easy way.
 (转换从终端或者脚本文件之中输入的字符串的类型的转换)
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.InputHandler.CasterString">
 <summary>
 Object为字符串类型，这个字典可以讲字符串转为目标类型
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.InputHandler.ParseDateTime(System.String)">
 <summary>
 Parsing the dat value from the expression text, if any exception happend, a null date value will returned.
 (空字符串会返回空的日期)
 </summary>
 <param name="s"></param>
 <returns></returns>

</member>
<member name="M:Microsoft.VisualBasic.Scripting.InputHandler.CTypeDynamic(System.Collections.Generic.IEnumerable{System.String},System.Type)">
 <summary>
 Parse the target string value collection as a new array in the given element <paramref name="target"/> type
 </summary>
 <param name="expression">
 A collection of object data in string value
 </param>
 <param name="target">
 The element type
 </param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.InputHandler.CTypeDynamic(System.String,System.Type)">
 <summary>
 Converts a string expression which was input from the console or script file to the specified type.
 (请注意，函数只是转换最基本的数据类型，转换错误会返回空值，空字符串也会返回空值)
 </summary>
 <param name="expression">The string expression to convert.</param>
 <param name="target">The type to which to convert the object.</param>
 <returns>An object whose type at run time is the requested target type.</returns>
 <remarks>
 If all failure, then will try <see cref="M:Microsoft.VisualBasic.Conversion.CTypeDynamic(System.Object,System.Type)"/>
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.InputHandler.CTypeDynamic``1(System.String,``0)">
 <summary>
 Converts a string expression which was input from the console or script file to the specified type.
 (请注意，函数只是转换最基本的数据类型，转换错误会返回空值)
 </summary>
 <param name="expr">The string expression to convert.</param>
 <typeparam name="T">The type to which to convert the object.</typeparam>
 <returns>An object whose type at run time is the requested target type.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.InputHandler.DefaultTextParser``1">
 <summary>
 默认的字符串解析方法为<see cref="M:Microsoft.VisualBasic.Scripting.InputHandler.CTypeDynamic(System.Collections.Generic.IEnumerable{System.String},System.Type)"/>脚本值动态转换函数
 </summary>
 <typeparam name="T"></typeparam>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.InputHandler.IsPrimitive(System.Type)">
 <summary>
 Does this type can be cast from the <see cref="T:System.String"/> type?
 </summary>
 <param name="targetType"></param>
 <returns></returns>
 <remarks>
 (目标类型能否由字符串转换过来??)
 </remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.Scripting.InputHandler.CapabilityPromise(System.String,System.Type,Microsoft.VisualBasic.Scripting.Abstract.LoadObject)">
 <summary>
 Dynamics updates the capability of function <see cref="M:Microsoft.VisualBasic.Scripting.InputHandler.CTypeDynamic(System.String,System.Type)"/>, 
 <see cref="M:Microsoft.VisualBasic.Scripting.InputHandler.CTypeDynamic``1(System.String,``0)"/> and 
 <see cref="M:Microsoft.VisualBasic.Scripting.InputHandler.IsPrimitive(System.Type)"/>
 </summary>
 <param name="briefName"></param>
 <param name="stringConvertType"></param>
 <param name="cast"></param>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.InputHandler.Types">
 <summary>
 Enumerate all of the types that can be handled in this module. All of the key string is in lower case.(键值都是小写的)
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.InputHandler.GetType(System.String,System.Boolean)">
 <summary>
 Get .NET clr <see cref="T:System.Type"/> definition info from its name.
 (类型获取失败会返回空值，大小写不敏感)
 </summary>
 <param name="name">Case insensitive.(类型的名称简写)</param>
 <param name="ObjectGeneric">是否出错的时候返回<see cref="T:System.Object"/>类型，默认返回Nothing</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.InputHandler.GetType(Microsoft.VisualBasic.Language.Value{System.String},System.Boolean)">
 <summary>
 Get .NET <see cref="T:System.Type"/> definition info from its name.
 (类型获取失败会返回空值，大小写不敏感)
 </summary>
 <param name="name">Case insensitive.(类型的名称简写)</param>
 <param name="ObjectGeneric">是否出错的时候返回<see cref="T:System.Object"/>类型，默认返回Nothing</param>
 <returns></returns>
 
</member>
<member name="P:Microsoft.VisualBasic.Scripting.InputHandler.String">
 <summary>
 <see cref="T:System.Type"/> information for <see cref="T:System.String"/> type from GetType operator
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.InputHandler.Convertible(System.Type,System.Type)">
 <summary>
 Does the <paramref name="inputtype"/> type can be cast to type <paramref name="DefType"/>.
 (主要为了方便减少脚本编程模块的代码)
 </summary>
 <param name="inputType"></param>
 <param name="DefType"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Scripting.InputHandler.ToString(System.Object,System.String,System.Boolean)">
 <summary>
 <seealso cref="M:Microsoft.VisualBasic.Scripting.Runtime.NumberConversionRoutines.CStrSafe(System.Object,System.String,System.Boolean)"/>, 出现错误的时候总是会返回空字符串的，
 
 注意：
 
 1. 对于一些基础的数据类型例如<see cref="T:System.Int32"/>,<see cref="T:System.Int64"/>等则是以json序列化来构建字符串值，
 2. 对于<see cref="T:System.Byte"/>数组则是被编码为base64字符串
 </summary>
 <param name="obj"></param>
 <param name="originToStringAsNothing">
 Result of <see cref="T:System.Object"/> as nothing
 </param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Scripting.InputHandler.CastArray``1(System.Object)">
 <summary>
 The parameter <paramref name="obj"/> should implements a <see cref="T:System.Collections.IEnumerable"/> interface on the type. and then DirectCast object to target type.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="obj"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.InputHandler.DirectCast(System.Collections.IEnumerable,System.Type)">
 <summary>
 Cast the <see cref="T:System.Object"/> array to typed object array.
 </summary>
 <param name="array"></param>
 <param name="type">数组里面的元素的类型</param>
 <returns></returns>
 <remarks>
 please note that, this function cast type by using direct cast, without 
 any type conversion. type-mismatch error may be happends.
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.InputHandler.CTypeDynamic(System.Collections.IEnumerable,System.Type)">
 <summary>
 the given <paramref name="type"/> value should be the target 
 array element type.
 </summary>
 <param name="array"></param>
 <param name="type"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.MetaData.Cite">
 <summary>
 EndNote tags
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.MetaData.Cite.Authors">
 <summary>
 author(eMail);author(eMail)
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.MetaData.Cite.ISSN">
 <summary>
 ISSN_1; ISSN_2; ISSN_3
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.MetaData.Cite.Abstract">
 <summary>
 文章的摘要，可以使用&lt;p>或者&lt;br/>来进行分段
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.MetaData.Cite.#ctor(System.String)">
 <summary>
 %x 是文章的摘要，可以使用&lt;p>或者&lt;br/>来进行分段
 </summary>
 <param name="EndNoteImports"></param>
 <remarks>
 %A Griffiths-Jones, Sam
 %A Bateman, Alex
 %A Marshall, Mhairi
 %A Khanna, Ajay
 %A Eddy, Sean R.
 %T Rfam: an RNA family database
 %0 Journal Article
 %D 2003 
 %8 January 1, 2003 
 %J Nucleic Acids Research 
 %P 439-441 
 %R 10.1093/nar/gkg006 
 %V 31 
 %N 1 
 %U http://nar.oxfordjournals.org/content/31/1/439.abstract 
 %X Rfam Is a collection of multiple sequence alignments And covariance models representing non-coding RNA families. Rfam Is available on the web in the UK at http://www.sanger.ac.uk/Software/Rfam/ And in the US at http://rfam.wustl.edu/. These websites allow the user to search a query sequence against a library of covariance models, And view multiple sequence alignments And family annotation. The database can also be downloaded in flatfile form And searched locally using the INFERNAL package (http://infernal.wustl.edu/). The first release of Rfam (1.0) contains 25 families, which annotate over 50 000 non-coding RNA genes in the taxonomic divisions of the EMBL nucleotide database. 
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.MetaData.Cite.__formatAbstractPreview(System.String)">
 <summary>
 摘要可能会有空值的
 </summary>
 <param name="absLen"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.MetaData.FunctionReturns.GetDescription(System.Reflection.MethodInfo)">
 <summary>
 Gets the description of the function returns value
 </summary>
 <param name="method"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.MetaData.OverloadsSignatureHandle">
 <summary>
 用于解决函数重载的函数数字签名的属性
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.MetaData.OverloadsSignatureHandle.#ctor(System.String,System.Type)">
 <summary>
 
 </summary>
 <param name="TypeIdBrief">Brief name for the target signature type <paramref name="FullName"></paramref></param>
 <param name="FullName">Target signature type for function overloads.</param>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.MetaData.MetaAPI.TypeInfo">
 <summary>
 <see cref="T:Microsoft.VisualBasic.Scripting.MetaData.PackageAttribute"/>
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.MetaData.MetaAPI.GetEntry(System.Type)">
 <summary>
 获取定义在类型定义上面的命名空间的标记信息
 </summary>
 <param name="type"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.MetaData.PackageAttribute">
 <summary>
 This attribute provides a more details information about a namepace package module in your scripting plugins.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.MetaData.PackageAttribute.Url">
 <summary>
 This plugins project's home page url.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.MetaData.PackageAttribute.Publisher">
 <summary>
 Your name or E-Mail
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.MetaData.PackageAttribute.Cites">
 <summary>
 这个脚本模块包的文献引用列表
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.MetaData.PackageAttribute.#ctor(Microsoft.VisualBasic.CommandLine.Reflection.Namespace)">
 <summary>
 This attribute provides a more details information about a namepace package module in your scripting plugins.
 </summary>
 <param name="ns"></param>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.MetaData.PackageAttribute.#ctor(Microsoft.VisualBasic.Scripting.MetaData.PackageAttribute)">
 <summary>
 拷贝自身
 </summary>
 <param name="base"></param>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.MetaData.PackageAttribute.#ctor(System.String)">
 <summary>
 This attribute provides a more details information about a namepace package module in your scripting plugins.
 </summary>
 <param name="[Namespace]"></param>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.MetaData.PackageAttribute.#ctor">
 <summary>
 This attribute provides a more details information about a namepace package module in your scripting plugins.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.MetaData.APICategories.SoftwareTools">
 <summary>
 API for facilities of the software development.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.MetaData.APICategories.ResearchTools">
 <summary>
 Analysis Tools API that applied on your scientific research or industry production on computer science.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.MetaData.APICategories.UtilityTools">
 <summary>
 Something small utilities for facility the scripting, makes your programming more easily.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.MetaData.APICategories.CLI_MAN">
 <summary>
 CLI program help manual.
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.MetaData.Parameter">
 <summary>
 You Cann assign the parameter value using the parameter's alias name in the scripting using this attribute.
 (你可以使用本属性将函数的参数名进行重命名，这样子你就可以使用本属性得到一个书写更加漂亮的编程脚本文件了)
 </summary>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.MetaData.Parameter.ParameterInfo">
 <summary>
 请使用这个方法<see cref="M:Microsoft.VisualBasic.Scripting.MetaData.Parameter.GetParameterNameAlias(System.Reflection.ParameterInfo,Microsoft.VisualBasic.Scripting.MetaData.Parameter)"></see>来获取参数信息
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.MetaData.Parameter.Alias">
 <summary>
 The alias name of this function parameter in the scripting.
 </summary>
 <value></value>
 <returns></returns>
 <remarks>(脚本函数的参数的别名)</remarks>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.MetaData.Parameter.Description">
 <summary>
 The description information in the scripting help system.(在帮助信息里面进行显示的本参数的简要的描述信息)  
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.MetaData.Parameter.#ctor(System.String,System.String)">
 <summary>
 You can using this attribute to customize your API interface.
 </summary>
 <param name="Alias">The alias name of this function parameter in the scripting.(当前脚本函数的这个参数的别名)</param>
 <param name="MyDescription">The description information in the scripting help system.(这个信息会显示在脚本环境的帮助系统之中)</param>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.MetaData.Parameter.GetAliasNameView(System.Reflection.ParameterInfo)">
 <summary>
 当没有定义属性的时候，会返回参数名
 </summary>
 <param name="pInfo"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.MetaData.TypeInfo">
 <summary>
 The clr type reference information.
 </summary>
 <remarks>(类型信息)</remarks>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.MetaData.TypeInfo.assembly">
 <summary>
 The assembly file which contains this type definition.
 </summary>
 <returns></returns>
 <remarks>(模块文件)</remarks>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.MetaData.TypeInfo.fullName">
 <summary>
 <see cref="P:System.Type.FullName"/>.
 </summary>
 <returns></returns>
 <remarks>(类型源)</remarks>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.MetaData.TypeInfo.isSystemKnownType">
 <summary>
 Is this type object is a known system type?
 </summary>
 <returns></returns>
 <remarks>(是否是已知的类型？)</remarks>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.MetaData.TypeInfo.#ctor(System.Type,System.Boolean)">
 <summary>
 Creates type reference from the definition.
 </summary>
 <param name="info"></param>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.MetaData.TypeInfo.LoadAssembly(Microsoft.VisualBasic.Language.Default.DefaultString)">
 <summary>
 Loads the assembly file which contains this type. If the <param name="directory"></param> is not a valid directory location, 
 then using the location <see cref="P:Microsoft.VisualBasic.App.HOME"/> as default.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.MetaData.TypeInfo.LoadAssembly(System.String[])">
 <summary>
 Loads the assembly file which contains this type. 
 </summary>
 <param name="searchPath">
 SetDllDirectory
 </param>
 <returns>
 nothing for dll not found
 </returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Scripting.MetaData.TypeInfo.LoadAssembly(System.String,System.String[])">
 <summary>
 Loads the assembly file which contains this type. 
 </summary>
 <param name="searchPath">
 SetDllDirectory
 </param>
 <param name="assembly">
 should be the file name of the assembly dll module file, example as: ``library.dll``
 </param>
 <returns>
 nothing for dll not found
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.MetaData.TypeInfo.GetType(System.Boolean,System.Boolean,System.Exception@,System.String[])">
 <summary>
 Get mapping type information.
 </summary>
 <param name="knownFirst">
 如果这个参数为真的话, 则会尝试直接从当前的应用程序域中查找类信息, 反之则会加载目标程序集进行类型信息查找
 </param>
 <param name="throwEx">
 如果这个参数设置为False的话，则出错的时候会返回空值
 </param>
 <param name="searchPath">
 A list of the candidates directory path for search dll files
 </param>
 <param name="getException">
 <see cref="T:System.DllNotFoundException"/>
 </param>
 <returns></returns>
 <remarks>
 the function of <see cref="M:Microsoft.VisualBasic.ApplicationServices.Development.NetCoreApp.deps.TryHandleNetCore5AssemblyBugs(System.Reflection.Assembly,System.String[])"/> has been called
 automatically when the assembly is built for .netcore app
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.MetaData.TypeInfo.op_Equality(Microsoft.VisualBasic.Scripting.MetaData.TypeInfo,System.Type)">
 <summary>
 检查a是否是指向b的类型引用的
 </summary>
 <param name="a"></param>
 <param name="b"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.Runtime.BinaryOperator">
 <summary>
 Binary operator invoker
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.Runtime.BinaryOperator.Name">
 <summary>
 The name of this binary operator
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.Runtime.BinaryOperator.#ctor(System.Reflection.MethodInfo[])">
 <summary>
 
 </summary>
 <param name="[overloads]">重名的运算符函数方法</param>
 
</member>
<member name="M:Microsoft.VisualBasic.Scripting.Runtime.BinaryOperator.#ctor(System.String,System.Reflection.MethodInfo[])">
 <summary>
 可以通过继承<see cref="T:System.Reflection.MethodInfo"/>类型来自定义函数，再使用这个操作符对象应用于脚本运行时环境之中
 </summary>
 <param name="name$"></param>
 <param name="methods"></param>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.Runtime.BinaryOperator.MatchLeft(System.Type)">
 <summary>
 ``args op me``.(参数在左边)
 </summary>
 <param name="type"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Scripting.Runtime.BinaryOperator.MatchRight(System.Type)">
 <summary>
 ``me op args``.(参数在右边)
 </summary>
 <param name="type"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Scripting.Runtime.BinaryOperator.InvokeSelfLeft(System.Object,System.Object,System.Object@)">
 <summary>
 参数在右边
 </summary>
 <param name="self"></param>
 <param name="obj"></param>
 <param name="result"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Scripting.Runtime.BinaryOperator.InvokeSelfRight(System.Object,System.Object,System.Object@)">
 <summary>
 参数在左边
 </summary>
 <param name="obj"></param>
 <param name="self"></param>
 <param name="result"></param>
 <returns></returns>
 
</member>
<member name="T:Microsoft.VisualBasic.Scripting.Runtime.ClrConversion">
 <summary>
 helper for make clr value type conversion
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.Runtime.ClrConversion.CreatePrimitiveType(System.TypeCode)">
 <summary>
 ``<see cref="T:System.TypeCode"/> -> <see cref="T:System.Type"/>``
 </summary>
 <param name="type"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.Runtime.ClrConversion.CreateArray(System.Collections.IEnumerable,System.Type,System.Boolean)">
 <summary>
 the given <paramref name="type"/> is the array element type
 </summary>
 <param name="data"></param>
 <param name="type">
 the element type of the generated target array
 </param>
 <returns>a generic type array</returns>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.Runtime.IParser">
 <summary>
 Custom user object parser
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.Runtime.IParser.ToString(System.Object)">
 <summary>
 将目标对象序列化为文本字符串
 </summary>
 <param name="obj"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.Runtime.IParser.TryParse(System.String)">
 <summary>
 从Csv文件之中所读取出来的字符串之中解析出目标对象
 </summary>
 <param name="content"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.Runtime.Casting">
 <summary>
 Methods for convert the <see cref="T:System.String"/> to some .NET data types.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.Runtime.Casting.TryParse``1(System.Text.RegularExpressions.Match,``0)">
 <summary>
 Try parse of the enum value.
 </summary>
 <typeparam name="T">This generic type should be an <see cref="T:System.Enum"/> type!</typeparam>
 <param name="expression"></param>
 <param name="[default]"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.Runtime.Casting.ScriptValue(System.Drawing.Size)">
 <summary>
 <see cref="T:System.Drawing.Size"/> object to string expression
 </summary>
 <param name="size"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.Runtime.Casting.Expression(System.Drawing.Size)">
 <summary>
 width,height
 </summary>
 <param name="size"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.Runtime.Casting.Expression(System.Drawing.SizeF)">
 <summary>
 width,height
 </summary>
 <param name="size"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.Runtime.Casting.PointParser(System.String)">
 <summary>
 Parse <see cref="T:System.Drawing.Point"/> from a given string expression
 </summary>
 <param name="pt$"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.Runtime.Casting.FloatPointParser(System.String)">
 <summary>
 Parse <see cref="T:System.Drawing.PointF"/> from a given string expression
 </summary>
 <param name="pt$"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.Runtime.Casting.SizeParser(System.String)">
 <summary>
 Parse <see cref="T:System.Drawing.Size"/> from a given string expression
 </summary>
 <param name="pt$"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.Runtime.Casting.FloatSizeParser(System.String)">
 <summary>
 Parse <see cref="T:System.Drawing.SizeF"/> from a given string expression
 </summary>
 <param name="pt$"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.Runtime.Casting.AsBaseType``2(``0)">
 <summary>
 ``DirectCast(obj, T)``. 这个函数主要是为了解决Class类型之间的继承类型的转换，例如子类型向基础类型转换
 </summary>
 <typeparam name="T"></typeparam>
 <param name="obj"></param>
 <returns></returns>
 <remarks>
 可能会和向量的As类型转换有冲突
 </remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.Scripting.Runtime.Casting.As``2(System.Collections.Generic.IEnumerable{``0})">
 <summary>
 Cast array type
 </summary>
 <typeparam name="T"></typeparam>
 <typeparam name="TOut"></typeparam>
 <param name="list">在这里使用向量而非使用通用接口是因为和单个元素的As转换有冲突</param>
 <returns></returns>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.Runtime.Casting.RegexpDouble">
 <summary>
 用于解析出任意实数的正则表达式
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.Runtime.Casting.RegexParseDouble(System.String)">
 <summary>
 Parsing a real number from the expression text by using the regex expression <see cref="F:Microsoft.VisualBasic.Scripting.Runtime.Casting.RegexpFloat"/>.
 (使用正则表达式解析目标字符串对象之中的一个实数)
 </summary>
 <param name="s"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.Runtime.Casting.ParseNumeric(System.String)">
 <summary>
 Will processing value NaN automatically and strip for the comma, percentage expression.
 </summary>
 <param name="s">
 + numeric
 + NaN, NA
 + p%
 + a/b
 </param>
 <returns></returns>
 <remarks>
 this function will mapping factor string ``NaN`` and ``NA`` as <see cref="F:System.Double.NaN"/>
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.Runtime.Casting.CastChar(System.String)">
 <summary>
 字符串是空值会返回空字符
 </summary>
 <param name="obj"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Scripting.Runtime.Casting.CastInteger(System.String)">
 <summary>
 出错会返回默认是0
 </summary>
 <param name="obj"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Scripting.Runtime.Casting.CastDate(System.String)">
 <summary>
 支持日期字符串和unix timstamp对<see cref="T:System.DateTime"/>的转换
 </summary>
 <param name="obj"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.Runtime.Casting.CastCommandLine(System.String)">
 <summary>
 <see cref="M:Microsoft.VisualBasic.CommandLine.CLITools.TryParse(System.String,System.String,System.Char)"/>
 </summary>
 <param name="obj"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Scripting.Runtime.Casting.CastImage(System.String)">
 <summary>
 <see cref="M:Microsoft.VisualBasic.Imaging.GraphicsExtensions.LoadImage(System.Byte[],System.Boolean)"/>
 </summary>
 <param name="path"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Scripting.Runtime.CastStringVector.AsCharacter(System.Collections.Generic.Dictionary{System.String,System.Double})">
 <summary>
 Convert the numeric <see cref="T:System.Double"/> type as the <see cref="T:System.String"/> text type.
 </summary>
 <param name="values"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.Runtime.CastStringVector.AsCharacter(System.Collections.Generic.Dictionary{System.String,System.Object},System.String)">
 <summary>
 Convert the numeric <see cref="T:System.Object"/> type as the <see cref="T:System.String"/> text type by <see cref="M:Microsoft.VisualBasic.Scripting.InputHandler.ToString(System.Object,System.String,System.Boolean)"/>.
 </summary>
 <param name="values"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.Runtime.CastStringVector.AsCharacter(System.Collections.Generic.IEnumerable{System.Double},System.Boolean,System.String)">
 <summary>
 Cats the given numeric vector as character string.
 </summary>
 <param name="values"></param>
 <param name="negPrefix">add prefix to the positive value for make align with the negative symbol, 
 example as if this parameter is set to true:
 
 ```
  256.333
 -111.112  
 ```
 
 the positive number ``256.333`` has a white space prefix for make aligned with the negative 
 value ``-111.112``.
 </param>
 <param name="format"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.Runtime.CastStringVector.AsCharacter``1(System.Collections.Generic.IEnumerable{``0},System.String)">
 <summary>
 使用<see cref="M:Microsoft.VisualBasic.Scripting.InputHandler.ToString(System.Object,System.String,System.Boolean)"/>方法将对象集合转换为字符串序列
 </summary>
 <typeparam name="T"></typeparam>
 <param name="values"></param>
 <param name="null$"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.Runtime.CastStringVector.AsNumeric(System.Collections.Generic.Dictionary{System.String,System.String})">
 <summary>
 Convert the <see cref="T:System.String"/> value as <see cref="T:System.Double"/> numeric type.
 </summary>
 <param name="values"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.Runtime.CastStringVector.AsGeneric``1(System.Collections.Generic.Dictionary{System.String,``0})">
 <summary>
 将字典之中的值转换为<see cref="T:System.Object"/>类型
 </summary>
 <typeparam name="T"></typeparam>
 <param name="values"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.Runtime.CastStringVector.AsType``1(System.Collections.Generic.IEnumerable{System.String})">
 <summary>
 string array parser helper. 
 </summary>
 <typeparam name="T">get parser for current type from <see cref="P:Microsoft.VisualBasic.Scripting.InputHandler.CasterString"/>.</typeparam>
 <param name="source"></param>
 <returns></returns>
 <remarks>
 批量的将一个字符串集合解析转换为目标类型<typeparamref name="T"/>的对象的集合
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.Runtime.CastStringVector.AsDouble(System.Collections.Generic.IEnumerable{System.String})">
 <summary>
 将字符串集合转换为一个数值向量
 </summary>
 <param name="source"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Scripting.Runtime.CastStringVector.AsDouble(System.Collections.Generic.IEnumerable{System.Single})">
 <summary>
 cast single float to double in batch
 </summary>
 <param name="singles"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.Runtime.CastStringVector.AsDouble(System.Collections.Generic.IEnumerable{System.Int32})">
 <summary>
 cast integer to double in batch
 </summary>
 <param name="singles"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.Runtime.CastStringVector.AsSingle(System.Collections.Generic.IEnumerable{System.String})">
 <summary>
 parse string as float number in batch mode
 </summary>
 <param name="source"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.Runtime.CastStringVector.AsLong(System.Collections.Generic.IEnumerable{System.String})">
 <summary>
 parse string as long integer in batch mode
 </summary>
 <param name="source"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.Runtime.CastStringVector.AsBoolean(System.Collections.Generic.IEnumerable{System.String})">
 <summary>
 parse string as boolean in batch mode
 </summary>
 <param name="source"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.Runtime.CastStringVector.AsInteger(System.Collections.Generic.IEnumerable{System.String})">
 <summary>
 parse string as integer in batch mode
 </summary>
 <param name="source"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.Runtime.CastStringVector.AsColor(System.Collections.Generic.IEnumerable{System.String})">
 <summary>
 parse string as gdi+ color object in batch mode
 </summary>
 <param name="source"></param>
 <returns></returns>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.Runtime.ImplictCType.operatorType">
 <summary>
 2070 = SpecialName
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.Runtime.ImplictCType.op_Explicit">
 <summary>
 x -> out
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.Runtime.ImplictCType.op_Implicit">
 <summary>
 in -> x
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.Runtime.ImplictCType.GetOperatorMethod(System.Reflection.TypeInfo,System.Type,System.String)">
 <summary>
 直接使用GetMethod方法仍然会出错？？如果目标类型是继承类型，基类型也有一个收缩的操作符的话，会爆出目标不明确的错误
 
 ```vbnet
 type.GetMethod(op_Explicit, NarrowingOperator)
 ```
 </summary>
 <param name="obj"></param>
 <returns>函数找不到会返回Nothing</returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.Runtime.ImplictCType.GetCTypeOperator(System.Type,System.Type)">
 <summary>
 get ctype operator function for cast <paramref name="fromType"/> to <paramref name="ctypeTo"/>.
 </summary>
 <param name="fromType"></param>
 <param name="ctypeTo"></param>
 <returns>
 this function returns nothing if the ctype operator is not found
 </returns>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.Runtime.NumberConversionRoutines">
 <summary>
 这个模块之中包含有安全的将字符串解析为不同的数值类型的方法函数
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.Runtime.NumberConversionRoutines.CStrSafe(System.Object,System.String,System.Boolean)">
 <summary>
 安全的将目标对象转换为字符串值
 </summary>
 <param name="obj"></param>
 <returns>
 如果目标是字节数组，则会被转换为base64字符串
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.Runtime.OverloadsFunction.Align(System.Reflection.MethodInfo,System.Type[])">
 <summary>
 Find the best matched overloads function based on the input parameter
 </summary>
 <param name="target"></param>
 <param name="args">The type of the input parameter values</param>
 <returns></returns>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.Runtime.Logics.And">
 <summary>
 两边的逻辑表达式都会被计算
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.Runtime.Logics.Or">
 <summary>
 两边的逻辑表达式都会被计算
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.Runtime.Logics.AndAlso">
 <summary>
 相比于<see cref="F:Microsoft.VisualBasic.Scripting.Runtime.Logics.And"/>，这个逻辑运算是会短路的
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.Runtime.Logics.OrElse">
 <summary>
 相比于<see cref="F:Microsoft.VisualBasic.Scripting.Runtime.Logics.Or"/>，这个逻辑运算是会短路的
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.Runtime.Where">
 <summary>
 Merge the logical lambda into one lambda function by a specifc logical operation in <see cref="T:Microsoft.VisualBasic.Scripting.Runtime.Logics"/>.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.Runtime.Where.BuildAll``1(Microsoft.VisualBasic.Scripting.Runtime.Logics,System.Func{``0,System.Boolean}[])">
 <summary>
 Not support <see cref="F:Microsoft.VisualBasic.Scripting.Runtime.Logics.Not"/>
 </summary>
 <typeparam name="T"></typeparam>
 <param name="logic"></param>
 <param name="tests"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.Runtime.Where.__or``1(``0,System.Func{``0,System.Boolean}[])">
 <summary>
 <see cref="F:Microsoft.VisualBasic.Scripting.Runtime.Logics.Or"/>, 所有的表达式都会被计算
 </summary>
 <typeparam name="T"></typeparam>
 <param name="x"></param>
 <param name="tests"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.Runtime.Where.__and``1(``0,System.Func{``0,System.Boolean}[])">
 <summary>
 <see cref="F:Microsoft.VisualBasic.Scripting.Runtime.Logics.And"/>, 所有的表达式都会被计算
 </summary>
 <param name="tests"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.SymbolBuilder.ScriptBuilder">
 <summary>
 对<see cref="T:System.Text.StringBuilder"/>对象的拓展，添加了操作符凭借字符串，从而能够让生成代码的操作更加的方便
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.SymbolBuilder.ScriptBuilder.Assign(System.String)">
 <summary>
 The variable in target script text should be in format like: ``{$name}``
 </summary>
 <param name="name"></param>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.SymbolBuilder.ScriptBuilder.Preview">
 <summary>
 Equals to <see cref="M:System.Text.StringBuilder.ToString"/>
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.SymbolBuilder.ScriptBuilder.Replace(System.String,System.String)">
 <summary>
 <see cref="M:System.Text.StringBuilder.Replace(System.String,System.String)"/>
 </summary>
 <param name="key$"></param>
 <param name="value$"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.SymbolBuilder.ScriptBuilder.ToString">
 <summary>
 Display the string text in the <see cref="T:System.Text.StringBuilder"/> object.
 </summary>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Scripting.SymbolBuilder.ScriptBuilder.AppendLine(System.String)">
 <summary>
 Appends a copy of the specified string followed by the default line terminator
 to the end of the current <see cref="T:Microsoft.VisualBasic.Scripting.SymbolBuilder.ScriptBuilder"/> object.
 </summary>
 <param name="line$">The string to append.</param>
 <returns>A reference to this instance after the append operation has completed.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.SymbolBuilder.ScriptBuilder.op_Explicit(Microsoft.VisualBasic.Scripting.SymbolBuilder.ScriptBuilder)~System.String">
 <summary>
 <see cref="M:System.Text.StringBuilder.ToString"/>
 </summary>
 <param name="sb"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Scripting.SymbolBuilder.ScriptBuilder.op_Concatenate(Microsoft.VisualBasic.Scripting.SymbolBuilder.ScriptBuilder,System.String)">
 <summary>
 <see cref="M:System.Text.StringBuilder.Append(,System.Int32)"/>
 </summary>
 <param name="sb"></param>
 <param name="s"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.SymbolBuilder.ScriptBuilder.op_Addition(Microsoft.VisualBasic.Scripting.SymbolBuilder.ScriptBuilder,System.String)">
 <summary>
 <see cref="M:System.Text.StringBuilder.AppendLine"/>
 </summary>
 <param name="sb"></param>
 <param name="s"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.SymbolBuilder.ScriptBuilder.Save(System.String,System.Text.Encoding)">
 <summary>
 save value from <see cref="M:Microsoft.VisualBasic.Scripting.SymbolBuilder.ScriptBuilder.ToString"/>
 </summary>
 <param name="path"></param>
 <param name="encoding"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.SymbolBuilder.VBLanguage.Extensions.AsVBIdentifier``1(System.Collections.Generic.Dictionary{System.String,``0})">
 <summary>
 这个拓展函数将字典之中的字符串主键处理为符合VB的对象命名规则的字符串
 </summary>
 <typeparam name="T"></typeparam>
 <param name="table"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Scripting.SymbolBuilder.VBLanguage.Extensions.AsVBIdentifier(System.String)">
 <summary>
 Normalize the input text token as a valid VisualBasic identifier
 </summary>
 <param name="key"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.SymbolBuilder.VBLanguage.Extensions.IsValidVBSymbolName(System.String)">
 <summary>
 the given string is a valid VB identifier symbol?
 </summary>
 <param name="name"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.SymbolBuilder.VBLanguage.KeywordProcessor">
 <summary>
 Keyword processor of the VB.NET language
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.SymbolBuilder.VBLanguage.KeywordProcessor.VBKeywords">
 <summary>
 List of VB.NET language keywords
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.SymbolBuilder.VBLanguage.KeywordProcessor.TokenWords">
 <summary>
 Tokenize of <see cref="F:Microsoft.VisualBasic.Scripting.SymbolBuilder.VBLanguage.KeywordProcessor.VBKeywords"/>
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.SymbolBuilder.VBLanguage.KeywordProcessor.AutoEscapeVBKeyword(System.String)">
 <summary>
 Escaping the vb variable name when it conflicts with VB keywords name, 
 this function can be using for the VB.NET related code generator.
 </summary>
 <param name="name$">The identifier name.</param>
 <returns>If the identifier is a VB.NET keyword, then it will be escaping and returns, 
 otherwise, will do nothing, function returns the raw input identifier.
 </returns>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.SymbolBuilder.VBLanguage.Patterns">
 <summary>
 <see cref="T:System.Text.RegularExpressions.Regex"/> pattern of VisualBasic language tokens
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.SymbolBuilder.VBLanguage.Patterns.Identifer">
 <summary>
 匹配一个合法的标识符，在正则匹配的时候应该不区分大小写
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.SymbolBuilder.VBLanguage.Patterns.TypeChar">
 <summary>
 The VB.NET type char index
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.TextGrepMethodToken">
 <summary>
 
 </summary>
 <param name="source">文本源</param>
 <param name="args">脚本命令的参数</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.TextGrepMethod">
 <summary>
 从目标源文本字符串之中进行字符串解析的操作
 </summary>
 <param name="source"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.TextGrepScriptEngine">
 <summary>
 A script object for grep the gene id in the blast output query and subject title.
 (用于解析基因名称的脚本类，这个对象是在项目的初始阶段，为了方便命令行操作而设置的)
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.TextGrepScriptEngine._operations">
 <summary>
 Source,Script,ReturnValue
 </summary>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.TextGrepScriptEngine.IsDoNothing">
 <summary>
 当前的这个脚本是否不进行任何操作
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.TextGrepScriptEngine.Compile(System.String)">
 <summary>
 对用户所输入的脚本进行编译，对于内部的空格，请使用单引号``'``进行分割
 </summary>
 <param name="scriptText">
 The script line should be this format: 
 ```
 script_tokens1;script_tokens2;....
 ```
 if there is any space in the script line, then the space should wrapped 
 by the ``'`` character.
 
 (如果这个参数传递的是一个空字符串，那么这个函数将会直接返回<see cref="P:Microsoft.VisualBasic.Scripting.TextGrepScriptEngine.DoNothing"/>脚本)
 </param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.TextGrepScriptEngine.DoNothing">
 <summary>
 Source in and then source out, no changes
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.TextGrepScriptEngine.PipelinePointer">
 <summary>
 <see cref="M:Microsoft.VisualBasic.Scripting.TextGrepScriptEngine.Grep(System.String)"/>
 字符串剪裁操作的函数指针
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.TextGrepScriptEngine.Grep(System.String)">
 <summary>
 修整目标字符串，按照脚本之中的方法取出所需要的字符串信息
 </summary>
 <param name="source"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.TextGrepScriptEngine.NoOperation(System.String,System.String[])">
 <summary>
 DO_NOTHING
 </summary>
 <param name="source"></param>
 <param name="script"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.TextGrepScriptEngine.Tokens(System.String,System.String[])">
 <summary>
 
 </summary>
 <param name="Source"></param>
 <param name="Script"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.TextGrepScriptEngine.MidString(System.String,System.String[])">
 <summary>
 
 </summary>
 <param name="source"></param>
 <param name="script">
 向量之中的第一个元素为命令的名字，第二个元素为Mid函数的Start参数，第三个元素为Mid函数的Length参数，可以被忽略掉
 </param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.TokenIcer.CodeSpan">
 <summary>
 目标Token对象在原始代码文本之中的定位位置
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.TokenIcer.CodeSpan.start">
 <summary>
 源代码中的起始位置 
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.TokenIcer.CodeSpan.stops">
 <summary>
 源代码中的结束位置
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.TokenIcer.CodeSpan.line">
 <summary>
 在代码文本的行号
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.TokenIcer.OperatorExpression.Linq2Symbols">
 <summary>
 Linq Type to operator symbols.
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.TokenIcer.ParserCommon">
 <summary>
 Generally expression parser codes
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.TokenIcer.ParserCommon.StartEscaping(Microsoft.VisualBasic.Language.List{System.Char},System.Char)">
 <summary>
 当前的token对象之中是否是转义的起始，即当前的token之中的最后一个符号是否是转移符<paramref name="escape"/>?
 </summary>
 <param name="buffer"></param>
 <param name="escape"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.TokenIcer.ParserCommon.StartEscaping(Microsoft.VisualBasic.Text.Parser.CharBuffer,System.Char)">
 <summary>
 当前的token对象之中是否是转义的起始，即当前的token之中的最后一个符号是否是转义符<paramref name="escape"/>?
 </summary>
 <param name="buffer"></param>
 <param name="escape"></param>
 <returns>
 this function deal with the empty collection: returns false if the given buffer is empty
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.TokenIcer.ParserCommon.GetCodeComment(System.String,System.String[])">
 <summary>
 假若返回来的是空字符串，则说明不是注释行
 </summary>
 <param name="line"></param>
 <param name="prefix">The prefix of the code comment character/string</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.TokenIcer.ParserCommon.As``2(Microsoft.VisualBasic.Scripting.TokenIcer.CodeToken{``0})">
 <summary>
 Dynamics casting the token value expression as target type object.
 </summary>
 <typeparam name="Tokens"></typeparam>
 <typeparam name="T"></typeparam>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.TokenIcer.ParserCommon.CType``1(Microsoft.VisualBasic.Scripting.TokenIcer.CodeToken{``0},System.Type)">
 <summary>
 Dynamics casting the token value expression as target type object.
 </summary>
 <typeparam name="Tokens"></typeparam>
 <param name="x"></param>
 <param name="type"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.TokenIcer.ParserCommon.TryCast``1(Microsoft.VisualBasic.Scripting.TokenIcer.CodeToken{``0})">
 <summary>
 Try cast the token value to a .NET object based on the token type name.
 </summary>
 <typeparam name="Tokens"></typeparam>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.TokenIcer.CodeToken`1">
 <summary>
 a Token object class, This defines the Token object
 </summary>
 <typeparam name="Tokens">应该是枚举类型</typeparam>
 <remarks>
 A Token object holds the token and token value.
 </remarks>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.TokenIcer.CodeToken`1.name">
 <summary>
 Token type
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.TokenIcer.CodeToken`1.text">
 <summary>
 The text that makes up the token.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.TokenIcer.CodeToken`1.isNumeric">
 <summary>
 Returns a Boolean value indicating whether an expression can be evaluated as
 a number.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.TokenIcer.CodeToken`1.op_Equality(Microsoft.VisualBasic.Scripting.TokenIcer.CodeToken{`0},System.ValueTuple{`0,System.String[]})">
 <summary>
 token is target token type andalso token text is one of any in the given text items 
 </summary>
 <param name="token"></param>
 <param name="element"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.TokenIcer.TokenStack`1">
 <summary>
 A general script token stack helper
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.TokenIcer.TokenStack`1.isEmpty">
 <summary>
 current stack is empty?
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.TokenIcer.TokenStack`1.Pop(Microsoft.VisualBasic.Scripting.TokenIcer.CodeToken{`0},System.Int32)">
 <summary>
 
 </summary>
 <param name="c">
 should be a stack ``close`` token
 </param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.TokenIcer.StackStates.MisMatched">
 <summary>
 syntax error?
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Serialization.IStringParser">
 <summary>
 数据类型转换方法的句柄对象
 </summary>
 <param name="data">源之中的数据，由于源是一个TEXT格式的数据文件，故而这里的数据类型为字符串，通过本句柄对象可以将字符串数据映射为其他的复杂数据类型</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.Serialization.IStringBuilder">
 <summary>
 将目标对象序列化为文本字符串的字符串构造方法
 </summary>
 <param name="data"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Serialization.IToString`1">
 <summary>
 delegate for generic cast object to string
 </summary>
 <typeparam name="T"></typeparam>
 <param name="obj"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Serialization.Bencoding.BDictionary">
 <summary>
 A bencode dictionary.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Serialization.Bencoding.BDictionary.Item(System.String)">
 <summary>
 Gets or sets the value assosiated with the specified key.
 </summary>
 <param name="key">The key of the value to get or set.</param>
 <returns>The value assosiated with the specified key.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.Bencoding.BDictionary.ToBencodedString">
 <summary>
 Generates the bencoded equivalent of the dictionary.
 </summary>
 <returns>The bencoded equivalent of the dictionary.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.Bencoding.BDictionary.ToBencodedString(System.Text.StringBuilder)">
 <summary>
 Generates the bencoded equivalent of the dictionary.
 </summary>
 <param name="u">The StringBuilder to append to.</param>
 <returns>The bencoded equivalent of the dictionary.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.Bencoding.BDictionary.Add(System.String,Microsoft.VisualBasic.Serialization.Bencoding.BElement)">
 <summary>
 Adds the specified key-value pair to the dictionary.
 </summary>
 <param name="key">The specified key.</param>
 <param name="value">The specified value.</param>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.Bencoding.BDictionary.Add(System.String,System.String)">
 <summary>
 Adds the specified key-value pair to the dictionary.
 </summary>
 <param name="key">The specified key.</param>
 <param name="value">The specified value.</param>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.Bencoding.BDictionary.Add(System.String,System.Int32)">
 <summary>
 Adds the specified key-value pair to the dictionary.
 </summary>
 <param name="key">The specified key.</param>
 <param name="value">The specified value.</param>
</member>
<member name="T:Microsoft.VisualBasic.Serialization.Bencoding.BElement">
 <summary>
 An interface for bencoded elements.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.Bencoding.BElement.ToBencodedString">
 <summary>
 Generates the bencoded equivalent of the element.
 </summary>
 <returns>The bencoded equivalent of the element.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.Bencoding.BElement.ToBencodedString(System.Text.StringBuilder)">
 <summary>
 Generates the bencoded equivalent of the element.
 </summary>
 <param name="u">The StringBuilder to append to.</param>
 <returns>The bencoded equivalent of the element.</returns>
</member>
<member name="T:Microsoft.VisualBasic.Serialization.Bencoding.BInteger">
 <summary>
 A bencode integer.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Serialization.Bencoding.BInteger.Value">
 <summary>
 The value of the bencoded integer.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.Bencoding.BInteger.#ctor(System.Int64)">
 <summary>
 The main constructor.
 </summary>
 <param name="value">The value of the bencoded integer.</param>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.Bencoding.BInteger.ToBencodedString">
 <summary>
 Generates the bencoded equivalent of the integer.
 </summary>
 <returns>The bencoded equivalent of the integer.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.Bencoding.BInteger.ToBencodedString(System.Text.StringBuilder)">
 <summary>
 Generates the bencoded equivalent of the integer.
 </summary>
 <returns>The bencoded equivalent of the integer.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.Bencoding.BInteger.GetHashCode">
 <see cref="T:System.Object"/>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.Bencoding.BInteger.Equals(System.Object)">
 <summary>
 Int32.Equals(object)
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.Bencoding.BInteger.ToString">
 <see cref="T:System.Object"/>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.Bencoding.BInteger.CompareTo(Microsoft.VisualBasic.Serialization.Bencoding.BInteger)">
 <see cref="M:System.IComparable.CompareTo(System.Object)"/>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.Bencoding.BInteger.op_Implicit(System.Int32)~Microsoft.VisualBasic.Serialization.Bencoding.BInteger">
 <summary>
 Allows you to set an integer to a BInteger.
 </summary>
 <param name="n"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Serialization.Bencoding.BList">
 <summary>
 A bencode list.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.Bencoding.BList.ToBencodedString">
 <summary>
 Generates the bencoded equivalent of the list.
 </summary>
 <returns>The bencoded equivalent of the list.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.Bencoding.BList.ToBencodedString(System.Text.StringBuilder)">
 <summary>
 Generates the bencoded equivalent of the list.
 </summary>
 <param name="u">The StringBuilder to append to.</param>
 <returns>The bencoded equivalent of the list.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.Bencoding.BList.Add(System.String)">
 <summary>
 Adds the specified value to the list.
 </summary>
 <param name="value">The specified value.</param>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.Bencoding.BList.Add(System.Int32)">
 <summary>
 Adds the specified value to the list.
 </summary>
 <param name="value">The specified value.</param>
</member>
<member name="T:Microsoft.VisualBasic.Serialization.Bencoding.BString">
 <summary>
 A bencode string.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Serialization.Bencoding.BString.Value">
 <summary>
 The value of the bencoded integer.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.Bencoding.BString.#ctor(System.String)">
 <summary>
 The main constructor.
 </summary>
 <param name="value"></param>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.Bencoding.BString.ToBencodedString">
 <summary>
 Generates the bencoded equivalent of the string.
 </summary>
 <returns>The bencoded equivalent of the string.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.Bencoding.BString.ToBencodedString(System.Text.StringBuilder)">
 <summary>
 Generates the bencoded equivalent of the string.
 </summary>
 <param name="u">The StringBuilder to append to.</param>
 <returns>The bencoded equivalent of the string.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.Bencoding.BString.GetHashCode">
 <see cref="T:System.Object"/>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.Bencoding.BString.Equals(System.Object)">
 <summary>
 String.Equals(object)
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.Bencoding.BString.ToString">
 <see cref="T:System.Object"/>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.Bencoding.BString.CompareTo(Microsoft.VisualBasic.Serialization.Bencoding.BString)">
 <see cref="M:System.IComparable.CompareTo(System.Object)"/>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.Bencoding.BString.op_Implicit(System.String)~Microsoft.VisualBasic.Serialization.Bencoding.BString">
 <summary>
 Allows you to set a string to a BString.
 </summary>
 <param name="s"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Serialization.Bencoding.BencodeDecoder">
 <summary>
 A class used for decoding Bencoding.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.Bencoding.BencodeDecoder.Decode(System.String)">
 <summary>
 Decodes the string.
 </summary>
 <param name="bencodedString">The bencoded string.</param>
 <returns>An array of root elements.</returns>
</member>
<member name="T:Microsoft.VisualBasic.Serialization.Bencoding.BencodingException">
 <summary>
 A bencoding exception.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.Bencoding.BencodingException.#ctor">
 <summary>
 Creates a new BencodingException.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.Bencoding.BencodingException.#ctor(System.String)">
 <summary>
 Creates a new BencodingException.
 </summary>
 <param name="message">The message.</param>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.Bencoding.BencodingException.#ctor(System.String,System.Exception)">
 <summary>
 Creates a new BencodingException.
 </summary>
 <param name="message">The message.</param>
 <param name="inner">The inner exception.</param>
</member>
<member name="T:Microsoft.VisualBasic.Serialization.Bencoding.BencodingExtensions">
 <summary>
 A class with extension methods for use with Bencoding.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.Bencoding.BencodingExtensions.BDecode(System.String)">
 <summary>
 Decode the current instance.
 </summary>
 <param name="s">The current instance.</param>
 <returns>The root elements of the decoded string.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.Bencoding.BencodingExtensions.ToList(Microsoft.VisualBasic.Serialization.Bencoding.BElement)">
 <summary>
 cast object to a object array
 </summary>
 <param name="b"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.Bencoding.BencodingExtensions.ToBEncodeString``1(``0,System.Func{System.Object,System.Object})">
 <summary>
 Generates the bencoded equivalent of the element.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="obj"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.Bencoding.BencodingExtensions.ToBEncode(System.Object,System.Func{System.Object,System.Object})">
 <summary>
 bencode有4种数据类型:string,integer,list和dictionary。
 
 string：字符是以这种方式编码的: &lt;字符串长度>:&lt;字符串>。
 如，"hello"：5:hello
 
 2. integer：整数是以这种方式编码的: i&lt;整数>e。
 
 如，1234：i1234e
 
 3. list：列表是以这种方式编码的: l[数据1][数据2][数据3][…]e。
 
 如，["hello","world",1234]
 1. "hello"编码：5:hello
 2. "world"编码：5:world
 3. 1234编码：i1234e
 4. 最终编码：l5:hello5:worldi1234ee
 
 4. dictionary：字典是以这种方式编码的: d[key1][value1][key2][value2][…]e，其中key必须是string而且按照字母顺序排序。
 
 如，{"name":"jisen","coin":"btc","balance":1000}
 1. "name":"jisen"编码：4:name5:jisen
 2. "coin":"btc"编码：4:coin3:btc
 3. "balance":1000编码：7:balancei1000e
 4. 最终编码，按key的字母排序：d7:balancei1000e4:coin3:btc4:name5:jisene
 </summary>
 <param name="obj"></param>
 <param name="digest"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Serialization.BinaryDumping.Buffer">
 <summary>
 A biffer object with byte length prefix
 </summary>
 <remarks>
 如果是类似于Memory map file的数据流,由于Memory map file的预分配大小可能会大于实际的数据大小
 所以会需要使用一个长度的prefix来保证数据可以被正确读取,反序列化
 </remarks>
</member>
<member name="F:Microsoft.VisualBasic.Serialization.BinaryDumping.Buffer.Length">
 <summary>
 the length of <see cref="F:Microsoft.VisualBasic.Serialization.BinaryDumping.Buffer.buffer"/> array
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Serialization.BinaryDumping.BufferAPI">
 <summary>
 适用于对变长的流的操作
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Serialization.BinaryDumping.NetworkByteOrderBuffer">
 <summary>
 ensure that the number is converted as bytes always in network byte order outputs.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Serialization.BinaryDumping.NetworkByteOrderBuffer.encode">
 <summary>
 encode the numeric vector as raw stream in network byte order
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Serialization.BinaryDumping.NetworkByteOrderBuffer.decode">
 <summary>
 decode the given raw stream as a numeric vector in network byte order
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.BinaryDumping.NetworkByteOrderBuffer.ParseDouble(System.String,Microsoft.VisualBasic.Serialization.BinaryDumping.NetworkByteOrderBuffer.Compression,System.Boolean)">
 <summary>
 parse the given base64 string as the numeric vector
 </summary>
 <param name="base64"></param>
 <param name="zip">does the given base64 string is gzip compressed data?</param>
 <param name="noMagic">does the zip compression data has two byte of magic number, default is false which means it has the magic number</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.BinaryDumping.NetworkByteOrderBuffer.Base64String(System.Collections.Generic.IEnumerable{System.Double},System.Boolean)">
 <summary>
 encode the given numeric data vector in network byte order and then returns the base64 encode string
 </summary>
 <param name="data"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.BinaryDumping.NetworkByteOrderBuffer.GetBytes(System.Collections.Generic.IEnumerable{System.Double})">
 <summary>
 make binary data encoding of a given numeric vector
 </summary>
 <param name="d"></param>
 <returns></returns>
 <remarks>
 a wrapper function of the <see cref="F:Microsoft.VisualBasic.Serialization.BinaryDumping.NetworkByteOrderBuffer.encode"/>
 </remarks>
</member>
<member name="T:Microsoft.VisualBasic.Serialization.BinaryDumping.DoVisitObject">
 <summary>
 Do serialization or count memory size by this interface method
 </summary>
 <param name="value"></param>
 <param name="type"></param>
 <param name="isVisited">当前的对象是否是一个已经被访问过的引用对象</param>
</member>
<member name="T:Microsoft.VisualBasic.Serialization.BinaryDumping.ObjectVisitor">
 <summary>
 A Common framework for visit a object
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Serialization.BinaryDumping.ObjectVisitor.VisitOnlyFields">
 <summary>
 Only visit instance fields, otherwise visit properties
 </summary>
 <returns></returns>
</member>
<member name="F:Microsoft.VisualBasic.Serialization.BinaryDumping.ObjectVisitor.visitedReferences">
 <summary>
 Visited reference types
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Serialization.BinaryDumping.ObjectOutputStream">
 <summary>
 clr object binary serialization helper
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.BinaryDumping.ObjectOutputStream.WriteObject(System.Object)">
 <summary>
 safe any kind of clr object to binary file
 </summary>
 <param name="obj"></param>
</member>
<member name="T:Microsoft.VisualBasic.Serialization.BinaryDumping.StructSerializer">
 <summary>
 Some times these method is not works well, not sure why?
 </summary>
 <remarks>
 http://blog.csdn.net/zztoll/article/details/8695992
 
 Marshal类的两个方法StructureToPtr和PtrToStructure实现序列化
 
 我们主要是使用Marshal类里的两个方法：
 
 第一个是StructureToPtr，将数据从托管对象封送到非托管内存块。
 第二个是PtrToStructure，将数据从非托管内存块封送到新分配的指定类型的托管对象。
 
 只要有了这两个相互转换的方法，我们就可以实现序列化了。
 
 首先我们先来看下序列化
 
 序列化：
 
 有一个前提条件，那就是我们必须要知道需要序列化对象的大小。
 
 第一步：我们先求出对象的大小，然后在非托管内存中给它分配相应的内存大小。
 第二步：接着我们就把这个对象封送到刚分配出来的内存中，之后我们会得到一个分配出来的内存块首地址指针。
 第三步：最后我们可以通过这个首地址指针，从指针所指的位置处开始，拷贝数据到指定的byte[]数组中，
 拷贝的长度就是我们为这个对象分配出来的内存大小，得到byte[]数据后，下面的事情我就不用多说了，
 你可以保存到数据库或者文件中。
 
 反序列化：
 
 序列化的时候我们先将一个对象封送到了非托管内存块中，然后再把内存块中的数据读到byte[]数组中，
 
 现在我们反序列化
 
 第一步：我们先求出对象的大小，然后在非托管内存中给它分配相应的内存大小。
 第二步：然后把这个byte[]数据拷贝到非托管内存块中。
 第三步：最后再从内存块中封送指定大小的数据到对象中。
 
 有一个地方需要注意，那就是因为引用类型的对象我们是无法求的它的实际大小的，所以这里的对象我们只能使用非托管对象，比如struct结构体。
 所以，当我们只是用来存储数据，不涉及任何操作的对象，我们可以把它作为一个结构体来处理，这样我们在序列化的时候可以节省空间开销。
 因为你如果你要是用平常的序列化方法去序列化一个类对象，他所需要的空间开销是要大于你去序列化一个具有相同结构的struct对象。
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.BinaryDumping.StructSerializer.Write``1(System.IO.BinaryWriter,``0)">
 <summary>
 write any structure into file/stream
 </summary>
 <typeparam name="T"></typeparam>
 <param name="buffer"></param>
 <param name="obj"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.BinaryDumping.StructSerializer.StructureToByte``1(``0)">
 <summary>
 由结构体转换为byte数组(字符串类型以及Class类型都将会被序列化为内存指针，所以这个函数只适合于值类型的)
 </summary>
 
</member>
<member name="M:Microsoft.VisualBasic.Serialization.BinaryDumping.StructSerializer.ByteToStructure``1(System.Byte[])">
 <summary>
 由byte数组转换为结构体(字符串类型以及Class类型都将会被序列化为内存指针，所以这个函数只适合于值类型的)
 </summary>
 
</member>
<member name="T:Microsoft.VisualBasic.Serialization.MappingsIgnored">
 <summary>
 这个属性或者方法不会被用于映射
 </summary>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.Serialization.UseCustomMapping">
 <summary>
 不会使用系统自带的映射方法进行映射
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.VisualBasic.Serialization.NodeMapping.Source">
 <summary>
 映射的文本文件源
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.VisualBasic.Serialization.NodeMapping.Mapping">
 <summary>
 映射操作的目标数据模型
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.VisualBasic.Serialization.NodeMapping.SourceToMappingCasting">
 <summary>
 从源映射到数据模型的类型转换
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.VisualBasic.Serialization.NodeMapping.MappingToSourceCasting">
 <summary>
 从数据模型映射到源的类型转换
 </summary>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.Serialization.ConfigurationMappings">
 <summary>
 最基本的思想是将属性值按照同名属性名称在A和B两个对象类型之间进行映射，即A与B两个对象之间必须要具备相同的属性名称，才可以产生映射，请注意在本对象之中仅能够映射最基本的值类型的数据类型
 对于一些自定义的映射操作，请在目标数据模型之中定义自定义的映射函数，要求为函数只有一个参数，参数类型和返回值类型分别为映射的两个节点的数据类型，程序会使用反射自动查找
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.ConfigurationMappings.LoadMapping``2(``1)">
 <summary>
 从源江基本的值类型映射到数据模型，以将配置数据读取出来并进行加载
 </summary>
 <typeparam name="T">数据模型</typeparam>
 <typeparam name="TMaps">源</typeparam>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.ConfigurationMappings.WriteMapping``2(``0)">
 <summary>
 从数据模型将值类型数据映射回源，以将配置数据写入文件
 </summary>
 <typeparam name="T">数据模型</typeparam>
 <typeparam name="TMaps">源</typeparam>
 <param name="Model"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.ConfigurationMappings.GetNodeMapping``2(System.Object)">
 <summary>
 获取从源映射至数据模型的映射过程
 </summary>
 <typeparam name="T">数据模型</typeparam>
 <typeparam name="TMaps">源</typeparam>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.DynamicsConfiguration.LoadDocument``1(System.String)">
 <summary>
 加载完数据之后返回其自身
 </summary>
 <typeparam name="T"></typeparam>
 <param name="path"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.DynamicsConfiguration.ToDictionary``1(System.Boolean)">
 <summary>
 将目标dump为一个字典
 </summary>
 <typeparam name="T"></typeparam>
 <param name="onlyPrimitive">
 假若这个为真的话，则只有初级类型的才会被读取，反之，复杂类型会被序列化为json作为字符串value
 </param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Serialization.JSON.AnonymousJSONExtensions">
 <summary>
 Extension helpers for deal with the anonymous type
 </summary>
 
</member>
<member name="M:Microsoft.VisualBasic.Serialization.JSON.AnonymousJSONExtensions.GetJson(System.Collections.Generic.IEnumerable{System.String},System.Boolean)">
 <summary>
 get string array json
 </summary>
 <param name="array">a string collection, this function will convert this
 enumerable collection object as array and then serialize as json.
 </param>
 <param name="indent"></param>
 <returns></returns>
 <remarks>
 专门为任意字符串集合所创建的json序列化方法，在这个函数之中会自动调用ToArray后再进行json序列化
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.JSON.AnonymousJSONExtensions.GetJson(System.Collections.Generic.Dictionary{System.String,System.Object}.KeyCollection,System.Boolean)">
 <summary>
 专门针对字符串集合的
 </summary>
 <param name="keys"></param>
 <param name="indent"></param>
 <returns></returns>
 <remarks>
 任意类型的字符串集合都会被首先转换为字符串数组然后再转换为json字符串
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.JSON.AnonymousJSONExtensions.GetJson(System.Collections.Generic.SortedDictionary{System.String,System.Object}.KeyCollection,System.Boolean)">
 <summary>
 专门针对字符串集合的
 </summary>
 <param name="keys"></param>
 <param name="indent"></param>
 <returns></returns>
 <remarks>
 任意类型的字符串集合都会被首先转换为字符串数组然后再转换为json字符串
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.JSON.AnonymousJSONExtensions.KeysJson``1(System.Collections.Generic.Dictionary{System.String,``0})">
 <summary>
 Returns all of the keys in a dictionary in json format
 </summary>
 <typeparam name="V"></typeparam>
 <param name="d"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Serialization.JSON.Formatter.Internals.Strategies.CloseBracketStrategy.#ctor">
 <summary>
 }
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.JSON.Formatter.Internals.Strategies.CloseSquareBracketStrategy.#ctor">
 <summary>
 ]
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.JSON.Formatter.Internals.Strategies.CommaStrategy.#ctor">
 <summary>
 ,
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.JSON.Formatter.Internals.Strategies.OpenBracketStrategy.#ctor">
 <summary>
 {
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.JSON.Formatter.Internals.Strategies.OpenSquareBracketStrategy.#ctor">
 <summary>
 [
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Serialization.JSON.Formatter.JsonFormatter">
 <summary>
 Provides JSON formatting functionality.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.JSON.Formatter.JsonFormatter.Format(System.String)">
 <summary>
 Returns a 'pretty printed' version of the specified JSON string, formatted for human
 consumption.
 </summary>
 <param name="json">A valid JSON string.</param>
 <returns>A 'pretty printed' version of the specified JSON string.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.JSON.Formatter.JsonFormatter.Minify(System.String)">
 <summary>
 Returns a 'minified' version of the specified JSON string, stripped of all 
 non-essential characters.
 </summary>
 <param name="json">A valid JSON string.</param>
 <returns>A 'minified' version of the specified JSON string.</returns>
</member>
<member name="T:Microsoft.VisualBasic.Serialization.JSON.JsonContract">
 <summary>
 Only works on the Public visible type.
 (使用.NET系统环境之中自带的框架进行JSON序列化和反序列化)
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.JSON.JsonContract.MatrixJson(System.Double[][])">
 <summary>
 Create json text for array matrix.
 </summary>
 <param name="matrix"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.JSON.JsonContract.GetObjectJson(System.Type,System.Object,System.Boolean,System.Boolean,System.Collections.Generic.IEnumerable{System.Type})">
 <summary>
 使用<see cref="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.ScriptIgnoreAttribute"/>来屏蔽掉不想序列化的属性
 </summary>
 <param name="obj"></param>
 <param name="type"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.JSON.JsonContract.writeJson(System.IO.Stream,System.Object,System.Type,System.Boolean,System.Collections.Generic.IEnumerable{System.Type})">
 <summary>
 Write json with setting configuration
 </summary>
 <param name="output"></param>
 <param name="obj"></param>
 <param name="type"></param>
 <param name="simpleDict"></param>
 <param name="knownTypes"></param>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.JSON.JsonContract.WriteLargeJson``1(``0,System.String,System.Boolean)">
 <summary>
 将目标对象保存为json文件
 </summary>
 <typeparam name="T"></typeparam>
 <param name="obj"></param>
 <param name="path"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.JSON.JsonContract.RemoveJsonNullItems(System.String)">
 <summary>
 有些javascript程序(例如highcharts.js)要求json里面不可以出现null的属性，可以使用这个方法进行移除
 </summary>
 <param name="json"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.JSON.JsonContract.GetJson``1(``0,System.Boolean,System.Boolean,System.Collections.Generic.IEnumerable{System.Type})">
 <summary>
 Gets the json text value of the target object, the attribute <see cref="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.ScriptIgnoreAttribute"/> 
 can be used for block the property which is will not serialize to the text.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="obj"></param>
 <returns></returns>
 <remarks>
 (使用<see cref="T:Microsoft.VisualBasic.ComponentModel.DataSourceModel.ScriptIgnoreAttribute"/>来屏蔽掉不想序列化的属性)
 
 2016-11-9 对字典进行序列化的时候，假若对象类型是从字典类型继承而来的，则新的附加属性并不会被序列化，只会序列化字典本身
 2018-10-5 不可以序列化匿名类型
 </remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.Serialization.JSON.JsonContract.LoadObject(System.String,System.Type,System.Boolean,System.Boolean,System.Exception@,System.Collections.Generic.IEnumerable{System.Type})">
 <summary>
 Create object instance from a given json text base on the template <see cref="T:System.Type"/>
 information.
 </summary>
 <param name="json">null -> Nothing</param>
 <param name="type"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.JSON.JsonContract.LoadJSON``1(System.String,System.Boolean,System.Boolean,System.Exception@,System.Collections.Generic.IEnumerable{System.Type})">
 <summary>
 从文本文件或者文本内容之中进行JSON反序列化
 </summary>
 <param name="json">This string value can be json text or json file path.</param>
 <remarks>
 null or empty string will be parsed as nothing if the optional
 parameter <paramref name="throwEx"/> option value is set to false
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.JSON.JsonContract.LoadObject``1(System.Xml.Linq.XElement,System.Boolean)">
 <summary>
 XML CDATA to json
 </summary>
 <typeparam name="T"></typeparam>
 <param name="json"></param>
 <param name="simpleDict"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Serialization.JSON.JsonContract.LoadJsonFile``1(System.String,System.Text.Encoding,System.Boolean,System.Collections.Generic.IEnumerable{System.Type},System.Boolean)">
 <summary>
 Create object instance from a json text of a given text file. 
 </summary>
 <typeparam name="T"></typeparam>
 <param name="file$"></param>
 <param name="encoding"></param>
 <param name="simpleDict"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Serialization.JSON.Markdown">
 <summary>
 Markdown doc generator for the json schema
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Serialization.JSON.Schema">
 <summary>
 Here is a basic example of a JSON Schema:
 
 ```json
 {
	   "title": "Example Schema",
	   "type": "object",
	   "properties": {
	       "firstName": {
	          "type": "string"
	       },
	       "lastName": {
	          "type": "string"
	       },
	       "age": {
	          "description": "Age in years",
	          "type": "integer",
	          "minimum": 0
	       }
	   },
	   "required": ["firstName", "lastName"]
 }
 ```
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Serialization.JSON.VisualBasicCode">
 <summary>
 Generates the VisualBasic source code from json schema
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Serialization.ISerializable">
 <summary>
 支持序列化的对象，则这个对象可以被应用于<see cref="T:Microsoft.VisualBasic.Parallel.RequestStream"/>数据载体的网络传输操作过程
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.ISerializable.Serialize">
 <summary>
 Transform this .NET object into a raw stream object for the network data transfer. 
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Serialization.RawStream">
 <summary>
 原始串流的基本模型，这个流对象应该具备有两个基本的方法：
 1. 从原始的字节流之中反序列化构造出自身的构造函数
 2. 将自身序列化为字节流的<see cref="M:Microsoft.VisualBasic.Serialization.ISerializable.Serialize"/>序列化方法
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.RawStream.#ctor(System.Byte[])">
 <summary>
 You should overrides this constructor to generate a stream object.(必须要有一个这个构造函数来执行反序列化)
 </summary>
 <param name="rawStream"></param>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.RawStream.Serialize">
 <summary>
 <see cref="M:Microsoft.VisualBasic.Serialization.ISerializable.Serialize"/>序列化方法
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.RawStream.GetRawStream``1(System.Byte[])">
 <summary>
 按照类型的定义进行反序列化操作
 </summary>
 <typeparam name="TRawStream"></typeparam>
 <param name="rawStream"></param>
 <returns></returns>
 
</member>
<member name="F:Microsoft.VisualBasic.Serialization.RawStream.INT32">
 <summary>
 Single/Integer
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Serialization.RawStream.DblFloat">
 <summary>
 sizeof <see cref="T:System.Double"/>
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Serialization.RawStream.GetBytes(System.Array,Microsoft.VisualBasic.Text.Encodings)">
 <summary>
 this function only works for the primitive data types
 </summary>
 <param name="vector"></param>
 <param name="encoding"></param>
 <returns>
 the empty byte collection will be return if the input vector is nothing
 </returns>
</member>
</members>
</doc>
