<?xml version="1.0"?>
<doc>
<assembly>
<name>
Microsoft.VisualBasic.Math.Core
</name>
</assembly>
<members>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.HelperExtensions.IsNaNImaginary(System.Collections.Generic.IEnumerable{System.Double})">
 <summary>
 get a logical vector for indicates that which elements inside the given numeric vector is invalid number, like NaN, Inf
 </summary>
 <param name="v"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.HelperExtensions.NAremove(System.Collections.Generic.IEnumerable{System.Double})">
 <summary>
 removes all invalid number from the given numeric vector data
 </summary>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.HelperExtensions.PrimitiveLinearEquation(System.Drawing.PointF,System.Drawing.PointF)">
 <summary>
 返回一元一次方程
 </summary>
 <param name="p1"></param>
 <param name="p2"></param>
 <returns>``y=ax+b``</returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.HelperExtensions.Tangent(Microsoft.VisualBasic.ComponentModel.Algorithm.base.SlideWindow{System.Drawing.PointF})">
 <summary>
 
 </summary>
 <param name="slideWindows">Just contains two points.</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.HelperExtensions.jaccard_coeff(System.Int32[][],System.Boolean)">
 <summary>
 Compute jaccard coefficient between nearest-neighbor sets
 
 Weights of both i->j and j->i are recorded if they have intersection. In this case
 w(i->j) should be equal to w(j->i). In some case i->j has weights while j&lt;-i has no
 intersections, only w(i->j) Is recorded. This Is determinded in code `if(u>0)`. 
 In this way, the undirected graph Is symmetrized by halfing the weight 
 in code ``weights(r, 2) = u/(2.0*ncol - u)/2``.
 </summary>
 <param name="idx"></param>
 <returns>
 the weight value of this function will affects by the 
 <paramref name="symmetrize"/> parameters, when 
 
 + symmetrize = TRUE(default), weight in value range ``(0, 0.5]``,
 + FALSE, weight in value range ``(0, 1]``.
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.HelperExtensions.JaccardIndex(System.Double[],System.Double[])">
 <summary>
 
 </summary>
 <param name="x"></param>
 <param name="y"></param>
 <returns></returns>
 <remarks>
 use common non-zero index as intersect
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.HelperExtensions.jaccard_coeff(System.String[],System.String[],System.Boolean)">
 <summary>
 Evaluate the jaccard coeff between two dataset
 </summary>
 <param name="a"></param>
 <param name="b"></param>
 <param name="symmetrize"></param>
 <returns></returns>
 
</member>
<member name="P:Microsoft.VisualBasic.Math.LinearAlgebra.EllipseFitResult.Center">
 <summary>
 椭圆的中心点（h,k）
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Math.LinearAlgebra.EllipseFitResult.SemiMajorAxis">
 <summary>
 长半轴
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Math.LinearAlgebra.EllipseFitResult.SemiMinorAxis">
 <summary>
 短半轴
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Math.LinearAlgebra.EllipseFitResult.RotationAngle">
 <summary>
 旋转角度（弧度）
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Math.LinearAlgebra.EllipseFitResult.Coefficients">
 <summary>
 原始系数向量 [A, B, C, D, E, F]
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Math.LinearAlgebra.EllipseFitResult.Area">
 <summary>
 计算并返回椭圆的面积。
 </summary>
 <returns>椭圆的面积，类型为 Double。</returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.EllipseFitResult.BuildDesignMatrix(System.Drawing.PointF[])">
 <summary>
 构建设计矩阵 M = [x², xy, y², x, y, 1]
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.EllipseFitResult.ExtractEllipseParameters(Microsoft.VisualBasic.Math.LinearAlgebra.Vector,System.Boolean)">
 <summary>
 从系数向量提取椭圆几何参数
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.EllipseFitResult.NormalizeAngle(System.Double)">
 <summary>
 规范化角度到 [0, π) 范围
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.LinearProgramming.Extensions.subscriptN(System.Int32)">
 <summary>
 Convert an integer into a multi-character subscript.
 </summary>
 <param name="n"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Math.LinearAlgebra.LinearProgramming.LPP">
 <summary>
 solve continuous-space linear programming problems by the simplex method.
 </summary>
 <remarks>
 java source: https://github.com/gthole/lpp
 </remarks>
</member>
<member name="F:Microsoft.VisualBasic.Math.LinearAlgebra.LinearProgramming.LPP.variableNames">
 <summary>
 这个变量名称列表之中会添加拓展的新的变量名称
 
 可以使用objectfunction的系数长度来取出原来的输入的变量名称的列表
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.LinearProgramming.LPP.#ctor(Microsoft.VisualBasic.Math.LinearAlgebra.LinearProgramming.OptimizationType,System.String[],System.Double[],System.Double[0:,0:],System.String[],System.Double[],System.Double)">
 <summary>
 
 </summary>
 <param name="opt">目标函数的类型，是求取极大值还是极小值</param>
 <param name="variableNames">方程之中的未知变量的名称，可以省略这个函数，程序会默认会自动使用x1, x2, x3...等来自动命名</param>
 <param name="objectiveFunctionCoefficients">目标函数之中每一个未知变量所对应的系数</param>
 <param name="constraintCoefficients">方程组的左边：系数矩阵</param>
 <param name="constraintTypes">方程组之中的函数类型：大于，小于，等于</param>
 <param name="constraintRightHandSides">方程组的右边：方程组之中每一个方程的结果值</param>
 <param name="objectiveFunctionValue">目标方程的目标结果值</param>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.LinearProgramming.LPP.#ctor(System.String,System.String[],System.Double[],System.Double[][],System.String[],System.Double[],System.Double)">
 <summary>
 
 </summary>
 <param name="objectiveFunctionType$">目标函数的类型，是求取极大值还是极小值</param>
 <param name="variableNames">方程之中的未知变量的名称，可以省略这个函数，程序会默认会自动使用x1, x2, x3...等来自动命名</param>
 <param name="objectiveFunctionCoefficients">目标函数之中每一个未知变量所对应的系数</param>
 <param name="constraintCoefficients">方程组的左边：系数矩阵</param>
 <param name="constraintTypes">方程组之中的函数类型：大于，小于，等于</param>
 <param name="constraintRightHandSides">方程组的右边：方程组之中每一个方程的结果值</param>
 <param name="objectiveFunctionValue">目标方程的目标结果值</param>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.LinearProgramming.LPP.makeStandardForm">
 <summary>
 Change Signs to = by adding variables
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.LinearProgramming.LPP.makeStandardForm(System.Collections.Generic.List{System.Int32})">
 <summary>
 Change signs to = by adding variables
 </summary>
 <param name="artificialVariables"></param>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.LinearProgramming.LPP.addVariableAt(System.Int32,System.Double)">
 <summary>
 Unfortunate copy and pasting going on here.
 </summary>
 <param name="constraintIndex"></param>
 <param name="value"></param>
</member>
<member name="T:Microsoft.VisualBasic.Math.LinearAlgebra.LinearProgramming.LPPModel">
 <summary>
 Linear Programming Model
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Math.LinearAlgebra.LinearProgramming.LPPModel.constraintCoefficients">
 <summary>
 base64 string represented matrix
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Math.LinearAlgebra.LinearProgramming.LPPModel.name">
 <summary>
 the model name
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Math.LinearAlgebra.LinearProgramming.LPPSolver">
 <summary>
 使用单纯形法进行线性规划问题的求解
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.LinearProgramming.LPPSolver.isFeasible(System.Collections.Generic.List{System.Int32})">
 <summary>
 判断当前的这个线性规划问题是否是可解的？ 
 </summary>
 <param name="possibleSolution"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.LinearProgramming.LPPSolver.pivot(System.Int32,System.Int32)">
 <summary>
 
 </summary>
 <param name="varIndex"></param>
 <param name="constIndex"></param>
</member>
<member name="F:Microsoft.VisualBasic.Math.LinearAlgebra.LinearProgramming.OptimizationType.MAX">
 <summary>
 Maximize
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Math.LinearAlgebra.LinearProgramming.OptimizationType.MIN">
 <summary>
 Minimize
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.CholeskyDecomposition">
 <summary>Cholesky Decomposition.
 For a symmetric, positive definite matrix A, the Cholesky decomposition
 is an lower triangular matrix L so that A = L*L'.
 If the matrix is not symmetric or positive definite, the constructor
 returns a partial decomposition and sets an internal flag that may
 be queried by the isSPD() method.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.CholeskyDecomposition.L">
 <summary>Array for internal storage of decomposition.
 @serial internal array storage.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.CholeskyDecomposition.n">
 <summary>Row and column dimension (square matrix).
 @serial matrix dimension.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.CholeskyDecomposition.isspd">
 <summary>Symmetric and positive definite flag.
 @serial is symmetric and positive definite flag.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.CholeskyDecomposition.#ctor(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix)">
 <summary>
 Cholesky algorithm for symmetric and positive definite matrix. returns Structure to access L and isspd flag.
 </summary>
 <param name="Arg">  Square, symmetric matrix.
 </param>
</member>
<member name="P:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.CholeskyDecomposition.SPD">
 <summary>Is the matrix symmetric and positive definite?</summary>
 <returns>     true if A is symmetric and positive definite.
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.CholeskyDecomposition.GetL">
 <summary>Return triangular factor.</summary>
 <returns>     L
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.CholeskyDecomposition.Solve(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix)">
 <summary>Solve A*X = B</summary>
 <param name="B">  A Matrix with as many rows as A and any number of columns.
 </param>
 <returns>     X so that L*L'*X = B
 </returns>
 <exception cref="T:System.ArgumentException">  Matrix row dimensions must agree.
 </exception>
 <exception cref="T:System.SystemException"> Matrix is not symmetric positive definite.
 </exception>
</member>
<member name="T:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.EigenvalueDecomposition">
 <summary>
 Eigenvalues and eigenvectors of a real matrix. 
 If A is symmetric, then A = V*D*V' where the eigenvalue matrix D is
 diagonal and the eigenvector matrix V is orthogonal.
 I.e. A = V.Multiply(D.Multiply(V.Transpose())) and 
 V.Multiply(V.Transpose()) equals the identity matrix.
 If A is not symmetric, then the eigenvalue matrix D is block diagonal
 with the real eigenvalues in 1-by-1 blocks and any complex eigenvalues,
 lambda + i*mu, in 2-by-2 blocks, [lambda, mu; -mu, lambda].  The
 columns of V represent the eigenvectors in the sense that A*V = V*D,
 i.e. A.Multiply(V) equals V.Multiply(D).  The matrix V may be badly
 conditioned, or even singular, so the validity of the equation
 A = V*D*Inverse(V) depends upon V.cond().
 
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.EigenvalueDecomposition.n">
 <summary>Row and column dimension (square matrix).
 @serial matrix dimension.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.EigenvalueDecomposition.issymmetric">
 <summary>Symmetry flag.
 @serial internal symmetry flag.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.EigenvalueDecomposition.m_d">
 <summary>Arrays for internal storage of eigenvalues.
 @serial internal storage of eigenvalues.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.EigenvalueDecomposition.m_e">
 <summary>Arrays for internal storage of eigenvalues.
 @serial internal storage of eigenvalues.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.EigenvalueDecomposition._V">
 <summary>Array for internal storage of eigenvectors.
 @serial internal storage of eigenvectors.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.EigenvalueDecomposition.H">
 <summary>Array for internal storage of nonsymmetric Hessenberg form.
 @serial internal storage of nonsymmetric Hessenberg form.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.EigenvalueDecomposition.ort">
 <summary>Working storage for nonsymmetric algorithm.
 @serial working storage for nonsymmetric algorithm.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.EigenvalueDecomposition.tred2">
 <summary>
 Symmetric Householder reduction to tridiagonal form.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.EigenvalueDecomposition.cdivr">
 <summary>
 Complex scalar division.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.EigenvalueDecomposition.cdivi">
 <summary>
 Complex scalar division.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.EigenvalueDecomposition.hqr2">
 <summary>
 Nonsymmetric reduction from Hessenberg to real Schur form.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.EigenvalueDecomposition.#ctor(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix)">
 <summary>
 Check for symmetry, then construct the eigenvalue decomposition, returns Structure to access D and V.
 </summary>
 <param name="Arg">Square matrix</param>
</member>
<member name="P:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.EigenvalueDecomposition.RealEigenvalues">
 <summary>Return the real parts of the eigenvalues</summary>
 <returns>     real(diag(D))
 </returns>
</member>
<member name="P:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.EigenvalueDecomposition.ImagEigenvalues">
 <summary>Return the imaginary parts of the eigenvalues</summary>
 <returns>     imag(diag(D))
 </returns>
</member>
<member name="P:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.EigenvalueDecomposition.D">
 <summary>Return the block diagonal eigenvalue matrix</summary>
 <returns>     D
 </returns>
</member>
<member name="P:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.EigenvalueDecomposition.V">
 <summary>Return the eigenvector matrix</summary>
 <returns>     V
 </returns>
</member>
<member name="T:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.LUDecomposition">
 <summary>LU Decomposition.
 For an m-by-n matrix A with m >= n, the LU decomposition is an m-by-n
 unit lower triangular matrix L, an n-by-n upper triangular matrix U,
 and a permutation vector piv of length m so that A(piv,:) = L*U.
 <code> If m &lt; n, then L is m-by-m and U is m-by-n. </code>
 The LU decompostion with pivoting always exists, even if the matrix is
 singular, so the constructor will never fail.  The primary use of the
 LU decomposition is in the solution of square systems of simultaneous
 linear equations.  This will fail if IsNonSingular() returns false.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.LUDecomposition.LU">
 <summary>Array for internal storage of decomposition.
 @serial internal array storage.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.LUDecomposition.m">
 <summary>Row and column dimensions, and pivot sign.
 @serial column dimension.
 @serial row dimension.
 @serial pivot sign.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.LUDecomposition.n">
 <summary>Row and column dimensions, and pivot sign.
 @serial column dimension.
 @serial row dimension.
 @serial pivot sign.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.LUDecomposition.pivsign">
 <summary>Row and column dimensions, and pivot sign.
 @serial column dimension.
 @serial row dimension.
 @serial pivot sign.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.LUDecomposition.piv">
 <summary>Internal storage of pivot vector.
 @serial pivot vector.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.LUDecomposition.#ctor(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix)">
 <summary>
 LU Decomposition, returns Structure to access L, U and piv.
 </summary>
 <param name="A">  Rectangular matrix
 </param>
</member>
<member name="P:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.LUDecomposition.IsNonSingular">
 <summary>Is the matrix nonsingular?</summary>
 <returns>     true if U, and hence A, is nonsingular.
 </returns>
</member>
<member name="P:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.LUDecomposition.L">
 <summary>Return lower triangular factor</summary>
 <returns>     L
 </returns>
</member>
<member name="P:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.LUDecomposition.U">
 <summary>Return upper triangular factor</summary>
 <returns>     U
 </returns>
</member>
<member name="P:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.LUDecomposition.Pivot">
 <summary>Return pivot permutation vector</summary>
 <returns>     piv
 </returns>
</member>
<member name="P:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.LUDecomposition.DoublePivot">
 <summary>Return pivot permutation vector as a one-dimensional double array</summary>
 <returns>     (double) piv
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.LUDecomposition.Determinant">
 <summary>Determinant</summary>
 <returns>     det(A)
 </returns>
 <exception cref="T:System.ArgumentException">  Matrix must be square
 </exception>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.LUDecomposition.Solve(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix)">
 <summary>Solve A*X = B</summary>
 <param name="B">  A Matrix with as many rows as A and any number of columns.
 </param>
 <returns>     X so that L*U*X = B(piv,:)
 </returns>
 <exception cref="T:System.ArgumentException"> Matrix row dimensions must agree.
 </exception>
 <exception cref="T:System.SystemException"> Matrix is singular.
 </exception>
</member>
<member name="T:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NMF">
 <summary>
 implementation of Non-negative Matrix Factorisation Algorithms
 </summary>
 <remarks>
 Non-Negative Matrix Factorization
 
 Non-Negative Matrix Factorization (NMF) is a recent technique for dimensionality 
 reduction and data analysis that yields a parts based, sparse nonnegative 
 representation for nonnegative input data. NMF has found a wide variety of applications,
 including text analysis, document clustering, face/image recognition, language
 modeling, speech processing and many others. Despite these numerous applications,
 the algorithmic development for computing the NMF factors has been relatively
 deficient.

 NMF can be applied To the statistical analysis Of multivariate data In the following 
 manner. Given a Set Of Of multivariate n-dimensional data vectors, the vectors are 
 placed In the columns Of an n x m matrix V where m Is the number Of examples In the 
 data Set. This matrix Is Then approximately factorized into an n x r matrix W (weights
 matrix) And an r x m matrix H (features matrix), where r Is the number Of features
 defined by the user. Usually r Is chosen To be smaller than n Or m, so that W And H 
 are smaller than the original matrix V. This results In a compressed version Of the
 original data matrix.
 
 NMF 算法将矩阵 A 分解为两个矩阵：基矩阵 W 和系数矩阵 H。这两个矩阵的乘积将尽可能地接近原始矩阵 A。

 + 基矩阵 W 表示的是 A 的潜在特征或主题，
 + 而系数矩阵 H 表示的是每个样本（在矩阵 A 中是每一行）在这些特征或主题上的分布。
 
 在 NMF 中，基矩阵 W 和系数矩阵 H 的乘积近似等于原始矩阵 A。通过这种方式，NMF 能够揭示矩阵 A 中的
 潜在结构和特征。例如，在基矩阵 W 的每一列可能代表了矩阵 A 中的主要特征或主题，而系数矩阵 H 的
 每一行则表示原始矩阵 A 中对应样本在这些特征或主题上的分布情况。
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NMF.Factorisation(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix,System.Int32,System.Int32,System.Double,System.Double,System.Boolean)">
 <summary>
 Implements Lee and Seungs Multiplicative Update Algorithm
 </summary>
 <param name="A"></param>
 <param name="k">number of features</param>
 <param name="max_iterations"></param>
 <param name="tolerance"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.QRDecomposition">
 <summary>QR Decomposition.
 For an m-by-n matrix A with m >= n, the QR decomposition is an m-by-n
 orthogonal matrix Q and an n-by-n upper triangular matrix R so that
 A = Q*R.
 
 The QR decompostion always exists, even if the matrix does not have
 full rank, so the constructor will never fail.  The primary use of the
 QR decomposition is in the least squares solution of nonsquare systems
 of simultaneous linear equations.  This will fail if IsFullRank()
 returns false.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.QRDecomposition.QR">
 <summary>Array for internal storage of decomposition.
 @serial internal array storage.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.QRDecomposition.m">
 <summary>Row and column dimensions.
 @serial column dimension.
 @serial row dimension.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.QRDecomposition.n">
 <summary>Row and column dimensions.
 @serial column dimension.
 @serial row dimension.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.QRDecomposition.Rdiag">
 <summary>Array for internal storage of diagonal of R.
 @serial diagonal of R.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.QRDecomposition.#ctor(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix)">
 <summary>
 QR Decomposition, computed by Householder reflections. returns Structure to access R and the Householder vectors and compute Q.
 </summary>
 <param name="A">   Rectangular matrix
 </param>
</member>
<member name="P:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.QRDecomposition.FullRank">
 <summary>Is the matrix full rank?</summary>
 <returns>     true if R, and hence A, has full rank.
 </returns>
</member>
<member name="P:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.QRDecomposition.H">
 <summary>Return the Householder vectors</summary>
 <returns>     Lower trapezoidal matrix whose columns define the reflections
 </returns>
</member>
<member name="P:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.QRDecomposition.R">
 <summary>Return the upper triangular factor</summary>
 <returns>     R
 </returns>
</member>
<member name="P:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.QRDecomposition.Q">
 <summary>Generate and return the (economy-sized) orthogonal factor</summary>
 <returns>     Q
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.QRDecomposition.Solve(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix)">
 <summary>Least squares solution of A*X = B</summary>
 <param name="B">   A Matrix with as many rows as A and any number of columns.
 </param>
 <returns>     X that minimizes the two norm of Q*R*X-B.
 </returns>
 <exception cref="T:System.ArgumentException"> Matrix row dimensions must agree.
 </exception>
 <exception cref="T:System.SystemException"> Matrix is rank deficient.
 </exception>
</member>
<member name="T:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.SingularValueDecomposition">
 <summary>Singular Value Decomposition.
 <P>
 For an m-by-n matrix A with m >= n, the singular value decomposition is
 an m-by-n orthogonal matrix U, an n-by-n diagonal matrix S, and
 an n-by-n orthogonal matrix V so that A = U*S*V'.</P>
 <P>
 The singular values, sigma[k] = S[k][k], are ordered so that
 sigma[0] >= sigma[1] >= ... >= sigma[n-1].</P>
 <P>
 The singular value decompostion always exists, so the constructor will
 never fail.  The matrix condition number and the effective numerical
 rank can be computed from this decomposition.</P>
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.SingularValueDecomposition.valueU">
 <summary>Arrays for internal storage of U and V.
 @serial internal storage of U.
 @serial internal storage of V.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.SingularValueDecomposition.valueV">
 <summary>Arrays for internal storage of U and V.
 @serial internal storage of U.
 @serial internal storage of V.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.SingularValueDecomposition.m_s">
 <summary>Array for internal storage of singular values.
 @serial internal storage of singular values.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.SingularValueDecomposition.m">
 <summary>Row and column dimensions.
 @serial row dimension.
 @serial column dimension.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.SingularValueDecomposition.n">
 <summary>Row and column dimensions.
 @serial row dimension.
 @serial column dimension.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.SingularValueDecomposition.#ctor(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix)">
 <summary>
 Construct the singular value decomposition, returns Structure to access U, S and V.
 </summary>
 <param name="Arg">   Rectangular matrix
 </param>
</member>
<member name="P:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.SingularValueDecomposition.SingularValues">
 <summary>Return the one-dimensional array of singular values</summary>
 <returns>     diagonal of S.
 </returns>
</member>
<member name="P:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.SingularValueDecomposition.S">
 <summary>Return the diagonal matrix of singular values</summary>
 <returns>     S
 </returns>
</member>
<member name="P:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.SingularValueDecomposition.U">
 <summary>Return the left singular vectors</summary>
 <returns>     U
 </returns>
</member>
<member name="P:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.SingularValueDecomposition.V">
 <summary>Return the right singular vectors</summary>
 <returns>     V
 </returns>
</member>
<member name="P:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.SingularValueDecomposition.Norm2">
 <summary>Two norm</summary>
 <returns>     max(S)
 </returns>
 
</member>
<member name="P:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.SingularValueDecomposition.Condition">
 <summary>Two norm condition number</summary>
 <returns>     max(S)/min(S)
 </returns>
</member>
<member name="P:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.SingularValueDecomposition.Rank">
 <summary>Effective numerical matrix rank</summary>
 <returns>     Number of nonnegligible singular values.
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.Extensions.ColumnVector(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix,System.Int32)">
 <summary>
 get a specific column data as vector
 </summary>
 <param name="matrix"></param>
 <param name="i%"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.Extensions.rand(System.Int32,System.Int32)">
 <summary>Generate matrix with random elements</summary>
 <param name="m">   Number of rows.
 </param>
 <param name="n">   Number of colums.
 </param>
 <returns>     An m-by-n matrix with uniformly distributed random elements.
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.Extensions.CenterNormalize(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix)">
 <summary>
 Centers each column of the data matrix at its mean.
 Normalizes the input matrix so that each column is centered at 0.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.Extensions.Covariance(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix)">
 <summary>
 Constructs the covariance matrix for this data set.
 @return	the covariance matrix of this data set
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.Extensions.Print(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix,System.String,System.IO.StreamWriter)">
 <summary>
 Print the matrix data onto the console or a specific stream.
 </summary>
 <param name="m"></param>
 <param name="format$"></param>
 <param name="out"></param>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.vbMatrix.SG(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix)">
 <summary>
 矩阵的满秩分解Math_Matrinx_SG，把矩阵K分解成一种行满秩Return_m 是m*r与列满秩的矩阵Return_n是r*n.返回值为r.r是其秩
 </summary>
 <param name="K">为要满秩分解的方阵</param>
 <returns>
 + 所求得的m*r矩阵
 + 所求得的r*n矩阵
 </returns>
 <remarks>
 其中A为m*n的矩阵,r为A的秩.即A=Return_M*Return_N.函数执行成功返回r(也就是其秩)
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.vbMatrix.Pinv(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix,Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix)">
 <summary>
 矩阵的广义逆A+ ，返回m*n矩阵Return_K(,)的m。此广义逆是Moore-Penrose A+逆
 </summary>
 <param name="K">要求广义逆的矩阵</param>
 <param name="Return_K">求得的广义逆矩阵</param>
 <returns>函数执行成功返回m,其中m代表Return_K的行数</returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.vbMatrix.Pinv2(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix,System.Int16,System.Int16,Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix)">
 <summary>
 矩阵的广义逆A-，函数执行成功返回Ret的行数,出错返回0
 </summary>
 <param name="K">要求广义逆的矩阵</param>
 <param name="Erro">误差控制参数</param>
 <param name="m">矩阵K的行数</param>
 <param name="Ret">求得的广义逆矩阵</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.vbMatrix.GetRank(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix,System.Int16)">
 <summary>
 矩阵求秩，函数执行成功返回秩的大小
 </summary>
 <param name="K">要求秩的矩阵</param>
 <param name="[error]">误差控制参数</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.vbMatrix.QR(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix,Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix,Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix)">
 <summary>
 方阵的QR分解
 </summary>
 <param name="K">要QR分解的矩阵，K必须是非奇异的n阶方阵</param>
 <param name="Q">分解后的Q矩阵</param>
 <param name="R">分解后的R矩阵</param>
 <returns>函数执行成功返回True,失败返回False</returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.vbMatrix.Schmidt(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix,Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix)">
 <summary>
 矩阵施密特(Schmidt)正交规范化
 </summary>
 <param name="K">要施密特(Schmidt)正交规范化的矩阵</param>
 <param name="Ret">正交规范化后的矩阵</param>
 <returns>函数执行成功返回True,失败返回False</returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.vbMatrix.EigenValue(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix,System.Int16,System.Int16,System.Int16,Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix,System.Boolean)">
 <summary>
 方阵求特征值
 </summary>
 <param name="K11">要求特征值的方阵</param>
 <param name="n">方阵K1的阶数</param>
 <param name="LoopNumber">循环次数</param>
 <param name="errors">误差控制变量</param>
 <param name="Ret">返回的特征值,Ret是是n*2的数组,第一列是实数部分,第2列为虚数部分</param>
 <param name="IsHess">K1是否已经是上Hessenberg矩阵</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.vbMatrix.Hessenberg(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix,System.Int16,Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix@)">
 <summary>
 将方阵化为上(Hessenberg)矩阵，函数成功返回Ret的阶数
 </summary>
 <param name="A">要化为上(Hessenberg)矩阵的矩阵</param>
 <param name="n">为方阵A的阶数</param>
 <param name="ret">化为上(Hessenberg)矩阵后的矩阵</param>
 <returns>函数成功返回Ret的阶数</returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.vbMatrix.SvdSplit(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix,System.Int16,Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix,System.Int16,Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix,System.Int16,Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix,System.Int16)">
 <summary>
 对矩阵A进行奇异值分解
 </summary>
 <param name="A">目标矩阵</param>
 <param name="m">A矩阵的行数</param>
 <param name="V">分解得到的一个V矩阵</param>
 <param name="V_m">V矩阵的行数</param>
 <param name="S">分解得到的一个S矩阵</param>
 <param name="S_m">S矩阵的行数</param>
 <param name="U">分解得到的一个U矩阵</param>
 <param name="U_m">U矩阵的行数</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.vbMatrix.Cramer22(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix,Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix,System.Int32,Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix)">
 <summary>
 求Kx=B的最小二乘解
 </summary>
 <param name="K">是x的系数矩阵</param>
 <param name="B">是等式右边的常数矩阵</param>
 <param name="k_m">矩阵K的行数</param>
 <param name="x">求解得到的解</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.vbMatrix.Det2(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix,System.Int32)">
 <summary>
 求行列式
 </summary>
 <param name="k">所求的n阶方阵</param>
 <param name="N">方阵K的阶数</param>
 <returns>函数成功返回其行列式的大小</returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.vbMatrix.SPD(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix)">
 <summary>
 矩阵正规、对称、正定性判断
 </summary>
 <param name="K">为要判断的矩阵</param>
 <returns>函数返回-1矩阵非对称矩阵,返回0矩阵不正定,返回1矩阵正定</returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.vbMatrix.LLt(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix,Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix,System.Boolean)">
 <summary>
 矩阵的LLt分解
 </summary>
 <param name="A">要进行LLt分解的方阵</param>
 <param name="L">分解得到的L方阵</param>
 <param name="is1_是否已经正定"></param>
 <returns>函数成功返回True,失败返回False.(其中Lt是L的转置,即分解后 A=L×Lt)</returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.vbMatrix.QR22(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix,Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix,Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix,System.Int16,System.Int16)">
 <summary>
 矩阵的QR分解
 </summary>
 <param name="A">要QR分解的矩阵（不一定是方阵）</param>
 <param name="Q">分解得到的Q矩阵</param>
 <param name="R">分解得到的R矩阵</param>
 <param name="Q_n">返回Q矩阵的列数</param>
 <param name="R_n">返回R矩阵的列数</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.vbMatrix.QR2(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix,Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix,Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix,System.Int16,System.Int16)">
 <summary>
 矩阵的QR分解
 </summary>
 <param name="A">要QR分解的矩阵(不一定是方阵)</param>
 <param name="Q">分解得到的Q矩阵</param>
 <param name="R">分解得到的R矩阵</param>
 <param name="Q_n">返回Q矩阵的列数</param>
 <param name="R_n">返回R矩阵的列数</param>
 <returns>函数成功返回True,失败返回False.使用本函数时,A矩阵的行数不能小于列数</returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.vbMatrix.LU(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix,System.Int16,Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix,Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix)">
 <summary>
 方阵LU分解
 </summary>
 <param name="K">为要LU分解的方阵</param>
 <param name="n">方阵K的阶数</param>
 <param name="L">为分解得到的L矩阵</param>
 <param name="U">为分解得到的U矩阵</param>
 <returns>其意义是K=LU.函数执行成功返回True,失败返回False</returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.vbMatrix.Inv2(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix,Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix,System.Int32)">
 <summary>
 矩阵求逆
 </summary>
 <param name="K">目标方阵</param>
 <param name="Return_K">求得的逆矩阵</param>
 <param name="N">方阵K的阶数</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.vbMatrix.DetF(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix,System.Int32)">
 <summary>
 求行列式，函数执行成功返回其行列式大小.其原理是按行列式定义依次展开求解.不适合大于5阶的方阵，K的数组大小为N*N的,不然程序出错
 </summary>
 <param name="k">为n阶方阵</param>
 <param name="N">为矩阵A的阶数</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.vbMatrix.Inv(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix,Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix)">
 <summary>
 矩阵求逆
 </summary>
 <param name="K">为要求逆的方阵</param>
 <param name="Return_K">为所求得的逆</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.vbMatrix.Svd(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix,System.Int16,Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix)">
 <summary>
 矩阵奇异值
 </summary>
 <param name="A">为目的矩阵</param>
 <param name="m">为A矩阵的行数</param>
 <param name="Ret">获取到的奇异值矩阵,即返回的Ret是m*1的矩阵</param>
 <returns>函数执行成功返回奇异值的个数,即Ret的行数,失败返回-1</returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.vbMatrix.SymTridMatrix(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix,System.Int16,System.Boolean,Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix)">
 <summary>
 实对称阵化为对称三对角阵
 </summary>
 <param name="A">目标方阵</param>
 <param name="n">方阵A的阶数</param>
 <param name="Is对称">不确定是否对称直接填False,对称则直接填True</param>
 <param name="ret">返回的三对角阵</param>
 <returns></returns>
 <remarks>本函数采用用豪斯赫尔蒙德变换将实对称阵化为对称三对角</remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.vbMatrix.Adj(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix,System.Int16,Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix)">
 <summary>
 矩阵伴随矩阵
 </summary>
 <param name="K">目标方阵</param>
 <param name="n">方阵K的阶数</param>
 <param name="Ret">获得的伴随矩阵</param>
 <returns></returns>
 <remarks>
 函数采用求代数余子式的方式进行求解,这样就存在一个问题,当目标矩阵的阶数很大的时候,本函数效率是相当慢的。
 建议使用左连翠提出的《伴随矩阵的新求法》里的方法进行求解。里面的方法可以求解非满秩矩阵的伴随矩阵。
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.vbMatrix.Pow(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix,System.Int32,System.Int32,Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix)">
 <summary>
 方阵求n次方
 </summary>
 <param name="A">目标方阵</param>
 <param name="m">方阵A的阶数</param>
 <param name="n">方阵A要求的次方数</param>
 <param name="Ret">方阵A进行n次方后获得的返回值</param>
 <returns></returns>
 <remarks>
 注意,本代码没有采用特征值法。而是直接采用2个矩阵相乘的方法(但又不是老老实实地去乘n次),因为用程序去求一个方阵的特征值,
 可能运算复杂度超过了你直接对矩阵相乘的复杂度,至少在n在1000以内大概是这样。
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.vbMatrix.PolyRoots2(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix,System.Int32,System.Int16,System.Int32,Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix@)">
 <summary>
 求多项式复数根贝尔斯托(Bairstow)算法
 </summary>
 <param name="A">多项式系数矩阵,为1*A_n的矩阵。A中的数据依次为多项式最高项系数,次高项系数……常数项系数</param>
 <param name="A_n">A矩阵的列数或大小</param>
 <param name="LoopNumber">控制的循环次数</param>
 <param name="Erro">误差控制变量</param>
 <param name="ret">返回的一个n*2的矩阵</param>
 <returns>函数执行完毕返回Ret的行数</returns>
 <remarks>
 对于多项式
 
 ```
 f(x) = (x^2+2x+3)(x^2-5x+9)
      = x^4-3x^3+2x^2+3x+27
 ```
 
 则 A(0,0)=1,
    A(0,1)=-3,
    A(0,2)=2,
    A(0,3)=3,
    A(0,4)=27,
    A_n=5.
 
 当执行下面的函数后,Ret是一个2×2的矩阵,即
 
 ```
 Ret(0,0)=2,
 Ret(0,1)=3,
 ```
 
 Ret(0,0)的2对应于(x^2+2x+3)当中2x的2,
 Ret(0,1)的3对应于(x^2+2x+3)当中常系数的3.
 
 用此函数前建议先把重根与实数根处理掉
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.vbMatrix.Cond(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix,System.Int32)">
 <summary>
 矩阵范数Cond及
 </summary>
 <param name="k">目标矩阵</param>
 <param name="m">矩阵的行数</param>
 <returns></returns>
 <remarks>
 函数运行原理是先求矩阵的奇异值,然后用最大的奇异值除以最小的奇异值即得矩阵的范数.对于只有1行或者1列的还得另行处理.这个函数和Matlab的Cond命令一样,即2范数
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.vbMatrix.Scatter(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix,System.Int32,Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix)">
 <summary>
 构建散点图矩阵(Scatter GeneralMatrix)
 </summary>
 <param name="X">目标矩阵</param>
 <param name="m">X矩阵的行数</param>
 <param name="S">获得的散点矩阵</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.vbMatrix.PolyDivEx(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix,Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix,Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix,Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix,System.Int32)">
 <summary>
 多项式除法
 </summary>
 <param name="A1">被除数存储多项式系数</param>
 <param name="A2">除数存储多项式系数</param>
 <param name="RetMod">求得的余数多项式系数</param>
 <param name="Ret">求得的多项式商系数</param>
 <param name="Erro">误差控制参数</param>
 <returns></returns>
 <remarks>A1/A2=Ret……RetMod</remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.vbMatrix.EigTorF(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix,System.Int32,System.Double,Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix)">
 <summary>
 矩阵特征值获取特征值向量
 </summary>
 <param name="A1">目标方阵</param>
 <param name="A_m">矩阵A的行数</param>
 <param name="EigValve">方阵A的一个特征值</param>
 <param name="X">函数执行成功后得到的一个特征向量</param>
 <remarks>
 函数原理:已知方阵A的一个特征值为r,则求解方程组(A-r*E)*X=0的解X即为我们的一个特征向量(这里E为单位矩阵),
 我们下面采用的是全选主元素法求解.但是需要注意的是,由于这个方程组是非满秩矩阵,因此在最后处理解的时候,我们
 总是令X解中的一个量为1(当然,你可以设置为其它数,建议设置为非0的数据),然后根据这个量导出其它的量
 
 例子:
 ```
 a =
  [ -1.0000000000000   0.00000000000000   0.00000000000000
    8.00000000000000   2.00000000000000   4.00000000000000
    8.00000000000000   3.00000000000000   3.00000000000000 ]

  Math_Matrix_EigTor(a,3,6,x)'上面矩阵a的一个特征值为6,则我们执行如下的命令后求得6的特征向量x如下
 x =
  [ 0.00000000000000
    1.00000000000000
    1.00000000000000 ]
 ```
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.vbMatrix.EigSym(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix,System.Int16,System.Int16,Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix,Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix)">
 <summary>
 求对称方阵特征值
 </summary>
 <param name="A">对称方阵</param>
 <param name="n">方阵A的阶数</param>
 <param name="Erro1">误差控制变量</param>
 <param name="Ret">返回的特征值</param>
 <param name="Ret_Eigenvectors">返回的特征值对应的特征向量</param>
 <returns></returns>
 <remarks>本代码采用雅可比过关法求解</remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.vbMatrix.Mul(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix,Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix,System.Int32,Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix@)">
 <summary>
 矩阵相乘
 </summary>
 <param name="K1">K1为矩阵乘法中左边的矩阵</param>
 <param name="K2">为矩阵乘法中右边的矩阵</param>
 <param name="n">代表K1的列数,K2的行数</param>
 <param name="Return_K">执行成功后返回的乘的结果的矩阵</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.vbMatrix.Sqrt(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix,System.Int32,Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix)">
 <summary>
 矩阵求平方根（sqrtm）
 </summary>
 <param name="K">目标方阵</param>
 <param name="n">方阵K的阶数</param>
 <param name="ks">求得的平方根.即ks*ks=K</param>
 <returns></returns>
 <remarks>
 如果K可以化成K=Inv(P)*diag(R)*P,其中Inv(P)表示P的逆矩阵,diag(R)*为K的特征值组成的对角矩阵,
 那么ks=Inv(P)*diag(R^0.5)*P,根据对角化原理,P*K*Inv(P)=Diag(R),其中Inv(P)是特征值R对应于K
 的特征向量,因此我们的算法=求特征值R,如果所有R均为正实数,则求R对应的特征向量Inv(P),然后讲R每
 个值取根放入对角矩阵对结果相乘即可
 
 例子:
 ```
 c =
  [  192.291902022941   136.423323830855  -22.2582056347830   10.9878603820001
    -176.869155076020  -120.047935463800   20.4023293672721  -16.5962890811120
    -21.6722775306690  -60.5101175154120   135.025037886378   5.36535497517843
     31.2279467353500   93.4954928282741  -106.961070363850   59.2865617399033  ]
  
 Math_Matrix_Sqrt(a,4,x)'求a平方根如下,可以进行x*x进行验证
 x =
  [  18.0067271094031   10.1514259204440  -0.80764239842560   0.96148324464486
    -13.6679053566890  -5.69822839694800   0.61394536284630  -1.38430646207250
    -3.17102914065820  -5.10751280313280   11.6191076697081   0.04254172112235
     4.81532683312183   7.92820343443191  -5.38805756370240   8.16305909603188  ]
 ```
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.vbMatrix.RU(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix,System.Int32,Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix,Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix)">
 <summary>
 右极分解，即F=R*U
 </summary>
 <param name="F">目标方阵</param>
 <param name="n">方阵F的阶数</param>
 <param name="R">分解得到的一个正交矩阵</param>
 <param name="U">分解得到的一个对称正定矩阵</param>
 <returns></returns>
 <remarks>
 原理:任何一个可逆方阵均可以唯一的进行右极分解与左极分解,即F=R*U=V*R,其中U^2=T(F)*F,V^2=F*T(F)
【其中T(F)表示F的转置】,则我们可以先通过F求得U或V,然后求R=F*Inv(U)=Inv(V)*F
 
 例子:
 a =
  [ 67.5919611787386     69.8554906388072     38.8768396987006     89.3106376236820
    17.0671848194055     1.12767200969517     31.5601159499772     96.9140055109346
    40.6681714768839     51.0876563615574     86.9885893943666     77.3506165842296
    73.6101518727886     87.9281915202402     23.9508483670423     3.45968334165387 ]
 
 Math_Matrix_RU(a,4,r,u)'进行右极分解得到如下结果
 r =
  [ -0.01806739003090   0.71913865214108  -0.27739456376250   0.63664949766408
     0.45823822484909  -0.57214688695250   0.04612554269224   0.67904624212867
    -0.09675742692290   0.20970810955629   0.95672796354849   0.17708590026142
     0.88326786307616   0.33437989881145   0.07527225185216  -0.31939364294910  ]
 u =
  [ 67.6841644139219  71.9849022272286  26.4791752992667  38.3171883770002
    71.9863924990090  89.6984480926248  36.1676400008128  26.2017432919420
    26.4820423188876  36.1668446729677  75.6890493922576  53.9420595009903
    38.3140405638833  26.2042694530458  53.9408769958847  135.276124831623  ]

 Math_Matrix_VR(a,4,v,r)'进行左极分解得到如下结果
 v =
  [ 95.0902981485406     53.4500420292151     61.1182769307013     57.4613130458042
    53.4438098825046     74.4408296746995     45.9449363126334    -13.1234428571640
    61.1187415068155     45.9418557217637     103.699821171875     34.8450484220080
    57.4619847804705    -13.1244040926920     34.8441839555448     95.1168377384350 ]
 r =
  [ -0.01835015300540     0.71939575068999    -0.27678823268990     0.63628327754090
     0.45799761221593    -0.57191020194030     0.04534571824682     0.67953103744654
    -0.09684035444340     0.20977163011655     0.95676617484504     0.17707600892713
     0.88364856259618     0.33406264059053     0.07478222238892    -0.31912379017620 ]
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.vbMatrix.VR(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix,System.Int32,Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix,Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix)">
 <summary>
 左极分解
 </summary>
 <param name="F">目标方阵</param>
 <param name="n">方阵F的阶数</param>
 <param name="V">分解得到的一个对称正定矩阵</param>
 <param name="R">分解得到的一个正交矩阵，即F=V*R</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.vbMatrix.Hamiltonian(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix,System.Int32,Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix)">
 <summary>
 构建哈密顿矩阵
 </summary>
 <param name="k">m阶的对称矩阵</param>
 <param name="m">矩阵k的行数</param>
 <param name="ret">获得的关于矩阵K的Hamiltonian矩阵</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.vbMatrix.Lehmer(System.Int32,Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix)">
 <summary>
 构建Lehmer矩阵
 </summary>
 <param name="n">构建Lehmer矩阵的阶数</param>
 <param name="k">构建的Lehmer矩阵</param>
 <remarks>Lehmer GeneralMatrix</remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.vbMatrix.PolyMul(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix,Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix,Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix)">
 <summary>
 多项式乘法
 </summary>
 <param name="Mul1">乘数多项式系数</param>
 <param name="Mul2">乘数多项式系数</param>
 <param name="Ret">获得的乘积结果多项式系数</param>
 <returns></returns>
 <remarks>Ret=Mul1*Mul2</remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.vbMatrix.PolyDiv(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix,Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix,Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix@,Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix@,System.Int32)">
 <summary>
 多项式除法
 </summary>
 <param name="A1">被除数存储多项式系数</param>
 <param name="A2">除数存储多项式系数</param>
 <param name="RetMod">求得的余数多项式系数</param>
 <param name="Ret">求得的多项式商系数</param>
 <param name="Erro">误差控制参数</param>
 <returns>
 多项式的除法，里边的数组均为1*n的矩阵,原理:A1/A2=Ret……RetMod'函数最终返回Ret商的数组大小
 </returns>
 <remarks>A1/A2=Ret……RetMod</remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.vbMatrix.PolyMod(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix,Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix,Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix@,System.Int32)">
 <summary>
 多项式求余数
 </summary>
 <param name="A1">被除数多项式系数</param>
 <param name="A2">除数多项式系数</param>
 <param name="Ret">求得的余数多项式系数</param>
 <param name="Erro">误差控制参数</param>
 <returns></returns>
 <remarks>A1%A2=Ret</remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.vbMatrix.IDFT(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix,System.Int32,System.Int32,Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix@)">
 <summary>
 离散傅里叶变换逆变换
 </summary>
 <param name="k">m*2的矩阵数据(数据点)K里的第一列代表数据的实数部分,第2列代表数据的虚数部分</param>
 <param name="m">矩阵k的行数</param>
 <param name="Number">离散点数</param>
 <param name="X">离散傅里叶变换逆变换的结果矩阵是Number*2的矩阵,X里的第一列代表数据的实数部分,第2列代表数据的虚数部分</param>
 <returns>本函数执行成功返回True.本函数相当于Matlab的快速傅里叶变换逆变换函数IFFT</returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.vbMatrix.DFT(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix,System.Int32,System.Int32,Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix@)">
 <summary>
 离散傅里叶变换
 </summary>
 <param name="k">m*2的矩阵数据(数据点)K里的第一列代表数据的实数部分,第2列代表数据的虚数部分</param>
 <param name="m">矩阵k的行数</param>
 <param name="Number">离散点数</param>
 <param name="X">离散傅里叶变换的结果矩阵是Number*2的矩阵,X里的第一列代表数据的实数部分,第2列代表数据的虚数部分</param>
 <returns>本函数执行成功返回True.本函数相当于Matlab的快速傅里叶变换函数FFT</returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.vbMatrix.Orth(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix,System.Int32,Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix@)">
 <summary>
 求矩阵的一个正交基Orth
 </summary>
 <param name="k">目标矩阵</param>
 <param name="m">k的行数</param>
 <param name="ret">获得的一个正交基矩阵</param>
 <returns>函数失败返回小于1的数据，成功返回ret的行数</returns>
 <remarks>对矩阵进行svd分解即用SvdSplit得到k=usv*,则s是奇异值矩阵,可以奇异值是否为0获得矩阵的秩r,然后ret就是m*r的矩阵且其就是u里的m*r的部分值</remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.vbMatrix.Magic(System.Int32,System.Double,Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix@)">
 <summary>
 幻方
 </summary>
 <param name="n">幻方的阶数(大于2)</param>
 <param name="start">幻方的中最小的正整数,一般可以设置为1</param>
 <param name="k">获得的幻方</param>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.vbMatrix.Sove2(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix,Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix,System.Int32,System.Int32,Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix@)">
 <summary>
 高斯全选主元素法解方程，本函数是求解AX=B这类问题的。函数采用全选主元素的高斯消元法，对于出现非满秩矩阵时(A的化简过程中的A)，
 只要函数有解(可能不止一组解,此时只返回一组解)，本函数都能返回其解
 </summary>
 <param name="A">A_m*n的矩阵</param>
 <param name="b">B_m*1的矩阵</param>
 <param name="A_m"></param>
 <param name="B_m"></param>
 <param name="X">求解得到的矩阵</param>
 <returns></returns>
 <remarks>
 例子:
 a =
  [ 89.7234413259306  12.9170338217714  79.9443395249286  78.1627263772128
    62.8960442556516  63.9951517172135  2.9257326400493   57.119458800703
    83.5902038885235  55.9411662425572  89.4671598865963  33.7297967792162 ]
 
 b =
  [ 65.2027291083721
    54.2041894766522
    63.722165657078   ]
 
 经过本函数后得到的解如下
 x =
  [ -0.826689550370445
    0.737377350436936
    0.646558671079671
    1                 ]
 
 即AX=B
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.vbMatrix.PolyGCF(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix,System.Int32,Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix,System.Int32,Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix,System.Int32)">
 <summary>
 多项式提取最大公因式
 </summary>
 <param name="A1">1*A1_n的存储多项式系数的矩阵</param>
 <param name="A1_n">A1的列数</param>
 <param name="A2">为1*A2_n的存储多项式系数的矩阵</param>
 <param name="A2_n">A2的列数</param>
 <param name="Ret">获得的最大公因式多项式系数</param>
 <param name="Erro">误差控制参数</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.vbMatrix.PolyGCFCall(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix,System.Int32,Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix,System.Int32,Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix,System.Int32)">
 <summary>
 求2个多项式的最大公因式Ret，A1为1*A1_n的矩阵，A2为1*A2_n的矩阵。函数执行后返回公因式Ret的大小
 </summary>
 <param name="A1"></param>
 <param name="A1_n"></param>
 <param name="A2"></param>
 <param name="A2_n"></param>
 <param name="Ret"></param>
 <param name="Erro"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.vbMatrix.Pascal(System.Int32,Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix)">
 <summary>
 n阶帕斯卡(Pascal)矩阵  
 </summary>
 <param name="n">表示产生帕斯卡(Pascal)矩阵的阶数</param>
 <param name="k">产生的n阶帕斯卡(Pascal)矩阵</param>
 <remarks>Pascal GeneralMatrix即产生n阶的帕斯卡矩阵由杨辉三角形表组成的矩阵称为帕斯卡(Pascal)矩阵</remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.Numpy.argsort(System.Collections.Generic.IEnumerable{System.Double})">
 <summary>
 Perform an indirect sort along the given axis using the algorithm specified
 by the `kind` keyword. It returns an array Of indices Of the same shape As
 `a` that index data along the given axis in sorted order.
 </summary>
 <param name="data"></param>
 <returns>Returns the indices that would sort an array.</returns>
 <example>
 x = np.array([3, 1, 2])
 np.argsort(x)
 array([1, 2, 0])
 </example>
 
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.Numpy.Sort(System.Collections.Generic.IEnumerable{System.Double},System.Boolean)">
 <summary>
 Sorting or Ordering Vectors
 Sort (or order) a vector or factor (partially) into ascending or descending order. For ordering along more than one variable, e.g., for sorting data frames, see order.
 </summary>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.Numpy.Where(System.Collections.Generic.IEnumerable{System.Boolean},Microsoft.VisualBasic.Math.LinearAlgebra.Vector,Microsoft.VisualBasic.Math.LinearAlgebra.Vector)">
 <summary>
 
 </summary>
 <param name="condition">
 当conditon的某个位置的为true时，输出x的对应位置的元素，否则选择y对应位置的元素；
 </param>
 <param name="x"></param>
 <param name="y"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumpyExtensions.t(System.Collections.Generic.IEnumerable{System.Double})">
 <summary>
 Create column vector matrix
 </summary>
 <param name="v"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumpyExtensions.r(System.Collections.Generic.IEnumerable{System.Double})">
 <summary>
 Create row vector matrix
 </summary>
 <param name="v"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumpyExtensions.Mean(System.Collections.Generic.IEnumerable{Microsoft.VisualBasic.Math.LinearAlgebra.Vector},System.Int32)">
 <summary>
 Returns the average of the array elements. The average is taken over the 
 flattened array by default, otherwise over the specified axis. float64 
 intermediate and return values are used for integer inputs.
 </summary>
 <param name="matrix"></param>
 <param name="axis%"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumpyExtensions.Apply``2(System.Collections.Generic.IEnumerable{Microsoft.VisualBasic.Math.LinearAlgebra.Vector},System.Func{System.Collections.Generic.IEnumerable{System.Double},``0},System.Int32,System.Func{System.Collections.Generic.IEnumerable{``0},``1})">
 <summary>
 
 </summary>
 <typeparam name="T"></typeparam>
 <typeparam name="Tout"></typeparam>
 <param name="matrix"></param>
 <param name="math"></param>
 <param name="axis">
 + 0 表示按列进行计算
 + 1 表示按行进行计算
 + 小于零则负数则表示所有元素作为一个向量来计算
 </param>
 <param name="aggregate"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.Serialization">
 <summary>
 data serialization of the numeric matrix
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.Serialization.Save(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix,System.IO.Stream)">
 <summary>
 Save the current numeric matrix into a binary file
 </summary>
 <param name="m"></param>
 <param name="s"></param>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.Serialization.Load(System.IO.Stream)">
 <summary>
 read matrix data from a binary file
 </summary>
 <param name="s"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix">
 <summary>
 [m,n]
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix.X(System.Int32,System.Int32)">
 <summary>
 get/set cell element value
 </summary>
 <param name="i"></param>
 <param name="j"></param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix.X(System.Collections.Generic.IEnumerable{System.Int32})">
 <summary>
 column projection via column index
 </summary>
 <remarks>
 select column values for each row for create a new matrix
 </remarks>
 <param name="indices"></param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix.RowDimension">
 <summary>
 m
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix.ColumnDimension">
 <summary>
 n
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix.GetMatrix(System.Int32[],System.Int32,System.Int32)">
 <summary>Get a submatrix.</summary>
 <param name="r">   Array of row indices.
 </param>
 <param name="j0">  Initial column index
 </param>
 <param name="j1">  Final column index
 </param>
 <returns>     A(r(:),j0:j1)
 </returns>
 <exception cref="T:System.IndexOutOfRangeException">   Submatrix indices
 </exception>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix.Dot(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix)">
 <summary>
 matrix dot product
 </summary>
 <param name="m2"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.IndexVector">
 <summary>
 another form of <see cref="T:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.SparseMatrix"/>
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.Multiply.RowMultiply(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix,Microsoft.VisualBasic.Math.LinearAlgebra.Vector)">
 <summary>
 the vector size is equals to the matrix rows,
 each element in target vector is multiply to
 each row in matrix
 </summary>
 <param name="m"></param>
 <param name="v"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.Multiply.ColumnMultiply(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix,Microsoft.VisualBasic.Math.LinearAlgebra.Vector)">
 <summary>
 the vector size is equals to the matrix columns,
 each element in target vector is multiply to
 each column in matrix
 </summary>
 <param name="m"></param>
 <param name="v"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.Subtraction.RowSubtraction(Microsoft.VisualBasic.Math.LinearAlgebra.Vector,Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix)">
 <summary>
 the dimension of the vector should be equals
 to the row dimension of the input matrix.
 
 <paramref name="v"/> - each column in m
 </summary>
 <param name="v"></param>
 <param name="m"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.MDSScale.Data">
 <summary>
 Created by IntelliJ IDEA.
 User: da
 Date: 10/8/11
 Time: 2:27 AM
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.MDSScale.LandmarkMDS">
 <summary>
 Created by IntelliJ IDEA.
 User: da
 Date: 10/8/11
 Time: 2:43 AM
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.MDSScale.MDS">
 <summary>
 Created by IntelliJ IDEA.
 User: da
 Date: 10/8/11
 Time: 2:25 AM
 </summary>
 <remarks>
 https://github.com/asarnow/mdscale
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.MDSScale.MDS.fullmds(System.Double[][],System.Int32)">
 <summary>
 
 </summary>
 <param name="d">should be a NxN distance matrix.</param>
 <param name="dim"></param>
 <returns>
 this function returns an column array with <paramref name="dim"/> elements, each elements is a dimension column result
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.MDSScale.MDSMethod.iterate">
 <summary>
 Perform 1 majorization iteration using this SMACOF instance. </summary>
 <returns> report </returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.MDSScale.MDSMethod.iterate(System.Int32)">
 <summary>
 Perform n majorization iterations using this SMACOF instance. </summary>
 <param name="n"> number of iterations </param>
 <returns> report </returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.MDSScale.MDSMethod.iterate(System.Int32,System.Int32)">
 <summary>
 Perform majorization iterations until the maximum number of iterations
 is reached, the maximum runtime has elapsed, or the change in
 normalized stress falls below the threshold, whichever comes first. </summary>
 <param name="iter"> maximum number of iterations </param>
 <param name="threshold"> threshold for change in normalized stress </param>
 <returns> report </returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.MDSScale.MDSMethod.weightMatrix(System.Double[][],System.Double)">
 <summary>
 Element-wise matrix exponentiation for self-weighting of distances. </summary>
 <param name="D"> distance matrix or initial weights </param>
 <param name="exponent"> power to raise each element the matrix </param>
 <returns> exponentiated weights </returns>
</member>
<member name="T:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.MDSScale.SMACOF">
 <summary>
 A class implementing Stress Minimization by Majorizing a Complex Function (SMACOF).
 
 Created by IntelliJ IDEA.
 User: da
 Date: 10/8/11
 Time: 2:43 AM
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.MDSScale.SMACOF.#ctor(System.Double[][],System.Double[][],System.Double[][])">
 <summary>
 Construct a new SMACOF instance. </summary>
 <param name="d"> distance matrix </param>
 <param name="x"> initial coordinate matrix </param>
 <param name="w"> weights matrix </param>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.MDSScale.SMACOF.#ctor(System.Double[][],System.Double[][])">
 <summary>
 Construct a SMACOF instance without weights. </summary>
 <param name="d"> distance matrix </param>
 <param name="x"> initial coordinate matrix </param>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.MDSScale.SMACOF.iterate(System.Int32)">
 <summary>
 Perform n majorization iterations using this SMACOF instance. </summary>
 <param name="n"> number of iterations </param>
 <returns> report </returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.MDSScale.SMACOF.iterate(System.Int32,System.Int32)">
 <summary>
 Perform majorization iterations until the maximum number of iterations
 is reached, the maximum runtime has elapsed, or the change in
 normalized stress falls below the threshold, whichever comes first. </summary>
 <param name="iter"> maximum number of iterations </param>
 <param name="threshold"> threshold for change in normalized stress </param>
 <returns> report </returns>
</member>
<member name="P:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.MDSScale.SMACOF.StressProp">
 <summary>
 Compute the absolute stress for this SMACOF instance. </summary>
 <returns> stress </returns>
</member>
<member name="P:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.MDSScale.SMACOF.NormalizedStressProp">
 <summary>
 Compute the normalized stress for this SMACOF instance. </summary>
 <returns> normalized stress </returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.MDSScale.SMACOF.majorize(System.Double[][],System.Double[][],System.Double[][],System.Int32,System.Int32)">
 <summary>
 SMACOF algorithm (weighted). </summary>
 <param name="x"> coordinates matrix </param>
 <param name="d"> distance matrix </param>
 <param name="w"> weights matrix </param>
 <param name="iter"> maximum iterations </param>
 <param name="threshold"> halting threshold for change in normalized stress </param>
 <returns> report </returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.MDSScale.SMACOF.majorize(System.Double[][],System.Double[][],System.Int32,System.Int32)">
 <summary>
 SMACOF algorithm (unweighted). </summary>
 <param name="x"> coordinates matrix </param>
 <param name="d"> distance matrix </param>
 <param name="iter"> maximum iterations </param>
 <param name="threshold"> halting threshold for change in normalized stress </param>
 <returns> report </returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.MDSScale.SMACOF.majorize(System.Double[][],System.Double[][],System.Double[][],System.Int32)">
 <summary>
 Bare SMACOF algorithm. Convenient for reading the algorithm. </summary>
 <param name="x"> coordinates matrix </param>
 <param name="d"> distance matrix </param>
 <param name="w"> weights matrix </param>
 <param name="iter"> number of iterations </param>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.MDSScale.SMACOF.stress(System.Double[][],System.Double[][],System.Double[][])">
 <summary>
 Compute the absolute stress between a weighted distance matrix and a configuration of coordinates. </summary>
 <param name="d"> distance matrix </param>
 <param name="w"> weights matrix </param>
 <param name="x"> coordinates matrix </param>
 <returns> stress </returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.MDSScale.SMACOF.stress(System.Double[][],System.Double[][])">
 <summary>
 Compute the absolute stress between a distance matrix and a configuration of coordinates. </summary>
 <param name="d"> distance matrix </param>
 <param name="x"> coordinates matrix </param>
 <returns> stress </returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.MDSScale.SMACOF.normalizedStress(System.Double[][],System.Double[][],System.Double[][])">
 <summary>
 Compute the normlized stress between a weighted distance matrix and a configuration of coordinates. </summary>
 <param name="d"> distance matrix </param>
 <param name="w"> weights matrix </param>
 <param name="x"> coordinate matrix </param>
 <returns> normalized stress </returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.MDSScale.SMACOF.normalizedStress(System.Double[][],System.Double[][])">
 <summary>
 Return the normlized stress between a distance matrix and a configuration of coordinates. </summary>
 <param name="d"> distance matrix </param>
 <param name="x"> coordinate matrix </param>
 <returns> normalized stress </returns>
</member>
<member name="T:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix">
 <summary>
 ### .NET GeneralMatrix class.
 
 The .NET <see cref="T:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix"/> Class provides the fundamental operations of numerical
 linear algebra.  Various constructors create Matrices from two dimensional
 arrays of double precision floating point numbers.  Various "gets" and
 "sets" provide access to submatrices and matrix elements.  Several methods 
 implement basic matrix arithmetic, including matrix addition and
 multiplication, matrix norms, and element-by-element array operations.
 Methods for reading and printing matrices are also included.  All the
 operations in this version of the <see cref="T:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix"/> Class involve real matrices.
 Complex matrices may be handled in a future version.
 
 Five fundamental matrix decompositions, which consist of pairs or triples
 of matrices, permutation vectors, and the like, produce results in five
 decomposition classes.  These decompositions are accessed by the <see cref="T:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix"/>
 class to compute solutions of simultaneous linear equations, determinants,
 inverses and other matrix functions.  
 
 The five decompositions are:
 
 + <see cref="T:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.CholeskyDecomposition"/> of symmetric, positive definite matrices.
 + <see cref="T:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.LUDecomposition"/> of rectangular matrices.
 + <see cref="T:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.QRDecomposition"/> of rectangular matrices.
 + <see cref="T:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.SingularValueDecomposition"/> of rectangular matrices.
 + <see cref="T:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.EigenvalueDecomposition"/> of both symmetric and nonsymmetric square matrices.
 
 Example of use:
 
 Solve a linear system A x = b and compute the residual norm, ``||b - A x||``.
 
 ```csharp
 double[][] vals;
 GeneralMatrix A = New NumericMatrix(vals);
 GeneralMatrix b = GeneralMatrix.Random(3,1);
 GeneralMatrix x = A.Solve(b);
 GeneralMatrix r = A.Multiply(x).Subtract(b);
 double rnorm = r.NormInf();
 ```
 </summary>
 <author>  
 The MathWorks, Inc. and the National Institute of Standards and Technology.
 
 + http://www.codeproject.com/Articles/5835/DotNetMatrix-Simple-Matrix-Library-for-NET
 + https://github.com/fiji/Jama/blob/master/src/main/java/Jama/Matrix.java
 </author>
 <version>  5 August 1998
 </version>
 <remarks>
 Access the internal two-dimensional array.
 Pointer to the two-dimensional array of matrix elements.
 this numeric matrix object consist with a collection of <see cref="T:Microsoft.VisualBasic.Math.LinearAlgebra.Vector"/> as rows.
 </remarks>
</member>
<member name="F:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.m">
 <summary>Row and column dimensions.
 @serial row dimension.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.n">
 <summary>
 Row and column dimensions.
 @serial column dimension.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.#ctor(System.Double[])">
 <summary>
 Create a new (column) RealMatrix using {@code v} as the
 data for the unique column of the created matrix.
 The input array Is copied.
 </summary>
 <param name="v">
 Column vector holding data for new matrix.
 </param>
 <remarks>
 20230815 创建一个只有一列数据的矩阵，矩阵的行数
 等于<paramref name="v"/>的元素数量
 </remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.#ctor(System.Int32,System.Int32)">
 <summary>Construct an m-by-n matrix of zeros. m is row number and n is column number</summary>
 <param name="m">Number of rows.</param>
 <param name="n">Number of colums.</param>
 <remarks>
 m is row number and n is column number
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.#ctor(System.Int32,System.Int32,System.Double)">
 <summary>Construct an m-by-n constant matrix.</summary>
 <param name="m">   Number of rows.
 </param>
 <param name="n">   Number of colums.
 </param>
 <param name="s">   Fill the matrix with this scalar value.
 </param>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.#ctor(System.Double[][],System.Boolean)">
 <summary>Construct a matrix from a 2-D array.</summary>
 <param name="A">Two-dimensional array of doubles.
 </param>
 <param name="t">
 the given raw data parameter <paramref name="A"/> is in columns
 required transpose of the matrix.
 </param>
 <exception cref="T:System.ArgumentException">All rows must have the same length
 </exception>
 <seealso cref="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.Create(System.Double[][])">
 </seealso>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.#ctor(System.Collections.Generic.IEnumerable{System.Double[]})">
 <summary>
 create a new numeric matrix based on a given collection of the row data vectors
 </summary>
 <param name="rows"></param>
 
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.#ctor(System.Double[][],System.Int32,System.Int32)">
 <summary>Construct a matrix quickly without checking arguments.</summary>
 <param name="A">   Two-dimensional array of doubles.
 </param>
 <param name="m">   Number of rows.
 </param>
 <param name="n">   Number of colums.
 </param>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.#ctor(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix)">
 <summary>
 make the matrix value copy
 </summary>
 <param name="m"></param>
 
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.#ctor(System.Double[],System.Int32)">
 <summary>Construct a matrix from a one-dimensional packed array</summary>
 <param name="vals">One-dimensional array of doubles, packed by columns (ala Fortran).
 </param>
 <param name="m">   Number of rows.
 </param>
 <exception cref="T:System.ArgumentException">   Array length must be a multiple of m.
 </exception>
</member>
<member name="P:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.ColumnPackedCopy">
 <summary>Make a one-dimensional column packed copy of the internal array.</summary>
 <returns>     Matrix elements packed in a one-dimensional array by columns.
 </returns>
</member>
<member name="P:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.RowPackedCopy">
 <summary>Make a one-dimensional row packed copy of the internal array.</summary>
 <returns>     Matrix elements packed in a one-dimensional array by rows.
 </returns>
</member>
<member name="P:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.RowDimension">
 <summary>Get row dimension.</summary>
 <returns>     m, the number of rows.
 </returns>
</member>
<member name="P:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.ColumnDimension">
 <summary>Get column dimension.</summary>
 <returns>     n, the number of columns.
 </returns>
</member>
<member name="P:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.Dimension">
 <summary>
 get [n,m] shape data
 </summary>
 <returns>
 the width is the number of columns(n) and the height is the number of rows(m)
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.Block(System.Int32,System.Int32,System.Int32,System.Int32)">
 <summary>
 
 </summary>
 <param name="i">the start location, col, x</param>
 <param name="j">the start location, row, y</param>
 <param name="p">the size of the block, nrows</param>
 <param name="q">the size of the block, ncols</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.Number">
 <summary>
 获取仅包含有一个元素的矩阵对象
 </summary>
 <returns></returns>
 <remarks></remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.Create(System.Double[][])">
 <summary>Construct a matrix from a copy of a 2-D array.</summary>
 <param name="A">   Two-dimensional array of doubles.
 </param>
 <exception cref="T:System.ArgumentException">   All rows must have the same length
 </exception>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.Copy">
 <summary>
 Make a deep copy of a matrix
 </summary>
 <remarks>
 this function will break the array class reference between the matrix instance
 </remarks>
</member>
<member name="P:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.Item(System.Int32,System.Int32)">
 <summary>Get a single element.</summary>
 <param name="i">   Row index.
 </param>
 <param name="j">   Column index.
 </param>
 <returns>     A(i,j)
 </returns>
 <exception cref="T:System.IndexOutOfRangeException">  
 </exception>
</member>
<member name="P:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.Item(System.UInt32,System.UInt32)">
 <summary>Get a single element.</summary>
 <param name="i">   Row index.
 </param>
 <param name="j">   Column index.
 </param>
 <returns>     A(i,j)
 </returns>
 <exception cref="T:System.IndexOutOfRangeException">  
 </exception>
</member>
<member name="P:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.Item(System.Collections.Generic.IEnumerable{System.Int32})">
 <summary>
 column projection via column index
 </summary>
 <remarks>
 select column values for each row for create a new matrix
 </remarks>
 <param name="indices"></param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.Item(System.Int32,System.Boolean)">
 <summary>
 get/set data vector by row or by column
 </summary>
 <param name="i"></param>
 <param name="byRow"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.GetMatrix(System.Int32,System.Int32,System.Int32,System.Int32)">
 <summary>Get a submatrix.</summary>
 <param name="i0">  Initial row index
 </param>
 <param name="i1">  Final row index
 </param>
 <param name="j0">  Initial column index
 </param>
 <param name="j1">  Final column index
 </param>
 <returns>     A(i0:i1,j0:j1)
 </returns>
 <exception cref="T:System.IndexOutOfRangeException">   Submatrix indices
 </exception>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.GetMatrix(System.Int32[],System.Int32[])">
 <summary>Get a submatrix.</summary>
 <param name="r">   Array of row indices.
 </param>
 <param name="c">   Array of column indices.
 </param>
 <returns>     A(r(:),c(:))
 </returns>
 <exception cref="T:System.IndexOutOfRangeException">   Submatrix indices
 </exception>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.GetMatrix(System.Int32,System.Int32,System.Int32[])">
 <summary>Get a submatrix.</summary>
 <param name="i0">  Initial row index
 </param>
 <param name="i1">  Final row index
 </param>
 <param name="c">   Array of column indices.
 </param>
 <returns>     A(i0:i1,c(:))
 </returns>
 <exception cref="T:System.IndexOutOfRangeException">   Submatrix indices
 </exception>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.GetMatrix(System.Int32[],System.Int32,System.Int32)">
 <summary>Get a submatrix.</summary>
 <param name="r">   
 Array of row indices.
 </param>
 <param name="j0">  
 Initial column index
 </param>
 <param name="j1">  
 Final column index
 </param>
 <returns>     
 A(r(:),j0:j1)
 </returns>
 <exception cref="T:System.IndexOutOfRangeException"> Submatrix indices
 </exception>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.SetMatrix(System.Int32,System.Int32,System.Int32,System.Int32,Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix)">
 <summary>Set a submatrix.</summary>
 <param name="i0">  
 Initial row index
 </param>
 <param name="i1">  
 Final row index
 </param>
 <param name="j0">  
 Initial column index
 </param>
 <param name="j1">  
 Final column index
 </param>
 <param name="X">   
 A(i0:i1,j0:j1)
 </param>
 <exception cref="T:System.IndexOutOfRangeException">  Submatrix indices
 </exception>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.SetMatrix(System.Int32[],System.Int32[],Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix)">
 <summary>Set a submatrix.</summary>
 <param name="r">   
 Array of row indices.
 </param>
 <param name="c">   
 Array of column indices.
 </param>
 <param name="X">   
 A(r(:),c(:))
 </param>
 <exception cref="T:System.IndexOutOfRangeException">  Submatrix indices
 </exception>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.SetMatrix(System.Int32[],System.Int32,System.Int32,Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix)">
 <summary>Set a submatrix.</summary>
 <param name="r">   
 Array of row indices.
 </param>
 <param name="j0">  
 Initial column index
 </param>
 <param name="j1">  
 Final column index
 </param>
 <param name="X">   
 A(r(:),j0:j1)
 </param>
 <exception cref="T:System.IndexOutOfRangeException"> Submatrix indices
 </exception>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.SetMatrix(System.Int32,System.Int32,System.Int32[],Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix)">
 <summary>Set a submatrix.</summary>
 <param name="i0">  
 Initial row index
 </param>
 <param name="i1">  
 Final row index
 </param>
 <param name="c">   
 Array of column indices.
 </param>
 <param name="X">   
 A(i0:i1,c(:))
 </param>
 <exception cref="T:System.IndexOutOfRangeException">  Submatrix indices
 </exception>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.Transpose">
 <summary>Matrix transpose.</summary>
 <returns>    
 A'
 </returns>
 <remarks>
 make a value copy of the matrix 
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.Norm1">
 <summary>One norm</summary>
 <returns>    
 maximum column sum.
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.Norm2">
 <summary>Two norm</summary>
 <returns>    
 maximum singular value.
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.NormInf">
 <summary>Infinity norm</summary>
 <returns>    
 maximum row sum.
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.NormF">
 <summary>Frobenius norm</summary>
 <returns>    
 sqrt of sum of squares of all elements.
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.op_UnaryNegation(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix)">
 <summary>Unary minus</summary>
 <returns>    -A
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.Add(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix)">
 <summary>C = A + B</summary>
 <param name="B">   
 another matrix
 </param>
 <returns>     
 A + B
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.AddEquals(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix)">
 <summary>A = A + B</summary>
 <param name="B">   
 another matrix
 </param>
 <returns>     
 A + B
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.Subtract(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix)">
 <summary>C = A - B</summary>
 <param name="B">   
 another matrix
 </param>
 <returns>     
 A - B
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.Subtract(System.Double)">
 <summary>C = A - B</summary>
 <param name="B">a numeric value
 </param>
 <returns>     
 A - B
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.Power(System.Double)">
 <summary>C = x ^ y</summary>
 <param name="y">power
 </param>
 <returns>x ^ y
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.SubtractEquals(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix)">
 <summary>A = A - B</summary>
 <param name="B">   
 another matrix
 </param>
 <returns>     
 A - B
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.ArrayMultiply(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix)">
 <summary>Element-by-element multiplication, C = A.*B</summary>
 <param name="B">   
 another matrix
 </param>
 <returns>     
 A.*B
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.ArrayMultiplyEquals(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix)">
 <summary>Element-by-element multiplication in place, A = A.*B</summary>
 <param name="B">   
 another matrix
 </param>
 <returns>     
 A.*B
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.ArrayRightDivide(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix)">
 <summary>Element-by-element right division, C = A./B</summary>
 <param name="B">   
 another matrix
 </param>
 <returns>     
 A./B
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.ArrayRightDivideEquals(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix)">
 <summary>Element-by-element right division in place, A = A./B</summary>
 <param name="B">   
 another matrix
 </param>
 <returns>     
 A./B
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.ArrayLeftDivide(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix)">
 <summary>Element-by-element left division, C = A.\B</summary>
 <param name="B">   
 another matrix
 </param>
 <returns>     
 A.\B
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.ArrayLeftDivideEquals(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix)">
 <summary>Element-by-element left division in place, A = A.\B</summary>
 <param name="B">   
 another matrix
 </param>
 <returns>     
 A.\B
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.Multiply(System.Double)">
 <summary>Multiply a matrix by a scalar, ``C = s*A``</summary>
 <param name="s">   
 scalar
 </param>
 <returns>     
 s*A
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.Multiply(Microsoft.VisualBasic.Math.LinearAlgebra.Vector)">
 <summary>Multiply a matrix by a scalar, ``C = s*A``</summary>
 <returns>
 s*A
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.max(System.Int32@,System.Int32@)">
 <summary>
 maxCoeff, get max value in current matrix
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.Min(System.Int32@,System.Int32@)">
 <summary>
 minCoeff, get min value in current matrix
 </summary>
 <param name="row"></param>
 <param name="col"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.MultiplyEquals(System.Double)">
 <summary>Multiply a matrix by a scalar in place, A = s*A</summary>
 <param name="s">   
 scalar
 </param>
 <returns>     
 replace A by s*A
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.Multiply(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix)">
 <summary>
 Linear algebraic matrix multiplication, ``A * B``
 
 ``Jama.Matrix.times``
 </summary>
 <param name="B">another matrix</param>
 <returns>Matrix product, A * B</returns>
 <exception cref="T:System.ArgumentException">Matrix inner dimensions must agree.
 </exception>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.op_Addition(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix,Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix)">
 <summary>
  Addition of matrices
 </summary>
 <param name="m1"></param>
 <param name="m2"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.op_Subtraction(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix,Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix)">
 <summary>
 Subtraction of matrices
 </summary>
 <param name="m1"></param>
 <param name="m2"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.op_Multiply(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix,Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix)">
 <summary>
 Element-by-element multiplication of two matrices
 </summary>
 <param name="m1"></param>
 <param name="m2"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.op_Multiply(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix,Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix)">
 <summary>
 Element-by-element multiplication of two matrices
 </summary>
 <param name="m1"></param>
 <param name="m2"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.op_Multiply(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix,Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix)">
 <summary>
 Element-by-element multiplication of two matrices
 </summary>
 <param name="m1"></param>
 <param name="m2"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.op_Division(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix,Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix)">
 <summary>
 Element-by-element right division
 </summary>
 <param name="m1"></param>
 <param name="m2"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.op_Multiply(System.Double,Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix)">
 <summary>
 Multiplication of matrices
 </summary>
 <param name="m2"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.op_Multiply(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix,System.Double)">
 <summary>
 Multiplication of matrices
 </summary>
 <param name="m2"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.op_Multiply(Microsoft.VisualBasic.Math.LinearAlgebra.Vector,Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix)">
 <summary>
 Multiplication of matrices
 </summary>
 <param name="m2"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.LUD">
 <summary>LU Decomposition</summary>
 <returns>     LUDecomposition
 </returns>
 <seealso cref="T:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.LUDecomposition">
 </seealso>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.QRD">
 <summary>QR Decomposition</summary>
 <returns>     QRDecomposition
 </returns>
 <seealso cref="T:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.QRDecomposition">
 </seealso>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.chol">
 <summary>Cholesky Decomposition</summary>
 <returns>     CholeskyDecomposition
 </returns>
 <seealso cref="T:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.CholeskyDecomposition">
 </seealso>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.SVD">
 <summary>Singular Value Decomposition</summary>
 <returns>     SingularValueDecomposition
 </returns>
 <seealso cref="T:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.SingularValueDecomposition">
 </seealso>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.Eigen">
 <summary>Eigenvalue Decomposition</summary>
 <returns>     EigenvalueDecomposition
 </returns>
 <seealso cref="T:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.EigenvalueDecomposition">
 </seealso>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.Solve(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix)">
 <summary>Solve A*X = B</summary>
 <param name="B">   right hand side
 </param>
 <returns>     solution if A is square, least squares solution otherwise
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.SolveTranspose(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix)">
 <summary>Solve X*A = B, which is also A'*X' = B'</summary>
 <param name="B">   right hand side
 </param>
 <returns>     solution if A is square, least squares solution otherwise.
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.Inverse">
 <summary>Matrix inverse or pseudoinverse</summary>
 <returns>     inverse(A) if A is square, pseudoinverse otherwise.
 </returns>
 <remarks>solve identity</remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.Determinant">
 <summary>GeneralMatrix determinant</summary>
 <returns>     determinant
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.Rank">
 <summary>GeneralMatrix rank</summary>
 <returns>     effective numerical rank, obtained from SVD.
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.Condition">
 <summary>Matrix condition (2 norm)</summary>
 <returns>     ratio of largest to smallest singular value.
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.Trace">
 <summary>Matrix trace.</summary>
 <returns>     sum of the diagonal elements.
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.Identity(System.Int32,System.Int32)">
 <summary>Generate identity matrix</summary>
 <param name="m">   Number of rows.
 </param>
 <param name="n">   Number of colums.
 </param>
 <returns>     An m-by-n matrix with ones on the diagonal and zeros elsewhere.
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.Identity(System.Int32)">
 <summary>
 Create [m,m] identity matrix
 </summary>
 <param name="m"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.CheckMatrixDimensions(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix)">
 <summary>Check if size(A) == size(B) *</summary>
 <remarks>
 m == m andalso n == n
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.Dispose">
 <summary>
 Do not make this method virtual.
 A derived class should not be able to override this method.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.Dispose(System.Boolean)">
 <summary>
 Dispose(bool disposing) executes in two distinct scenarios.
 If disposing equals true, the method has been called directly
 or indirectly by a user's code. Managed and unmanaged resources
 can be disposed.
 If disposing equals false, the method has been called by the 
 runtime from inside the finalizer and you should not reference 
 other objects. Only unmanaged resources can be disposed.
 </summary>
 <param name="disposing"></param>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.Finalize">
 <summary>
 This destructor will run only if the Dispose method 
 does not get called.
 It gives your base class the opportunity to finalize.
 Do not provide destructors in types derived from this class.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.Resize(System.Int32,System.Int32)">
 <summary>
 调整矩阵的大小，并保留原有的数据
 </summary>
 <param name="m"></param>
 <param name="n"></param>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.Clone">
 <summary>
 Clone the GeneralMatrix object.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.ArrayPack(System.Boolean)">
 <summary>Copy the internal two-dimensional array.</summary>
 <returns>     Two-dimensional array copy of matrix elements.
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.One(System.Int32,System.Int32)">
 <summary>
 fill numeric value 1 to matrix with dimension size [<paramref name="columnDimension"/> x <paramref name="rowDimension"/>]
 </summary>
 <param name="columnDimension"></param>
 <param name="rowDimension"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.Gauss(System.Int32,System.Int32)">
 <summary>
 create a random matrix with dimension size [<paramref name="columnDimension"/> x <paramref name="rowDimension"/>]
 </summary>
 <param name="columnDimension"></param>
 <param name="rowDimension"></param>
 <returns></returns>
 <remarks>
 element data range that generats inside the matrix is [-1,1]
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.random(System.Int32,System.Int32,System.Double,System.Double)">
 <summary>
 create a random matrix with dimension size [<paramref name="columnDimension"/> x <paramref name="rowDimension"/>]
 </summary>
 <param name="columnDimension"></param>
 <param name="rowDimension"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix.DotProduct(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix)">
 <summary>
 矩阵乘积(matrix product，也叫matmul product)：A 的列数必须和 B 的行数相等
 </summary>
 <param name="B"></param>
 <returns></returns>
</member>
<member name="F:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.SparseMatrix.rows">
 <summary>
 just store the non-zero element index and the element value, all missing index is ZERO
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.SparseMatrix.#ctor(System.Int32,System.Int32)">
 <summary>
 
 </summary>
 <param name="m">nrows</param>
 <param name="n">ncols</param>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.SparseMatrix.Get(System.UInt32,System.UInt32)">
 <summary>
 
 </summary>
 <param name="i"></param>
 <param name="j"></param>
 <returns>
 value of missing index is ZERO
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.SparseMatrix.ArrayPack(System.Boolean)">
 <summary>
 convert to real [m,n] matrix
 </summary>
 <param name="deepcopy"></param>
 <returns>A dense matrix data</returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.SparseMatrix.UnpackData(System.Single[],System.Int32[],System.Int32[],System.Int32)">
 <summary>
 
 </summary>
 <param name="xdata"></param>
 <param name="xindices">
 the corresponding index value of the <paramref name="xdata"/>, this
 vector size of this parameter must be equals to the <paramref name="xdata"/>!
 </param>
 <param name="xindptr"></param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Math.LinearAlgebra.Formula.Factors">
 <summary>
 多项式系数向量
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Math.LinearAlgebra.MultivariatePolynomial">
 <summary>
 多元多项式
 
 ```
 f(x1, x2, x3, ...) = a*x1 + b*x2 + c*x3 + ...
 ```
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.MultivariatePolynomial.Evaluate(System.Double[])">
 <summary>
 sum(x * b) 
 </summary>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Math.LinearAlgebra.Polynomial">
 <summary>
 一元多项式的数据模型
 
 ```
 f(x) = a + bx + cx^2 + dx^3 + ...
 ```
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Math.LinearAlgebra.Polynomial.F(System.Double)">
 <summary>
 f(x)
 </summary>
 <param name="x#"></param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Math.LinearAlgebra.Polynomial.IsLinear">
 <summary>
 Is linear or poly?
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Polynomial.#ctor(System.Double,System.Double)">
 <summary>
 y = a + bx
 </summary>
 <param name="a"></param>
 <param name="b"></param>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Polynomial.Parse(System.String)">
 <summary>
 
 </summary>
 <param name="str">
 a+bx
 y=a+bx
 </param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Math.LinearAlgebra.Solvers.GaussianElimination">
 <summary>
 ### Gaussian elimination
 
 In mathematics, Gaussian elimination, also known as row reduction, is an algorithm 
 for solving systems of linear equations. It consists of a sequence of row-wise 
 operations performed on the corresponding matrix of coefficients. This method can 
 also be used to compute the rank of a matrix, the determinant of a square matrix, 
 and the inverse of an invertible matrix. The method is named after Carl Friedrich 
 Gauss (1777–1855). To perform row reduction on a matrix, one uses a sequence of
 elementary row operations to modify the matrix until the lower left-hand corner of 
 the matrix is filled with zeros, as much as possible. There are three types of 
 elementary row operations:
 
 + Swapping two rows,
 + Multiplying a row by a nonzero number,
 + Adding a multiple Of one row To another row.
 
 Using these operations, a matrix can always be transformed into an upper triangular
 matrix, And In fact one that Is In row echelon form. Once all Of the leading coefficients 
 (the leftmost nonzero entry In Each row) are 1, And every column containing a leading
 coefficient has zeros elsewhere, the matrix Is said To be In reduced row echelon form.
 This final form Is unique; In other words, it Is independent Of the sequence Of row
 operations used. For example, In the following sequence Of row operations (where two 
 elementary operations On different rows are done at the first And third steps), the 
 third And fourth matrices are the ones In row echelon form, And the final matrix Is 
 the unique reduced row echelon form.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Solvers.GaussianElimination.Solve(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix,Microsoft.VisualBasic.Math.LinearAlgebra.Vector)">
 <summary>
 solve a system of equation
 
 ```
 x * A = b
 ```
 </summary>
 <param name="a"></param>
 <param name="b"></param>
 <returns>x</returns>
 <remarks></remarks>
 <example>
 Dim a As New NumericMatrix({
     { 2,  1, -1},
     {-3, -1,  2},
     {-2,  1,  2}
 })
 Dim b As Vector = {8, -11, -3}
 Dim x As Vector = GaussianElimination.Solve(a, b)
 
  2x + y -  z =  8
 -3x - y + 2z = -11
 -2x + y + 2z = -3
 
 ' &lt;dims: 3> [2, 3, -1...]
 Console.WriteLine(x)
 </example>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Solvers.GaussianElimination.UpTri(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix,Microsoft.VisualBasic.Math.LinearAlgebra.Vector)">
 <summary>
 上三角矩阵方程解法
 </summary>
 <param name="A"></param>
 <param name="b"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.Math.LinearAlgebra.Solvers.Solve">
 <summary>
 ``a*b=0 -> x``
 </summary>
 <param name="a"></param>
 <param name="b"></param>
 <returns>x</returns>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.Math.LinearAlgebra.Solvers.PowerMethod">
 <summary>
 Method for finding eigenvectors
 </summary>
 <remarks>
 https://github.com/ValentinDutin/PowerIterationMethod
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Solvers.SOR.Solve(Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.GeneralMatrix,Microsoft.VisualBasic.Math.LinearAlgebra.Vector,System.Double,System.Double,System.Int32)">
 <summary>
 
 </summary>
 <param name="A"></param>
 <param name="b"></param>
 <param name="Omiga">松弛因子</param>
 <param name="e">误差容限</param>
 <param name="Iteration">最大允许迭代次数</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.SVD.SVDecomposition(System.Double[0:,0:],System.Double[]@,System.Double[0:,0:]@)">
 <summary>
 Singular Value Decomposition
 </summary>
 <param name="a">Number of rows in A must be greater or equal to number of columns</param>
 <param name="w"></param>
 <param name="v"></param>
</member>
<member name="F:Microsoft.VisualBasic.Math.LinearAlgebra.Tensor.data">
 <summary>
 the tensor data
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Math.LinearAlgebra.Vector">
 <summary>
 A numeric vector
 </summary>
 <remarks>
 this numeric vector is based on the <see cref="T:Microsoft.VisualBasic.Language.Vectorization.Vector`1"/>
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Vector.Call``1(System.Delegate,Microsoft.VisualBasic.Math.LinearAlgebra.Vector.Argument[])">
 <summary>
 Try to call target <paramref name="method"/> in vector mode.
 </summary>
 <typeparam name="TOut"></typeparam>
 <param name="method">只可以是静态的共享方法</param>
 <param name="args"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Math.LinearAlgebra.Vector.Argument">
 <summary>
 Numeric argument for <see cref="M:Microsoft.VisualBasic.Math.LinearAlgebra.Vector.Call``1(System.Delegate,Microsoft.VisualBasic.Math.LinearAlgebra.Vector.Argument[])"/>
 </summary>
 <remarks>
 ###### 2019-03-07 
 因为这个类的名称会与<see cref="T:Microsoft.VisualBasic.CommandLine.Reflection.ArgumentAttribute"/>产生冲突，所以将这个对象移到内部了
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Vector.Argument.Populate">
 <summary>
 Iterator function
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Vector.Sqrt(Microsoft.VisualBasic.Math.LinearAlgebra.Vector)">
 <summary>
 abs(x) computes the absolute value of x, sqrt(x) computes the (principal) square root of x, √{x}.
 </summary>
 <param name="x">a numeric or complex vector or array.</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Vector.Exp(Microsoft.VisualBasic.Math.LinearAlgebra.Vector)">
 <summary>
 log computes logarithms, by default natural logarithms, log10 computes common (i.e., base 10) logarithms, 
 and log2 computes binary (i.e., base 2) logarithms. 
 The general form log(x, base) computes logarithms with base base.
 log1p(x) computes log(1+x) accurately also for |x| &lt;&lt; 1.
 exp computes the exponential function.
 expm1(x) computes exp(x) - 1 accurately also for |x| &lt;&lt; 1.
 </summary>
 <param name="x">a numeric or complex vector.</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Vector.Exp">
 <summary>
 log computes logarithms, by default natural logarithms, log10 computes common (i.e., base 10) logarithms, 
 and log2 computes binary (i.e., base 2) logarithms. 
 The general form log(x, base) computes logarithms with base base.
 log1p(x) computes log(1+x) accurately also for |x| &lt;&lt; 1.
 exp computes the exponential function.
 expm1(x) computes exp(x) - 1 accurately also for |x| &lt;&lt; 1.
 </summary>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Vector.Quantile(System.Double[])">
 <summary>
 
 </summary>
 <param name="percentage">``[0, 1]``之间</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Vector.Log(Microsoft.VisualBasic.Math.LinearAlgebra.Vector,System.Double)">
 <summary>
 
 </summary>
 <param name="x">a numeric or complex vector.</param>
 <returns></returns>
 <param name="base">a positive or complex number: the base with respect to which logarithms are computed. Defaults to e=exp(1).</param>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Vector.Trunc(Microsoft.VisualBasic.Math.LinearAlgebra.Vector)">
 <summary>
 Rounding of Numbers
 </summary>
 <param name="x"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Vector.BesselI(Microsoft.VisualBasic.Math.LinearAlgebra.Vector,Microsoft.VisualBasic.Math.LinearAlgebra.Vector,System.Boolean)">
 <summary>
 Bessel Functions of integer and fractional order, of first and second kind, J(nu) and Y(nu), 
 and Modified Bessel functions (of first and third kind), I(nu) and K(nu).
 </summary>
 <returns>
 Numeric vector with the (scaled, if expon.scaled = TRUE) values of the corresponding Bessel function.
 The length of the result is the maximum of the lengths of the parameters. All parameters are recycled to that length.
 </returns>
 <remarks></remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Vector.Order(Microsoft.VisualBasic.Math.LinearAlgebra.Vector,System.Boolean,System.Boolean)">
 <summary>
 order returns a permutation which rearranges its first argument into ascending or descending order, 
 breaking ties by further arguments. sort.list is the same, using only one argument.
 </summary>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.Math.LinearAlgebra.Vector.NaN">
 <summary>
 <see cref="F:System.Double.NaN"/>
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Math.LinearAlgebra.Vector.Inf">
 <summary>
 <see cref="F:System.Double.PositiveInfinity"/>
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Math.LinearAlgebra.Vector.Zero(System.Int32)">
 <summary>
 Only one number in the vector and its value is ZERO
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Math.LinearAlgebra.Vector.IsNumeric">
 <summary>
 check of current vector is scalar?
 </summary>
 <returns></returns>
 <remarks>
 <see cref="P:Microsoft.VisualBasic.Math.Scripting.Rscript.GenericVector`1.Dim"/>为1?即当前的向量对象是否是只包含有一个数字？
 </remarks>
</member>
<member name="P:Microsoft.VisualBasic.Math.LinearAlgebra.Vector.IsNaN">
 <summary>
 get NaN elements
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Math.LinearAlgebra.Vector.Item(System.String)">
 <summary>
 
 </summary>
 <param name="rangeExpression"></param>
 <returns></returns>
 <remarks>
 syntax helper
 </remarks>
</member>
<member name="P:Microsoft.VisualBasic.Math.LinearAlgebra.Vector.Mod">
 <summary>
 ``norm2()``
 
 向量模的平方，``||x||``是向量``x=(x1，x2，…，xp)``的欧几里得范数
 </summary>
 <returns></returns>
 <remarks>
 SquaredNorm 平方绝对值的总和
 </remarks>
</member>
<member name="P:Microsoft.VisualBasic.Math.LinearAlgebra.Vector.SumMagnitude">
 <summary>
 ``norm()``
 
 http://math.stackexchange.com/questions/440320/what-is-magnitude-of-sum-of-two-vector
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Math.LinearAlgebra.Vector.Unit">
 <summary>
 normalize
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Math.LinearAlgebra.Vector.Range">
 <summary>
 ``[min, max]``
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Vector.#ctor(System.Int32)">
 <summary>
 Creates vector with <paramref name="m"/> element and init value set to zero
 It creates a double-precision vector of the specified length with each element equal to 0.
 </summary>
 <param name="m"></param>
 <remarks>
 equality to R expression
 
 ```R
 numeric(<paramref name="m"/>)
 ```
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Vector.#ctor">
 <summary>
 创建一个空的向量，包含有零个元素
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Vector.#ctor(System.Collections.Generic.IEnumerable{System.Double})">
 <summary>
 Creates vector with a specific value sequence.
 </summary>
 <param name="data">
 a sequence of numeric value that will fill the vector's 
 data <see cref="F:Microsoft.VisualBasic.Language.Vectorization.Vector`1.buffer"/>.
 </param>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Vector.#ctor(System.Collections.Generic.IEnumerable{System.Single})">
 <summary>
 Creates vector with a specific value sequence
 </summary>
 <param name="shorts"></param>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Vector.#ctor(System.Collections.Generic.IEnumerable{System.Double},System.Func{System.Double,System.Double})">
 <summary>
 Init with transform
 </summary>
 <param name="x"></param>
 <param name="apply"></param>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Vector.#ctor(System.Collections.Generic.IEnumerable{System.Int32})">
 <summary>
 Creates vector with a specific value sequence
 </summary>
 <param name="integers"></param>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Vector.#ctor(System.Double,System.Int32)">
 <summary>
 Creates vector with m element and init value specific by init parameter.
 </summary>
 <param name="init"></param>
 <param name="m"></param>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Vector.#ctor(System.Single[],System.Int32)">
 <summary>
 Creates a vector from a specified array starting at a specified index position.
 </summary>
 <param name="values">
 The values to add to the vector, as an array of objects of type T. 
 The array must contain at least Count elements from the specified 
 index and only the first Count elements are used.
 </param>
 <param name="index">
 The starting index position from which to create the vector.
 </param>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Vector.#ctor(System.Double[],System.Int32,System.Int32)">
 <summary>
 Creates a vector from a specified array starting at a specified index position.
 </summary>
 <param name="values">
 The values to add to the vector, as an array of objects of type T. 
 The array must contain at least Count elements from the specified 
 index and only the first Count elements are used.
 </param>
 <param name="index">
 The starting index position from which to create the vector.
 </param>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Vector.AsDiagonal">
 <summary>
 Convert the vector as the diagonal matrix
 </summary>
 <returns>
 returns a NxN matrix object, N size is equals to the vector dimension size
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Vector.CopyTo(System.Double[]@,System.Int32)">
 <summary>
 Copies the vector instance to a specified destination array starting at a specified index position.
 </summary>
 <param name="destination">The array to receive a copy of the vector values.</param>
 <param name="startIndex">The starting index in destination at which to begin the copy operation.</param>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Vector.CopyTo(System.Int32[],System.Int32)">
 <summary>
 Copies the vector instance to a specified destination array starting at a specified index position.
 </summary>
 <param name="destination">The array to receive a copy of the vector values.</param>
 <param name="startIndex">The starting index in destination at which to begin the copy operation.</param>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Vector.CopyTo(System.Single[],System.Int32)">
 <summary>
 Copies the vector instance to a specified destination array starting at a specified index position.
 </summary>
 <param name="destination">The array to receive a copy of the vector values.</param>
 <param name="startIndex">The starting index in destination at which to begin the copy operation.</param>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Vector.CopyFrom(System.Double[]@,System.Int32,System.Int32)">
 <summary>
 Make data copy from the given <paramref name="source"/> to current vector object
 </summary>
 <param name="source">the source vector data for copy data to current vector</param>
 <param name="startIndex">the start index of the data in current vector</param>
 <param name="count">the number of the data elements copy from the source data</param>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Vector.op_Addition(Microsoft.VisualBasic.Math.LinearAlgebra.Vector,Microsoft.VisualBasic.Math.LinearAlgebra.Vector)">
 <summary>
 两个向量加法算符重载，分量分别相加
 </summary>
 <param name="v1"></param>
 <param name="v2"></param>
 <returns>
 this operator is a safe function: if any one vector is nothing, then returns the copy of another vector directly.
 </returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Vector.op_Subtraction(Microsoft.VisualBasic.Math.LinearAlgebra.Vector,Microsoft.VisualBasic.Math.LinearAlgebra.Vector)">
 <summary>
 向量减法算符重载，分量分别相减
 </summary>
 <param name="v1"></param>
 <param name="v2"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Vector.op_Multiply(Microsoft.VisualBasic.Math.LinearAlgebra.Vector,System.Double[])">
 <summary>
 向量乘法算符重载，分量分别相乘，相当于MATLAB中的``.*``算符
 </summary>
 <param name="v1"></param>
 <param name="v2"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Vector.op_Multiply(Microsoft.VisualBasic.Math.LinearAlgebra.Vector,Microsoft.VisualBasic.Math.LinearAlgebra.Vector)">
 <summary>
 向量乘法算符重载，分量分别相乘，相当于MATLAB中的``.*``算符
 </summary>
 <param name="v1"></param>
 <param name="v2"></param>
 <returns></returns>
 <remarks></remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Vector.op_Division(Microsoft.VisualBasic.Math.LinearAlgebra.Vector,Microsoft.VisualBasic.Math.LinearAlgebra.Vector)">
 <summary>
 向量除法算符重载，分量分别相除，相当于MATLAB中的``./``算符
 </summary>
 <param name="v1"></param>
 <param name="v2"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Vector.op_Addition(Microsoft.VisualBasic.Math.LinearAlgebra.Vector,System.Double)">
 <summary>
 向量减加实数，各分量分别加实数
 </summary>
 <param name="v1"></param>
 <param name="a"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Vector.op_Subtraction(Microsoft.VisualBasic.Math.LinearAlgebra.Vector,System.Double)">
 <summary>
 向量减实数，各分量分别减实数
 </summary>
 <param name="v1"></param>
 <param name="a"></param>
 <returns></returns>
 <remarks></remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Vector.op_Multiply(Microsoft.VisualBasic.Math.LinearAlgebra.Vector,System.Double)">
 <summary>
 向量 数乘，各分量分别乘以实数
 </summary>
 <param name="v1"></param>
 <param name="a"></param>
 <returns></returns>
 <remarks></remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Vector.op_Division(Microsoft.VisualBasic.Math.LinearAlgebra.Vector,System.Double)">
 <summary>
 向量 数除，各分量分别除以实数
 </summary>
 <param name="v1"></param>
 <param name="a"></param>
 <returns></returns>
 <remarks></remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Vector.op_Addition(System.Double,Microsoft.VisualBasic.Math.LinearAlgebra.Vector)">
 <summary>
 实数加向量
 </summary>
 <param name="a"></param>
 <param name="v1"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Vector.op_Subtraction(System.Double,Microsoft.VisualBasic.Math.LinearAlgebra.Vector)">
 <summary>
 实数减向量
 </summary>
 <param name="a"></param>
 <param name="v1"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Vector.op_Multiply(System.Double,Microsoft.VisualBasic.Math.LinearAlgebra.Vector)">
 <summary>
 向量 数乘
 </summary>
 <param name="a"></param>
 <param name="v1"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Vector.op_BitwiseOr(Microsoft.VisualBasic.Math.LinearAlgebra.Vector,Microsoft.VisualBasic.Math.LinearAlgebra.Vector)">
 <summary>
 向量内积
 </summary>
 <param name="v1"></param>
 <param name="v2"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Vector.op_ExclusiveOr(Microsoft.VisualBasic.Math.LinearAlgebra.Vector,Microsoft.VisualBasic.Math.LinearAlgebra.Vector)">
 <summary>
 向量外积（相当于列向量，乘以横向量）
 </summary>
 <param name="v1"></param>
 <param name="v2"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Vector.op_UnaryNegation(Microsoft.VisualBasic.Math.LinearAlgebra.Vector)">
 <summary>
 负向量 
 </summary>
 <param name="v1"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Vector.op_Equality(Microsoft.VisualBasic.Math.LinearAlgebra.Vector,System.Int32)">
 <summary>
 <paramref name="x"/>向量之中的每一个元素是否都等于<paramref name="n"/>?
 </summary>
 <param name="x"></param>
 <param name="n"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Vector.op_Equality(Microsoft.VisualBasic.Math.LinearAlgebra.Vector,System.Double)">
 <summary>
 <paramref name="x"/>向量之中的每一个元素是否都等于<paramref name="n"/>?
 </summary>
 <param name="x"></param>
 <param name="n"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Vector.op_Exponent(Microsoft.VisualBasic.Math.LinearAlgebra.Vector,System.Double)">
 <summary>
 Power: <see cref="M:System.Math.Pow(System.Double,System.Double)"/>
 </summary>
 <param name="v"></param>
 <param name="n"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Vector.op_GreaterThanOrEqual(Microsoft.VisualBasic.Math.LinearAlgebra.Vector,System.Double)">
 <summary>
 返回一个逻辑向量，用来指示向量对象的每一个分量与目标比较的逻辑值结果
 </summary>
 <param name="x"></param>
 <param name="n"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Vector.op_LessThanOrEqual(Microsoft.VisualBasic.Math.LinearAlgebra.Vector,System.Double)">
 <summary>
 x &lt;= n
 </summary>
 <param name="x"></param>
 <param name="n"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Vector.op_Implicit(System.String)~Microsoft.VisualBasic.Math.LinearAlgebra.Vector">
 <summary>
 [1,2,3,4,5,6,...]
 </summary>
 <param name="vector$"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Vector.slice(System.Int32,System.Int32,System.Int32)">
 <summary>
 进行序列切片操作
 </summary>
 <param name="start%"></param>
 <param name="stop%"></param>
 <param name="steps%"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Vector.DotProduct(Microsoft.VisualBasic.Math.LinearAlgebra.Vector)">
 <summary>
 dot
 
 + http://mathworld.wolfram.com/DotProduct.html
 + http://www.mathsisfun.com/algebra/vectors-dot-product.html
 </summary>
 <param name="v2"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Vector.dot(System.Double[]@,System.Double[]@)">
 <summary>
 helper function for vector dot product
 </summary>
 <param name="lhs"></param>
 <param name="rhs"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Vector.dot(System.Single[]@,System.Single[]@)">
 <summary>
 helper function for vector dot product
 </summary>
 <param name="lhs"></param>
 <param name="rhs"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Vector.Product">
 <summary>
 返回这个向量之中的所有的元素的乘积
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Vector.ScaleToRange(Microsoft.VisualBasic.ComponentModel.Ranges.Model.DoubleRange)">
 <summary>
 scale elements in current vector to another value <paramref name="range"/>.
 </summary>
 <param name="range"></param>
 <returns>
 a new data <see cref="T:Microsoft.VisualBasic.Math.LinearAlgebra.Vector"/> which its element value is 
 in range of a given <paramref name="range"/>.
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Vector.ToString">
 <summary>
 Display member's data as json array
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Vector.Order">
 <summary>
 ``order()``的返回值是对应``排名``的元素所在向量中的位置。
 
 ```R
 x &lt;- c(97, 93, 85, 74, 32, 100, 99, 67);
 
 sort(x)
 # [1] 32  67  74  85  93  97  99 100
 order(x)
 # [1] 5 8 4 3 2 1 7 6
 rank(x)
 # [1] 6 5 4 3 1 8 7 2
 ```
 </summary>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Vector.SumMagnitudes(Microsoft.VisualBasic.Math.LinearAlgebra.Vector,Microsoft.VisualBasic.Math.LinearAlgebra.Vector)">
 <summary>
 http://math.stackexchange.com/questions/440320/what-is-magnitude-of-sum-of-two-vector
 </summary>
 <param name="x1"></param>
 <param name="x2"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Vector.Ones(System.Int32)">
 <summary>
 Returns a numeric vector with all elements is value ``1``
 </summary>
 <param name="n"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Vector.rand(System.Int32)">
 <summary>
 
 </summary>
 <param name="size%"></param>
 <returns></returns>
 <remarks>
 this method can be affected by the <see cref="M:Microsoft.VisualBasic.Math.RandomExtensions.SetSeed(System.Int32)"/> method.
 </remarks> 

</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Vector.norm(System.Int32,System.Double,System.Double)">
 <summary>
 create a vector that contains the random number from the gaussian distribution
 </summary>
 <param name="size"></param>
 <param name="mu"></param>
 <param name="sigma"></param>
 <returns></returns>
 <remarks>
 gaussian number generated via the <see cref="M:Microsoft.VisualBasic.Math.RandomExtensions.NextGaussian(System.Double,System.Double)"/> method.
 </remarks>
</member>
<member name="T:Microsoft.VisualBasic.Math.LinearAlgebra.HalfVector">
 <summary>
 精度比较低的半精度向量
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Math.LinearAlgebra.SparseVector">
 <summary>
 稀疏的向量
 </summary>
 <remarks>
 在这个向量中存在大量的零，主要适用于节省计算内存
 因为有<see cref="F:Microsoft.VisualBasic.Math.LinearAlgebra.SparseVector.buffer"/>索引的存在，所以假若零数值比较少的话，
 使用这个稀疏向量来存储数据反而会导致内存被过度占用
 </remarks>
 
</member>
<member name="F:Microsoft.VisualBasic.Math.LinearAlgebra.SparseVector.buffer">
 <summary>
 非零值的索引号和对应的值
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Math.LinearAlgebra.SparseVector.dimension">
 <summary>
 这个向量的虚拟长度
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Math.LinearAlgebra.SparseVector.Length">
 <summary>
 返回这个向量的虚拟长度
 </summary>
 <returns></returns>
 <remarks>
 请注意，由于buffer对象记录的是非零元素的数据记录集合，所以其元素计数并不是当前
 的这个向量对象的真实长度，<see cref="F:Microsoft.VisualBasic.Math.LinearAlgebra.SparseVector.dimension"/>的值是真实的长度
 </remarks>
</member>
<member name="P:Microsoft.VisualBasic.Math.LinearAlgebra.SparseVector.Dim">
 <summary>
 返回这个向量的虚拟长度
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Math.LinearAlgebra.SparseVector.Values">
 <summary>
 返回所有的非零元素
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Math.LinearAlgebra.SparseVector.Data">
 <summary>
 returns all data values in current vector object.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Math.LinearAlgebra.SparseVector.Item(System.Int32)">
 <summary>
 Get/Set value by index access
 </summary>
 <param name="index"></param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Math.LinearAlgebra.SparseVector.Precision">
 <summary>
 All of the element its ABS value less than this precision threshold will be treated as ZERO value
 So the larger of this threshold value, the lower precision precision of all of the math algorithm
 that related to this <see cref="T:Microsoft.VisualBasic.Math.LinearAlgebra.SparseVector"/>.
 
 (当元素的绝对值小于这个值之后就会被当作为零，可以根据情况来设置这个公用属性来控制稀疏向量的计算精度)
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.SparseVector.#ctor(System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Int32},System.Int32)">
 <summary>
 
 </summary>
 <param name="data">非零元素值列表</param>
 <param name="index">非零元素对应的索引编号</param>
 <param name="length">
 因为存在大量零，数组中并不是存储真实的数据，而是非零值，所以在这里必须要有一个长度来标记出当前的这个向量的长度
 </param>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.SparseVector.#ctor(System.Collections.Generic.IEnumerable{System.Double})">
 <summary>
 create a new sparse compact numeric vector from the given raw data
 </summary>
 <param name="data">
 the given raw data
 </param>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.SparseVector.Sum">
 <summary>
 
 </summary>
 <returns></returns>
 <remarks>
 忽略掉所有的零值
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.SparseVector.GetEnumerator">
 <summary>
 这个枚举器函数会枚举出所有的元素，包括非零元素以及值等于零的元素
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Extensions.Points(Microsoft.VisualBasic.Math.LinearAlgebra.Vector,Microsoft.VisualBasic.Math.LinearAlgebra.Vector)">
 <summary>
 Populate points from two <see cref="T:Microsoft.VisualBasic.Math.LinearAlgebra.Vector"/>.
 </summary>
 <param name="x"></param>
 <param name="y"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Extensions.Point2D(System.ValueTuple{Microsoft.VisualBasic.Math.LinearAlgebra.Vector,Microsoft.VisualBasic.Math.LinearAlgebra.Vector})">
 <summary>
 iterates a set of point from the given vector tuple
 </summary>
 <param name="polygon">
 two vector should be in size equals
 </param>
 <returns>
 a set of the point data in float data type
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Extensions.Top(Microsoft.VisualBasic.Math.LinearAlgebra.Vector,System.Int32)">
 <summary>
 Check of the elements of the vector inside the top n elements?
 </summary>
 <param name="vector"></param>
 <param name="n"></param>
 <returns>a logical vector that indicates that each corresponding element is inside the top n elements?</returns>
 <remarks>
 this function will create the top n element index, and then
 check of the each vector elements that existed inside the
 top n element index or not?
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Extensions.Take(Microsoft.VisualBasic.Math.LinearAlgebra.Vector,System.Collections.Generic.IEnumerable{System.Int32})">
 <summary>
 Simplified (numPy) take method: 1) axis is always 0, 2) first argument is always a vector
 </summary>
 <param name="v">List of values</param>
 <param name="indices">List of indices</param>
 <returns>Vector containing elements from vector 1 at the indicies in vector 2</returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Extensions.rand(System.Int32,Microsoft.VisualBasic.ComponentModel.Ranges.Model.DoubleRange)">
 <summary>
 默认返回目标长度的``[0-1]``之间的随机数向量
 </summary>
 <param name="size">the length of the result vector, or n lements</param>
 <returns></returns>
 <remarks>
 this method can be affected by the <see cref="M:Microsoft.VisualBasic.Math.RandomExtensions.SetSeed(System.Int32)"/> method.
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.Extensions.rand(Microsoft.VisualBasic.ComponentModel.Ranges.Model.DoubleRange,System.Int32)">
 <summary>
 获取一个指定长度的由目标区间范围内的随机数所构成的向量
 </summary>
 <param name="range"></param>
 <param name="size%">函数所返回的向量的长度</param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Math.LinearAlgebra.NumericsVector">
 <summary>
 Numerics vector converts for numeric types like:
 <see cref="T:System.Int32"/>, <see cref="T:System.Int64"/>, <see cref="T:System.UInt64"/>, <see cref="T:System.Byte"/>, <see cref="T:System.Single"/>
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.NumericsVector.AsVector``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>
 Convert the numeric collection as a math vector
 </summary>
 <typeparam name="T">
 should be a numeric type
 </typeparam>
 <param name="source"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.NumericsVector.AsInteger(Microsoft.VisualBasic.Math.LinearAlgebra.Vector)">
 <summary>
 numeric to integer values
 </summary>
 <param name="vector"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.NumericsVector.AsLong(Microsoft.VisualBasic.Math.LinearAlgebra.Vector)">
 <summary>
 A helper function for cast current <see cref="T:Microsoft.VisualBasic.Math.LinearAlgebra.Vector"/> as a numeric array in <see cref="T:System.Int64"/> type.
 </summary>
 <param name="vector"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.NumericsVector.AsSingle(Microsoft.VisualBasic.Math.LinearAlgebra.Vector)">
 <summary>
 A helper function for cast current <see cref="T:Microsoft.VisualBasic.Math.LinearAlgebra.Vector"/> as a numeric array in <see cref="T:System.Single"/> type.
 </summary>
 <param name="vector"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.NumericsVector.AsUInteger(Microsoft.VisualBasic.Math.LinearAlgebra.Vector)">
 <summary>
 A helper function for cast current <see cref="T:Microsoft.VisualBasic.Math.LinearAlgebra.Vector"/> as a numeric array in <see cref="T:System.UInt32"/> type.
 </summary>
 <param name="vector"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.NumericsVector.AsULong(Microsoft.VisualBasic.Math.LinearAlgebra.Vector)">
 <summary>
 A helper function for cast current <see cref="T:Microsoft.VisualBasic.Math.LinearAlgebra.Vector"/> as a numeric array in <see cref="T:System.UInt64"/> type.
 </summary>
 <param name="vector"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.NumericsVector.AsUShort(Microsoft.VisualBasic.Math.LinearAlgebra.Vector)">
 <summary>
 A helper function for cast current <see cref="T:Microsoft.VisualBasic.Math.LinearAlgebra.Vector"/> as a numeric array in <see cref="T:System.UInt16"/> type.
 </summary>
 <param name="vector"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Math.LinearAlgebra.VectorEqualityComparer">
 <summary>
 Determine that the two vector are equals to each other.
 </summary>
 <remarks>单实例模式？？</remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.VectorEqualityComparer.VectorEqualsToAnother(System.Collections.Generic.List{System.Double},System.Collections.Generic.List{System.Double})">
 <summary>
 Sequence Equals
 </summary>
 <param name="list1"></param>
 <param name="list2"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.LinearAlgebra.VectorEqualityComparer.GetHashCode(Microsoft.VisualBasic.Math.LinearAlgebra.Vector)">
 <summary>
 Sum all elements' hashcode 
 </summary>
 <param name="v"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Distributions.Abundance.RelativeAbundances``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>
 x除以最大的值就是相对丰度
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Distributions.Abundance.Skewness(System.Collections.Generic.IEnumerable{System.Double},Microsoft.VisualBasic.Math.Distributions.Abundance.AlgorithmType)">
 <summary>
 **Skewness**
 
 Skewness is a fundamental statistical measure used to describe the asymmetry of the probability distribution of a 
 real-valued random variable. It provides insights into the direction and extent of the deviation from a symmetric 
 distribution.
 
 ### Key Aspects of Skewness:
 
 1. **Definition**:
 
    - Skewness is the third standardized moment of a distribution.
    - It is calculated as the average of the cubed deviations of the data from its mean, standardized by the standard deviation raised to the third power.
    
 2. **Types of Skewness**:
 
    - **Zero Skewness**: Indicates a symmetric distribution where the mean, median, and mode are all equal.
    - **Positive Skewness (Right-Skewed)**: The tail on the right side of the distribution is longer or fatter. In this case, the mean is greater than the median.
    - **Negative Skewness (Left-Skewed)**: The tail on the left side of the distribution is longer or fatter. Here, the mean is less than the median.
    
 3. **Interpretation**:
 
    - Skewness values close to zero suggest a nearly symmetric distribution.
    - Positive values indicate right-skewed distributions, while negative values indicate left-skewed distributions.
    - The magnitude of the skewness value reflects the degree of asymmetry.
    
 4. **Applications**:
 
    - **Finance**: Used to analyze the distribution of returns on investments, helping investors understand the potential for extreme outcomes.
    - **Economics**: Assists in examining income distributions, enabling economists to assess income inequality.
    - **Natural Sciences**: Describes the distribution of experimental data in scientific research.
    
 5. **Considerations**:
 
    - Skewness is just one aspect of distribution shape and should be considered alongside other statistical measures like kurtosis for a comprehensive understanding.
    - For small sample sizes, the estimation of skewness can be unreliable.
    
 In essence, skewness is a statistical tool for understanding the asymmetry of data distributions, 
 with wide-ranging applications in various fields such as finance, economics, and the natural 
 sciences.
 
 </summary>
 <remarks>
 If x contains missings and these are not removed, the skewness is NA.
 Otherwise, write xi for the non-missing elements of x, n for their number, μ for their mean, s for their standard deviation, and 
 mr =∑i (xi −μ) ^ r /n for the sample moments of order r.

 Joanes and Gill (1998) discuss three methods for estimating skewness:

 Type 1: g1 = m3 / m2 ^ (3/2). This is the typical definition used in many older textbooks.
 Type 2: G1 = g1 * sqrt(n(n−1)) /(n−2). Used in SAS and SPSS.
 Type 3: b1 = m3 /s^3 = g1 * ((n−1)/n) ^ (3/2) . Used in MINITAB and BMDP.

 All three skewness measures are unbiased under normality.
 </remarks>
</member>
<member name="T:Microsoft.VisualBasic.Math.Distributions.Abundance.AlgorithmType">
 <summary>
 the algorithms for computing kurtosis/skewness
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Math.Distributions.Abundance.AlgorithmType.Classical">
 <summary>
 This is the typical definition used in many older textbooks.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Math.Distributions.Abundance.AlgorithmType.SAS">
 <summary>
 Used in SAS and SPSS.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Math.Distributions.Abundance.AlgorithmType.MINITAB">
 <summary>
 Used in MINITAB and BMDP.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.Distributions.Abundance.Kurtosis(System.Collections.Generic.IEnumerable{System.Double},Microsoft.VisualBasic.Math.Distributions.Abundance.AlgorithmType)">
 <summary>
 **Kurtosis** is a statistical measure that describes the "tailedness" of the probability distribution of a
 real-valued random variable. In simpler terms, it indicates the extent to which the tails of the distribution 
 differ from those of a normal distribution.
 
 ### Key Points about Kurtosis:
 
 1. **Definition**:
 
    - Kurtosis is the fourth standardized moment of a distribution.
    - It is calculated as the average of the squared deviations of the data from its mean, raised to the fourth power, standardized by the standard deviation raised to the fourth power.
    
 2. **Types of Kurtosis**:
 
    - **Mesokurtic**: Distributions with kurtosis similar to that of the normal distribution (kurtosis value of 3). The tails of a mesokurtic distribution are neither particularly fat nor particularly thin.
    - **Leptokurtic**: Distributions with positive kurtosis greater than 3. These distributions have "fat tails" and a sharp peak, indicating more frequent large deviations from the mean than a normal distribution.
    - **Platykurtic**: Distributions with kurtosis less than 3. These distributions have "thin tails" and a flatter peak, indicating fewer large deviations from the mean than a normal distribution.
    
 3. **Excess Kurtosis**:
 
    - Often, kurtosis is reported as "excess kurtosis," which is the kurtosis value minus 3. This adjustment makes the kurtosis of a normal distribution equal to 0.
    - Positive excess kurtosis indicates a leptokurtic distribution, while negative excess kurtosis indicates a platykurtic distribution.
    
 4. **Interpretation**:
 
    - High kurtosis in a data set is an indicator that data has heavy tails or outliers. This can affect the performance of statistical models and methods that assume normality.
    - Low kurtosis indicates that the data has light tails and lacks outliers.
    
 5. **Applications**:
 
    - In finance, kurtosis is used to describe the distribution of returns of an investment. A high kurtosis indicates a higher risk of extreme returns.
    - In data analysis, kurtosis helps in understanding the shape of the data distribution and identifying potential outliers.
    
 6. **Calculation in R**:
 
    - The `kurtosis()` function in the `e1071` package can be used to calculate kurtosis in R.
    - Alternatively, kurtosis can be calculated manually using the formula:
    
 ```R
 kurtosis &lt;- sum((data - mean(data))^4) / ((length(data) - 1) * sd(data)^4) - 3
 ```
 
 kurtosis is a statistical measure for understanding the shape of a data distribution, particularly the behavior 
 of its tails. It is widely used in various fields, including finance, data analysis, and statistics.
 </summary>
 <remarks>
 If x contains missings and these are not removed, the kurtosis is NA.

 Otherwise, write xi for the non-missing elements of x, n for their number, μ for their mean, s for their standard deviation, and 
 mr = ∑i (xi −μ) ^ r /n for the sample moments of order r.

 Joanes and Gill (1998) discuss three methods for estimating kurtosis:

 Type 1: g2 = m4/m2 ^ 2 −3. This is the typical definition used in many older textbooks.
 Type 2: G2 = ((n+1)*g2 +6)∗(n−1)/((n−2)(n−3)). Used in SAS and SPSS.
 Type 3: b2 = m4 /s ^ 4 −3 = (g2 +3)(1−1/n) ^ 2 −3. Used in MINITAB and BMDP.

 Only G2 (corresponding to type = 2) is unbiased under normality.
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.Distributions.AxisDensity.MAD(Microsoft.VisualBasic.Math.LinearAlgebra.Vector)">
 <summary>
 MAD（Median Absolute Deviation，中位数绝对偏差）是一种鲁棒的统计量，用于衡量单变量数据的离散程度。其核心思想是通过中位数计算偏差，避免异常值对结果的影响。数学定义为：
 
 ```
 MAD=median(∣Xi−median(X)∣)
 ```
 
 其中 X表示基因在所有样本中的表达值向量，Xi为单个样本的表达值，median(X)是基因表达值的中位数。
 与标准差不同，MAD使用中位数而非均值，因此不受极端值干扰。例如，若某基因在多数样本中表达稳定，但个别样本异常高/低，标准差会显著增大，而MAD几乎不变。
 
 WGCNA等共表达网络分析中，需筛选高变异基因（如取MAD值最高的前5000个基因）。高MAD值表明基因表达在样本间波动大，可能具有生物学意义（如调控关键通路）。
 </summary>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Math.Distributions.Beta">
 <summary>
 Beta distribution
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.Distributions.Beta.beta(System.Double,System.Double,System.Double)">
 <summary>
 Beta PDF
 </summary>
 <param name="x#"></param>
 <param name="alpha#"></param>
 <param name="_beta#"></param>
 <returns></returns>
 <remarks>
 https://github.com/drbenmorgan/CLHEP/blob/master/GenericFunctions/src/BetaDistribution.cc
 
 2016-10-22
 beta distribution function test success!
 </remarks>
</member>
<member name="F:Microsoft.VisualBasic.Math.Distributions.BinBox.BinMaps.Mean">
 <summary>
 均值
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Math.Distributions.BinBox.BinMaps.Median">
 <summary>
 中位数
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Math.Distributions.BinBox.BinMaps.Boundary">
 <summary>
 边界值
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Math.Distributions.BinBox.CutBins">
 <summary>
 进行数据分箱操作
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.Distributions.BinBox.CutBins.FixedWidthBins(System.Collections.Generic.IEnumerable{System.Double},System.Int32)">
 <summary>
 ### 数据等宽分箱
 
 将变量的取值范围分为<paramref name="k"/>个等宽的区间，每个区间当作一个分箱。
 </summary>
 <param name="data"></param>
 <returns></returns>
 <remarks>
 宽度是自动计算的
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.Distributions.BinBox.CutBins.FixedWidthBins(System.Collections.Generic.IEnumerable{System.Single},System.Int32)">
 <summary>
 ### 数据等宽分箱
 
 将变量的取值范围分为<paramref name="k"/>个等宽的区间，每个区间当作一个分箱。
 </summary>
 <param name="data"></param>
 <returns></returns>
 <remarks>
 宽度是自动计算的
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.Distributions.BinBox.CutBins.FixedWidthBins``1(System.Collections.Generic.IEnumerable{``0},System.Int32,Microsoft.VisualBasic.Math.Evaluate{``0},System.Double,Microsoft.VisualBasic.ComponentModel.Ranges.Model.DoubleRange,System.Boolean)">
 <summary>
 ### 数据等宽分箱
 
 将变量的取值范围分为<paramref name="k"/>个等宽的区间，每个区间当作一个分箱。
 </summary>
 <param name="data"></param>
 <param name="allow_empty">
 this function will just returns an empty collection of the data bin box if the given 
 data collection is empty and also this parameter is set to TRUE.
 </param>
 <returns></returns>
 <remarks>
 宽度是自动计算的
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.Distributions.BinBox.CutBins.FixedWidthBins``1(System.Collections.Generic.IEnumerable{``0},System.Double,Microsoft.VisualBasic.ComponentModel.Ranges.Model.DoubleRange,Microsoft.VisualBasic.Math.Evaluate{``0})">
 <summary>
 ### 数据等宽分箱
 
 将变量按照给定的值域宽度分为多个区间
 </summary>
 <typeparam name="T"></typeparam>
 <param name="v"></param>
 <param name="width">所给定的区间宽度</param>
 <param name="eval"></param>
 <returns></returns>
 <remarks>
 宽度是手工指定的
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.Distributions.BinBox.CutBins.FixedWidthBins``1(``0[],System.Double,Microsoft.VisualBasic.Math.Evaluate{``0},System.Double,System.Double,System.Double)">
 <summary>
 ### 数据等宽分箱
 
 将变量按照给定的值域宽度分为多个区间
 </summary>
 <typeparam name="T"></typeparam>
 <param name="v"></param>
 <param name="width">所给定的区间宽度</param>
 <param name="eval"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Distributions.BinBox.CutBins.EqualFrequencyBins``1(System.Collections.Generic.IEnumerable{``0},System.Int32,Microsoft.VisualBasic.Math.Evaluate{``0})">
 <summary>
 等频分箱，每一个bin之中的元素数目相等
 </summary>
 <param name="data"></param>
 <param name="k">得到K个bin</param>
 <returns></returns>
 
</member>
<member name="T:Microsoft.VisualBasic.Math.Distributions.BinBox.DataBinBox`1">
 <summary>
 数据分箱之中的一个bucket
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Math.Distributions.BinBox.DataBinBox`1.Raw">
 <summary>
 get the raw data points in current data bin box.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Distributions.BinBox.DataBinBox`1.GetBinMaps(System.Collections.Generic.IEnumerable{`0},Microsoft.VisualBasic.Math.Distributions.BinBox.BinMaps,Microsoft.VisualBasic.Math.Evaluate{`0})">
 <summary>
 将当前的区间内的对象序列映射为一段实数序列
 </summary>
 <param name="data"></param>
 <param name="method"></param>
 <param name="eval"></param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Math.Distributions.BinBox.Violin.range">
 <summary>
 upper and lower bound range of the plot
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Distributions.BinBox.Violin.ViolinDensity(System.Int32)">
 <summary>
 generates the plot data
 </summary>
 <param name="nPoints"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Distributions.BinBox.Violin.Bandwidth">
 <summary>
 Silverman带宽计算法则
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.Distributions.BinBox.Violin.KDE(System.Double[],System.Double)">
 <summary>
 计算核密度估计
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Math.Distributions.Bootstraping">
 <summary>
 Data sampling bootstrapping extensions
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.Distributions.Bootstraping.Sample(System.Int32)">
 <summary>
 Generate a numeric <see cref="T:Microsoft.VisualBasic.Math.LinearAlgebra.Vector"/> by <see cref="M:Microsoft.VisualBasic.Math.RandomExtensions.Permutation(System.Random,System.Int32,System.Int32)"/> <paramref name="x"/> times.
 </summary>
 <param name="x%"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Math.Distributions.Bootstraping.Samples``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Int32,System.Boolean)">
 <summary>
 bootstrap是一种非参数估计方法，它用到蒙特卡洛方法。bootstrap算法如下：
 假设样本容量为N

 + 有放回的从样本中随机抽取N次(所以可能x1..xn中有的值会被抽取多次)，每次抽取一个元素。并将抽到的元素放到集合S中；
 + 重复**步骤1** B次（例如``B = 100``）， 得到B个集合， 记作S1, S2,…, SB;
 + 对每个``Si(i=1, 2, ..., B)``，用蒙特卡洛方法估计随机变量的数字特征d，分别记作d1,d2,…,dB;
 + 用d1,d2,…dB来近似d的分布；
 
 本质上，bootstrap算法是最大似然估计的一种实现，它和最大似然估计相比的优点在于，它不需要用参数来刻画总体分布。
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source">总体样本</param>
 <param name="N">每一个样本的大小，即在每一个袋子中有多少个样本元素</param>
 <param name="bags">采样的次数，这个函数返回多少个袋子集合？</param>
 <param name="replace">
 是否为有放回的进行抽样？默认是有放回的。设置这个参数为False表示不重复的采样，即抽取过后的元素将不会再出现在后面的采样结果之中
 </param>
 <returns>
 index of the returns value <see cref="P:Microsoft.VisualBasic.Linq.SeqValue`1.i"/> is zero based.
 </returns>
 <remarks>
 this method can be affected by the <see cref="M:Microsoft.VisualBasic.Math.RandomExtensions.SetSeed(System.Int32)"/> method.
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.Distributions.Bootstraping.Sample``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Boolean)">
 <summary>
 bootstrap sampling of given source collection
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <param name="N"></param>
 <param name="replace"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Distributions.Bootstraping.GetBagSample``1(``0[],System.Int32,Microsoft.VisualBasic.Language.List{System.Int32},System.Boolean)">
 <summary>
 
 </summary>
 <typeparam name="T"></typeparam>
 <param name="pool"></param>
 <param name="N"></param>
 <param name="index"></param>
 <param name="replace">
 if replace, then each bag sample may contains duplicated element
 else, each of the data element in one bag sample is unique.
 </param>
 <returns></returns>
 <remarks>
 this method can be affected by the <see cref="M:Microsoft.VisualBasic.Math.RandomExtensions.SetSeed(System.Int32)"/> method.
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.Distributions.Bootstraping.Distributes(System.Collections.Generic.IEnumerable{System.Double},System.Single)">
 <summary>
 ###### 频数分布表与直方图
 
 返回来的标签数据之中的标签是在某个区间范围内的数值集合的平均值
 </summary>
 <param name="data"></param>
 <param name="base"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Distributions.Bootstraping.Hist(System.Double[],System.Single,System.Nullable{System.Double},System.Nullable{System.Double})">
 <summary>
 ###### 频数分布表与直方图
 
 这个函数返回来的是频数以及区间内的所有的数的平均值
 </summary>
 <param name="data"></param>
 <param name="step!"></param>
 <returns>
 返回来的数据为区间的下限 -> {频数, 平均值}
 </returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Math.Distributions.Bootstraping.TabulateBin(System.Collections.Generic.IEnumerable{System.Double},System.Boolean,System.Int32)">
 <summary>
 Find top frequency binbox
 </summary>
 <param name="data"></param>
 <param name="topBin"></param>
 <param name="bags">binbox number of the fix width cut bins method</param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Math.Distributions.DirichletDistribution">
 <summary>
 Dirichlet distribution
 
 In probability and statistics, the Dirichlet distribution (after Peter Gustav Lejeune Dirichlet), often denoted 
 {\displaystyle \operatorname {Dir} ({\boldsymbol {\alpha }})} \operatorname {Dir} ({\boldsymbol {\alpha }}), is 
 a family of continuous multivariate probability distributions parameterized by a vector 
 {\displaystyle {\boldsymbol {\alpha }}} {\boldsymbol {\alpha }} of positive reals. 
 It is a multivariate generalization of the beta distribution.[1] Dirichlet distributions are very often used as 
 prior distributions in Bayesian statistics, and in fact the Dirichlet distribution is the conjugate prior of the 
 categorical distribution and multinomial distribution.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.Distributions.DirichletDistribution.lgamma(System.Double)">
 <summary>
 see http://www.machinedlearnings.com/2011/06/faster-lda.html
 </summary>
 <param name="x"></param>
 <returns></returns>
 <remarks>Works fun with function <see cref="M:Microsoft.VisualBasic.Math.Distributions.Beta.beta(System.Double,System.Double,System.Double)"/></remarks>
</member>
<member name="T:Microsoft.VisualBasic.Math.Distributions.ECDF">
 <summary>
 #### Empirical distribution function
 
 In statistics, an empirical distribution function (commonly also called 
 an empirical cumulative distribution function, eCDF) is the distribution
 function associated with the empirical measure of a sample. This cumulative
 distribution function is a step function that jumps up by 1/n at each of
 the n data points. Its value at any specified value of the measured 
 variable is the fraction of observations of the measured variable that 
 are less than or equal to the specified value.

 The empirical distribution Function Is an estimate Of the cumulative 
 distribution Function that generated the points In the sample. It converges 
 With probability 1 To that underlying distribution, according To the 
 Glivenko–Cantelli theorem. A number Of results exist To quantify the rate 
 Of convergence Of the empirical distribution Function To the underlying
 cumulative distribution Function.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Math.Distributions.ECDF.X">
 <summary>
 the input x vector data
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Distributions.ECDF.FindThreshold(System.Double,System.Double)">
 <summary>
 
 </summary>
 <param name="q"></param>
 <param name="eps"></param>
 <returns>
 the upper bound raw value of the threshold
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Distributions.ECDF.CDF(System.Collections.Generic.IEnumerable{Microsoft.VisualBasic.Math.Distributions.BinBox.DataBinBox{System.Double}},System.Int32)">
 <summary>
 T computation involves the cumulative distributive
 function p(k)(CDF), defined As
 
 ```
 q ~ p(k) = sum(h(i)) / N
 ```

 h(i) stands For the i bin's frequency within an image 
 histogram, N is the image’s pixel count. Given a target 
 probability q it Is possible to find the bin k whose 
 CDF closely resembles q. Then, the upper limit Of the 
 bin k In h will be used As the threshold value T.
 </summary>
 <param name="bin"></param>
 <param name="N"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Math.Distributions.MathGamma">
 <summary>
 gamma function (Γ) from mathematics
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.Distributions.MathGamma.lngamm(System.Double)">
 <summary>
 Reference: "Lanczos, C. 'A precision approximation
 of the gamma function', J. SIAM Numer. Anal., B, 1, 86-96, 1964."
 Translation of  Alan Miller's FORTRAN-implementation
 See http://lib.stat.cmu.edu/apstat/245
 </summary>
 <param name="Z"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Distributions.MathGamma.lngamma(System.Double)">
 <summary>
 Spouge approximation (suitable for large arguments)
 </summary>
 <param name="z"></param>
 <returns></returns>
 <remarks>
 http://lib.stat.cmu.edu/apstat/245
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.Distributions.MathGamma.Γ(System.Double)">
 <summary>
 gamma function ``Γ`` from mathematics
 </summary>
 <param name="x"></param>
 <returns></returns>
 <remarks>
 Alias for <see cref="M:Microsoft.VisualBasic.Math.Distributions.MathGamma.gamma(Microsoft.VisualBasic.Math.LinearAlgebra.Vector)"/>
 
 Test:
 
 ```
 > var gamma = require('gamma')
 > gamma(5)
 23.999999999999996
 > gamma(1.6)
 0.8935153492876909
 ```
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.Distributions.MathGamma.gamma(System.Double)">
 <summary>
 Γ
 </summary>
 <param name="z"></param>
 <returns></returns>
 
</member>
<member name="T:Microsoft.VisualBasic.Math.Distributions.Gaussian">
 <summary>
 ##### Gaussian function
 
 https://en.wikipedia.org/wiki/Gaussian_function
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.Distributions.Gaussian.Gaussian(System.Double,System.Double,System.Double,System.Double)">
 <summary>
 
 </summary>
 <param name="x"></param>
 <param name="A">is the height of the curve's peak</param>
 <param name="mu">is the position of the center of the peak</param>
 <param name="sigma">(the standard deviation, sometimes called the Gaussian RMS width) 
 controls the width of the "bell"</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Distributions.Gaussian.StandadizedGaussianFunction(System.Double,System.Double)">
 <summary>
 the Gaussian Kernel
 </summary>
 <param name="diff"></param>
 <param name="devi">
 the bandwidth
 </param>
 <returns></returns>
 <remarks>
 高斯核函数
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.Distributions.Gaussian.rnorm(System.Int32,System.Double,System.Double)">
 <summary>
 Returns a vector with specific parameters normal distribution of length n elements.
 Distribution data was generated by the n length random seeds as the normal distribution 
 inputs.
 </summary>
 <param name="n"></param>
 <param name="m"></param>
 <param name="sd"></param>
 <returns></returns>
 
</member>
<member name="T:Microsoft.VisualBasic.Math.Distributions.pnorm">
 <summary>
 正态分布帮助模块
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.Distributions.pnorm.Z(System.Double,System.Double,System.Double)">
 <summary>
 ###### Z-score 标准化(zero-mean normalization)
 
 也叫标准差标准化，经过处理的数据符合标准正态分布，即均值为0，标准差为1
 其中<paramref name="μ"/>为所有样本数据的均值，<paramref name="σ"/>为所有样本数据的标准差。
 </summary>
 <param name="x#">Sample data</param>
 <param name="μ#">μ is the mean of the population.</param>
 <param name="σ#">σ is the standard deviation of the population.</param>
 <returns></returns>
 <remarks>
 注：是否要进行标准化，要根据具体实验定。如果特征非常稀疏，并且有大量的0（现实应用中很多特征都具有这个特点），
 ``Z-score`` 标准化的过程几乎就是一个除0的过程，结果不可预料。
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.Distributions.pnorm.Z(Microsoft.VisualBasic.Math.LinearAlgebra.Vector)">
 <summary>
 ## Standard score(z-score)
 
 In statistics, the standard score is the signed number of standard deviations by which the value of 
 an observation or data point is above the mean value of what is being observed or measured. Observed 
 values above the mean have positive standard scores, while values below the mean have negative 
 standard scores. The standard score is a dimensionless quantity obtained by subtracting the population 
 mean from an individual raw score and then dividing the difference by the population standard deviation. 
 This conversion process is called standardizing or normalizing (however, "normalizing" can refer to 
 many types of ratios; see normalization for more).
 
 > https://en.wikipedia.org/wiki/Standard_score
 </summary>
 <param name="x"></param>
 <returns></returns>
 <remarks>
 http://blog.163.com/huai_jing@126/blog/static/171861983201321074124426/
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.Distributions.pnorm.Z(System.Double[])">
 <summary>
 ## Standard score(z-score)
 
 In statistics, the standard score is the signed number of standard deviations by which the value of 
 an observation or data point is above the mean value of what is being observed or measured. Observed 
 values above the mean have positive standard scores, while values below the mean have negative 
 standard scores. The standard score is a dimensionless quantity obtained by subtracting the population 
 mean from an individual raw score and then dividing the difference by the population standard deviation. 
 This conversion process is called standardizing or normalizing (however, "normalizing" can refer to 
 many types of ratios; see normalization for more).
 
 > https://en.wikipedia.org/wiki/Standard_score
 </summary>
 <param name="x"></param>
 <returns></returns>
 <remarks>
 http://blog.163.com/huai_jing@126/blog/static/171861983201321074124426/
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.Distributions.pnorm.Logistic(System.Double,System.Double,System.Double,System.Double)">
 <summary>
 A logistic function or logistic curve is a common "S" shape (sigmoid curve)
 > https://en.wikipedia.org/wiki/Logistic_function
 </summary>
 <param name="L#">the curve's maximum value</param>
 <param name="x#">current x value</param>
 <param name="x0#">the x-value of the sigmoid's midpoint,</param>
 <param name="k#">the steepness of the curve.</param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Math.Distributions.pnorm.DeviationStandardization(Microsoft.VisualBasic.Math.LinearAlgebra.Vector)">
 <summary>
 ###### 0-1标准化(0-1 normalization)
 也叫离差标准化，是对原始数据的线性变换，使结果落到[0,1]区间
 其中max为样本数据的最大值，min为样本数据的最小值。这种方法有一个缺陷就是当有新数据加入时，可能导致max和min的变化，需要重新定义。
 </summary>
 <param name="x"></param>
 <returns></returns>
 <remarks>
 数据的标准化（normalization）是将数据按比例缩放，使之落入一个小的特定区间。这样去除数据的单位限制，
 将其转化为无量纲的纯数值，便于不同单位或量级的指标能够进行比较和加权。
 其中最典型的就是0-1标准化和Z标准化
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.Distributions.pnorm.TruncNDist(System.Int32,System.Double)">
 <summary>
 
 </summary>
 <param name="len"></param>
 <param name="sd"></param>
 <returns></returns>
 <remarks>https://github.com/mpadge/tnorm</remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.Distributions.pnorm.StandardDistribution(System.Double)">
 <summary>
 标准正态分布, delta = 1, u = 0
 </summary>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Distributions.pnorm.eval(System.Double,System.Double,System.Double,System.Boolean,System.Boolean,System.Int32)">
 <summary>
 Density, distribution function, quantile function and random generation for the 
 normal distribution with mean equal to mean and standard deviation equal to sd.
 </summary>
 <param name="q">vector of quantiles.</param>
 <param name="mean">vector of means.</param>
 <param name="sd">vector of standard deviations.</param>
 <param name="lower_tail">logical; if TRUE (default), probabilities are ``P[X ≤ x]`` otherwise, ``P[X > x]``.</param>
 <param name="logP">logical; if TRUE, probabilities p are given as log(p).</param>
 <returns></returns>
 <remarks>
 implements of the R language ``pnorm`` function
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.Distributions.pnorm.eval(Microsoft.VisualBasic.Math.LinearAlgebra.Vector,System.Double,System.Double,System.Boolean,System.Boolean,System.Int32)">
 <summary>
 Density, distribution function, quantile function and random generation for the 
 normal distribution with mean equal to mean and standard deviation equal to sd.
 </summary>
 <param name="q">vector of quantiles.</param>
 <param name="mean">vector of means.</param>
 <param name="sd">vector of standard deviations.</param>
 <param name="lower_tail">logical; if TRUE (default), probabilities are ``P[X ≤ x]`` otherwise, ``P[X > x]``.</param>
 <param name="logP">logical; if TRUE, probabilities p are given as log(p).</param>
 <returns></returns>
 <remarks>
 implements of the R language ``pnorm`` function
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.Distributions.pnorm.ProbabilityDensity(System.Double,System.Double,System.Double)">
 <summary>
 #### normal-pdf
 
 Gaussian PDF function,
 Normal Distribution.
 </summary>
 <param name="x"></param>
 <param name="m">Mean</param>
 <param name="sd"></param>
 <returns>Get normal distribution density value at a point.</returns>
 <remarks>
 (正态分布)
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.Distributions.pnorm.ProbabilityDensity(Microsoft.VisualBasic.Math.LinearAlgebra.Vector,System.Double,System.Double)">
 <summary>
 
 </summary>
 <param name="x"></param>
 <param name="m"></param>
 <param name="sd"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Distributions.pnorm.TrapezodialRule(System.Double,System.Double,System.Int32,System.Double,System.Double)">
 <summary>
 
 </summary>
 <param name="a#"></param>
 <param name="b#"></param>
 <param name="resolution">计算的分辨率，越大越好</param>
 <param name="m#"></param>
 <param name="sd#"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Math.Distributions.PoissonDiskGenerator">
 <summary>
 cf paper: Fast Poisson Disk Sampling in Arbitrary Dimensions. Robert Bridson. ACM SIGGRAPH 2007
 
 How to use:
 
 1. set parameters. ( minDist / k / sampleRange )
 2. call Generate(). It will return the list contains sample points.
 </summary>
 <remarks>
 https://github.com/HexStark/PoissonDiskGeneratorForUnity/tree/master
 </remarks>
</member>
<member name="F:Microsoft.VisualBasic.Math.Distributions.PoissonDiskGenerator.minDist">
 <summary>
 the minimumx distance between any of the two samples.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Math.Distributions.PoissonDiskGenerator.k">
 <summary>
 the time of throw darts. Higher k generate better result but slower.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Math.Distributions.PoissonDiskGenerator.sampleRange">
 <summary>
 the range of generated samples. From 0[inclusive] to sampleRange[inclusive]
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Math.Distributions.PoissonDiskGenerator.m_resultSet">
 <summary>
 result of samples
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Math.Distributions.PoissonDiskGenerator.grid">
 <summary>
 grid for save sample locations.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.Distributions.PoissonDiskGenerator.IsInputsValid(System.Single,System.Single,System.Int32)">
 <summary>
 Determines if inputs are appropriate.
 </summary>
 <returns><c>true</c> if is inputs valid; otherwise, <c>false</c>.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Distributions.PoissonDiskGenerator.Generate(System.Single,System.Single,System.Int32,Microsoft.VisualBasic.Imaging.Bitmap)">
 <summary>
 Generate samples. Based on minDist / k / sampleRange.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.Distributions.PoissonDiskGenerator._PositionToGridIndex(System.Single)">
 <summary>
 Given a float, return the grid index in any dimenssion 
 </summary>
 <param name="f"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Distributions.PoissonDiskGenerator._WrapRepeatFloat(System.Single)">
 <summary>
 wrap float into generate range
 </summary>
 <param name="f"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Distributions.PoissonDiskGenerator._WrapIndex(System.Int32)">
 <summary>
 wrap grid index into grid length
 </summary>
 <param name="index"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Math.Distributions.SampleDistribution">
 <summary>
 The data sample xml model
 </summary>
 <remarks>
 summary of the sample data vector
 </remarks>
</member>
<member name="P:Microsoft.VisualBasic.Math.Distributions.SampleDistribution.stdErr">
 <summary>
 standard deviation of the population
 </summary>
 <returns></returns>
 <remarks>
 evaluated from the <see cref="M:Microsoft.VisualBasic.Math.VBMath.SD(System.Collections.Generic.IEnumerable{System.Double},System.Boolean)"/> function.
 </remarks>
</member>
<member name="P:Microsoft.VisualBasic.Math.Distributions.SampleDistribution.size">
 <summary>
 length of the raw data vector
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Math.Distributions.SampleDistribution.quantile">
 <summary>
 分别为0%, 25%, 50%, 75%, 100%
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Distributions.SampleDistribution.#ctor(System.Collections.Generic.IEnumerable{System.Double},System.Boolean)">
 <summary>
 Construct a feature data based on a specific dataframe column data
 </summary>
 <param name="data">the raw data matrix column data</param>
 <param name="estimateQuantile"></param>
 
</member>
<member name="M:Microsoft.VisualBasic.Math.Distributions.SampleDistribution.#ctor(System.Double[],System.Boolean)">
 <summary>
 Construct a feature data based on a specific dataframe column data
 </summary>
 <param name="v">the raw data matrix column data</param>
 <param name="estimateQuantile"></param>
</member>
<member name="M:Microsoft.VisualBasic.Math.Distributions.SampleDistribution.GetRange">
 <summary>
 <see cref="M:Microsoft.VisualBasic.Math.Extensions.DoubleRange(System.ValueTuple{System.Double,System.Double})"/> = ``[<see cref="P:Microsoft.VisualBasic.Math.Distributions.SampleDistribution.min"/>, <see cref="P:Microsoft.VisualBasic.Math.Distributions.SampleDistribution.max"/>]``
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Math.Distributions.TrIQ">
 <summary>
 Contrast optimization of mass spectrometry imaging (MSI) data visualization by threshold intensity quantization (TrIQ)
 </summary>
 <remarks>
 works based on the <see cref="T:Microsoft.VisualBasic.Math.Distributions.ECDF"/>.
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.Distributions.TrIQ.CutThreshold(System.Collections.Generic.IEnumerable{System.Double},System.Double,System.Int32,System.Double)">
 <summary>
 trim the head intensity data by a given cutoff threshold 
 which is evaluated via the TrIQ algorithm.
 </summary>
 <param name="data"></param>
 <param name="q"></param>
 <param name="N"></param>
 <param name="eps"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Distributions.TrIQ.FindThreshold(System.Collections.Generic.IEnumerable{System.Double},System.Double,System.Int32,System.Double)">
 <summary>
 The Threshold Intensity Quantization addresses this issue by setting a new upper limit T
 </summary>
 <param name="data"></param>
 <param name="q"></param>
 <param name="N"></param>
 <param name="eps"></param>
 <returns>the upper bound raw value of the threshold</returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Distributions.TrIQ.GetTrIQRange(System.Collections.Generic.IEnumerable{System.Double},System.Double,System.Int32,System.Double)">
 <summary>
 get the best value range for level scaler via TrIQ algorithm. 
 </summary>
 <param name="data"></param>
 <param name="q"></param>
 <param name="N"></param>
 <param name="eps"></param>
 <returns>[min,max] of the data range.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Distributions.TrIQ.DiscreteLevels(System.Collections.Generic.IEnumerable{System.Double},System.Int32,System.Nullable{System.Double})">
 <summary>
 Quantization is a process for mapping a range 
 of analog intensity values To a Single discrete 
 value, known As a gray level.
 </summary>
 <param name="data"></param>
 <param name="n"></param>
 <param name="T"></param>
 <returns></returns>
 <remarks>
 Quantization is a process For mapping a range of 
 analog intensity values To a Single discrete value, 
 known As a gray level. Zero-memory Is a widely 
 used quantization method. The zero-memory quantizer
 computes equally spaced intensity bins Of width w:
 
 ```
 w = (max(f) - min(f)) / n
 ```
 
 where n represents the number Of discrete values, 
 usually 256; min(f) And max(f) operators provide 
 minimum And maximum intensity values. Quantization 
 Is based On a comparison with the transition levels 
 tk:
 
 ```
 tk = w + min(f), 2w + min(f), ..., nw + min(f)
 ```
 
 Finally, the discrete mapped value Q Is obtained:
 
 ```
 Q(f(x, y)) = {
     
     0,  f(x,y) &lt;= t1
     k,  tk &lt; f(x,y) &lt; tk+1
 }
 ```
 </remarks>
</member>
<member name="T:Microsoft.VisualBasic.Math.DownSampling.Bucket">
 <summary>
 A bucket holds a subset of events and select significant events from it
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Math.DownSampling.BucketBasedAlgorithm`2">
 <summary>
 General algorithm using buckets to downsample events:<br />
 <ul>
 <li>Prepare data.</li>
 <li>Split events into buckets.</li>
 <li>Calculate weight of events.</li>
 <li>Select significant events from each bucket.</li>
 </ul>
 </summary>
 <typeparam name="B"> Bucket class </typeparam>
 <typeparam name="E"> Event class </typeparam>
</member>
<member name="M:Microsoft.VisualBasic.Math.DownSampling.BucketBasedAlgorithm`2.prepare(System.Collections.Generic.IList{Microsoft.VisualBasic.ComponentModel.TagData.ITimeSignal})">
 <summary>
 initialize data for down sampling
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.DownSampling.BucketBasedAlgorithm`2.beforeSelect(System.Collections.Generic.IList{`0},System.Int32)">
 <summary>
 calculating weight or something else
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Math.DownSampling.BucketSplitter`2">
 <summary>
 Split up events into buckets
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Math.DownSampling.DownSamplingAlgorithm">
 <summary>
 Interface for downSampling algorithms
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.DownSampling.DownSamplingAlgorithm.process(System.Collections.Generic.IList{Microsoft.VisualBasic.ComponentModel.TagData.ITimeSignal},System.Int32)">
 
 <param name="data"> The original data </param>
 <param name="threshold"> Number of data points to be returned </param>
 <returns> the downsampled data </returns>
</member>
<member name="T:Microsoft.VisualBasic.Math.DownSampling.DSAlgorithms">
 <summary>
 Downsampling algorithms for time series data（LTOB, LTTB, LTD, OSI-PI Plot）
 </summary>
 <remarks>
 https://github.com/avina/downsampling
 </remarks>
</member>
<member name="F:Microsoft.VisualBasic.Math.DownSampling.DSAlgorithms.PIPLOT">
 <summary>
 OSIsoft PI PlotValues </summary>
</member>
<member name="F:Microsoft.VisualBasic.Math.DownSampling.DSAlgorithms.LTTB">
 <summary>
 Largest Triangle Three Bucket </summary>
</member>
<member name="F:Microsoft.VisualBasic.Math.DownSampling.DSAlgorithms.LTOB">
 <summary>
 Largest Triangle One Bucket </summary>
</member>
<member name="F:Microsoft.VisualBasic.Math.DownSampling.DSAlgorithms.LTD">
 <summary>
 Largest Triangle Dynamic </summary>
</member>
<member name="F:Microsoft.VisualBasic.Math.DownSampling.DSAlgorithms.MAXMIN">
 <summary>
 Maximum and minimum value </summary>
</member>
<member name="T:Microsoft.VisualBasic.Math.DownSampling.FixedNumBucketSplitter`2">
 <summary>
 Assign the first event to the first bucket, the last event to the last bucket.<br />
 Split the rest events into the rest (threshold - 2) buckets each containing approximately equal number of events
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Math.DownSampling.FixedTimeBucketSplitter`2">
 <summary>
 Split data into buckets with equal time span
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Math.DownSampling.LargestTriangleBucket.LinkedBucketNode">
 <summary>
 Tow-way linked list to perform bucket split and merge.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.DownSampling.LargestTriangleBucket.LinkedBucketNode.split">
 <summary>
 split this node into 2 new nodes,each contains a new bucket with half events.
 </summary>
 <returns> if bucket contains more than 2 events, return the last node, else return this. </returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.DownSampling.LargestTriangleBucket.LinkedBucketNode.merge">
 <summary>
 merge this node and the next node into one.
 </summary>
 <returns> the merged node; </returns>
</member>
<member name="T:Microsoft.VisualBasic.Math.DownSampling.LargestTriangleBucket.LTABuilder">
 <summary>
 A builder class for LT Algorithms.
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Math.DownSampling.LargestTriangleBucket.LTAlgorithm">
 <summary>
 Largest Triangle Bucket Algorithm family.
 <ul>
 <li>LTOB: Largest Triangle One Bucket</li>
 <li>LTTB: Largest Triangle Three Bucket</li>
 <li>LTD: Largest Triangle Dynamic (three bucket)</li>
 </ul>
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Math.DownSampling.LargestTriangleBucket.LTDynamicBucketSplitter">
 <summary>
 <para>
 A bucket-splitter dynamically resize bucket according to their SSE(Sum of Square Errors).
 </para>
 <para>
 In each iteration, the bucket with the highest SSE is split into two new buckets, two buckets with the lowest SSE
 are merged into a new one.
 </para>
 <para>
 LTD recommended number of iterations is DataSize / threshold * 10 but it depends. For a plot whit one highly
 fluctuating area and several small peaks, big number of iterations causes small peaks to be lost. So I change the
 formula to DataSize / threshold / 10 and limit the number to 500.
 </para>
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Math.DownSampling.LargestTriangleBucket.LTOneBucketWeightCalculator">
 <summary>
 Weight = Area of triangle (point A: the previous event, point B: this event; point C: the next event)
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Math.DownSampling.LargestTriangleBucket.LTThreeBucketWeightCalculator">
 <summary>
 Weight = Area of triangle (point A: the previous selected event, point B: this event; point C: average event int the next bucket)
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Math.DownSampling.LargestTriangleBucket.LTWeightedBucket.m_average">
 <summary>
 a virtual event represents the average value in next bucket
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.DownSampling.LargestTriangleBucket.LTWeightedBucket.average">
 <summary>
 a virtual event represents the average value in next bucket
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Math.DownSampling.LargestTriangleBucket.LTWeightedBucket.sse">
 <summary>
 -1 means SSE not calculated yet
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.DownSampling.LargestTriangleBucket.LTWeightedBucket.calcSSE(Microsoft.VisualBasic.Math.DownSampling.LargestTriangleBucket.LTWeightedBucket,Microsoft.VisualBasic.Math.DownSampling.LargestTriangleBucket.LTWeightedBucket)">
 <summary>
 Calculate sum of squared errors, with one event in adjacent buckets overlapping
 
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Math.DownSampling.LargestTriangleBucket.Triangle">
 <summary>
 Calculate a triangle's area
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Math.DownSampling.MaxMin.MMAlgorithm">
 <summary>
 Select events with maximum or minimum value in bucket
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Math.DownSampling.MaxMin.MMBucket">
 <summary>
 Bucket that selects events with maximum or minimum value
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Math.DownSampling.MaxMin.PIPlotAlgorithm">
 <summary>
 OSISoft PI PlotValues algorithm. (without interpolation on boundary)
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Math.DownSampling.MaxMin.PIPlotBucket">
 <summary>
 Bucket that selects the first, the last event and events with maximum or minimum value
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Math.DownSampling.Mixed.MixedAlgorithm">
 <summary>
 Merge other algorithms' results into a new result, then deduplicate and sort it.
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Math.DownSampling.TimeGap.TimeGapAlgorithm">
 <summary>
 Find out big gaps between events and select events at both ends of those gaps.
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Math.Extensions">
 <summary>
 向量以及统计函数拓展
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.Extensions.Shadows``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>
 Create the vector model from target .NET object collection.
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Extensions.FlipCoin(System.Int32,System.Int32)">
 <summary>
 
 </summary>
 <param name="headsCutoff">这个参数用来调整事件的发生概率，这个参数值越小，事件越容易发生</param>
 <param name="ntimes%"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Extensions.SSM(Microsoft.VisualBasic.Math.LinearAlgebra.Vector,Microsoft.VisualBasic.Math.LinearAlgebra.Vector)">
 <summary>
 计算两个离散信号之间的相似度
 </summary>
 <param name="q"></param>
 <param name="s"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Extensions.SSM_SIMD(System.Double[],System.Double[])">
 <summary>
 SIMD version of the modified cosine score
 </summary>
 <param name="q"></param>
 <param name="s"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Extensions.AsVector(System.Collections.Generic.IEnumerable{System.Double})">
 <summary>
 Construct the <see cref="T:Microsoft.VisualBasic.Math.LinearAlgebra.Vector"/> class from a numeric collecton.
 </summary>
 <param name="data"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Extensions.AsVector(Microsoft.VisualBasic.Language.Vectorization.Vector{System.Int32})">
 <summary>
 Create a <see cref="T:Microsoft.VisualBasic.Math.LinearAlgebra.Vector"/> from a specific <see cref="T:System.Int32"/> abstract vector.
 </summary>
 <param name="v"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Extensions.AsVector(Microsoft.VisualBasic.Language.Vectorization.Vector{System.Double})">
 <summary>
 Create a <see cref="T:Microsoft.VisualBasic.Math.LinearAlgebra.Vector"/> from a specific numeric collection.
 </summary>
 <param name="v"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Extensions.AsVector(Microsoft.VisualBasic.ComponentModel.DataSourceModel.DynamicPropertyBase{System.Double},System.String[])">
 <summary>
 Create a <see cref="T:Microsoft.VisualBasic.Math.LinearAlgebra.Vector"/> from a given subset of the dynamics object property values.
 </summary>
 <param name="data"></param>
 <param name="keys$"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Extensions.FDR(System.Collections.Generic.IEnumerable{System.Double},System.Nullable{System.Int32})">
 <summary>
 FDR错误控制法是Benjamini于1995年提出一种方法,通过控制FDR(False Discovery Rate)来决定P值的域值. 
 假设你挑选了``R``个差异表达的基因，其中有``S``个是真正有差异表达的，另外有``V``个其实是没有差异表达的，是假阳性的。
 实践中希望错误比例``Q＝V/R``平均而言不能超过某个预先设定的值（比如0.05），在统计学上，
 这也就等价于控制FDR不能超过5％.
 
 对所有候选基因的p值进行从小到大排序，则若想控制fdr不能超过q，则只需找到最大的正整数i，使得 
 ``p(i)&lt;= (i*q)/m``.然后，挑选对应p(1),p(2),...,p(i)的基因做为差异表达基因，这样就能从统计学上
 保证fdr不超过q。因此，FDR的计算公式如下
 
 ``FDR = length(pvalue)*pvalue/rank(pvalue)``
 </summary>
 <param name="pvalue"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Extensions.Iterates(System.ValueTuple{System.Int32,System.Int32})">
 <summary>
 Tuple range iterates
 </summary>
 <param name="range">Number values iterates from value ``from`` to value ``to``.</param>
 <returns></returns>
 <remarks>
 step 1 or -1 based on the to - from delta value its sign symbol.
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.Extensions.FirstDecrease(System.Collections.Generic.IEnumerable{System.Double},System.Double)">
 <summary>
 返回数值序列之中的首次出现符合条件的减少的位置
 </summary>
 <param name="data"></param>
 <param name="ratio"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Extensions.FirstIncrease(System.Collections.Generic.IEnumerable{System.Double},System.Double,System.Double)">
 <summary>
 只对单调递增的那一部分曲线有效
 </summary>
 <param name="data">y值</param>
 <param name="alpha"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Extensions.Reach(System.Collections.Generic.IEnumerable{System.Double},System.Double,System.Double)">
 <summary>
 
 </summary>
 <param name="data"></param>
 <param name="n"></param>
 <param name="offset">距离目标数据点<paramref name="n"/>的正负偏移量</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Extensions.seq2(System.Double,System.Double,System.Double)">
 <summary>
 [Sequence Generation] Generate regular sequences. seq is a standard generic with a default method.
 </summary>
 <param name="From">
 the starting and (maximal) end values of the sequence. Of length 1 unless just from is supplied as an unnamed argument.
 </param>
 <param name="To">
 the starting and (maximal) end values of the sequence. Of length 1 unless just from is supplied as an unnamed argument.
 </param>
 <param name="By">number: increment of the sequence</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.Extensions.Sim(Microsoft.VisualBasic.Math.LinearAlgebra.Vector,Microsoft.VisualBasic.Math.LinearAlgebra.Vector)">
 <summary>
 余弦相似度
 </summary>
 <param name="x"></param>
 <param name="y"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Extensions.Tanimoto(Microsoft.VisualBasic.Math.LinearAlgebra.Vector,Microsoft.VisualBasic.Math.LinearAlgebra.Vector)">
 <summary>
 这是x和y所共有的属性个数与x或y所具有的属性个数之间的比率。这个函数被称为Tanimoto系数或Tanimoto距离，
 它经常用在信息检索和生物学分类中。(余弦度量的一个简单的变种)
 当属性是二值属性时，余弦相似性函数可以用共享特征或属性解释。假设如果xi=1，则对象x具有第i个属性。于是，
 x·y是x和y共同具有的属性数，而xy是x具有的属性数与y具有的属性数的几何均值。于是，sim(x,y)是公共属性相
 对拥有的一种度量。
 </summary>
 <param name="x">vector of elements of 0 or 1 binary data</param>
 <param name="y">vector of elements of 0 or 1 binary data</param>
 <returns></returns>
 <remarks>
 http://xiao5461.blog.163.com/blog/static/22754562201211237567238/
 </remarks>
</member>
<member name="T:Microsoft.VisualBasic.Math.Logical.FuzzyLogic.FuzzyEngine">
 <summary>
 Represents the inferential engine.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Math.Logical.FuzzyLogic.FuzzyEngine.LinguisticVariableCollection">
 <summary>
 A collection of linguistic variables.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Math.Logical.FuzzyLogic.FuzzyEngine.Consequent">
 <summary>
 The consequent variable name.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Math.Logical.FuzzyLogic.FuzzyEngine.FuzzyRuleCollection">
 <summary>
 A collection of rules.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.Logical.FuzzyLogic.FuzzyEngine.Defuzzify">
 <summary>
 Calculates the defuzzification value with the CoG (Center of Gravity) technique.
 </summary>
 <returns>The defuzzification value.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Logical.FuzzyLogic.FuzzyEngine.ToModel">
 <summary>
 Sets the FilePath property and saves the project into a FCL-like XML file.
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Math.Logical.FuzzyLogic.FuzzyRule">
 <summary>
 Represents a rule.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.Logical.FuzzyLogic.FuzzyRule.#ctor">
 <summary>
 Default constructor.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.Logical.FuzzyLogic.FuzzyRule.#ctor(System.String)">
 <param name="text">The text of the rule.</param>
</member>
<member name="P:Microsoft.VisualBasic.Math.Logical.FuzzyLogic.FuzzyRule.Text">
 <summary>
 The text of the rule.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Math.Logical.FuzzyLogic.FuzzyRule.Value">
 <summary>
 The value of the rule after the evaluation process.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.Logical.FuzzyLogic.FuzzyRule.Conditions">
 <summary>
 Returns the conditions of the rule.
 The part of the rule between IF and THEN.
 </summary>
 <returns>The conditions of the rule.</returns>
</member>
<member name="T:Microsoft.VisualBasic.Math.Logical.FuzzyLogic.FuzzyRuleCollection">
 <summary>
 Represents a collection of rules.
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Math.Logical.FuzzyLogic.LinguisticVariable">
 <summary>
 Represents a linguistic variable.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.Logical.FuzzyLogic.LinguisticVariable.#ctor">
 <summary>
 Default constructor.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.Logical.FuzzyLogic.LinguisticVariable.#ctor(System.String)">
 <param name="name">The name that identificates the linguistic variable.</param>
</member>
<member name="M:Microsoft.VisualBasic.Math.Logical.FuzzyLogic.LinguisticVariable.#ctor(System.String,Microsoft.VisualBasic.Math.Logical.FuzzyLogic.MembershipFunctionCollection)">
 <param name="name">The name that identificates the linguistic variable.</param>
 <param name="membershipFunctionCollection">A membership functions collection for the lingusitic variable.</param>
</member>
<member name="P:Microsoft.VisualBasic.Math.Logical.FuzzyLogic.LinguisticVariable.Name">
 <summary>
 The name that identificates the linguistic variable.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Math.Logical.FuzzyLogic.LinguisticVariable.MembershipFunctionCollection">
 <summary>
 A membership functions collection for the lingusitic variable.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Math.Logical.FuzzyLogic.LinguisticVariable.InputValue">
 <summary>
 The input value for the linguistic variable.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.Logical.FuzzyLogic.LinguisticVariable.Fuzzify(System.String)">
 <summary>
 Implements the fuzzification of the linguistic variable.
 </summary>
 <param name="membershipFunctionName">The membership function for which fuzzify the variable.</param>
 <returns>The degree of membership.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Logical.FuzzyLogic.LinguisticVariable.MinValue">
 <summary>
 Returns the minimum value of the linguistic variable.
 </summary>
 <returns>The minimum value of the linguistic variable.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Logical.FuzzyLogic.LinguisticVariable.MaxValue">
 <summary>
 Returns the maximum value of the linguistic variable.
 </summary>
 <returns>The maximum value of the linguistic variable.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Logical.FuzzyLogic.LinguisticVariable.Range">
 <summary>
 Returns the difference between MaxValue() and MinValue().
 </summary>
 <returns>The difference between MaxValue() and MinValue().</returns>
</member>
<member name="T:Microsoft.VisualBasic.Math.Logical.FuzzyLogic.LinguisticVariableCollection">
 <summary>
 Represents a collection of rules.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.Logical.FuzzyLogic.LinguisticVariableCollection.Find(System.String)">
 <summary>
 Finds a linguistic variable in a collection.
 </summary>
 <param name="linguisticVariableName">Linguistic variable name.</param>
 <returns>The linguistic variable, if founded.</returns>
</member>
<member name="T:Microsoft.VisualBasic.Math.Logical.FuzzyLogic.MembershipFunction">
 <summary>
 Represents a membership function.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.Logical.FuzzyLogic.MembershipFunction.#ctor">
 <summary>
 Default constructor.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.Logical.FuzzyLogic.MembershipFunction.#ctor(System.String)">
 <param name="name">The name that identificates the membership function.</param>
</member>
<member name="M:Microsoft.VisualBasic.Math.Logical.FuzzyLogic.MembershipFunction.#ctor(System.String,System.Double,System.Double,System.Double,System.Double)">
 <param name="name">The name that identificates the linguistic variable.</param>
 <param name="x0">The value of the (x0, 0) point.</param>
 <param name="x1">The value of the (x1, 1) point.</param>
 <param name="x2">The value of the (x2, 1) point.</param>
 <param name="x3">The value of the (x3, 0) point.</param>
</member>
<member name="P:Microsoft.VisualBasic.Math.Logical.FuzzyLogic.MembershipFunction.Name">
 <summary>
 The name that identificates the membership function.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Math.Logical.FuzzyLogic.MembershipFunction.X0">
 <summary>
 The value of the (x0, 0) point.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Math.Logical.FuzzyLogic.MembershipFunction.X1">
 <summary>
 The value of the (x1, 1) point.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Math.Logical.FuzzyLogic.MembershipFunction.X2">
 <summary>
 The value of the (x2, 1) point.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Math.Logical.FuzzyLogic.MembershipFunction.X3">
 <summary>
 The value of the (x3, 0) point.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Math.Logical.FuzzyLogic.MembershipFunction.Value">
 <summary>
 The value of membership function after evaluation process.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.Logical.FuzzyLogic.MembershipFunction.Centorid">
 <summary>
 Calculate the centroid of a trapezoidal membership function.
 </summary>
 <returns>The value of centroid.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Logical.FuzzyLogic.MembershipFunction.Area">
 <summary>
 Calculate the area of a trapezoidal membership function.
 </summary>
 <returns>The value of area.</returns>
</member>
<member name="T:Microsoft.VisualBasic.Math.Logical.FuzzyLogic.MembershipFunctionCollection">
 <summary>
 Represents a collection of membership functions.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.Logical.FuzzyLogic.MembershipFunctionCollection.Find(System.String)">
 <summary>
 Finds a membership function in a collection.
 </summary>
 <param name="membershipFunctionName">Membership function name.</param>
 <returns>The membership function, if founded.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Logical.FuzzyLogic.Models.FuzzyModel.Load">
 <summary>
 Sets the FilePath property and loads a project from a FCL-like XML file.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Math.Logical.FuzzyLogic.Models.Tokens.Operator">
 <summary>
 And Or Not Xor Nor Nand
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Math.Logical.FuzzyLogic.Models.Tokens.Comparer">
 <summary>
 &lt;&lt;, &lt;, &lt;=, >, =>, >>, ~=, =, &lt;>
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Math.Logical.FuzzyLogic.Models.Tokens.WhiteSpace">
 <summary>
 Space or VbTab
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Math.Crc32">
 <summary>
 Crc32校验码
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Math.HashMaps.HashBlizzard">
 <summary>
 Blizzard hash algorithm code
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Math.HashMaps.HashBlizzard.dwHashTypes">
 <summary>
 The dwHashType: hash value types
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Math.HashMaps.HashBlizzard.dwHashTypes.Position">
 <summary>
 Hash ``dwHashType = 0`` calculated values are used to determine the position of the string in a hash table.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Math.HashMaps.HashBlizzard.dwHashTypes.Validate1">
 <summary>
 dwHashType = 1, Hash dwHashType = 2 calculated values are used to validate the string
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Math.HashMaps.HashBlizzard.dwHashTypes.Validate2">
 <summary>
 dwHashType = 1, Hash dwHashType = 2 calculated values are used to validate the string
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.HashMaps.HashBlizzard.HashBlizzard(System.String,Microsoft.VisualBasic.Math.HashMaps.HashBlizzard.dwHashTypes)">
 <summary>
 暴雪公司出名的哈希码.
 测试了 二千万 GUID, 没有重复.但运算量比较大。
 </summary>
 <param name="key"></param>
 <param name="HasType">HasType =0 ,1 ,2 </param>
 <returns></returns>
 <remarks>
 ###### Testing
 
 ``"unitneutralacritter.grp" -> 0xA26067F3``
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.HashMaps.HashBlizzard.HashBlizzard(System.Byte[],Microsoft.VisualBasic.Math.HashMaps.HashBlizzard.dwHashTypes)">
 <summary>
 暴雪公司著名的 HashMap .
 测试了 二千万 GUID, 没有重复.但运算量比较大。
 </summary>
 <param name="keyByte"></param>
 <param name="HasType">HasType =[0 ,1 ,2] </param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Math.HashMaps.HashMap">
 <summary>
 VB.NET常用的哈希算法集.其中包括了著名的暴雪的哈希,T33哈希.......
 不同的哈希算法在分布式,布降过滤器,位图MAP等等应用得比较多...
 </summary>
 <remarks>
 http://bbs.csdn.net/topics/391950537
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.HashMaps.HashMap.HashDJB(System.String)">
 <summary>
 和 HashCMyMap 基本一样.
 </summary>
 <param name="Key"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.HashMaps.HashMap.HashDJB(System.Byte[])">
 <summary>
 和 HashCMyMap 基本一样.
 </summary>
 <param name="KeyByte"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.HashMaps.HashMap.HashBKDR(System.String,System.Int64)">
 <summary>
 BKDR 哈希
 </summary>
 <param name="Key"></param>
 <param name="seed">种子.最好是使用质数.</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.HashMaps.HashMap.HashBKDR(System.Byte[],System.Int64)">
 <summary>
 BKDR 哈希
 </summary>
 <param name="KeyByte"></param>
 <param name="seed">种子数</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.HashMaps.HashMap.HashCMyMap(System.String)">
 <summary>
 经典times33算法。简单高效。[这个使用移位代替*33]
 测试一千万。没有重复哈希值。
 </summary>
 <param name="Key"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.HashMaps.HashMap.HashCMyMap(System.Byte[])">
 <summary>
 经典times33算法。简单高效。[这个使用移位代替*33]
 测试一千万。没有重复哈希值。
 </summary>
 <param name="KeyByte"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.HashMaps.HashMap.HashTimeMap(System.String,System.Int16)">
 <summary>
 经典的Time算法。简单，高效。
 Ngix使用的是 time31，Tokyo Cabinet使用的是 time37
 小写英文词汇适合33, 大小写混合使用65。time33比较适合的是英文词汇的hash.
 </summary>
 <param name="Key"></param>
 <param name="seed">种子数。 31，33，37 。。。</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.HashMaps.HashMap.HashTimeMap(System.Byte[]@,System.UInt32)">
 <summary>
 经典的Time算法。简单，高效。
 Ngix使用的是 time31，Tokyo Cabinet使用的是 time37
 小写英文词汇适合33, 大小写混合使用65。time33比较适合的是英文词汇的hash.
 </summary>
 <param name="KeyByte"></param>
 <param name="seed">种子质数。 31，33，37 。。。</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.HashMaps.HashMap.HashTimeMapCheckSum(System.Byte[]@,System.UInt32)">
 <summary>
 经典的Time算法。简单，高效。
 Ngix使用的是 time31，Tokyo Cabinet使用的是 time37
 小写英文词汇适合33, 大小写混合使用65。time33比较适合的是英文词汇的hash.
 </summary>
 <param name="KeyByte"></param>
 <param name="seed">种子质数。 31，33，37 。。。</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.HashMaps.HashMap.HashCodePair(System.Int32,System.Int32)">
 <summary>
 generate unique hashcode for a tuple object
 </summary>
 <param name="a">hashcode of one clr object.</param>
 <param name="b">hashcode of another clr object.</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.HashMaps.HashMap.HashCodePair(System.UInt64,System.UInt64)">
 <summary>
 generate unique hashcode for a tuple object
 </summary>
 <param name="a">hashcode of one clr object.</param>
 <param name="b">hashcode of another clr object.</param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Math.HashMaps.JenkinsHash">
 <summary>
 Original source from http://256.com/sources/jenkins_hash_java/
 
 <b>This is a Bob Jenkins hashing algorithm implementation</b>
 &lt;br> 
 These are functions for producing 32-bit hashes for hash table lookup.
 hashword(), hashlittle(), hashlittle2(), hashbig(), mix(), and final()
 are externally useful functions.  Routines to test the hash are included
 if SELF_TEST is defined.  You can use this free for any purpose.  It's in
 the public domain.  It has no warranty.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Math.HashMaps.JenkinsHash.MAX_VALUE">
 <summary>
 max value to limit it to 4 bytes
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.HashMaps.JenkinsHash.byteToLong(System.SByte)">
 <summary>
 Convert a byte into a long value without making it negative. </summary>
 <param name="b">
 @return </param>
</member>
<member name="M:Microsoft.VisualBasic.Math.HashMaps.JenkinsHash.add(System.Int64,System.Int64)">
 <summary>
 Do addition and turn into 4 bytes. </summary>
 <param name="val"> </param>
 <param name="___add">
 @return </param>
</member>
<member name="M:Microsoft.VisualBasic.Math.HashMaps.JenkinsHash.subtract(System.Int64,System.Int64)">
 <summary>
 Do subtraction and turn into 4 bytes. </summary>
 <param name="val"> </param>
 <param name="___subtract">
 @return </param>
</member>
<member name="M:Microsoft.VisualBasic.Math.HashMaps.JenkinsHash.xor(System.Int64,System.Int64)">
 <summary>
 Left shift val by shift bits and turn in 4 bytes. </summary>
 <param name="val"> </param>
 <param name="___xor">
 @return </param>
</member>
<member name="M:Microsoft.VisualBasic.Math.HashMaps.JenkinsHash.leftShift(System.Int64,System.Int32)">
 <summary>
 Left shift val by shift bits.  Cut down to 4 bytes. </summary>
 <param name="val"> </param>
 <param name="shift">
 @return </param>
</member>
<member name="M:Microsoft.VisualBasic.Math.HashMaps.JenkinsHash.fourByteToLong(System.SByte[],System.Int32)">
 <summary>
 Convert 4 bytes from the buffer at offset into a long value. </summary>
 <param name="bytes"> </param>
 <param name="offset">
 @return </param>
</member>
<member name="M:Microsoft.VisualBasic.Math.HashMaps.JenkinsHash.hashMix(System.Int64@,System.Int64@,System.Int64@)">
 <summary>
 Mix up the values in the hash function.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.HashMaps.JenkinsHash.hash(System.SByte[],System.Int64)">
 <summary>
 Hash a variable-length key into a 32-bit value.  Every bit of the
 key affects every bit of the return value.  Every 1-bit and 2-bit
 delta achieves avalanche.  The best hash table sizes are powers of 2.
 </summary>
 <param name="buffer">       Byte array that we are hashing on. </param>
 <param name="initialValue"> Initial value of the hash if we are continuing from
                     a previous run.  0 if none. </param>
 <returns> Hash value for the buffer. </returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.HashMaps.JenkinsHash.hash(System.SByte[])">
 <summary>
 See hash(byte[] buffer, long initialValue)
 </summary>
 <param name="buffer"> Byte array that we are hashing on. </param>
 <returns> Hash value for the buffer. </returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.HashMaps.JenkinsHash.hash(System.String)">
 <summary>
 只允许ASCII字符串
 </summary>
 <param name="key$"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Math.NumberExtension">
 <summary>
 https://github.com/cobaltblueocean/Mercury.Language.Extensions
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.NumberExtension.Epsilon(System.Double)">
 <summary>
 This is the Taylor expansion of $$\frac{\exp(x)-1}{x}$$ - note for $$|x| > 10^{-10}$$ the expansion is note used
 </summary>
 <param name="x">value</param>
 <returns>result</returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.NumberExtension.EpsilonP(System.Double)">
 <summary>
 This is the Taylor expansion of the first derivative of $$\frac{\exp(x)-1}{x}$$
 </summary>
 <param name="x">value</param>
 <returns>result</returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.NumberExtension.EpsilonPP(System.Double)">
 <summary>
 This is the Taylor expansion of the second derivative of $$\frac{\exp(x)-1}{x}$$
 </summary>
 <param name="x">value</param>
 <returns>result</returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.NumberExtension.Expm1(System.Double)">
 <summary>
 Returns <em>e</em><sup>x</sup> - 1.
 Special cases:
 <ul>
 <li>If the argument is NaN, the result is NaN.</li>
 <li>If the argument is positive infinity, the result is positive
 infinity</li>
 <li>If the argument is negative infinity, the result is -1.</li>
 <li>If the argument is zero, the result is zero.</li>
 </ul>
 
 </summary>
 <param name="x">the argument to <em>e</em><sup>x</sup> - 1.</param>
 <returns><em>e</em> raised to the power <code>x</code> minus one.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.NumberExtension.GetLowDWord(System.Int64)">
 <summary>
 Returns the lower two words of a long. This is intended to be
 used like this: 
 <code>getLowDWord(Double.doubleToLongBits(x))</code>.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.NumberExtension.GetHighDWord(System.Int64)">
 <summary>
 Returns the higher two words of a long. This is intended to be
 used like this:
 <code>getHighDWord(Double.doubleToLongBits(x))</code>.
 </summary>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Math.Numerics.BigDecimal">
 <summary>
 
 </summary>
 <remarks>
 http://tizzyt-archive.blogspot.com/2015/03/quick-and-dirty-net-bigdecimal.html
 </remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.Math.Numerics.BigDecimal.op_Division(Microsoft.VisualBasic.Math.Numerics.BigDecimal,Microsoft.VisualBasic.Math.Numerics.BigDecimal)">
 <summary>
 Does division on two BigDecimal numbers
 </summary>
 <param name="Num1"></param>
 <param name="Num2"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Math.Numerics.Half">
 <summary>
 Represents a half-precision floating point number. 
 </summary>
 <remarks>
 Note:
     Half is not fast enought and precision is also very bad, 
     so is should not be used for matemathical computation (use Single instead).
     The main advantage of Half type is lower memory cost: two bytes per number. 
     Half is typically used in graphical applications.
     
 Note: 
     All functions, where is used conversion half->float/float->half, 
     are approx. ten times slower than float->double/double->float, i.e. ~3ns on 2GHz CPU.

 References:
     - Fast Half Float Conversions, Jeroen van der Zijp, link: http://www.fox-toolkit.org/ftp/fasthalffloatconversion.pdf
     - IEEE 754 revision, link: http://grouper.ieee.org/groups/754/
 </remarks>
</member>
<member name="F:Microsoft.VisualBasic.Math.Numerics.Half.Value">
 <summary>
 Internal representation of the half-precision floating-point number.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Math.Numerics.Half.Epsilon">
 <summary>
 Represents the smallest positive System.Half value greater than zero. This field is constant.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Math.Numerics.Half.MaxValue">
 <summary>
 Represents the largest possible value of System.Half. This field is constant.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Math.Numerics.Half.MinValue">
 <summary>
 Represents the smallest possible value of System.Half. This field is constant.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Math.Numerics.Half.NaN">
 <summary>
 Represents not a number (NaN). This field is constant.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Math.Numerics.Half.NegativeInfinity">
 <summary>
 Represents negative infinity. This field is constant.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Math.Numerics.Half.PositiveInfinity">
 <summary>
 Represents positive infinity. This field is constant.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.Numerics.Half.#ctor(System.Single)">
 <summary>
 Initializes a new instance of System.Half to the value of the specified single-precision floating-point number.
 </summary>
 <param name="value">The value to represent as a System.Half.</param>
</member>
<member name="M:Microsoft.VisualBasic.Math.Numerics.Half.#ctor(System.Int32)">
 <summary>
 Initializes a new instance of System.Half to the value of the specified 32-bit signed integer.
 </summary>
 <param name="value">The value to represent as a System.Half.</param>
</member>
<member name="M:Microsoft.VisualBasic.Math.Numerics.Half.#ctor(System.Int64)">
 <summary>
 Initializes a new instance of System.Half to the value of the specified 64-bit signed integer.
 </summary>
 <param name="value">The value to represent as a System.Half.</param>
</member>
<member name="M:Microsoft.VisualBasic.Math.Numerics.Half.#ctor(System.Double)">
 <summary>
 Initializes a new instance of System.Half to the value of the specified double-precision floating-point number.
 </summary>
 <param name="value">The value to represent as a System.Half.</param>
</member>
<member name="M:Microsoft.VisualBasic.Math.Numerics.Half.#ctor(System.Decimal)">
 <summary>
 Initializes a new instance of System.Half to the value of the specified decimal number.
 </summary>
 <param name="value">The value to represent as a System.Half.</param>
</member>
<member name="M:Microsoft.VisualBasic.Math.Numerics.Half.#ctor(System.UInt32)">
 <summary>
 Initializes a new instance of System.Half to the value of the specified 32-bit unsigned integer.
 </summary>
 <param name="value">The value to represent as a System.Half.</param>
</member>
<member name="M:Microsoft.VisualBasic.Math.Numerics.Half.#ctor(System.UInt64)">
 <summary>
 Initializes a new instance of System.Half to the value of the specified 64-bit unsigned integer.
 </summary>
 <param name="value">The value to represent as a System.Half.</param>
</member>
<member name="M:Microsoft.VisualBasic.Math.Numerics.Half.Negate(Microsoft.VisualBasic.Math.Numerics.Half)">
 <summary>
 Returns the result of multiplying the specified System.Half value by negative one.
 </summary>
 <param name="half">A System.Half.</param>
 <returns>A System.Half with the value of half, but the opposite sign. -or- Zero, if half is zero.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Numerics.Half.Add(Microsoft.VisualBasic.Math.Numerics.Half,Microsoft.VisualBasic.Math.Numerics.Half)">
 <summary>
 Adds two specified System.Half values.
 </summary>
 <param name="half1">A System.Half.</param>
 <param name="half2">A System.Half.</param>
 <returns>A System.Half value that is the sum of half1 and half2.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Numerics.Half.Subtract(Microsoft.VisualBasic.Math.Numerics.Half,Microsoft.VisualBasic.Math.Numerics.Half)">
 <summary>
 Subtracts one specified System.Half value from another.
 </summary>
 <param name="half1">A System.Half (the minuend).</param>
 <param name="half2">A System.Half (the subtrahend).</param>
 <returns>The System.Half result of subtracting half2 from half1.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Numerics.Half.Multiply(Microsoft.VisualBasic.Math.Numerics.Half,Microsoft.VisualBasic.Math.Numerics.Half)">
 <summary>
 Multiplies two specified System.Half values.
 </summary>
 <param name="half1">A System.Half (the multiplicand).</param>
 <param name="half2">A System.Half (the multiplier).</param>
 <returns>A System.Half that is the result of multiplying half1 and half2.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Numerics.Half.Divide(Microsoft.VisualBasic.Math.Numerics.Half,Microsoft.VisualBasic.Math.Numerics.Half)">
 <summary>
 Divides two specified System.Half values.
 </summary>
 <param name="half1">A System.Half (the dividend).</param>
 <param name="half2">A System.Half (the divisor).</param>
 <returns>The System.Half that is the result of dividing half1 by half2.</returns>
 <exception cref="T:System.DivideByZeroException">half2 is zero.</exception>
</member>
<member name="M:Microsoft.VisualBasic.Math.Numerics.Half.op_UnaryPlus(Microsoft.VisualBasic.Math.Numerics.Half)">
 <summary>
 Returns the value of the System.Half operand (the sign of the operand is unchanged).
 </summary>
 <param name="half">The System.Half operand.</param>
 <returns>The value of the operand, half.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Numerics.Half.op_UnaryNegation(Microsoft.VisualBasic.Math.Numerics.Half)">
 <summary>
 Negates the value of the specified System.Half operand.
 </summary>
 <param name="half">The System.Half operand.</param>
 <returns>The result of half multiplied by negative one (-1).</returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Numerics.Half.op_Addition(Microsoft.VisualBasic.Math.Numerics.Half,Microsoft.VisualBasic.Math.Numerics.Half)">
 <summary>
 Adds two specified System.Half values.
 </summary>
 <param name="half1">A System.Half.</param>
 <param name="half2">A System.Half.</param>
 <returns>The System.Half result of adding half1 and half2.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Numerics.Half.op_Subtraction(Microsoft.VisualBasic.Math.Numerics.Half,Microsoft.VisualBasic.Math.Numerics.Half)">
 <summary>
 Subtracts two specified System.Half values.
 </summary>
 <param name="half1">A System.Half.</param>
 <param name="half2">A System.Half.</param>
 <returns>The System.Half result of subtracting half1 and half2.</returns>        
</member>
<member name="M:Microsoft.VisualBasic.Math.Numerics.Half.op_Multiply(Microsoft.VisualBasic.Math.Numerics.Half,Microsoft.VisualBasic.Math.Numerics.Half)">
 <summary>
 Multiplies two specified System.Half values.
 </summary>
 <param name="half1">A System.Half.</param>
 <param name="half2">A System.Half.</param>
 <returns>The System.Half result of multiplying half1 by half2.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Numerics.Half.op_Division(Microsoft.VisualBasic.Math.Numerics.Half,Microsoft.VisualBasic.Math.Numerics.Half)">
 <summary>
 Divides two specified System.Half values.
 </summary>
 <param name="half1">A System.Half (the dividend).</param>
 <param name="half2">A System.Half (the divisor).</param>
 <returns>The System.Half result of half1 by half2.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Numerics.Half.op_Equality(Microsoft.VisualBasic.Math.Numerics.Half,Microsoft.VisualBasic.Math.Numerics.Half)">
 <summary>
 Returns a value indicating whether two instances of System.Half are equal.
 </summary>
 <param name="half1">A System.Half.</param>
 <param name="half2">A System.Half.</param>
 <returns>true if half1 and half2 are equal; otherwise, false.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Numerics.Half.op_Inequality(Microsoft.VisualBasic.Math.Numerics.Half,Microsoft.VisualBasic.Math.Numerics.Half)">
 <summary>
 Returns a value indicating whether two instances of System.Half are not equal.
 </summary>
 <param name="half1">A System.Half.</param>
 <param name="half2">A System.Half.</param>
 <returns>true if half1 and half2 are not equal; otherwise, false.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Numerics.Half.op_LessThan(Microsoft.VisualBasic.Math.Numerics.Half,Microsoft.VisualBasic.Math.Numerics.Half)">
 <summary>
 Returns a value indicating whether a specified System.Half is less than another specified System.Half.
 </summary>
 <param name="half1">A System.Half.</param>
 <param name="half2">A System.Half.</param>
 <returns>true if half1 is less than half1; otherwise, false.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Numerics.Half.op_GreaterThan(Microsoft.VisualBasic.Math.Numerics.Half,Microsoft.VisualBasic.Math.Numerics.Half)">
 <summary>
 Returns a value indicating whether a specified System.Half is greater than another specified System.Half.
 </summary>
 <param name="half1">A System.Half.</param>
 <param name="half2">A System.Half.</param>
 <returns>true if half1 is greater than half2; otherwise, false.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Numerics.Half.op_LessThanOrEqual(Microsoft.VisualBasic.Math.Numerics.Half,Microsoft.VisualBasic.Math.Numerics.Half)">
 <summary>
 Returns a value indicating whether a specified System.Half is less than or equal to another specified System.Half.
 </summary>
 <param name="half1">A System.Half.</param>
 <param name="half2">A System.Half.</param>
 <returns>true if half1 is less than or equal to half2; otherwise, false.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Numerics.Half.op_GreaterThanOrEqual(Microsoft.VisualBasic.Math.Numerics.Half,Microsoft.VisualBasic.Math.Numerics.Half)">
 <summary>
 Returns a value indicating whether a specified System.Half is greater than or equal to another specified System.Half.
 </summary>
 <param name="half1">A System.Half.</param>
 <param name="half2">A System.Half.</param>
 <returns>true if half1 is greater than or equal to half2; otherwise, false.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Numerics.Half.op_Implicit(System.Byte)~Microsoft.VisualBasic.Math.Numerics.Half">
 <summary>
 Converts an 8-bit unsigned integer to a System.Half.
 </summary>
 <param name="value">An 8-bit unsigned integer.</param>
 <returns>A System.Half that represents the converted 8-bit unsigned integer.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Numerics.Half.op_Implicit(System.Int16)~Microsoft.VisualBasic.Math.Numerics.Half">
 <summary>
 Converts a 16-bit signed integer to a System.Half.
 </summary>
 <param name="value">A 16-bit signed integer.</param>
 <returns>A System.Half that represents the converted 16-bit signed integer.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Numerics.Half.op_Implicit(System.Char)~Microsoft.VisualBasic.Math.Numerics.Half">
 <summary>
 Converts a Unicode character to a System.Half.
 </summary>
 <param name="value">A Unicode character.</param>
 <returns>A System.Half that represents the converted Unicode character.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Numerics.Half.op_Implicit(System.Int32)~Microsoft.VisualBasic.Math.Numerics.Half">
 <summary>
 Converts a 32-bit signed integer to a System.Half.
 </summary>
 <param name="value">A 32-bit signed integer.</param>
 <returns>A System.Half that represents the converted 32-bit signed integer.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Numerics.Half.op_Implicit(System.Int64)~Microsoft.VisualBasic.Math.Numerics.Half">
 <summary>
 Converts a 64-bit signed integer to a System.Half.
 </summary>
 <param name="value">A 64-bit signed integer.</param>
 <returns>A System.Half that represents the converted 64-bit signed integer.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Numerics.Half.op_Explicit(System.Single)~Microsoft.VisualBasic.Math.Numerics.Half">
 <summary>
 Converts a single-precision floating-point number to a System.Half.
 </summary>
 <param name="value">A single-precision floating-point number.</param>
 <returns>A System.Half that represents the converted single-precision floating point number.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Numerics.Half.op_Explicit(System.Double)~Microsoft.VisualBasic.Math.Numerics.Half">
 <summary>
 Converts a double-precision floating-point number to a System.Half.
 </summary>
 <param name="value">A double-precision floating-point number.</param>
 <returns>A System.Half that represents the converted double-precision floating point number.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Numerics.Half.op_Explicit(System.Decimal)~Microsoft.VisualBasic.Math.Numerics.Half">
 <summary>
 Converts a decimal number to a System.Half.
 </summary>
 <param name="value">decimal number</param>
 <returns>A System.Half that represents the converted decimal number.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Numerics.Half.op_Explicit(Microsoft.VisualBasic.Math.Numerics.Half)~System.Byte">
 <summary>
 Converts a System.Half to an 8-bit unsigned integer.
 </summary>
 <param name="value">A System.Half to convert.</param>
 <returns>An 8-bit unsigned integer that represents the converted System.Half.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Numerics.Half.op_Explicit(Microsoft.VisualBasic.Math.Numerics.Half)~System.Char">
 <summary>
 Converts a System.Half to a Unicode character.
 </summary>
 <param name="value">A System.Half to convert.</param>
 <returns>A Unicode character that represents the converted System.Half.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Numerics.Half.op_Explicit(Microsoft.VisualBasic.Math.Numerics.Half)~System.Int16">
 <summary>
 Converts a System.Half to a 16-bit signed integer.
 </summary>
 <param name="value">A System.Half to convert.</param>
 <returns>A 16-bit signed integer that represents the converted System.Half.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Numerics.Half.op_Explicit(Microsoft.VisualBasic.Math.Numerics.Half)~System.Int32">
 <summary>
 Converts a System.Half to a 32-bit signed integer.
 </summary>
 <param name="value">A System.Half to convert.</param>
 <returns>A 32-bit signed integer that represents the converted System.Half.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Numerics.Half.op_Explicit(Microsoft.VisualBasic.Math.Numerics.Half)~System.Int64">
 <summary>
 Converts a System.Half to a 64-bit signed integer.
 </summary>
 <param name="value">A System.Half to convert.</param>
 <returns>A 64-bit signed integer that represents the converted System.Half.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Numerics.Half.op_Implicit(Microsoft.VisualBasic.Math.Numerics.Half)~System.Single">
 <summary>
 Converts a System.Half to a single-precision floating-point number.
 </summary>
 <param name="value">A System.Half to convert.</param>
 <returns>A single-precision floating-point number that represents the converted System.Half.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Numerics.Half.op_Implicit(Microsoft.VisualBasic.Math.Numerics.Half)~System.Double">
 <summary>
 Converts a System.Half to a double-precision floating-point number.
 </summary>
 <param name="value">A System.Half to convert.</param>
 <returns>A double-precision floating-point number that represents the converted System.Half.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Numerics.Half.op_Explicit(Microsoft.VisualBasic.Math.Numerics.Half)~System.Decimal">
 <summary>
 Converts a System.Half to a decimal number.
 </summary>
 <param name="value">A System.Half to convert.</param>
 <returns>A decimal number that represents the converted System.Half.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Numerics.Half.op_Implicit(System.SByte)~Microsoft.VisualBasic.Math.Numerics.Half">
 <summary>
 Converts an 8-bit signed integer to a System.Half.
 </summary>
 <param name="value">An 8-bit signed integer.</param>
 <returns>A System.Half that represents the converted 8-bit signed integer.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Numerics.Half.op_Implicit(System.UInt16)~Microsoft.VisualBasic.Math.Numerics.Half">
 <summary>
 Converts a 16-bit unsigned integer to a System.Half.
 </summary>
 <param name="value">A 16-bit unsigned integer.</param>
 <returns>A System.Half that represents the converted 16-bit unsigned integer.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Numerics.Half.op_Implicit(System.UInt32)~Microsoft.VisualBasic.Math.Numerics.Half">
 <summary>
 Converts a 32-bit unsigned integer to a System.Half.
 </summary>
 <param name="value">A 32-bit unsigned integer.</param>
 <returns>A System.Half that represents the converted 32-bit unsigned integer.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Numerics.Half.op_Implicit(System.UInt64)~Microsoft.VisualBasic.Math.Numerics.Half">
 <summary>
 Converts a 64-bit unsigned integer to a System.Half.
 </summary>
 <param name="value">A 64-bit unsigned integer.</param>
 <returns>A System.Half that represents the converted 64-bit unsigned integer.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Numerics.Half.op_Explicit(Microsoft.VisualBasic.Math.Numerics.Half)~System.SByte">
 <summary>
 Converts a System.Half to an 8-bit signed integer.
 </summary>
 <param name="value">A System.Half to convert.</param>
 <returns>An 8-bit signed integer that represents the converted System.Half.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Numerics.Half.op_Explicit(Microsoft.VisualBasic.Math.Numerics.Half)~System.UInt16">
 <summary>
 Converts a System.Half to a 16-bit unsigned integer.
 </summary>
 <param name="value">A System.Half to convert.</param>
 <returns>A 16-bit unsigned integer that represents the converted System.Half.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Numerics.Half.op_Explicit(Microsoft.VisualBasic.Math.Numerics.Half)~System.UInt32">
 <summary>
 Converts a System.Half to a 32-bit unsigned integer.
 </summary>
 <param name="value">A System.Half to convert.</param>
 <returns>A 32-bit unsigned integer that represents the converted System.Half.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Numerics.Half.op_Explicit(Microsoft.VisualBasic.Math.Numerics.Half)~System.UInt64">
 <summary>
 Converts a System.Half to a 64-bit unsigned integer.
 </summary>
 <param name="value">A System.Half to convert.</param>
 <returns>A 64-bit unsigned integer that represents the converted System.Half.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Numerics.Half.CompareTo(Microsoft.VisualBasic.Math.Numerics.Half)">
 <summary>
 Compares this instance to a specified System.Half object.
 </summary>
 <param name="other">A System.Half object.</param>
 <returns>
 A signed number indicating the relative values of this instance and value.
 Return Value Meaning Less than zero This instance is less than value. Zero
 This instance is equal to value. Greater than zero This instance is greater than value.
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Numerics.Half.CompareTo(System.Object)">
 <summary>
 Compares this instance to a specified System.Object.
 </summary>
 <param name="obj">An System.Object or null.</param>
 <returns>
 A signed number indicating the relative values of this instance and value.
 Return Value Meaning Less than zero This instance is less than value. Zero
 This instance is equal to value. Greater than zero This instance is greater
 than value. -or- value is null.
 </returns>
 <exception cref="T:System.ArgumentException">value is not a System.Half</exception>
</member>
<member name="M:Microsoft.VisualBasic.Math.Numerics.Half.Equals(Microsoft.VisualBasic.Math.Numerics.Half)">
 <summary>
 Returns a value indicating whether this instance and a specified System.Half object represent the same value.
 </summary>
 <param name="other">A System.Half object to compare to this instance.</param>
 <returns>true if value is equal to this instance; otherwise, false.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Numerics.Half.Equals(System.Object)">
 <summary>
 Returns a value indicating whether this instance and a specified System.Object
 represent the same type and value.
 </summary>
 <param name="obj">An System.Object.</param>
 <returns>true if value is a System.Half and equal to this instance; otherwise, false.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Numerics.Half.GetHashCode">
 <summary>
 Returns the hash code for this instance.
 </summary>
 <returns>A 32-bit signed integer hash code.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Numerics.Half.GetTypeCode">
 <summary>
 Returns the System.TypeCode for value type System.Half.
 </summary>
 <returns>The enumerated constant (TypeCode)255.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Numerics.Half.GetBytes(Microsoft.VisualBasic.Math.Numerics.Half)">
 <summary>
 Returns the specified half-precision floating point value as an array of bytes.
 </summary>
 <param name="value">The number to convert.</param>
 <returns>An array of bytes with length 2.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Numerics.Half.GetBits(Microsoft.VisualBasic.Math.Numerics.Half)">
 <summary>
 Converts the value of a specified instance of System.Half to its equivalent binary representation.
 </summary>
 <param name="value">A System.Half value.</param>
 <returns>A 16-bit unsigned integer that contain the binary representation of value.</returns>        
</member>
<member name="M:Microsoft.VisualBasic.Math.Numerics.Half.ToHalf(System.Byte[],System.Int32)">
 <summary>
 Returns a half-precision floating point number converted from two bytes
 at a specified position in a byte array.
 </summary>
 <param name="value">An array of bytes.</param>
 <param name="startIndex">The starting position within value.</param>
 <returns>A half-precision floating point number formed by two bytes beginning at startIndex.</returns>
 <exception cref="T:System.ArgumentException">
 startIndex is greater than or equal to the length of value minus 1, and is
 less than or equal to the length of value minus 1.
 </exception>
 <exception cref="T:System.ArgumentNullException">value is null.</exception>
 <exception cref="T:System.ArgumentOutOfRangeException">startIndex is less than zero or greater than the length of value minus 1.</exception>
</member>
<member name="M:Microsoft.VisualBasic.Math.Numerics.Half.ToHalf(System.UInt16)">
 <summary>
 Returns a half-precision floating point number converted from its binary representation.
 </summary>
 <param name="bits">Binary representation of System.Half value</param>
 <returns>A half-precision floating point number formed by its binary representation.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Numerics.Half.Sign(Microsoft.VisualBasic.Math.Numerics.Half)">
 <summary>
 Returns a value indicating the sign of a half-precision floating-point number.
 </summary>
 <param name="value">A signed number.</param>
 <returns>
 A number indicating the sign of value. Number Description -1 value is less
 than zero. 0 value is equal to zero. 1 value is greater than zero.
 </returns>
 <exception cref="T:System.ArithmeticException">value is equal to System.Half.NaN.</exception>
</member>
<member name="M:Microsoft.VisualBasic.Math.Numerics.Half.Abs(Microsoft.VisualBasic.Math.Numerics.Half)">
 <summary>
 Returns the absolute value of a half-precision floating-point number.
 </summary>
 <param name="value">A number in the range System.Half.MinValue ≤ value ≤ System.Half.MaxValue.</param>
 <returns>A half-precision floating-point number, x, such that 0 ≤ x ≤System.Half.MaxValue.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Numerics.Half.Max(Microsoft.VisualBasic.Math.Numerics.Half,Microsoft.VisualBasic.Math.Numerics.Half)">
 <summary>
 Returns the larger of two half-precision floating-point numbers.
 </summary>
 <param name="value1">The first of two half-precision floating-point numbers to compare.</param>
 <param name="value2">The second of two half-precision floating-point numbers to compare.</param>
 <returns>
 Parameter value1 or value2, whichever is larger. If value1, or value2, or both val1
 and value2 are equal to System.Half.NaN, System.Half.NaN is returned.
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Numerics.Half.Min(Microsoft.VisualBasic.Math.Numerics.Half,Microsoft.VisualBasic.Math.Numerics.Half)">
 <summary>
 Returns the smaller of two half-precision floating-point numbers.
 </summary>
 <param name="value1">The first of two half-precision floating-point numbers to compare.</param>
 <param name="value2">The second of two half-precision floating-point numbers to compare.</param>
 <returns>
 Parameter value1 or value2, whichever is smaller. If value1, or value2, or both val1
 and value2 are equal to System.Half.NaN, System.Half.NaN is returned.
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Numerics.Half.IsNaN(Microsoft.VisualBasic.Math.Numerics.Half)">
 <summary>
 Returns a value indicating whether the specified number evaluates to not a number (System.Half.NaN).
 </summary>
 <param name="half">A half-precision floating-point number.</param>
 <returns>true if value evaluates to not a number (System.Half.NaN); otherwise, false.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Numerics.Half.IsInfinity(Microsoft.VisualBasic.Math.Numerics.Half)">
 <summary>
 Returns a value indicating whether the specified number evaluates to negative or positive infinity.
 </summary>
 <param name="half">A half-precision floating-point number.</param>
 <returns>true if half evaluates to System.Half.PositiveInfinity or System.Half.NegativeInfinity; otherwise, false.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Numerics.Half.IsNegativeInfinity(Microsoft.VisualBasic.Math.Numerics.Half)">
 <summary>
 Returns a value indicating whether the specified number evaluates to negative infinity.
 </summary>
 <param name="half">A half-precision floating-point number.</param>
 <returns>true if half evaluates to System.Half.NegativeInfinity; otherwise, false.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Numerics.Half.IsPositiveInfinity(Microsoft.VisualBasic.Math.Numerics.Half)">
 <summary>
 Returns a value indicating whether the specified number evaluates to positive infinity.
 </summary>
 <param name="half">A half-precision floating-point number.</param>
 <returns>true if half evaluates to System.Half.PositiveInfinity; otherwise, false.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Numerics.Half.Parse(System.String)">
 <summary>
 Converts the string representation of a number to its System.Half equivalent.
 </summary>
 <param name="value">The string representation of the number to convert.</param>
 <returns>The System.Half number equivalent to the number contained in value.</returns>
 <exception cref="T:System.ArgumentNullException">value is null.</exception>
 <exception cref="T:System.FormatException">value is not in the correct format.</exception>
 <exception cref="T:System.OverflowException">value represents a number less than System.Half.MinValue or greater than System.Half.MaxValue.</exception>
</member>
<member name="M:Microsoft.VisualBasic.Math.Numerics.Half.Parse(System.String,System.IFormatProvider)">
 <summary>
 Converts the string representation of a number to its System.Half equivalent 
 using the specified culture-specific format information.
 </summary>
 <param name="value">The string representation of the number to convert.</param>
 <param name="provider">An System.IFormatProvider that supplies culture-specific parsing information about value.</param>
 <returns>The System.Half number equivalent to the number contained in s as specified by provider.</returns>
 <exception cref="T:System.ArgumentNullException">value is null.</exception>
 <exception cref="T:System.FormatException">value is not in the correct format.</exception>
 <exception cref="T:System.OverflowException">value represents a number less than System.Half.MinValue or greater than System.Half.MaxValue.</exception>
</member>
<member name="M:Microsoft.VisualBasic.Math.Numerics.Half.Parse(System.String,System.Globalization.NumberStyles)">
 <summary>
 Converts the string representation of a number in a specified style to its System.Half equivalent.
 </summary>
 <param name="value">The string representation of the number to convert.</param>
 <param name="style">
 A bitwise combination of System.Globalization.NumberStyles values that indicates
 the style elements that can be present in value. A typical value to specify is
 System.Globalization.NumberStyles.Number.
 </param>
 <returns>The System.Half number equivalent to the number contained in s as specified by style.</returns>
 <exception cref="T:System.ArgumentNullException">value is null.</exception>
 <exception cref="T:System.ArgumentException">
 style is not a System.Globalization.NumberStyles value. -or- style is the
 System.Globalization.NumberStyles.AllowHexSpecifier value.
 </exception>
 <exception cref="T:System.FormatException">value is not in the correct format.</exception>
 <exception cref="T:System.OverflowException">value represents a number less than System.Half.MinValue or greater than System.Half.MaxValue.</exception>
</member>
<member name="M:Microsoft.VisualBasic.Math.Numerics.Half.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
 <summary>
 Converts the string representation of a number to its System.Half equivalent 
 using the specified style and culture-specific format.
 </summary>
 <param name="value">The string representation of the number to convert.</param>
 <param name="style">
 A bitwise combination of System.Globalization.NumberStyles values that indicates
 the style elements that can be present in value. A typical value to specify is 
 System.Globalization.NumberStyles.Number.
 </param>
 <param name="provider">An System.IFormatProvider object that supplies culture-specific information about the format of value.</param>
 <returns>The System.Half number equivalent to the number contained in s as specified by style and provider.</returns>
 <exception cref="T:System.ArgumentNullException">value is null.</exception>
 <exception cref="T:System.ArgumentException">
 style is not a System.Globalization.NumberStyles value. -or- style is the
 System.Globalization.NumberStyles.AllowHexSpecifier value.
 </exception>
 <exception cref="T:System.FormatException">value is not in the correct format.</exception>
 <exception cref="T:System.OverflowException">value represents a number less than System.Half.MinValue or greater than System.Half.MaxValue.</exception>
</member>
<member name="M:Microsoft.VisualBasic.Math.Numerics.Half.TryParse(System.String,Microsoft.VisualBasic.Math.Numerics.Half@)">
 <summary>
 Converts the string representation of a number to its System.Half equivalent.
 A return value indicates whether the conversion succeeded or failed.
 </summary>
 <param name="value">The string representation of the number to convert.</param>
 <param name="result">
 When this method returns, contains the System.Half number that is equivalent
 to the numeric value contained in value, if the conversion succeeded, or is zero
 if the conversion failed. The conversion fails if the s parameter is null,
 is not a number in a valid format, or represents a number less than System.Half.MinValue
 or greater than System.Half.MaxValue. This parameter is passed uninitialized.
 </param>
 <returns>true if s was converted successfully; otherwise, false.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Numerics.Half.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,Microsoft.VisualBasic.Math.Numerics.Half@)">
 <summary>
 Converts the string representation of a number to its System.Half equivalent
 using the specified style and culture-specific format. A return value indicates
 whether the conversion succeeded or failed.
 </summary>
 <param name="value">The string representation of the number to convert.</param>
 <param name="style">
 A bitwise combination of System.Globalization.NumberStyles values that indicates
 the permitted format of value. A typical value to specify is System.Globalization.NumberStyles.Number.
 </param>
 <param name="provider">An System.IFormatProvider object that supplies culture-specific parsing information about value.</param>
 <param name="result">
 When this method returns, contains the System.Half number that is equivalent
 to the numeric value contained in value, if the conversion succeeded, or is zero
 if the conversion failed. The conversion fails if the s parameter is null,
 is not in a format compliant with style, or represents a number less than
 System.Half.MinValue or greater than System.Half.MaxValue. This parameter is passed uninitialized.
 </param>
 <returns>true if s was converted successfully; otherwise, false.</returns>
 <exception cref="T:System.ArgumentException">
 style is not a System.Globalization.NumberStyles value. -or- style 
 is the System.Globalization.NumberStyles.AllowHexSpecifier value.
 </exception>
</member>
<member name="M:Microsoft.VisualBasic.Math.Numerics.Half.ToString">
 <summary>
 Converts the numeric value of this instance to its equivalent string representation.
 </summary>
 <returns>A string that represents the value of this instance.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Numerics.Half.ToString(System.IFormatProvider)">
 <summary>
 Converts the numeric value of this instance to its equivalent string representation
 using the specified culture-specific format information.
 </summary>
 <param name="formatProvider">An System.IFormatProvider that supplies culture-specific formatting information.</param>
 <returns>The string representation of the value of this instance as specified by provider.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Numerics.Half.ToString(System.String)">
 <summary>
 Converts the numeric value of this instance to its equivalent string representation, using the specified format.
 </summary>
 <param name="format">A numeric format string.</param>
 <returns>The string representation of the value of this instance as specified by format.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Numerics.Half.ToString(System.String,System.IFormatProvider)">
 <summary>
 Converts the numeric value of this instance to its equivalent string representation 
 using the specified format and culture-specific format information.
 </summary>
 <param name="format">A numeric format string.</param>
 <param name="formatProvider">An System.IFormatProvider that supplies culture-specific formatting information.</param>
 <returns>The string representation of the value of this instance as specified by format and provider.</returns>
 <exception cref="T:System.FormatException">format is invalid.</exception>
</member>
<member name="T:Microsoft.VisualBasic.Math.Numerics.HalfHelper">
 <summary>
 Helper class for Half conversions and some low level operations.
 This class is internally used in the Half class.
 </summary>
 <remarks>
 References:
     - Fast Half Float Conversions, Jeroen van der Zijp, link: http://www.fox-toolkit.org/ftp/fasthalffloatconversion.pdf
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.Numerics.HalfHelper.ConvertMantissa(System.Int32)">
 <summary>
 Transforms the subnormal representation to a normalized one. 
 </summary>
 <param name="i"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Math.Numerics.UncheckedInteger">
 <summary>
 > https://stackoverflow.com/questions/2403154/fastest-way-to-do-an-unchecked-integer-addition-in-vb-net
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Math.Numerics.UncheckedInteger.Value">
 <summary>
 The integer value
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Math.Numerics.UncheckIntegerExtensions">
 <summary>
 unchecked arithmetic
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Math.Framework.Iterator.Kernel">
 <summary>
 the simulator iterator kernel
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.Framework.Iterator.Kernel.Step(System.Int32)">
 <summary>
 Execute the iterator step.
 </summary>
 <param name="itr"></param>
</member>
<member name="P:Microsoft.VisualBasic.Math.Framework.VariableObject.Id">
 <summary>
 the unique id of current object variable 
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Math.Framework.Optimization.LBFGSB.BKLDLT">
 <summary>
 Bunch-Kaufman LDLT decomposition
 </summary>
 <remarks>
 https://lbfgspp.statr.me/doc/BKLDLT_8h_source.html
 </remarks>
</member>
<member name="T:Microsoft.VisualBasic.Math.Framework.Optimization.LBFGSB.BKLDLT.Pair">
 <summary>
 Compressed permutations
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Math.Framework.Optimization.LBFGSB.BKLDLT.IndexType">
 <summary>
 Index reference, mutable
 </summary>		
</member>
<member name="T:Microsoft.VisualBasic.Math.Framework.Optimization.LBFGSB.Debugger">
 <summary>
 internal logger wrapper for echo debug message
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.Framework.Optimization.LBFGSB.IGradFunction.gradient(System.Double[]@,System.Double[]@,System.Double)">
 <summary>
 finite difference, symmetrical gradient, stores result in grad[]
 </summary>
 <param name="x"></param>
 <param name="grad"></param>
 <param name="eps"></param>
</member>
<member name="T:Microsoft.VisualBasic.Math.Framework.Optimization.LBFGSB.LBFGSB">
 <summary>
 L-BFGS-B optimizer
 
 # LBFGSBJava
 
 L-BFGS-B box constrained optimizer 
 
 * Most of the code ported from [LBFGS++](https://lbfgspp.statr.me/) code.
 * MoreThuente line search ported from [R source](https://github.com/SurajGupta/r-source/blob/master/src/appl/lbfgsb.c#L2976) and 
       [Julia LineSearches.jl](https://github.com/JuliaNLSolvers/LineSearches.jl/blob/master/src/morethuente.jl)
 * MoreThuente can be used with strong or weak (default) Wolfe condition 
 * LewisOverton (experimental, don't use) line search ported from [LBFGS-Lite](https://github.com/ZJU-FAST-Lab/LBFGS-Lite/blob/master/include/lbfgs.hpp)
 
 LBFGSB is implemented without any dependencies.
 
 See `org.generateme.lbfgsb.examples` for usage cases.
 
 ## Target function
 
 Each target function should implement `IGradFunction` interface.
 
 * default implementation of `gradient` uses finite differences method
 * implementing only `evaluate(x)` will use finite differences
 * there is a possibility to calculate function value and gradient in one call, implement `gradient(x,grad)` and 
   implement `in_place_gradient` to return `true`. See `Rosenbrock` in examples.
 
 ## Licence
 
 Copyright (c) 2023 GenerateMe
 
 The MIT Licence
 </summary>
 <remarks>
 https://github.com/genmeblog/LBFGSBJava
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.Framework.Optimization.LBFGSB.LBFGSB.minimize(Microsoft.VisualBasic.Math.Framework.Optimization.LBFGSB.IGradFunction,System.Double[],System.Double[],System.Double[])">
 <summary>
 
 </summary>
 <param name="f">function</param>
 <param name="[in]">initial and final value</param>
 <param name="lb">lower bounds</param>
 <param name="ub">upper bounds</param>
 <returns></returns>
</member>
<member name="F:Microsoft.VisualBasic.Math.Framework.Optimization.LBFGSB.LineSearches.LewisOverton.PhiDPhi.drt">
 <summary>
 search direction (cauchy point - x)
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Math.Framework.Optimization.LBFGSB.LineSearches.LewisOverton.PhiDPhi.xp">
 <summary>
 previous x
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Math.Framework.Optimization.LBFGSB.LineSearches.LewisOverton.PhiDPhi.x">
 <summary>
 current x
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Math.Framework.Optimization.LBFGSB.LineSearches.LewisOverton.PhiDPhi.grad">
 <summary>
 gradient
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Math.Framework.Optimization.LBFGSB.LineSearches.LewisOverton.PhiDPhi.dg">
 <summary>
 dot(grad,drt)
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Math.Framework.Optimization.LBFGSB.LineSearches.LineSearch">
 <summary>
 Line search methods for optimization and root-finding
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Math.Framework.Optimization.LBFGSB.Parameters.xtol">
 <summary>
 More Thuente
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Math.Scripting.Rscript.GenericVector`1">
 <summary>
 在这个泛型向量之中,仅包含有对元素对象的访问方法的封装,并没有涉及类型解析等反射操作
 </summary>
 <typeparam name="T"></typeparam>
</member>
<member name="P:Microsoft.VisualBasic.Math.Scripting.Rscript.GenericVector`1.Dim">
 <summary>
 向量维数，就是向量的长度（元素的个数）
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.Scripting.Rscript.GenericVector`1.#ctor(System.Int32)">
 <summary>
 Initializes a new instance of the generic type vector class that
 is empty and has the specified initial capacity.
 </summary>
 <param name="capacity">
 The number of elements that the new list can initially store.
 </param>
</member>
<member name="P:Microsoft.VisualBasic.Math.Scripting.Rscript.GenericVector`1.GET(Microsoft.VisualBasic.Math.LinearAlgebra.Vector,Microsoft.VisualBasic.Math.LinearAlgebra.Vector)">
 <summary>
 
 </summary>
 <param name="a">只有一个元素的</param>
 <param name="b">只有一个元素的</param>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.Math.Scripting.MathExpression.Arithmetic">
 <summary>
 The basics arithmetic operators' definition.
 (基本的四则运算符号的定义)
 </summary>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.Math.Scripting.MathExpression.Arithmetic.Arithmetic">
 <summary>
 +-*/\%^!
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.VisualBasic.Math.Scripting.MathExpression.Arithmetic.Operators">
 <summary>
 A string constant that enumerate all of the arithmetic operators.
 (一个枚举所有的基本运算符的字符串常数)
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.VisualBasic.Math.Scripting.MathExpression.Arithmetic.NumericRegexp">
 <summary>
 A string constant RegularExpressions that stands a double type number.
 (一个用于表示一个双精度类型的实数的正则表达式)
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.Scripting.MathExpression.Arithmetic.Evaluate(System.Double,System.Double,System.Char)">
 <summary>
 Do a basically arithmetic calculation.
 (进行一次简单的四则运算)
 </summary>
 <param name="a"></param>
 <param name="b"></param>
 <param name="o">Arithmetic operator(运算符)</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.Scripting.MathExpression.Arithmetic.Factorial(System.Double,System.Double)">
 <summary>
 Calculate the factorial value of a number, as this function is the part of the arithmetic operation
 delegate type of 'System.Func(Of Double, Double, Double)', so it must keep the form of two double
 parameter, well, the parameter 'b As Double' is useless.
 (计算某一个数的阶乘值，由于这个函数是四则运算操作委托'System.Func(Of Double, Double, Double)'中的一部分，
 故而本函数保持着两个双精度浮点型数的函数参数的输入形式，也就是说本函数的第二个参数'b'是没有任何用途的)
 </summary>
 <param name="a">The number that will be calculated(将要被计算的数字)</param>
 <param name="b">Useless parameter 'b'(为了保持函数接口兼容性而设置的一个无用的参数'b')</param>
 <returns>
 Return the factorial value of the number 'a', if 'a' is a negative number then this function
 return value 1.
 (函数返回参数'a'的阶乘计算值，假若'a'是一个负数的话，则会返回1)
 </returns>
 <remarks></remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.Math.Scripting.MathExpression.Arithmetic.RND(System.Double,System.Double)">
 <summary>
 This function return a random number, you can specific the boundary of the random number in the parameters. 
 </summary>
 <param name="UpBound">
 If this parameter is empty or value is zero, then return the randome number between 0 and 1.
 (如果这个参数为空或者其值为0，那么函数就会返回0和1之间的随机数)
 </param>
 <param name="LowBound"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.Scripting.MathExpression.ExpressionBuilder.isFunctionInvoke(Microsoft.VisualBasic.Math.Scripting.MathExpression.MathToken[])">
 <summary>
 *
 </summary>
 <param name="tokens"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Scripting.MathExpression.ExpressionBuilder.isOperator(Microsoft.VisualBasic.Math.Scripting.MathExpression.MathToken[],System.String[])">
 <summary>
 *
 </summary>
 <param name="tokens"></param>
 <param name="operators"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Scripting.MathExpression.ExpressionBuilder.processOperators(Microsoft.VisualBasic.Language.List{Microsoft.VisualBasic.Language.Variant{Microsoft.VisualBasic.Math.Scripting.MathExpression.Impl.Expression,System.String}},Microsoft.VisualBasic.Language.List{System.String},System.String[],System.Func{System.String,System.String,System.Boolean})">
 <summary>
 
 </summary>
 <param name="buf"></param>
 <param name="oplist"></param>
 <param name="operators$"></param>
 <param name="test">test(op, o)</param>
</member>
<member name="T:Microsoft.VisualBasic.Math.Scripting.MathExpression.DynamicInvoke">
 <summary>
 An abstract function interface for make math formula expression evaluation
 </summary>
 <param name="eval">evaluate the variable as numeric value.</param>
 <returns></returns>
</member>
<member name="F:Microsoft.VisualBasic.Math.Scripting.MathExpression.ExpressionEngine.functions">
 <summary>
 The mathematics calculation delegates collection with its specific name.
 (具有特定名称的数学计算委托方法的集合) 
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.Scripting.MathExpression.ExpressionEngine.AddFunction(System.String,System.String[],System.String)">
 <summary>
 
 </summary>
 <param name="name">函数名</param>
</member>
<member name="M:Microsoft.VisualBasic.Math.Scripting.MathExpression.ExpressionEngine.SetSymbol(System.String,System.Double)">
 <summary>
 set the symbol value
 </summary>
 <param name="symbol"></param>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Math.Scripting.MathExpression.Impl.BinaryExpression">
 <summary>
 left op right
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.Scripting.MathExpression.Impl.BinaryExpression.#ctor(Microsoft.VisualBasic.Math.Scripting.MathExpression.Impl.Expression,Microsoft.VisualBasic.Math.Scripting.MathExpression.Impl.Expression,System.String)">
 <summary>
 construct a new binary expression of:
 
 ```
 <paramref name="left"/> <paramref name="op"/> <paramref name="right"/>
 ```
 </summary>
 <param name="left"></param>
 <param name="right"></param>
 <param name="op">
 the binary math operator
 </param>
</member>
<member name="T:Microsoft.VisualBasic.Math.Scripting.MathExpression.Impl.Expression">
 <summary>
 the abstract math expression
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.Scripting.MathExpression.Impl.Expression.Parse(System.String)">
 <summary>
 Parse a given math formula expression code as the math expression model
 </summary>
 <param name="str"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Math.Scripting.MathExpression.Impl.Factorial">
 <summary>
 x!
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Math.Scripting.MathExpression.Impl.FunctionInvoke">
 <summary>
 f(x)
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Math.Scripting.MathExpression.Impl.Literal">
 <summary>
 A number literal
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Math.Scripting.MathExpression.Impl.Literal.One">
 <summary>
 the literal value of 1
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Math.Scripting.MathExpression.Impl.Literal.Zero">
 <summary>
 the literal value of 0
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Math.Scripting.MathExpression.Impl.SymbolExpression">
 <summary>
 symbol x
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Math.Scripting.MathExpression.FunctionElement">
 <summary>
 将用户定义的函数持久化的保存在XML文件之中所使用到的格式
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Math.Scripting.MathExpression.MathToken.ZERO">
 <summary>
 get a new literal zero token
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Scripting.FactorExtensions.factors``1(System.Collections.Generic.IEnumerable{``0},System.Single)">
 <summary>
 这个函数和<see cref="M:Microsoft.VisualBasic.Linq.Extensions.SeqIterator(System.Int32,System.Int32)"/>类似，但是这个函数之中添加了去重和排序
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <param name="step">取默认值1是为了保持与Integer类型的index的兼容</param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Math.Scripting.Factor`1">
 <summary>
 R language like string factor
 </summary>
 <typeparam name="T"></typeparam>
</member>
<member name="T:Microsoft.VisualBasic.Math.Scripting.FactorVector`1">
 <summary>
 提供和R之中的向量类似的行为：可以用两种方式来访问向量之中的成员，名字或者向量数组的下表
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Math.Scripting.NamedVector">
 <summary>
 提供字符串映射到具体的数值
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.Scripting.NamedVector.Add(System.String,System.Double)">
 <summary>
 添加一个映射
 </summary>
 <param name="factor$"></param>
 <param name="value#"></param>
</member>
<member name="T:Microsoft.VisualBasic.Math.Scripting.NamedVectorFactory">
 <summary>
 Factory for <see cref="T:System.Collections.Generic.Dictionary`2"/> to <see cref="T:Microsoft.VisualBasic.Math.LinearAlgebra.Vector"/>
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Math.Scripting.FormulaDependency.formula">
 <summary>
 the value expression of the target symbol: symbol = formula_expression
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Math.Scripting.FormulaDependency.dependency">
 <summary>
 a collection of the <see cref="P:Microsoft.VisualBasic.Math.Scripting.FormulaDependency.symbol"/> dependency in the 
 current <see cref="P:Microsoft.VisualBasic.Math.Scripting.FormulaDependency.formula"/> expression.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Scripting.FormulaDependency.Sort(System.Collections.Generic.IEnumerable{Microsoft.VisualBasic.Math.Scripting.FormulaDependency})">
 <summary>
 sort of the given formula list via the formula <see cref="P:Microsoft.VisualBasic.Math.Scripting.FormulaDependency.dependency"/>
 </summary>
 <param name="formulas"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Scripting.FormulaDependency.Visit(Microsoft.VisualBasic.Math.Scripting.FormulaDependency@,System.Collections.Generic.Dictionary{System.String,Microsoft.VisualBasic.Math.Scripting.FormulaDependency}@,System.Collections.Generic.Dictionary{System.String,System.Collections.Generic.List{System.String}}@,System.Collections.Generic.Dictionary{System.String,System.Boolean}@,System.Collections.Generic.Dictionary{System.String,System.Boolean}@,System.Collections.Generic.List{Microsoft.VisualBasic.Math.Scripting.FormulaDependency}@)">
 <summary>
 深度优先访问节点，检测循环依赖
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Math.Scripting.ParameterExpressionScript">
 <summary>
 在vb之中由于可选参数的值只能够是常量，假若变量之间还存在关联，则必须要用表达式，
 但是表达式不是常量，所以使用这个模块之中的代码来模拟R语言之中的可选参数表达式
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.Scripting.ParameterExpressionScript.Evaluate(System.Linq.Expressions.Expression{System.Func{System.Object[]}})">
 <summary>
 进行参数计算的时候只会接受数值类型以及字符串类型的参数
 </summary>
 <param name="params">假若参数是不需要进行计算的，则在生成字典的时候不放进去就行了</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Scripting.ParameterExpressionScript.Apply(System.Linq.Expressions.Expression{System.Func{System.Object[]}})">
 <summary>
 在计算参数表达式的同时，也将计算之后的值更新回原来的参数变量之上
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.Scripting.ParameterExpressionScript.GetValue(System.Collections.Generic.Dictionary{System.String,System.Double})">
 <summary>
 因为字符串插值过程之中变量名称的大小写可能不会敏感，所以还需要在这个函数值中对Key进行额外的小写转换处理
 </summary>
 <param name="values"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Scripting.ParameterExpressionScript.Evaluate(Microsoft.VisualBasic.ComponentModel.Collection.Dictionary{Microsoft.VisualBasic.Language.Value},System.Reflection.MethodBase,Microsoft.VisualBasic.Language.List{System.String}@)">
 <summary>
 进行参数计算的时候只会接受数值类型以及字符串类型的参数，字符串插值计算会被自动的忽略掉
 </summary>
 <param name="params">假若参数是不需要进行计算的，则在生成字典的时候不放进去就行了</param>
 <param name="strings">进行字符串插值的变量名称列表</param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Math.Scripting.ScriptEngine">
 <summary>
 Math expression script engine.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Math.Scripting.ScriptEngine.Expression">
 <summary>
 The default expression engine.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Math.Scripting.ScriptEngine.StatementEngine">
 <summary>
 all of the commands are stored at here
 </summary>
 <remarks>
 .quit for do nothing and end of this program.
 </remarks>
</member>
<member name="P:Microsoft.VisualBasic.Math.Scripting.ScriptEngine.Scripts">
 <summary>
 Lambda expression table.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Scripting.ScriptEngine.setSymbol(System.String)">
 <summary>
 var x = 100
 const x = 100
 </summary>
 <param name="run"></param>
</member>
<member name="M:Microsoft.VisualBasic.Math.Scripting.ScriptEngine.setFunction(System.String)">
 <summary>
 func add(x, y) x+y
 </summary>
 <param name="run"></param>
</member>
<member name="M:Microsoft.VisualBasic.Math.Scripting.ScriptEngine.setFunction(Microsoft.VisualBasic.Math.Scripting.MathExpression.ExpressionEngine,System.String)">
 <summary>
 func add(x, y) x+y
 </summary>
 <param name="run"></param>
 
</member>
<member name="M:Microsoft.VisualBasic.Math.Scripting.ScriptEngine.Shell(System.String)">
 <summary>
 Run the simple script that stores in the <see cref="P:Microsoft.VisualBasic.Math.Scripting.ScriptEngine.Scripts"/> table.
 </summary>
 <param name="statement"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Scripting.ScriptEngine.Evaluate(System.String,System.Boolean)">
 <summary>
 <see cref="M:Microsoft.VisualBasic.Math.Scripting.ScriptEngine.Shell(System.String)"/> function name alias.
 </summary>
 <param name="statement$"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Scripting.ScriptEngine.SetVariable(System.String,System.String)">
 <summary>
 Set variable value
 </summary>
 <param name="name"></param>
 <param name="expr"></param>
</member>
<member name="M:Microsoft.VisualBasic.Math.Scripting.ScriptEngine.ParseExpression(System.String,System.Boolean)">
 <summary>
 Parse the given expression string as the math expression
 </summary>
 <param name="expression"></param>
 <param name="throwEx">
 throw exception if the parser error occured.
 </param>
 <returns>
 this function will returns nothing if the expression parser error and also not throw exception
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Scripting.ScriptEngine.CheckFormulaDependency(System.Collections.Generic.Dictionary{System.String,Microsoft.VisualBasic.Math.Scripting.MathExpression.Impl.Expression},Microsoft.VisualBasic.ComponentModel.Collection.Index{System.String})">
 <summary>
 check of the formula symbol dependency and sort the formulas in asc order by dependency list
 </summary>
 <param name="formulas">
 a collection of the symbol value assigned expression: [symbol &lt;- expression]
 </param>
 <param name="ignores"></param>
 <returns>
 the given formula dependency result list is sorted via the dependency order
 </returns>
</member>
<member name="P:Microsoft.VisualBasic.Math.Scripting.IVector`1.Item(System.String)">
 <summary>
 <paramref name="name"/>大小写不敏感
 </summary>
 <param name="name$"></param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Math.Scripting.IVector`1.Item(System.Int32)">
 <summary>
 按照索引编号来取出元素
 </summary>
 <param name="index">
 目标在序列之中的位置索引编号，即数组的下标
 </param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Math.Scripting.IVector`1.Item(System.Collections.Generic.IEnumerable{System.Boolean})">
 <summary>
 这个属性返回来一个新的向量子集
 </summary>
 <param name="booleans"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Math.Quantile.DataQuartile">
 <summary>
 A data quartile model based on a given sample data input
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Math.Quantile.DataQuartile.Q1">
 <summary>
 第一四分位数 (Q1)，又称“较小四分位数”，等于该样本中所有数值由小到大排列后第25%的数字。
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Math.Quantile.DataQuartile.Q2">
 <summary>
 第二四分位数 (Q2)，又称“中位数”，等于该样本中所有数值由小到大排列后第50%的数字。
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Math.Quantile.DataQuartile.Q3">
 <summary>
 第三四分位数 (Q3)，又称“较大四分位数”，等于该样本中所有数值由小到大排列后第75%的数字。
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Math.Quantile.DataQuartile.IQR">
 <summary>
 第三四分位数与第一四分位数的差距又称四分位距（InterQuartile Range, IQR）。
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Math.Quantile.DataQuartile.range">
 <summary>
 极值范围
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Math.Quantile.DataQuartile.ModelSamples">
 <summary>
 The raw sample data input for create current quartile model
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Math.Quantile.Extensions">
 <summary>
 GK quantile extensions method
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.Quantile.Extensions.GKQuantile(System.Collections.Generic.IEnumerable{System.Int64},System.Double,System.Int32)">
 <summary>
 Example Usage:
 
 ```vbnet
 Dim shuffle As Long() = New Long(window_size - 1) {}

 For i As Integer = 0 To shuffle.Length - 1
     shuffle(i) = i
 Next

 shuffle = shuffle.Shuffles

 Dim estimator As QuantileEstimationGK = Shuffle.GKQuantile
 Dim quantiles As Double() = {0.5, 0.9, 0.95, 0.99, 1.0}

 For Each q As Double In quantiles
     Dim estimate As Long = estimator.query(q)
     Dim actual As Long = Shuffle.actually(q)
     Dim out As String = String.Format("Estimated {0:F2} quantile as {1:D} (actually {2:D})", q, estimate, actual)

     Call out.debug
 Next
 ```
 </summary>
 <param name="source"></param>
 <param name="epsilon"></param>
 <param name="compact_size"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Quantile.Extensions.GKQuantile(System.Collections.Generic.IEnumerable{System.Int32},System.Double,System.Int32)">
 <summary>
 <see cref="T:Microsoft.VisualBasic.Math.Quantile.QuantileEstimationGK"/> for numeric vector.
 </summary>
 <param name="source"></param>
 <param name="epsilon#"></param>
 <param name="compact_size%"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Quantile.Extensions.GKQuantile(System.Collections.Generic.IEnumerable{System.Double},System.Double,System.Int32)">
 <summary>
 <see cref="T:Microsoft.VisualBasic.Math.Quantile.QuantileEstimationGK"/> for numeric vector.
 </summary>
 <param name="source"></param>
 <param name="epsilon#"></param>
 <param name="compact_size%"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Quantile.Extensions.Threshold(System.Collections.Generic.IEnumerable{System.Double},System.Double,System.Double,System.Int32)">
 <summary>
 Measure sample threshold data by a given quantile level.
 </summary>
 <param name="data"></param>
 <param name="quantile">数量的百分比，值位于0-1之间</param>
 <param name="epsilon"></param>
 <param name="compact_size"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Math.Quantile.Extensions.QuantileLevels(System.Collections.Generic.IEnumerable{System.Double},System.Double,System.Double,System.Int32,System.Boolean)">
 <summary>
 将数值转化为相对应的quantile水平等级
 </summary>
 <param name="source"></param>
 <param name="steps#"></param>
 <param name="epsilon#"></param>
 <param name="compact_size%"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Quantile.Extensions.SelectByQuantile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int64},System.Double[],System.Double,System.Int32)">
 <summary>
 Selector for object sequence that by using quantile calculation.(对指定的序列按照所给定的quantile值进行分块)
 </summary>
 <typeparam name="T"></typeparam>
 <param name="data"></param>
 <param name="getValue">
 Object in the input sequence that can be measuring as a numeric value by using this function pointer.
 (通过这个函数指针可以将序列之中的对象转换为可计算quantile的数值)
 </param>
 <param name="quantiles#"></param>
 <param name="epsilon#"></param>
 <param name="compact_size%"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Quantile.Extensions.Summary(System.Collections.Generic.IEnumerable{System.Double},System.IO.TextWriter)">
 <summary>
 默认是输出到标准输出上的
 </summary>
 <param name="data"></param>
 <param name="dev"></param>
</member>
<member name="M:Microsoft.VisualBasic.Math.Quantile.FastRankQuantile.Query(System.Double)">
 <summary>
 
 </summary>
 <param name="q">[0, 1]</param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Math.Quantile.QuantileEstimationGK">
 <summary>
 Implementation of the Greenwald and Khanna algorithm for streaming
 calculation of epsilon-approximate quantiles.
 
 See: 
 
 > Greenwald and Khanna, "Space-efficient online computation of quantile summaries" in SIGMOD 2001
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Math.Quantile.QuantileEstimationGK.epsilon">
 <summary>
 Acceptable % error in percentile estimate
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Math.Quantile.QuantileEstimationGK.count">
 <summary>
 Total number of items in stream
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Math.Quantile.QuantileEstimationGK.compact_size">
 <summary>
 Threshold to trigger a compaction
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.Quantile.QuantileEstimationGK.#ctor(System.Double,System.Int32,System.Collections.Generic.IEnumerable{System.Double})">
 <summary>
 Implementation of the Greenwald and Khanna algorithm for streaming
 calculation of epsilon-approximate quantiles.
 </summary>
 <param name="epsilon">Acceptable % error in percentile estimate</param>
 <param name="compact_size">Threshold to trigger a compaction</param>
</member>
<member name="M:Microsoft.VisualBasic.Math.Quantile.QuantileEstimationGK.Insert(System.Double)">
 <summary>
 
 </summary>
 <param name="v"></param>
 <remarks>
 对这个函数的调用无法被并行化
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.Quantile.QuantileEstimationGK.Query(System.Double)">
 <summary>
 使用数量百分比来获取得到对应的阈值，<paramref name="quantile"/>为``[0,1]``之间的百分比值
 </summary>
 <param name="quantile#">``[0,1]``之间的百分比值</param>
 <returns>阈值</returns>
</member>
<member name="T:Microsoft.VisualBasic.Math.Quantile.Quartile">
 <summary>
 四分位数（Quartile）是在统计学中把所有数值由小到大排列并分成四等份够，处于三个分割点位置的数值。
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.Quantile.Quartile.Quartile(System.Collections.Generic.IEnumerable{System.Double},System.Boolean)">
 <summary>
 + 第一四分位数 (Q1)，又称“较小四分位数”，等于该样本中所有数值由小到大排列后第25%的数字。
 + 第二四分位数 (Q2)，又称“中位数”，等于该样本中所有数值由小到大排列后第50%的数字。
 + 第三四分位数 (Q3)，又称“较大四分位数”，等于该样本中所有数值由小到大排列后第75%的数字。
 + 第三四分位数与第一四分位数的差距又称四分位距（InterQuartile Range,IQR）。
 </summary>
 <param name="data"></param>
 <param name="altPosition">
 + <see cref="T:System.Boolean"/>.True  for n-1 method
 + <see cref="T:System.Boolean"/>.False for n+1 method
 </param>
 <returns>
 理论上,正常值范围应该是Q1到Q3范围内的值
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Quantile.Quartile.Outlier(Microsoft.VisualBasic.Math.LinearAlgebra.Vector,Microsoft.VisualBasic.Math.Quantile.DataQuartile)">
 <summary>
 异常值被定义为小于``Q1－1.5*IQR``或大于``Q3+1.5*IQR``的值。虽然这种标准有点任意性，但它来源于经验判断，
 经验表明它在处理需要特别注意的数据方面表现不错。这与识别异常值的经典方法有些不同。众所周知，基于正态分布
 的3σ法则或z分数方法是以假定数据服从正态分布为前提的，但实际数据往往并不严格服从正态分布。它们判断异常值的
 标准是以计算数据批的均值和标准差为基础的，而均值和标准差的耐抗性极小，异常值本身会对它们产生较大影响，这样
 产生的异常值个数不会多于总数0.7%。显然，应用这种方法于非正态分布数据中判断异常值，其有效性是有限的。箱形图
 的绘制依靠实际数据，不需要事先假定数据服从特定的分布形式，没有对数据作任何限制性要求，它只是真实直观地表现
 数据形状的本来面貌；另一方面，箱形图判断异常值的标准以四分位数和四分位距为基础，四分位数具有一定的耐抗性，
 多达25%的数据可以变得任意远而不会很大地扰动四分位数，所以异常值不能对这个标准施加影响，箱形图识别异常值的
 结果比较客观。
 </summary>
 <param name="data"></param>
 <param name="quartile"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Math.Quantile.Selector">
 <summary>
 String expression for select the sequence members by its numeric values, 
 selector expression provider for CLI programming.
 (对输入的目标序列进行数量上面的选择的表达式)
 </summary>
 <remarks>
 |name             |syntax          |description                                                                                              |
 |-----------------|----------------|---------------------------------------------------------------------------------------------------------|
 |quantile selector|``quantile:p%`` |``quantile:75%`` means selector object if its value is greater than quantile 75%.                        |
 |quartile selector|``Q1|2|3``      |quartile selector only have 3 enumerate values: ``Q1``, ``Q2``, ``Q3``, all of the values are UPPER_CASE.|
 |rank selector    |``desc:n|asc:n``|selector using object its rank order, desc:n for top n and asc:n for first n.                            |
 </remarks>
</member>
<member name="F:Microsoft.VisualBasic.Math.Quantile.Selector.Provider`1.getValue">
 <summary>
 描述了如何从具体的对象之中解析出数值信息
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.Quantile.Selector.ApplySelector``1(Microsoft.VisualBasic.Math.Quantile.Selector.Provider{``0},System.String)">
 <summary>
 可以使用``|``管道进行组合使用
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <param name="exp$"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Quantile.Selector.SelectByQuantile``1(Microsoft.VisualBasic.Math.Quantile.Selector.Provider{``0},System.Double)">
 <summary>
 使用数量百分比来进行选择
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <param name="q#"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Math.Quantile.X">
 <summary>
 Data variables
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Math.Interpolation.BezierCurve">
 <summary>
 A Bezier curve is a parametric curve frequently used in computer graphics and related fields. 
 In vector graphics, Bezier curves are used to model smooth curves that can be scaled indefinitely. 
 There are many ways to construct a Bezier curve. This simple program uses the midpoint algorithm 
 of constructing a Bezier curve. To show the nature of the divide and conquer approach in the 
 algorithm, a recursive function has been used to implement the construction of the piece of 
 Bezier curve.
 </summary>
 <remarks>
 http://www.codeproject.com/Articles/223159/Midpoint-Algorithm-Divide-and-Conquer-Method-for-D
 </remarks> 
</member>
<member name="P:Microsoft.VisualBasic.Math.Interpolation.BezierCurve.BezierPoints">
 <summary>
 store the list of points in the bezier curve.(贝塞尔曲线插值的结果列表)
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Math.Interpolation.BezierCurve.InitPointsList">
 <summary>
 store the list of initial points
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Math.Interpolation.BezierCurve.Iterations">
 <summary>
 store the number of iterations
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.Interpolation.BezierCurve.ReCalculate(System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF,System.Int32)">
 <summary>
 recreate the bezier curve.
 </summary>
 <param name="ctrl1">first initial point</param>
 <param name="ctrl2">second initial point</param>
 <param name="ctrl3">third initial point</param>
 <param name="iteration">number of iteration of the algorithm</param>
 <returns>the list of points in the curve</returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Interpolation.BezierCurve.CreateBezier(System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF)">
 <summary>
 create a bezier curve
 </summary>
 <param name="ctrl1">first initial point</param>
 <param name="ctrl2">second initial point</param>
 <param name="ctrl3">third initial point</param>
</member>
<member name="M:Microsoft.VisualBasic.Math.Interpolation.BezierCurve.PopulateBezierPoints(System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF,System.Int32)">
 <summary>
 Recursivly call to construct the bezier curve with control points
 </summary>
 <param name="ctrl1">first control point of bezier curve segment</param>
 <param name="ctrl2">second control point of bezier curve segment</param>
 <param name="ctrl3">third control point of bezier curve segment</param>
 <param name="currentIteration">the current interation of a branch</param>
 <remarks>
 http://www.codeproject.com/Articles/223159/Midpoint-Algorithm-Divide-and-Conquer-Method-for-D
 </remarks> 
</member>
<member name="M:Microsoft.VisualBasic.Math.Interpolation.BezierCurve.MidPoint(System.Drawing.PointF,System.Drawing.PointF)">
 <summary>
 Find mid point
 </summary>
 <param name="control1">first control point</param>
 <param name="control2">second control point</param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Math.Interpolation.BezierCurve.MidPoints(System.Double[])">
 <summary>
 medial axes between node centres And also boundary lines for the grid
 </summary>
 <param name="a"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Interpolation.BezierExtensions.BezierSmoothInterpolation(System.Double[],System.Int32,System.Int32,System.Boolean)">
 <summary>
 
 </summary>
 <param name="data"></param>
 <param name="parallel">并行版本的</param>
 <param name="windowSize">数据采样的窗口大小，默认大小是<paramref name="data"></paramref>的百分之1</param>
 <returns></returns>
 <remarks>先对数据进行采样，然后插值，最后返回插值后的平滑曲线数据以用于下一步分析</remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.Interpolation.BezierExtensions.Interpolation(System.Double[],System.Int32)">
 <summary>
 
 </summary>
 <param name="X"></param>
 <param name="iteration"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.Math.Interpolation.BSpline">
 <summary>
 B-spline arguments
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Math.Interpolation.B_Spline">
 <summary>
 B-spline.
 
 degree参数应该是大于1的，否则等于1的时候将不会进行插值处理
 </summary>
 <remarks>https://github.com/kerrot/B_Spline</remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.Interpolation.B_Spline.BSpline(System.Collections.Generic.IEnumerable{System.Drawing.Point},System.Single,System.Int32)">
 <summary>
 B-spline curve interpolation
 </summary>
 <param name="ctrlPts">Control points</param>
 <param name="degree%"></param>
 <param name="RESOLUTION%"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Interpolation.B_Spline.BSpline(System.Collections.Generic.IEnumerable{System.Drawing.PointF},System.Single,System.Int32)">
 <summary>
 B-spline curve interpolation
 </summary>
 <param name="ctrlPts">Control points</param>
 <param name="degree%"></param>
 <param name="RESOLUTION%"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Interpolation.B_Spline.Compute(System.Collections.Generic.IEnumerable{System.Drawing.PointF},System.Single,System.Int32)">
 <summary>
 B-spline curve interpolation
 </summary>
 <param name="controlPoints">Control points</param>
 <param name="degree%"></param>
 <param name="RESOLUTION%"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Math.Interpolation.B_Spline.OutputPoint(System.Drawing.PointF[],System.Double[],System.Int32,System.Double)">
 <summary>
 
 </summary>
 <param name="ctrlPts"></param>
 <param name="t"></param>
 <param name="k%">
 因为在这个函数里面的k参数是用来计算数组元素的index的，所以在这里不使用实数来表示了，而是使用整形数
 </param>
 <param name="u"></param>
</member>
<member name="T:Microsoft.VisualBasic.Math.Interpolation.CatmullRomSpline">
 <summary>
 Calculates interpolated point between two points using Catmull-Rom Spline
 </summary>
 <remarks>https://en.wikipedia.org/wiki/Centripetal_Catmull%E2%80%93Rom_spline</remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.Interpolation.CatmullRomSpline.PointOnCurve(System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF,System.Double)">
 <summary>
 Calculates interpolated point between two points using Catmull-Rom Spline</summary>
 <remarks>
 Points calculated exist on the spline between points two and three.</remarks>
 <param name="p0">First Point</param>
 <param name="p1">Second Point</param>
 <param name="p2">Third Point</param>
 <param name="p3">Fourth Point</param>
 <param name="t">
 Normalised distance between second and third point where the spline point will be calculated</param>
 <returns>Calculated Spline Point</returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Math.Interpolation.CatmullRomSpline.CatmullRomSpline(System.Collections.Generic.IEnumerable{System.Drawing.Point},System.Double,System.Boolean)">
 <summary>
 Catmull-Rom splines are a family of cubic interpolating splines formulated such 
 that the tangent at each point **Pi** Is calculated using the previous And next 
 point on the spline
 </summary>
 <param name="raw"></param>
 <param name="interpolationStep#"></param>
 <param name="isPolygon"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Interpolation.CatmullRomSpline.CatmullRomSpline(System.Collections.Generic.IEnumerable{System.Drawing.PointF},System.Double,System.Boolean)">
 <summary>
 Catmull-Rom splines are a family of cubic interpolating splines formulated such 
 that the tangent at each point **Pi** Is calculated using the previous And next 
 point on the spline
 </summary>
 <param name="points"></param>
 <param name="interpolationStep#"></param>
 <param name="isPolygon"></param>
 <returns></returns>
 <remarks>http://www.codeproject.com/Articles/747928/Spline-Interpolation-history-theory-and-implementa</remarks>
</member>
<member name="T:Microsoft.VisualBasic.Math.Interpolation.CentripetalCatmullRomSpline">
 <summary>
 ###### Centripetal Catmull–Rom spline
 
 In computer graphics, centripetal Catmull–Rom spline is a variant form of 
 Catmull-Rom spline formulated by Edwin Catmull and Raphael Rom according 
 to the work of Barry and Goldman. It is a type of interpolating spline 
 (a curve that goes through its control points) defined by four control points
 P0, P1, P2, P3, with the curve drawn only from P1 to P2.
 
 > https://en.wikipedia.org/wiki/Centripetal_Catmull%E2%80%93Rom_spline#cite_ref-1
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.Interpolation.CentripetalCatmullRomSpline.CatmulRom(System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF,System.Single,System.Single)">
 <summary>
 In computer graphics, centripetal Catmull–Rom spline is a variant form of 
 Catmull-Rom spline formulated by Edwin Catmull and Raphael Rom according 
 to the work of Barry and Goldman. It is a type of interpolating spline 
 (a curve that goes through its control points) defined by four control points
 P0, P1, P2, P3, with the curve drawn only from P1 to P2.
 </summary>
 <param name="pa">four control points P0, P1, P2, P3, with the curve drawn only from P1 to P2.</param>
 <param name="alpha!">set from 0-1</param>
 <param name="amountOfPoints!">How many points you want on the curve</param>
 <returns>points on the Catmull curve so we can visualize them</returns>
</member>
<member name="T:Microsoft.VisualBasic.Math.Interpolation.CubicSpline">
 <summary>
 Cubic spline interpolation
 </summary>
 <remarks>
 https://github.com/CrushedPixel/CubicSplineDemo
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Math.Interpolation.CubicSpline.RecalcSpline(System.Collections.Generic.IEnumerable{System.Drawing.PointF},System.Double)">
 <summary>
 三次样本曲线插值
 </summary>
 <param name="source">原始数据点集合，请注意，这些数据点之间都是有顺序分别的</param>
 <param name="expected">所期望的数据点的个数</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Interpolation.CubicSpline.RecalcSpline``1(System.Collections.Generic.IEnumerable{``0},System.Func{System.Single,System.Single,System.Single,``0},System.Double)">
 <summary>
 应用于3维空间的点对象的三次插值
 </summary>
 <typeparam name="Point"></typeparam>
 <param name="source"></param>
 <param name="newPoint">如何进行点对象的创建工作？</param>
 <param name="expected#">所期望的数据点的个数</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Interpolation.CubicSpline.RecalcSpline(System.Collections.Generic.IEnumerable{System.Drawing.Point},System.Double)">
 <summary>
 对一个二维点集合进行三次插值处理
 </summary>
 <param name="source"></param>
 <param name="expected#"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Math.Interpolation.CubicSplineVector">
 <summary>
 三次样条插值的核心代码模块
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Math.Interpolation.DouglasPeucker">
 <summary>
 Ramer–Douglas–Peucker algorithm
 
 The Ramer–Douglas–Peucker algorithm, also known as the Douglas–Peucker 
 algorithm and iterative end-point fit algorithm, is an algorithm that 
 decimates a curve composed of line segments to a similar curve with fewer
 points. It was one of the earliest successful algorithms developed for 
 cartographic generalization.
 
 > https://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.Interpolation.DouglasPeucker.RDPsd(System.Drawing.PointF[],System.Double)">
 <summary>
 ## RDP with ShortestDistance
         
 this Is the implementation with shortest Distance 
 (as of 2013-09 suggested by the wikipedia page. Thanks 
 Edward Lee for pointing this out)
 </summary>
 <param name="points"></param>
 <param name="epsilon"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Math.Interpolation.DouglasPeucker.RDPppd(System.Drawing.PointF[],System.Double)">
 <summary>
 ## RDP with PerpendicularDistance
 
 this Is the implementation with perpendicular Distance
 </summary>
 <param name="points"></param>
 <param name="epsilon"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Math.Interpolation.DouglasPeucker.distanceFromPointToLine(System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF)">
 <summary>
 code as suggested by Edward Lee
 </summary>
 <param name="p"></param>
 <param name="a"></param>
 <param name="b"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Math.Interpolation.DouglasPeucker.distanceFromPointToLineSquared(System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF)">
 <summary>
 This Is the difficult part. Commenting as we go.
 </summary>
 <param name="p"></param>
 <param name="i"></param>
 <param name="j"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Interpolation.DouglasPeucker.pointDistance(System.Drawing.PointF,System.Drawing.PointF)">
 <summary>
 returns distance between two points. Easy geometry.
 </summary>
 <param name="i"></param>
 <param name="j"></param>
 <returns></returns>
 
</member>
<member name="T:Microsoft.VisualBasic.Math.Interpolation.Splines">
 <summary>
 线条插值算法类型
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Math.Interpolation.Splines.None">
 <summary>
 无插值操作
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Math.Interpolation.Splines.B_Spline">
 <summary>
 二次插值
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Math.Interpolation.Splines.Bezier">
 <summary>
 贝塞尔曲线插值
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Math.Interpolation.Splines.CubicSpline">
 <summary>
 三次插值处理
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.Interpolation.Extensions.Range(System.Int32,System.Double[],System.Int32)">
 <summary>
 Computes the range of a strided array.
 </summary>
 <param name="N">number of indexed elements</param>
 <param name="x">input array</param>
 <param name="stride">stride length</param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Math.Interpolation.PolynomialNewton">
 <summary>
 似乎对三角函数不起作用
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Math.Interpolation.PolynomialNewton.NewtonPolynomial(System.Collections.Generic.IEnumerable{System.Drawing.PointF},System.Int32)">
 <summary>
 PolynomialNewton Spline
 </summary>
 <param name="points">序列之中的<see cref="P:System.Drawing.PointF.X"/>必须要是单调递增或者递减的</param>
 <param name="divided%"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Math.Interpolation.PolynomialNewton.Newton(Microsoft.VisualBasic.Math.LinearAlgebra.Vector,System.Double[],System.Double[])">
 <summary>
 使用牛顿多项式插值计算出给定的X点<paramref name="x1"/>所对应的Y值
 <paramref name="x"/>和<paramref name="y"/>是已知的实验值点
 </summary>
 <param name="x1#"></param>
 <param name="x#"></param>
 <param name="y#"></param>
 <returns></returns>
 <remarks>
 <paramref name="x"/> and <paramref name="y"/> should be length equals
 </remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.Math.Interpolation.PrincipalCurve.#ctor(System.Collections.Generic.IEnumerable{Microsoft.VisualBasic.Imaging.Math2D.Vector2D},System.Double,System.Int32,System.Double)">
 <summary>
 
 </summary>
 <param name="dataPoints">the input scatter data points</param>
 <param name="bandwidth"></param>
 <param name="maxIterations"></param>
 <param name="tolerance"></param>
</member>
</members>
</doc>
