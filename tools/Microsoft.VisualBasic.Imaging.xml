<?xml version="1.0"?>
<doc>
<assembly>
<name>
Microsoft.VisualBasic.Imaging
</name>
</assembly>
<members>
<member name="T:Microsoft.VisualBasic.Imaging.My.Resources.Resources">
<summary>
  A strongly-typed resource class, for looking up localized strings, etc.
</summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.My.Resources.Resources.ResourceManager">
<summary>
  Returns the cached ResourceManager instance used by this class.
</summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.My.Resources.Resources.Culture">
<summary>
  Overrides the current thread's CurrentUICulture property for all
  resource lookups using this strongly typed resource class.
</summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.My.Resources.Resources.colorbrewer">
<summary>
  Looks up a localized resource of type System.Byte[].
</summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.My.Resources.Resources.Default_Aspect">
<summary>
  Looks up a localized string similar to &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;
&lt;a:clrScheme xmlns:a=&quot;http://schemas.openxmlformats.org/drawingml/2006/main&quot; name=&quot;Default_Aspect&quot;&gt;&lt;a:dk1&gt;&lt;a:sysClr val=&quot;windowText&quot; lastClr=&quot;000000&quot;/&gt;&lt;/a:dk1&gt;&lt;a:lt1&gt;&lt;a:sysClr val=&quot;window&quot; lastClr=&quot;FFFFFF&quot;/&gt;&lt;/a:lt1&gt;&lt;a:dk2&gt;&lt;a:srgbClr val=&quot;323232&quot;/&gt;&lt;/a:dk2&gt;&lt;a:lt2&gt;&lt;a:srgbClr val=&quot;E3DED1&quot;/&gt;&lt;/a:lt2&gt;&lt;a:accent1&gt;&lt;a:srgbClr val=&quot;F07F09&quot;/&gt;&lt;/a:accent1&gt;&lt;a:accent2&gt;&lt;a:srgbClr val=&quot;9F2936&quot;/&gt;&lt;/a:accent2&gt;&lt;a:accent3&gt;&lt;a:srgbClr val=&quot;1B587C&quot;/&gt;&lt;/a:accent3&gt;&lt;a:accent4&gt;&lt;a:srg [rest of string was truncated]&quot;;.
</summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.My.Resources.Resources.Default_Blue">
<summary>
  Looks up a localized string similar to &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;
&lt;a:clrScheme xmlns:a=&quot;http://schemas.openxmlformats.org/drawingml/2006/main&quot; name=&quot;Default_Blue&quot;&gt;&lt;a:dk1&gt;&lt;a:sysClr val=&quot;windowText&quot; lastClr=&quot;000000&quot;/&gt;&lt;/a:dk1&gt;&lt;a:lt1&gt;&lt;a:sysClr val=&quot;window&quot; lastClr=&quot;FFFFFF&quot;/&gt;&lt;/a:lt1&gt;&lt;a:dk2&gt;&lt;a:srgbClr val=&quot;17406D&quot;/&gt;&lt;/a:dk2&gt;&lt;a:lt2&gt;&lt;a:srgbClr val=&quot;DBEFF9&quot;/&gt;&lt;/a:lt2&gt;&lt;a:accent1&gt;&lt;a:srgbClr val=&quot;0F6FC6&quot;/&gt;&lt;/a:accent1&gt;&lt;a:accent2&gt;&lt;a:srgbClr val=&quot;009DD9&quot;/&gt;&lt;/a:accent2&gt;&lt;a:accent3&gt;&lt;a:srgbClr val=&quot;0BD0D9&quot;/&gt;&lt;/a:accent3&gt;&lt;a:accent4&gt;&lt;a:srgbC [rest of string was truncated]&quot;;.
</summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.My.Resources.Resources.Default_Blue2">
<summary>
  Looks up a localized string similar to &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;
&lt;a:clrScheme xmlns:a=&quot;http://schemas.openxmlformats.org/drawingml/2006/main&quot; name=&quot;Default_Blue2&quot;&gt;&lt;a:dk1&gt;&lt;a:sysClr val=&quot;windowText&quot; lastClr=&quot;000000&quot;/&gt;&lt;/a:dk1&gt;&lt;a:lt1&gt;&lt;a:sysClr val=&quot;window&quot; lastClr=&quot;FFFFFF&quot;/&gt;&lt;/a:lt1&gt;&lt;a:dk2&gt;&lt;a:srgbClr val=&quot;335B74&quot;/&gt;&lt;/a:dk2&gt;&lt;a:lt2&gt;&lt;a:srgbClr val=&quot;DFE3E5&quot;/&gt;&lt;/a:lt2&gt;&lt;a:accent1&gt;&lt;a:srgbClr val=&quot;1CADE4&quot;/&gt;&lt;/a:accent1&gt;&lt;a:accent2&gt;&lt;a:srgbClr val=&quot;2683C6&quot;/&gt;&lt;/a:accent2&gt;&lt;a:accent3&gt;&lt;a:srgbClr val=&quot;27CED7&quot;/&gt;&lt;/a:accent3&gt;&lt;a:accent4&gt;&lt;a:srgb [rest of string was truncated]&quot;;.
</summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.My.Resources.Resources.Default_BlueGreen">
<summary>
  Looks up a localized string similar to &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;
&lt;a:clrScheme xmlns:a=&quot;http://schemas.openxmlformats.org/drawingml/2006/main&quot; name=&quot;Default_BlueGreen&quot;&gt;&lt;a:dk1&gt;&lt;a:sysClr val=&quot;windowText&quot; lastClr=&quot;000000&quot;/&gt;&lt;/a:dk1&gt;&lt;a:lt1&gt;&lt;a:sysClr val=&quot;window&quot; lastClr=&quot;FFFFFF&quot;/&gt;&lt;/a:lt1&gt;&lt;a:dk2&gt;&lt;a:srgbClr val=&quot;373545&quot;/&gt;&lt;/a:dk2&gt;&lt;a:lt2&gt;&lt;a:srgbClr val=&quot;CEDBE6&quot;/&gt;&lt;/a:lt2&gt;&lt;a:accent1&gt;&lt;a:srgbClr val=&quot;3494BA&quot;/&gt;&lt;/a:accent1&gt;&lt;a:accent2&gt;&lt;a:srgbClr val=&quot;58B6C0&quot;/&gt;&lt;/a:accent2&gt;&lt;a:accent3&gt;&lt;a:srgbClr val=&quot;75BDA7&quot;/&gt;&lt;/a:accent3&gt;&lt;a:accent4&gt;&lt;a: [rest of string was truncated]&quot;;.
</summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.My.Resources.Resources.Default_BlueWarm">
<summary>
  Looks up a localized string similar to &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;
&lt;a:clrScheme xmlns:a=&quot;http://schemas.openxmlformats.org/drawingml/2006/main&quot; name=&quot;Default_BlueWarm&quot;&gt;&lt;a:dk1&gt;&lt;a:sysClr val=&quot;windowText&quot; lastClr=&quot;000000&quot;/&gt;&lt;/a:dk1&gt;&lt;a:lt1&gt;&lt;a:sysClr val=&quot;window&quot; lastClr=&quot;FFFFFF&quot;/&gt;&lt;/a:lt1&gt;&lt;a:dk2&gt;&lt;a:srgbClr val=&quot;242852&quot;/&gt;&lt;/a:dk2&gt;&lt;a:lt2&gt;&lt;a:srgbClr val=&quot;ACCBF9&quot;/&gt;&lt;/a:lt2&gt;&lt;a:accent1&gt;&lt;a:srgbClr val=&quot;4A66AC&quot;/&gt;&lt;/a:accent1&gt;&lt;a:accent2&gt;&lt;a:srgbClr val=&quot;629DD1&quot;/&gt;&lt;/a:accent2&gt;&lt;a:accent3&gt;&lt;a:srgbClr val=&quot;297FD5&quot;/&gt;&lt;/a:accent3&gt;&lt;a:accent4&gt;&lt;a:s [rest of string was truncated]&quot;;.
</summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.My.Resources.Resources.Default_GrayScale">
<summary>
  Looks up a localized string similar to &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;
&lt;a:clrScheme xmlns:a=&quot;http://schemas.openxmlformats.org/drawingml/2006/main&quot; name=&quot;Default_GrayScale&quot;&gt;&lt;a:dk1&gt;&lt;a:sysClr val=&quot;windowText&quot; lastClr=&quot;000000&quot;/&gt;&lt;/a:dk1&gt;&lt;a:lt1&gt;&lt;a:sysClr val=&quot;window&quot; lastClr=&quot;FFFFFF&quot;/&gt;&lt;/a:lt1&gt;&lt;a:dk2&gt;&lt;a:srgbClr val=&quot;000000&quot;/&gt;&lt;/a:dk2&gt;&lt;a:lt2&gt;&lt;a:srgbClr val=&quot;F8F8F8&quot;/&gt;&lt;/a:lt2&gt;&lt;a:accent1&gt;&lt;a:srgbClr val=&quot;DDDDDD&quot;/&gt;&lt;/a:accent1&gt;&lt;a:accent2&gt;&lt;a:srgbClr val=&quot;B2B2B2&quot;/&gt;&lt;/a:accent2&gt;&lt;a:accent3&gt;&lt;a:srgbClr val=&quot;969696&quot;/&gt;&lt;/a:accent3&gt;&lt;a:accent4&gt;&lt;a: [rest of string was truncated]&quot;;.
</summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.My.Resources.Resources.Default_Green">
<summary>
  Looks up a localized string similar to &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;
&lt;a:clrScheme xmlns:a=&quot;http://schemas.openxmlformats.org/drawingml/2006/main&quot; name=&quot;Default_Green&quot;&gt;&lt;a:dk1&gt;&lt;a:sysClr val=&quot;windowText&quot; lastClr=&quot;000000&quot;/&gt;&lt;/a:dk1&gt;&lt;a:lt1&gt;&lt;a:sysClr val=&quot;window&quot; lastClr=&quot;FFFFFF&quot;/&gt;&lt;/a:lt1&gt;&lt;a:dk2&gt;&lt;a:srgbClr val=&quot;455F51&quot;/&gt;&lt;/a:dk2&gt;&lt;a:lt2&gt;&lt;a:srgbClr val=&quot;E3DED1&quot;/&gt;&lt;/a:lt2&gt;&lt;a:accent1&gt;&lt;a:srgbClr val=&quot;549E39&quot;/&gt;&lt;/a:accent1&gt;&lt;a:accent2&gt;&lt;a:srgbClr val=&quot;8AB833&quot;/&gt;&lt;/a:accent2&gt;&lt;a:accent3&gt;&lt;a:srgbClr val=&quot;C0CF3A&quot;/&gt;&lt;/a:accent3&gt;&lt;a:accent4&gt;&lt;a:srgb [rest of string was truncated]&quot;;.
</summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.My.Resources.Resources.Default_GreenYellow">
<summary>
  Looks up a localized string similar to &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;
&lt;a:clrScheme xmlns:a=&quot;http://schemas.openxmlformats.org/drawingml/2006/main&quot; name=&quot;Default_GreenYellow&quot;&gt;&lt;a:dk1&gt;&lt;a:sysClr val=&quot;windowText&quot; lastClr=&quot;000000&quot;/&gt;&lt;/a:dk1&gt;&lt;a:lt1&gt;&lt;a:sysClr val=&quot;window&quot; lastClr=&quot;FFFFFF&quot;/&gt;&lt;/a:lt1&gt;&lt;a:dk2&gt;&lt;a:srgbClr val=&quot;455F51&quot;/&gt;&lt;/a:dk2&gt;&lt;a:lt2&gt;&lt;a:srgbClr val=&quot;E2DFCC&quot;/&gt;&lt;/a:lt2&gt;&lt;a:accent1&gt;&lt;a:srgbClr val=&quot;99CB38&quot;/&gt;&lt;/a:accent1&gt;&lt;a:accent2&gt;&lt;a:srgbClr val=&quot;63A537&quot;/&gt;&lt;/a:accent2&gt;&lt;a:accent3&gt;&lt;a:srgbClr val=&quot;37A76F&quot;/&gt;&lt;/a:accent3&gt;&lt;a:accent4&gt;&lt; [rest of string was truncated]&quot;;.
</summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.My.Resources.Resources.Default_Marquee">
<summary>
  Looks up a localized string similar to &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;
&lt;a:clrScheme xmlns:a=&quot;http://schemas.openxmlformats.org/drawingml/2006/main&quot; name=&quot;Default_Marquee&quot;&gt;&lt;a:dk1&gt;&lt;a:srgbClr val=&quot;000000&quot;/&gt;&lt;/a:dk1&gt;&lt;a:lt1&gt;&lt;a:sysClr val=&quot;window&quot; lastClr=&quot;FFFFFF&quot;/&gt;&lt;/a:lt1&gt;&lt;a:dk2&gt;&lt;a:srgbClr val=&quot;5E5E5E&quot;/&gt;&lt;/a:dk2&gt;&lt;a:lt2&gt;&lt;a:srgbClr val=&quot;DDDDDD&quot;/&gt;&lt;/a:lt2&gt;&lt;a:accent1&gt;&lt;a:srgbClr val=&quot;418AB3&quot;/&gt;&lt;/a:accent1&gt;&lt;a:accent2&gt;&lt;a:srgbClr val=&quot;A6B727&quot;/&gt;&lt;/a:accent2&gt;&lt;a:accent3&gt;&lt;a:srgbClr val=&quot;F69200&quot;/&gt;&lt;/a:accent3&gt;&lt;a:accent4&gt;&lt;a:srgbClr val=&quot;838383&quot;/&gt; [rest of string was truncated]&quot;;.
</summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.My.Resources.Resources.Default_Median">
<summary>
  Looks up a localized string similar to &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;
&lt;a:clrScheme xmlns:a=&quot;http://schemas.openxmlformats.org/drawingml/2006/main&quot; name=&quot;Default_Median&quot;&gt;&lt;a:dk1&gt;&lt;a:sysClr val=&quot;windowText&quot; lastClr=&quot;000000&quot;/&gt;&lt;/a:dk1&gt;&lt;a:lt1&gt;&lt;a:sysClr val=&quot;window&quot; lastClr=&quot;FFFFFF&quot;/&gt;&lt;/a:lt1&gt;&lt;a:dk2&gt;&lt;a:srgbClr val=&quot;775F55&quot;/&gt;&lt;/a:dk2&gt;&lt;a:lt2&gt;&lt;a:srgbClr val=&quot;EBDDC3&quot;/&gt;&lt;/a:lt2&gt;&lt;a:accent1&gt;&lt;a:srgbClr val=&quot;94B6D2&quot;/&gt;&lt;/a:accent1&gt;&lt;a:accent2&gt;&lt;a:srgbClr val=&quot;DD8047&quot;/&gt;&lt;/a:accent2&gt;&lt;a:accent3&gt;&lt;a:srgbClr val=&quot;A5AB81&quot;/&gt;&lt;/a:accent3&gt;&lt;a:accent4&gt;&lt;a:srg [rest of string was truncated]&quot;;.
</summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.My.Resources.Resources.Default_Office">
<summary>
  Looks up a localized string similar to &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;
&lt;a:clrScheme xmlns:a=&quot;http://schemas.openxmlformats.org/drawingml/2006/main&quot; name=&quot;Default_Office&quot;&gt;
  &lt;a:dk1&gt;
    &lt;a:sysClr val=&quot;windowText&quot; lastClr=&quot;000000&quot;/&gt;
  &lt;/a:dk1&gt;
  &lt;a:lt1&gt;
    &lt;a:sysClr val=&quot;window&quot; lastClr=&quot;FFFFFF&quot;/&gt;
  &lt;/a:lt1&gt;
  &lt;a:dk2&gt;
    &lt;a:srgbClr val=&quot;44546A&quot;/&gt;
  &lt;/a:dk2&gt;
  &lt;a:lt2&gt;
    &lt;a:srgbClr val=&quot;E7E6E6&quot;/&gt;
  &lt;/a:lt2&gt;
  &lt;a:accent1&gt;
    &lt;a:srgbClr val=&quot;5B9BD5&quot;/&gt;
  &lt;/a:accent1&gt;
  &lt;a:accent2&gt;
    &lt;a:srgbClr val=&quot;ED7D31&quot;/&gt;
  &lt;/a:accent2 [rest of string was truncated]&quot;;.
</summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.My.Resources.Resources.Default_Office2007_2010">
<summary>
  Looks up a localized string similar to &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;
&lt;a:clrScheme xmlns:a=&quot;http://schemas.openxmlformats.org/drawingml/2006/main&quot; name=&quot;Default_Office2007-2010&quot;&gt;
  &lt;a:dk1&gt;
    &lt;a:sysClr val=&quot;windowText&quot; lastClr=&quot;000000&quot;/&gt;
  &lt;/a:dk1&gt;
  &lt;a:lt1&gt;
    &lt;a:sysClr val=&quot;window&quot; lastClr=&quot;FFFFFF&quot;/&gt;
  &lt;/a:lt1&gt;
  &lt;a:dk2&gt;
    &lt;a:srgbClr val=&quot;1F497D&quot;/&gt;
  &lt;/a:dk2&gt;
  &lt;a:lt2&gt;
    &lt;a:srgbClr val=&quot;EEECE1&quot;/&gt;
  &lt;/a:lt2&gt;
  &lt;a:accent1&gt;
    &lt;a:srgbClr val=&quot;4F81BD&quot;/&gt;
  &lt;/a:accent1&gt;
  &lt;a:accent2&gt;
    &lt;a:srgbClr val=&quot;C0504D&quot;/&gt;
  &lt;/ [rest of string was truncated]&quot;;.
</summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.My.Resources.Resources.Default_Orange">
<summary>
  Looks up a localized string similar to &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;
&lt;a:clrScheme xmlns:a=&quot;http://schemas.openxmlformats.org/drawingml/2006/main&quot; name=&quot;Default_Orange&quot;&gt;&lt;a:dk1&gt;&lt;a:srgbClr val=&quot;000000&quot;/&gt;&lt;/a:dk1&gt;&lt;a:lt1&gt;&lt;a:sysClr val=&quot;window&quot; lastClr=&quot;FFFFFF&quot;/&gt;&lt;/a:lt1&gt;&lt;a:dk2&gt;&lt;a:srgbClr val=&quot;637052&quot;/&gt;&lt;/a:dk2&gt;&lt;a:lt2&gt;&lt;a:srgbClr val=&quot;CCDDEA&quot;/&gt;&lt;/a:lt2&gt;&lt;a:accent1&gt;&lt;a:srgbClr val=&quot;E48312&quot;/&gt;&lt;/a:accent1&gt;&lt;a:accent2&gt;&lt;a:srgbClr val=&quot;BD582C&quot;/&gt;&lt;/a:accent2&gt;&lt;a:accent3&gt;&lt;a:srgbClr val=&quot;865640&quot;/&gt;&lt;/a:accent3&gt;&lt;a:accent4&gt;&lt;a:srgbClr val=&quot;9B8357&quot;/&gt;&lt; [rest of string was truncated]&quot;;.
</summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.My.Resources.Resources.Default_OrangeRed">
<summary>
  Looks up a localized string similar to &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;
&lt;a:clrScheme xmlns:a=&quot;http://schemas.openxmlformats.org/drawingml/2006/main&quot; name=&quot;Default_OrangeRed&quot;&gt;&lt;a:dk1&gt;&lt;a:sysClr val=&quot;windowText&quot; lastClr=&quot;000000&quot;/&gt;&lt;/a:dk1&gt;&lt;a:lt1&gt;&lt;a:sysClr val=&quot;window&quot; lastClr=&quot;FFFFFF&quot;/&gt;&lt;/a:lt1&gt;&lt;a:dk2&gt;&lt;a:srgbClr val=&quot;696464&quot;/&gt;&lt;/a:dk2&gt;&lt;a:lt2&gt;&lt;a:srgbClr val=&quot;E9E5DC&quot;/&gt;&lt;/a:lt2&gt;&lt;a:accent1&gt;&lt;a:srgbClr val=&quot;D34817&quot;/&gt;&lt;/a:accent1&gt;&lt;a:accent2&gt;&lt;a:srgbClr val=&quot;9B2D1F&quot;/&gt;&lt;/a:accent2&gt;&lt;a:accent3&gt;&lt;a:srgbClr val=&quot;A28E6A&quot;/&gt;&lt;/a:accent3&gt;&lt;a:accent4&gt;&lt;a: [rest of string was truncated]&quot;;.
</summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.My.Resources.Resources.Default_Paper">
<summary>
  Looks up a localized string similar to &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;
&lt;a:clrScheme xmlns:a=&quot;http://schemas.openxmlformats.org/drawingml/2006/main&quot; name=&quot;Default_Paper&quot;&gt;&lt;a:dk1&gt;&lt;a:sysClr val=&quot;windowText&quot; lastClr=&quot;000000&quot;/&gt;&lt;/a:dk1&gt;&lt;a:lt1&gt;&lt;a:sysClr val=&quot;window&quot; lastClr=&quot;FFFFFF&quot;/&gt;&lt;/a:lt1&gt;&lt;a:dk2&gt;&lt;a:srgbClr val=&quot;444D26&quot;/&gt;&lt;/a:dk2&gt;&lt;a:lt2&gt;&lt;a:srgbClr val=&quot;FEFAC9&quot;/&gt;&lt;/a:lt2&gt;&lt;a:accent1&gt;&lt;a:srgbClr val=&quot;A5B592&quot;/&gt;&lt;/a:accent1&gt;&lt;a:accent2&gt;&lt;a:srgbClr val=&quot;F3A447&quot;/&gt;&lt;/a:accent2&gt;&lt;a:accent3&gt;&lt;a:srgbClr val=&quot;E7BC29&quot;/&gt;&lt;/a:accent3&gt;&lt;a:accent4&gt;&lt;a:srgb [rest of string was truncated]&quot;;.
</summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.My.Resources.Resources.Default_Red">
<summary>
  Looks up a localized string similar to &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;
&lt;a:clrScheme xmlns:a=&quot;http://schemas.openxmlformats.org/drawingml/2006/main&quot; name=&quot;Default_Red&quot;&gt;&lt;a:dk1&gt;&lt;a:sysClr val=&quot;windowText&quot; lastClr=&quot;000000&quot;/&gt;&lt;/a:dk1&gt;&lt;a:lt1&gt;&lt;a:sysClr val=&quot;window&quot; lastClr=&quot;FFFFFF&quot;/&gt;&lt;/a:lt1&gt;&lt;a:dk2&gt;&lt;a:srgbClr val=&quot;323232&quot;/&gt;&lt;/a:dk2&gt;&lt;a:lt2&gt;&lt;a:srgbClr val=&quot;E5C243&quot;/&gt;&lt;/a:lt2&gt;&lt;a:accent1&gt;&lt;a:srgbClr val=&quot;A5300F&quot;/&gt;&lt;/a:accent1&gt;&lt;a:accent2&gt;&lt;a:srgbClr val=&quot;D55816&quot;/&gt;&lt;/a:accent2&gt;&lt;a:accent3&gt;&lt;a:srgbClr val=&quot;E19825&quot;/&gt;&lt;/a:accent3&gt;&lt;a:accent4&gt;&lt;a:srgbCl [rest of string was truncated]&quot;;.
</summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.My.Resources.Resources.Default_RedOrange">
<summary>
  Looks up a localized string similar to &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;
&lt;a:clrScheme xmlns:a=&quot;http://schemas.openxmlformats.org/drawingml/2006/main&quot; name=&quot;Default_RedOrange&quot;&gt;&lt;a:dk1&gt;&lt;a:sysClr val=&quot;windowText&quot; lastClr=&quot;000000&quot;/&gt;&lt;/a:dk1&gt;&lt;a:lt1&gt;&lt;a:sysClr val=&quot;window&quot; lastClr=&quot;FFFFFF&quot;/&gt;&lt;/a:lt1&gt;&lt;a:dk2&gt;&lt;a:srgbClr val=&quot;505046&quot;/&gt;&lt;/a:dk2&gt;&lt;a:lt2&gt;&lt;a:srgbClr val=&quot;EEECE1&quot;/&gt;&lt;/a:lt2&gt;&lt;a:accent1&gt;&lt;a:srgbClr val=&quot;E84C22&quot;/&gt;&lt;/a:accent1&gt;&lt;a:accent2&gt;&lt;a:srgbClr val=&quot;FFBD47&quot;/&gt;&lt;/a:accent2&gt;&lt;a:accent3&gt;&lt;a:srgbClr val=&quot;B64926&quot;/&gt;&lt;/a:accent3&gt;&lt;a:accent4&gt;&lt;a: [rest of string was truncated]&quot;;.
</summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.My.Resources.Resources.Default_RedViolet">
<summary>
  Looks up a localized string similar to &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;
&lt;a:clrScheme xmlns:a=&quot;http://schemas.openxmlformats.org/drawingml/2006/main&quot; name=&quot;Default_RedViolet&quot;&gt;&lt;a:dk1&gt;&lt;a:sysClr val=&quot;windowText&quot; lastClr=&quot;000000&quot;/&gt;&lt;/a:dk1&gt;&lt;a:lt1&gt;&lt;a:sysClr val=&quot;window&quot; lastClr=&quot;FFFFFF&quot;/&gt;&lt;/a:lt1&gt;&lt;a:dk2&gt;&lt;a:srgbClr val=&quot;454551&quot;/&gt;&lt;/a:dk2&gt;&lt;a:lt2&gt;&lt;a:srgbClr val=&quot;D8D9DC&quot;/&gt;&lt;/a:lt2&gt;&lt;a:accent1&gt;&lt;a:srgbClr val=&quot;E32D91&quot;/&gt;&lt;/a:accent1&gt;&lt;a:accent2&gt;&lt;a:srgbClr val=&quot;C830CC&quot;/&gt;&lt;/a:accent2&gt;&lt;a:accent3&gt;&lt;a:srgbClr val=&quot;4EA6DC&quot;/&gt;&lt;/a:accent3&gt;&lt;a:accent4&gt;&lt;a: [rest of string was truncated]&quot;;.
</summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.My.Resources.Resources.Default_Slipstream">
<summary>
  Looks up a localized string similar to &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;
&lt;a:clrScheme xmlns:a=&quot;http://schemas.openxmlformats.org/drawingml/2006/main&quot; name=&quot;Default_Slipstream&quot;&gt;
  &lt;a:dk1&gt;
    &lt;a:sysClr val=&quot;windowText&quot; lastClr=&quot;000000&quot;/&gt;
  &lt;/a:dk1&gt;
  &lt;a:lt1&gt;
    &lt;a:sysClr val=&quot;window&quot; lastClr=&quot;FFFFFF&quot;/&gt;
  &lt;/a:lt1&gt;
  &lt;a:dk2&gt;
    &lt;a:srgbClr val=&quot;212745&quot;/&gt;
  &lt;/a:dk2&gt;
  &lt;a:lt2&gt;
    &lt;a:srgbClr val=&quot;B4DCFA&quot;/&gt;
  &lt;/a:lt2&gt;
  &lt;a:accent1&gt;
    &lt;a:srgbClr val=&quot;4E67C8&quot;/&gt;
  &lt;/a:accent1&gt;
  &lt;a:accent2&gt;
    &lt;a:srgbClr val=&quot;5ECCF3&quot;/&gt;
  &lt;/a:acc [rest of string was truncated]&quot;;.
</summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.My.Resources.Resources.Default_Violet">
<summary>
  Looks up a localized string similar to &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;
&lt;a:clrScheme xmlns:a=&quot;http://schemas.openxmlformats.org/drawingml/2006/main&quot; name=&quot;Default_Violet&quot;&gt;&lt;a:dk1&gt;&lt;a:sysClr val=&quot;windowText&quot; lastClr=&quot;000000&quot;/&gt;&lt;/a:dk1&gt;&lt;a:lt1&gt;&lt;a:sysClr val=&quot;window&quot; lastClr=&quot;FFFFFF&quot;/&gt;&lt;/a:lt1&gt;&lt;a:dk2&gt;&lt;a:srgbClr val=&quot;373545&quot;/&gt;&lt;/a:dk2&gt;&lt;a:lt2&gt;&lt;a:srgbClr val=&quot;DCD8DC&quot;/&gt;&lt;/a:lt2&gt;&lt;a:accent1&gt;&lt;a:srgbClr val=&quot;AD84C6&quot;/&gt;&lt;/a:accent1&gt;&lt;a:accent2&gt;&lt;a:srgbClr val=&quot;8784C7&quot;/&gt;&lt;/a:accent2&gt;&lt;a:accent3&gt;&lt;a:srgbClr val=&quot;5D739A&quot;/&gt;&lt;/a:accent3&gt;&lt;a:accent4&gt;&lt;a:srg [rest of string was truncated]&quot;;.
</summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.My.Resources.Resources.Default_Violet2">
<summary>
  Looks up a localized string similar to &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;
&lt;a:clrScheme xmlns:a=&quot;http://schemas.openxmlformats.org/drawingml/2006/main&quot; name=&quot;Default_Violet2&quot;&gt;&lt;a:dk1&gt;&lt;a:sysClr val=&quot;windowText&quot; lastClr=&quot;000000&quot;/&gt;&lt;/a:dk1&gt;&lt;a:lt1&gt;&lt;a:sysClr val=&quot;window&quot; lastClr=&quot;FFFFFF&quot;/&gt;&lt;/a:lt1&gt;&lt;a:dk2&gt;&lt;a:srgbClr val=&quot;632E62&quot;/&gt;&lt;/a:dk2&gt;&lt;a:lt2&gt;&lt;a:srgbClr val=&quot;EAE5EB&quot;/&gt;&lt;/a:lt2&gt;&lt;a:accent1&gt;&lt;a:srgbClr val=&quot;92278F&quot;/&gt;&lt;/a:accent1&gt;&lt;a:accent2&gt;&lt;a:srgbClr val=&quot;9B57D3&quot;/&gt;&lt;/a:accent2&gt;&lt;a:accent3&gt;&lt;a:srgbClr val=&quot;755DD9&quot;/&gt;&lt;/a:accent3&gt;&lt;a:accent4&gt;&lt;a:sr [rest of string was truncated]&quot;;.
</summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.My.Resources.Resources.Default_Yellow">
<summary>
  Looks up a localized string similar to &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;
&lt;a:clrScheme xmlns:a=&quot;http://schemas.openxmlformats.org/drawingml/2006/main&quot; name=&quot;Default_Yellow&quot;&gt;&lt;a:dk1&gt;&lt;a:sysClr val=&quot;windowText&quot; lastClr=&quot;000000&quot;/&gt;&lt;/a:dk1&gt;&lt;a:lt1&gt;&lt;a:sysClr val=&quot;window&quot; lastClr=&quot;FFFFFF&quot;/&gt;&lt;/a:lt1&gt;&lt;a:dk2&gt;&lt;a:srgbClr val=&quot;39302A&quot;/&gt;&lt;/a:dk2&gt;&lt;a:lt2&gt;&lt;a:srgbClr val=&quot;E5DEDB&quot;/&gt;&lt;/a:lt2&gt;&lt;a:accent1&gt;&lt;a:srgbClr val=&quot;FFCA08&quot;/&gt;&lt;/a:accent1&gt;&lt;a:accent2&gt;&lt;a:srgbClr val=&quot;F8931D&quot;/&gt;&lt;/a:accent2&gt;&lt;a:accent3&gt;&lt;a:srgbClr val=&quot;CE8D3E&quot;/&gt;&lt;/a:accent3&gt;&lt;a:accent4&gt;&lt;a:srg [rest of string was truncated]&quot;;.
</summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.My.Resources.Resources.Default_YellowOrange">
<summary>
  Looks up a localized string similar to &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;
&lt;a:clrScheme xmlns:a=&quot;http://schemas.openxmlformats.org/drawingml/2006/main&quot; name=&quot;Default_YellowOrange&quot;&gt;&lt;a:dk1&gt;&lt;a:sysClr val=&quot;windowText&quot; lastClr=&quot;000000&quot;/&gt;&lt;/a:dk1&gt;&lt;a:lt1&gt;&lt;a:sysClr val=&quot;window&quot; lastClr=&quot;FFFFFF&quot;/&gt;&lt;/a:lt1&gt;&lt;a:dk2&gt;&lt;a:srgbClr val=&quot;4E3B30&quot;/&gt;&lt;/a:dk2&gt;&lt;a:lt2&gt;&lt;a:srgbClr val=&quot;FBEEC9&quot;/&gt;&lt;/a:lt2&gt;&lt;a:accent1&gt;&lt;a:srgbClr val=&quot;F0A22E&quot;/&gt;&lt;/a:accent1&gt;&lt;a:accent2&gt;&lt;a:srgbClr val=&quot;A5644E&quot;/&gt;&lt;/a:accent2&gt;&lt;a:accent3&gt;&lt;a:srgbClr val=&quot;B58B80&quot;/&gt;&lt;/a:accent3&gt;&lt;a:accent4&gt; [rest of string was truncated]&quot;;.
</summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.My.Resources.Resources.designer_colors">
<summary>
  Looks up a localized resource of type System.Byte[].
</summary>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.d3js.SVG.CSS.DirectedForceGraph">
 <summary>
 Style generator for the value of <see cref="P:Microsoft.VisualBasic.MIME.Html.XmlMeta.CSS.style"/>
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.d3js.Layout.Anchor">
 <summary>
 
 </summary>
 <remarks>
 anchor point can be created via <see cref="M:Microsoft.VisualBasic.Imaging.d3js.ModuleAPI.GetLabelAnchors(System.Collections.Generic.IEnumerable{Microsoft.VisualBasic.Imaging.d3js.Layout.Label},System.Single)"/> function
 </remarks>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.d3js.Layout.Anchor.x">
 <summary>
 the x-coordinate of the anchor.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.d3js.Layout.Anchor.y">
 <summary>
 the y-coordinate of the anchor.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.d3js.Layout.Anchor.r">
 <summary>
 the anchor radius (assuming anchor is a circle).
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.d3js.Layout.Anchor.#ctor(System.Drawing.Rectangle)">
 <summary>
 目标节点的绘图模型
 </summary>
 <param name="circle">假设anchor是一个圆，画圆的时候是依据矩形框来建模的</param>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.d3js.Layout.DataLabeler.unpinnedLabels">
 <summary>
 the index of the labels which is unpinned
 (can move on the canvas) in the array of 
 <see cref="F:Microsoft.VisualBasic.Imaging.d3js.Layout.DataLabeler.m_labels"/>, this index value 
 can also used for read anchor object from 
 the <see cref="F:Microsoft.VisualBasic.Imaging.d3js.Layout.DataLabeler.m_anchors"/>.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.d3js.Layout.DataLabeler.CANVAS_WIDTH">
 <summary>
 box width/height
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.d3js.Layout.DataLabeler.Start(System.Int32,System.Boolean)">
 <summary>
 main simulated annealing function.
 (这个函数运行完成之后，可以直接使用<see cref="P:Microsoft.VisualBasic.Imaging.d3js.Layout.Label.X"/>和
 <see cref="P:Microsoft.VisualBasic.Imaging.d3js.Layout.Label.Y"/>位置数据进行作图)
 </summary>
 <param name="nsweeps"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.d3js.Layout.DataLabeler.Width(System.Double)">
 <summary>
 users insert graph width
 </summary>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.d3js.Layout.DataLabeler.Height(System.Double)">
 <summary>
 users insert graph height
 </summary>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.d3js.Layout.DataLabeler.Labels(System.Collections.Generic.IEnumerable{Microsoft.VisualBasic.Imaging.d3js.Layout.Label})">
 <summary>
 users insert label positions
 </summary>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.d3js.Layout.DataLabeler.Anchors(System.Collections.Generic.IEnumerable{Microsoft.VisualBasic.Imaging.d3js.Layout.Anchor})">
 <summary>
 users insert anchor positions
 </summary>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.d3js.Layout.Forcedirected.avoidRegions">
 <summary>
 会尽量避免在这个区域内存在网络的节点，这个区域一般为legend的绘制区域
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.d3js.Layout.Forcedirected.runRepulsive">
 <summary>
 标签节点之间存在的排斥力
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.d3js.Layout.Forcedirected.runAttraction">
 <summary>
 标签节点与anchor之间得吸引力
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.d3js.Layout.Label">
 <summary>
 a text label object
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.d3js.Layout.Label.X">
 <summary>
 the x-coordinate of the label.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.d3js.Layout.Label.Y">
 <summary>
 the y-coordinate of the label.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.d3js.Layout.Label.width">
 <summary>
 the width of the label (approximating the label as a rectangle).
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.d3js.Layout.Label.height">
 <summary>
 the height of the label (same approximation).
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.d3js.Layout.Label.text">
 <summary>
 the label text.
 </summary>
 <returns></returns>
 <remarks>
 20200618 实际上这个标签文本与实际的标签没有很多关联，也可以为一个用于获取图片对象的主键
 </remarks>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.d3js.Layout.Label.pinned">
 <summary>
 在计算位置的时候，这个标签将不会被随机模拟事件选中
 即这个标签当这个属性为true的时候不会发生任何变化
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.d3js.Layout.Label.rectangle">
 <summary>
 当前的这个文本标签对象所处的位置以及所占据的大小等数据
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.d3js.Layout.Label.location">
 <summary>
 [x, y]
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.d3js.Layout.Label.#ctor(Microsoft.VisualBasic.Imaging.d3js.Layout.Label)">
 <summary>
 make value copy of the text label data
 </summary>
 <param name="copy"></param>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.d3js.Layout.Labeler">
 <summary>
 A D3 plug-in for automatic label placement using simulated annealing that 
 easily incorporates into existing D3 code, with syntax mirroring other 
 D3 layouts.
 </summary>
 <remarks>
 https://github.com/tinker10/D3-Labeler
 </remarks>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.d3js.Layout.Labeler.maxMove">
 <summary>
 the max move distance in each loop iteration
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.d3js.Layout.Labeler.maxDistance">
 <summary>
 the max total move distance of the label with 
 the corresponding anchor point.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.d3js.Layout.Labeler.energy(System.Int32)">
 <summary>
 energy function, tailored for label placement
 </summary>
 <param name="index%"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.d3js.Layout.Labeler.intersect(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
 <summary>
 returns true if two lines intersect, else false
 from http:'paulbourke.net/geometry/lineline2d/
 </summary>
 <param name="x1"></param>
 <param name="x2"></param>
 <param name="x3"></param>
 <param name="x4"></param>
 <param name="y1"></param>
 <param name="y2"></param>
 <param name="y3"></param>
 <param name="y4"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.d3js.Layout.Labeler.mclMove(System.Int32)">
 <summary>
 Monte Carlo translation move
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.d3js.Layout.Labeler.mclRotate(System.Int32)">
 <summary>
 Monte Carlo rotation move
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.d3js.Layout.Labeler.coolingSchedule(System.Double,System.Double,System.Double)">
 <summary>
 Default is using linear cooling
 </summary>
 <param name="currT#"></param>
 <param name="initialT#"></param>
 <param name="nsweeps#"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.d3js.Layout.Labeler.Start(System.Int32,System.Boolean)">
 <summary>
 main simulated annealing function.(这个函数运行完成之后，可以直接使用<see cref="P:Microsoft.VisualBasic.Imaging.d3js.Layout.Label.X"/>和<see cref="P:Microsoft.VisualBasic.Imaging.d3js.Layout.Label.Y"/>位置数据进行作图)
 </summary>
 <param name="nsweeps"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.d3js.Layout.Labeler.EnergyFunction(System.Func{System.Int32,Microsoft.VisualBasic.Imaging.d3js.Layout.Label[],Microsoft.VisualBasic.Imaging.d3js.Layout.Anchor[],System.Double})">
 <summary>
 user defined energy
 </summary>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.d3js.Layout.Labeler.coolingSchedule(Microsoft.VisualBasic.Imaging.d3js.Layout.CoolingSchedule)">
 <summary>
 user defined cooling_schedule
 </summary>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.d3js.ModuleAPI.labeler(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
 <summary>
 A D3 plug-in for automatic label placement using simulated annealing that easily 
 incorporates into existing D3 code, with syntax mirroring other D3 layouts.
 </summary>
 <param name="w_len">
 penalty for length of leader line. positive value for penalty, zero for dont care and negative for encourage
 </param>
 <returns></returns>
 
</member>
<member name="T:Microsoft.VisualBasic.Imaging.d3js.ScaleChromatic">
 <summary>
 ###### d3-scale-chromatic
 
 > https://github.com/d3/d3-scale-chromatic
 
 This module provides sequential, diverging and categorical color schemes derived from Cynthia A. Brewer’s ColorBrewer. 
 Since ColorBrewer publishes only discrete color schemes, the sequential and diverging scales are interpolated using 
 uniform B-splines. These schemes and interpolators are designed to work with d3-scale’s d3.scaleOrdinal and 
 d3.scaleSequential. 
 
 For example, to create a categorical color scale using the Accent color scheme:

 ```vbnet
 Dim color = d3js.scaleOrdinal(d3js.schemeAccent)
 ```

 To create a diverging color scale using the PiYG color scheme:
 
 ```vbnet
 Dim color = d3js.scaleSequential(d3js.interpolatePiYG)
 ```
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.d3js.ScaleChromatic.category10">
 <summary>
 ``# d3.scale.category10()``
 Constructs a new ordinal scale with a range of ten categorical colors:
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.d3js.ScaleChromatic.category20">
 <summary>
 ``# d3.scale.category20()``
 
 Constructs a new ordinal scale with a range of twenty categorical colors:
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.d3js.ScaleChromatic.category20b">
 <summary>
 ``# d3.scale.category20b()``
 
 Constructs a new ordinal scale with a range of twenty categorical colors:
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.d3js.ScaleChromatic.category20c">
 <summary>
 ``# d3.scale.category20c()``
 
 Constructs a new ordinal scale with a range of twenty categorical colors:
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.d3js.scale.Extensions">
 <summary>
 + Continuous scales map a continuous, quantitative input domain to a continuous output range. 
   If the range is also numeric, the mapping may be inverted. A continuous scale is not 
   constructed directly; instead, try a linear, power, log, identity, time or sequential color 
   scale.
 + Sequential scales are similar to continuous scales in that they map a continuous, numeric 
   input domain to a continuous output range. However, unlike continuous scales, the output range 
   of a sequential scale is fixed by its interpolator and not configurable. These scales do not 
   expose invert, range, rangeRound and interpolate methods.
 + Unlike continuous scales, ordinal scales have a discrete domain and range. For example, an 
   ordinal scale might map a set of named categories to a set of colors, or determine the 
   horizontal positions of columns in a column chart.
 </summary>
 <remarks>
 + https://stackoverflow.com/questions/29785238/d3-different-between-scale-in-ordinal-and-linear
 </remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.d3js.scale.Extensions.ordinal">
 <summary>
 > Ordinal scales have a discrete domain, such as a set of names or categories.
 > An ordinal scale's values must be coercible to a string, and the stringified 
 > version of the domain value uniquely identifies the corresponding range value.
 
 So, as an example, a domain of an ordinal scale may contain names, like so:

 ```javascript
 var ordinalScale = d3.scale.ordinal()
     .domain(['Alice', 'Bob'])
     .range([0, 100]);

 ordinalScale('Alice'); // 0
 ordinalScale('Bob');   // 100
 ```
 
 Notice how all values are strings. They cannot be interpolated. What Is between 
 'Alice' and 'Bob'? I don't know. Neither does D3.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.d3js.scale.Extensions.linear(System.Boolean)">
 <summary>
 > Quantitative scales have a continuous domain, such as the set of real numbers, or dates.
 
 As an example, you can construct the following scale:

 ```javascript
 var linearScale = d3.scale.linear()
     .domain([0, 10])
     .range([0, 100]);

 linearScale(0);  // 0
 linearScale(5);  // 50
 linearScale(10); // 100
 ```
 
 Notice how D3 Is able To interpolate 5 even If we haven't specified it explicitly in the 
 domain.
 </summary>
 <returns>
 Constructs a new continuous scale with the unit domain [0, 1], the unit range [0, 1], 
 the default interpolator and clamping disabled. Linear scales are a good default 
 choice for continuous quantitative data because they preserve proportional differences. 
 Each range value y can be expressed as a function of the domain value x: ``y = mx + b``.
 </returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.d3js.scale.Scaler">
 <summary>
 data scaler and transform
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.d3js.scale.Scaler.Value(System.Double)">
 <summary>
 value transform
 </summary>
 <param name="x#"></param>
 <returns>
 pixel value in plot range
 </returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.d3js.scale.Scaler.Value(System.String)">
 <summary>
 term value transform
 </summary>
 <param name="term$"></param>
 <returns>
 pixel value in plot range
 </returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.d3js.scale.Scaler.Value(System.Array)">
 <summary>
 
 </summary>
 <param name="vector">
 vector should be a string array or float64 numeric array
 </param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.d3js.scale.Scaler.Zero">
 <summary>
 返回用户作图数据为零的时候的绘图位置映射结果数据
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.d3js.scale.Scaler.domainSize">
 <summary>
 作图的用户数据的区间长度
 </summary>
 <returns>
 + 对于<see cref="T:Microsoft.VisualBasic.Imaging.d3js.scale.LinearScale"/>这个属性值为浮点数
 + 对于<see cref="T:Microsoft.VisualBasic.Imaging.d3js.scale.OrdinalScale"/>这个属性值为整形数
 </returns>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.d3js.scale.IScale`1._range">
 <summary>
 绘图的时候的实际的像素区间
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.d3js.scale.IScale`1.range(System.Collections.Generic.IEnumerable{System.Double})">
 <summary>
 If range is specified, sets the range of the ordinal scale to the specified array of values. 
 The first element in the domain will be mapped to the first element in range, the second 
 domain value to the second range value, and so on. If there are fewer elements in the range 
 than in the domain, the scale will reuse values from the start of the range. If range is 
 not specified, this method returns the current range.
 </summary>
 <param name="values"></param>
 <returns></returns>
 <remarks>
 (设置绘图的实际的像素区间)
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.d3js.scale.IScale`1.range(System.Collections.Generic.IEnumerable{System.Int32})">
 <summary>
 输入绘图的坐标轴在画布上面的X/Y值的范围(设置绘图的实际的像素区间)
 </summary>
 <param name="integers"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.d3js.scale.IScale`1.range(System.Collections.Generic.IEnumerable{System.Single})">
 <summary>
 (设置绘图的实际的像素区间)
 </summary>
 <param name="singles"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.d3js.scale.LinearScale">
 <summary>
 连续性的映射
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.d3js.scale.LinearScale._domain">
 <summary>
 作图的时候的用户数据区间
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.d3js.scale.LinearScale._reverse">
 <summary>
 适用于Y坐标轴数据的映射，因为Y坐标轴与绘制的像素Y之间是反过来的关系
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.d3js.scale.LinearScale.valueDomain">
 <summary>
 作图的时候的用户数据区间
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.d3js.scale.LinearScale.domainSize">
 <summary>
 <see cref="P:Microsoft.VisualBasic.ComponentModel.Ranges.Model.DoubleRange.Length"/> value of <see cref="P:Microsoft.VisualBasic.Imaging.d3js.scale.LinearScale.valueDomain"/>
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.d3js.scale.LinearScale.#ctor(System.Boolean)">
 <summary>
 Constructs a new continuous scale with the unit domain [0, 1], the unit range [0, 1], 
 the default interpolator and clamping disabled. Linear scales are a good default 
 choice for continuous quantitative data because they preserve proportional differences. 
 Each range value y can be expressed as a function of the domain value x: ``y = mx + b``.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.d3js.scale.LinearScale.Value(System.Double)">
 <summary>
 将图形数据映射为实际的像素位置
 </summary>
 <param name="x"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.d3js.scale.LinearScale.domain(System.Collections.Generic.IEnumerable{System.Double})">
 <summary>
 输入的绘图数据，建议输入由原始数据所计算出来的Ticks的结果
 </summary>
 <param name="values"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.d3js.scale.LinearScale.domain(System.Collections.Generic.IEnumerable{System.String})">
 <summary>
 设置绘图的值区间
 </summary>
 <param name="values"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.d3js.scale.LinearScale.domain(System.Collections.Generic.IEnumerable{System.Int32})">
 <summary>
 设置绘图的值区间
 </summary>
 <param name="values"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.d3js.scale.LinearScale.domain(System.Collections.Generic.IEnumerable{System.Single})">
 <summary>
 设置绘图的值区间
 </summary>
 <param name="singles"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.d3js.scale.MapperTypes">
 <summary>
 从graphics的属性值到相应的图形属性(大小，颜色，字体，形状)的映射操作类型
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.d3js.scale.MapperTypes.Continuous">
 <summary>
 连续的数值型的映射
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.d3js.scale.MapperTypes.Discrete">
 <summary>
 离散的分类映射
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.d3js.scale.MapperTypes.Passthrough">
 <summary>
 直接映射
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.d3js.scale.OrdinalScale">
 <summary>
 Unlike continuous scales, ordinal scales have a discrete domain and range. 
 For example, an ordinal scale might map a set of named categories to a 
 set of colors, or determine the horizontal positions of columns in a column 
 chart.
 (相当于cytoscape之中的离散型映射)
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.d3js.scale.OrdinalScale.domainSize">
 <summary>
 count of the term factors
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.d3js.scale.OrdinalScale.range(System.Collections.Generic.IEnumerable{System.Double})">
 <summary>
 set the plot canvas region boundary
 </summary>
 <param name="values"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.d3js.scale.OrdinalScale.range(System.Double,System.Double)">
 <summary>
 set the plot canvas region boundary
 </summary>
 <param name="min"></param>
 <param name="max"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.d3js.scale.OrdinalScale.domain(System.Collections.Generic.IEnumerable{System.Double})">
 <summary>
 set the ordinal value range, the input numeric value will be transform as the string term factors in this function.
 </summary>
 <param name="values"></param>
 <returns></returns>
 <remarks>
 the term ordinal value could be get from the <see cref="M:Microsoft.VisualBasic.Imaging.d3js.scale.OrdinalScale.getTerms"/> function.
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.d3js.scale.OrdinalScale.domain(System.Collections.Generic.IEnumerable{System.String})">
 <summary>
 If domain is specified, sets the domain to the specified array of values. 
 The first element in domain will be mapped to the first element in the range, 
 the second domain value to the second range value, and so on. Domain values 
 are stored internally in a map from stringified value to index; the resulting 
 index is then used to retrieve a value from the range. Thus, an ordinal scale’s 
 values must be coercible to a string, and the stringified version of the domain 
 value uniquely identifies the corresponding range value. If domain is not specified, 
 this method returns the current domain.

 Setting the domain On an ordinal scale Is Optional If the unknown value Is implicit 
 (the Default). In this Case, the domain will be inferred implicitly from usage by 
 assigning Each unique value passed To the scale a New value from the range. Note 
 that an explicit domain Is recommended To ensure deterministic behavior, As inferring 
 the domain from usage will be dependent On ordering.
 </summary>
 <param name="tags"></param>
 <returns></returns>
 <remarks>
 the term ordinal value could be get from the <see cref="M:Microsoft.VisualBasic.Imaging.d3js.scale.OrdinalScale.getTerms"/> function.
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.d3js.scale.OrdinalScale.domain(System.Collections.Generic.IEnumerable{System.Int32})">
 <summary>
 set the ordinal value range, the input integer value will be transform as the string term factors in this function.
 </summary>
 <param name="values"></param>
 <returns></returns>
 <remarks>
 the term ordinal value could be get from the <see cref="M:Microsoft.VisualBasic.Imaging.d3js.scale.OrdinalScale.getTerms"/> function.
 </remarks>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.ColorBrewer">
 <summary>
 Colorbrewer is a nice application for creating color schemes.
 (color data source: https://github.com/xieguigang/sciBASIC/blob/e9ebaf2670ffca4eab35338cb08d84f8ec3d54c8/gr/Colors/colorbrewer/colorbrewer.json)
 </summary>
 <remarks>
 1. Sequential schemes are suited to ordered data that progress from low to high. Lightness steps dominate the 
 look of these schemes, with light colors for low data values to dark colors for high data values. 
 
 2. Diverging schemes put equal emphasis on mid-range critical values and extremes at both ends of the data range. 
 The critical class or break in the middle of the legend is emphasized with light colors and low and high extremes 
 are emphasized with dark colors that have contrasting hues. diverging
 Diverging schemes are most effective when the class break in the middle of the sequence, or the lightest middle 
 color, is meaningfully related to the mapped data. Use the break or class emphasized by a hue and lightness change 
 to represent a critical value in the data such as the mean, median, or zero. Colors increase in darkness to 
 represent differences in both directions from this meaningful mid-range value in the data.
 
 NOTE: Although we have designed the diverging schemes to be symmetrical, you may need to customize schemes by 
 moving the critical break/class closer to one end of the sequence to suit your map data. For example, a map of 
 population change might have two classes of population loss and five classes of growth, requiring a scheme 
 with only two colors on one side of a zero-change break and five on the other. Choose a scheme with ten-colors 
 and omit three colors from the loss side of the scheme.

 3. Qualitative schemes do not imply magnitude differences between legend classes, and hues are used to create the 
 primary visual differences between classes. Qualitative schemes are best suited to representing nominal or 
 categorical data. 
 
 Most of the qualitative schemes rely on differences in hue with only subtle lightness differences between colors. 
 You may pick a subset of colors from a legend with more classes if you are not pleased with the subsets. 
 For example, you could pick four colors from a seven-color legend. Two exceptions to the use of consistent lightness:
 
 +  paired scheme
    Paired Scheme: This scheme presents a series of lightness pairs for each hue (e.g. light green and dark green). 
    Use this when you have categories that should be visually related, though they are not explicitly ordered. 
    For example, 'forest' and 'woodland' would be suitably represented with dark and light green.
 +  accent scheme
    Accent Scheme: Use to accent small areas or important classes with colors that are more saturated/darker/lighter 
    than others in the scheme - found at the bottom of the 'Accents' legends. Beware of emphasizing unimportant 
    classes when you use qualitative schemes.
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.ColorBrewer.ParseName(System.String)">
 <summary>
 example: ``Accent:c6``
 </summary>
 <param name="term$"></param>
 <returns></returns>
 
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.ColorBrewer.DivergingSchemes">
 <summary>
 Diverging schemes put equal emphasis on mid-range critical values and extremes at both ends of the data range. 
 The critical class or break in the middle of the legend is emphasized with light colors and low and high extremes 
 are emphasized with dark colors that have contrasting hues.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.ColorBrewer.Spectral">
 <summary>
 div
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.ColorBrewer.RdYlGn">
 <summary>
 div
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.ColorBrewer.RdBu">
 <summary>
 div
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.ColorBrewer.PiYG">
 <summary>
 div
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.ColorBrewer.PRGn">
 <summary>
 div
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.ColorBrewer.RdYlBu">
 <summary>
 div
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.ColorBrewer.BrBG">
 <summary>
 div
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.ColorBrewer.RdGy">
 <summary>
 div
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.ColorBrewer.PuOr">
 <summary>
 div
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.ColorBrewer.QualitativeSchemes">
 <summary>
 Qualitative schemes do not imply magnitude differences between legend classes, and hues are used to create the 
 primary visual differences between classes. Qualitative schemes are best suited to representing nominal or 
 categorical data. 
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.ColorBrewer.Set2">
 <summary>
 qual
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.ColorBrewer.Accent">
 <summary>
 qual
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.ColorBrewer.Set1">
 <summary>
 qual
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.ColorBrewer.Set3">
 <summary>
 qual
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.ColorBrewer.Dark2">
 <summary>
 qual
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.ColorBrewer.Paired">
 <summary>
 qual
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.ColorBrewer.Pastel2">
 <summary>
 qual
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.ColorBrewer.Pastel1">
 <summary>
 qual
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.ColorBrewer.SequentialSchemes">
 <summary>
 Sequential schemes are suited to ordered data that progress from low to high. Lightness steps dominate the 
 look of these schemes, with light colors for low data values to dark colors for high data values. 
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.ColorBrewer.OrRd">
 <summary>
 seq
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.ColorBrewer.PuBu">
 <summary>
 seq
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.ColorBrewer.BuPu">
 <summary>
 seq
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.ColorBrewer.Oranges">
 <summary>
 seq
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.ColorBrewer.BuGn">
 <summary>
 seq
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.ColorBrewer.YlOrBr">
 <summary>
 seq
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.ColorBrewer.YlGn">
 <summary>
 seq
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.ColorBrewer.Reds">
 <summary>
 seq
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.ColorBrewer.RdPu">
 <summary>
 seq
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.ColorBrewer.Greens">
 <summary>
 seq
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.ColorBrewer.YlGnBu">
 <summary>
 seq
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.ColorBrewer.Purples">
 <summary>
 seq
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.ColorBrewer.GnBu">
 <summary>
 seq
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.ColorBrewer.Greys">
 <summary>
 seq
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.ColorBrewer.YlOrRd">
 <summary>
 seq
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.ColorBrewer.PuRd">
 <summary>
 seq
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.ColorBrewer.Blues">
 <summary>
 seq
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.ColorBrewer.PuBuGn">
 <summary>
 seq
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.CustomDesigns.TSF">
 <summary>
 From TSF launcher on Android
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.CustomDesigns.ClusterColour">
 <summary>
 10 category colors for the data object cluster result
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.CustomDesigns.ExtractThemeColors(Microsoft.VisualBasic.Imaging.Bitmap,System.Int32,System.Double,System.Byte,System.Byte)">
 <summary>
 extract the theme colors from the given bitmap image
 </summary>
 <param name="src"></param>
 <param name="topN"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.Designer">
 <summary>
 Generate color sequence
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.Designer.AvailableInterpolates">
<summary>
 {  
  &quot;Color [PapayaWhip]&quot;: [
    {
      &quot;knownColor&quot;: 93,
      &quot;name&quot;: null,
      &quot;state&quot;: 1,
      &quot;value&quot;: 0
    },
    {
      &quot;knownColor&quot;: 119,
      &quot;name&quot;: null,
      &quot;state&quot;: 1,
      &quot;value&quot;: 0
    },
    {
      &quot;knownColor&quot;: 30,
      &quot;name&quot;: null,
      &quot;state&quot;: 1,
      &quot;value&quot;: 0
    },
    {
      &quot;knownColor&quot;: 165,
      &quot;name&quot;: null,
      &quot;state&quot;: 1,
      &quot;value&quot;: 0
    },
    {
      &quot;knownColor&quot;: 81,
      &quot;name&quot;: null,
      &quot;state&quot;: 1,
      &quot;value&quot;: [rest of string was truncated]&quot;;.
</summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.Designer.Clusters">
 <summary>
 <see cref="M:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.Designer.GetColors(System.String)"/> schema name for color profile: <see cref="M:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.CustomDesigns.ClusterColour"/>.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.Designer.ConsoleColors">
 <summary>
 16 console colors
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.Designer.ConsoleColor(System.ConsoleColor)">
 <summary>
 将<see cref="T:System.ConsoleColor"/>枚举值转换为gdi+颜色对象
 </summary>
 <param name="color"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.Designer.#cctor">
 <summary>
 
 </summary>
 <remarks>
 ###### 2017-9-7
 
 mono的Json反序列化任然存在问题
 
 [ERROR 2017/9/7 10:03:20] &lt;Print>::System.Exception: Print ---> System.Reflection.TargetInvocationException: Exception has been thrown by the target of an invocation. ---> System.TypeInitializationException: The type initializer for 'Microsoft.VisualBasic.Imaging.Drawing2D.Colors.Designer' threw an exception. ---> System.Reflection.TargetInvocationException: Exception has been thrown by the target of an invocation. ---> System.ArgumentNullException: Value cannot be null.
 Parameter name :  key
   at System.Collections.Generic.Dictionary`2[TKey,TValue].TryInsert (TKey key, TValue value, System.Collections.Generic.InsertionBehavior behavior) [0x00008] In &lt;902ab9e386384bec9c07fa19aa938869>:0
   at System.Collections.Generic.Dictionary`2[TKey,TValue].Add (TKey key, TValue value) [0x00000] In &lt;902ab9e386384bec9c07fa19aa938869>:0
   at (wrapper managed-to-native) System.Reflection.MonoMethod:InternalInvoke (System.Reflection.MonoMethod,object,object[],System.Exception&amp;)
   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x00032] In &lt;902ab9e386384bec9c07fa19aa938869>:0
    --- End of inner exception stack trace ---
   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x00048] In &lt;902ab9e386384bec9c07fa19aa938869>:0
   at System.Reflection.MethodBase.Invoke (System.Object obj, System.Object[] parameters) [0x00000] In &lt;902ab9e386384bec9c07fa19aa938869>:0
   at System.Runtime.Serialization.Json.JsonFormatReaderInterpreter.ReadSimpleDictionary (System.Runtime.Serialization.CollectionDataContract collectionContract, System.Type keyValueType) [0x0014a] In &lt;8a29d8bc61874dfaa700acd3dd58b577>:0
   at System.Runtime.Serialization.Json.JsonFormatReaderInterpreter.ReadCollection (System.Runtime.Serialization.CollectionDataContract collectionContract) [0x000fe] In &lt;8a29d8bc61874dfaa700acd3dd58b577>:0
   at System.Runtime.Serialization.Json.JsonFormatReaderInterpreter.ReadCollectionFromJson (System.Runtime.Serialization.XmlReaderDelegator xmlReader, System.Runtime.Serialization.Json.XmlObjectSerializerReadContextComplexJson context, System.Xml.XmlDictionaryString emptyDictionaryString, System.Xml.XmlDictionaryString itemName, System.Runtime.Serialization.CollectionDataContract collectionContract) [0x00025] In &lt;8a29d8bc61874dfaa700acd3dd58b577>:0
   at System.Runtime.Serialization.Json.JsonFormatReaderGenerator+CriticalHelper+&lt;>c__DisplayClass1_0.&lt;GenerateCollectionReader>b__0 (System.Runtime.Serialization.XmlReaderDelegator xr, System.Runtime.Serialization.Json.XmlObjectSerializerReadContextComplexJson ctx, System.Xml.XmlDictionaryString emptyDS, System.Xml.XmlDictionaryString inm, System.Runtime.Serialization.CollectionDataContract cc) [0x0000c] In &lt;8a29d8bc61874dfaa700acd3dd58b577>:0
   at System.Runtime.Serialization.Json.JsonCollectionDataContract.ReadJsonValueCore (System.Runtime.Serialization.XmlReaderDelegator jsonReader, System.Runtime.Serialization.Json.XmlObjectSerializerReadContextComplexJson context) [0x0004f] In &lt;8a29d8bc61874dfaa700acd3dd58b577>:0
   at System.Runtime.Serialization.Json.JsonDataContract.ReadJsonValue (System.Runtime.Serialization.XmlReaderDelegator jsonReader, System.Runtime.Serialization.Json.XmlObjectSerializerReadContextComplexJson context) [0x00007] In &lt;8a29d8bc61874dfaa700acd3dd58b577>:0
   at System.Runtime.Serialization.Json.DataContractJsonSerializer.ReadJsonValue (System.Runtime.Serialization.DataContract contract, System.Runtime.Serialization.XmlReaderDelegator reader, System.Runtime.Serialization.Json.XmlObjectSerializerReadContextComplexJson context) [0x00006] In &lt;8a29d8bc61874dfaa700acd3dd58b577>:0
   at System.Runtime.Serialization.Json.XmlObjectSerializerReadContextComplexJson.ReadDataContractValue (System.Runtime.Serialization.DataContract dataContract, System.Runtime.Serialization.XmlReaderDelegator reader) [0x00000] In &lt;8a29d8bc61874dfaa700acd3dd58b577>:0
   at System.Runtime.Serialization.XmlObjectSerializerReadContext.InternalDeserialize (System.Runtime.Serialization.XmlReaderDelegator reader, System.String name, System.String ns, System.Type declaredType, System.Runtime.Serialization.DataContract&amp; dataContract) [0x00264] In &lt;8a29d8bc61874dfaa700acd3dd58b577>:0
   at System.Runtime.Serialization.XmlObjectSerializerReadContext.InternalDeserialize (System.Runtime.Serialization.XmlReaderDelegator xmlReader, System.Type declaredType, System.Runtime.Serialization.DataContract dataContract, System.String name, System.String ns) [0x0000b] In &lt;8a29d8bc61874dfaa700acd3dd58b577>:0
   at System.Runtime.Serialization.XmlObjectSerializerReadContextComplex.InternalDeserialize (System.Runtime.Serialization.XmlReaderDelegator xmlReader, System.Type declaredType, System.Runtime.Serialization.DataContract dataContract, System.String name, System.String ns) [0x00010] In &lt;8a29d8bc61874dfaa700acd3dd58b577>:0
   at System.Runtime.Serialization.Json.DataContractJsonSerializer.InternalReadObject (System.Runtime.Serialization.XmlReaderDelegator xmlReader, System.Boolean verifyObjectName) [0x000c5] In &lt;8a29d8bc61874dfaa700acd3dd58b577>:0
   at System.Runtime.Serialization.XmlObjectSerializer.InternalReadObject (System.Runtime.Serialization.XmlReaderDelegator reader, System.Boolean verifyObjectName, System.Runtime.Serialization.DataContractResolver dataContractResolver) [0x00000] In &lt;8a29d8bc61874dfaa700acd3dd58b577>:0
   at System.Runtime.Serialization.XmlObjectSerializer.ReadObjectHandleExceptions (System.Runtime.Serialization.XmlReaderDelegator reader, System.Boolean verifyObjectName, System.Runtime.Serialization.DataContractResolver dataContractResolver) [0x00072] In &lt;8a29d8bc61874dfaa700acd3dd58b577>:0
   at System.Runtime.Serialization.XmlObjectSerializer.ReadObjectHandleExceptions (System.Runtime.Serialization.XmlReaderDelegator reader, System.Boolean verifyObjectName) [0x00000] In &lt;8a29d8bc61874dfaa700acd3dd58b577>:0
   at System.Runtime.Serialization.Json.DataContractJsonSerializer.ReadObject (System.Xml.XmlDictionaryReader reader) [0x0000d] In &lt;8a29d8bc61874dfaa700acd3dd58b577>:0
   at System.Runtime.Serialization.Json.DataContractJsonSerializer.ReadObject (System.IO.Stream stream) [0x00017] In &lt;8a29d8bc61874dfaa700acd3dd58b577>:0
   at Microsoft.VisualBasic.Serialization.JSON.JsonContract.LoadObject (System.String json, System.Type type, System.Boolean simpleDict) [0x0003e] In &lt;fb45d3e2e23e49ecae88d0914baf5cb7>:0
   at Microsoft.VisualBasic.Serialization.JSON.JsonContract.LoadObject[T] (System.String json, System.Boolean simpleDict) [0x00000] In &lt;fb45d3e2e23e49ecae88d0914baf5cb7>:0
   at Microsoft.VisualBasic.Imaging.Drawing2D.Colors.Designer..cctor () [0x0040f] In &lt;fe90788c758b4b75b8659df0623dea4b>:0
    --- End of inner exception stack trace ---
   at json.Program.Convert (System.String In, System.String nodesTable, System.String kegKCF, System.Boolean degreeSize, System.Boolean compress, System.String style, System.Boolean nodeID, System.String[] maps) [0x00058] In &lt;f0aa82bd17214027b520f8953095c372>:0
   at Biodeep.KEGG.Network.Common.KEGG.BuildNetworkJSON (System.Collections.Generic.IEnumerable`1[T] compounds, System.String repo, System.String out, System.String[] mapIDs) [0x00145] In &lt;598a64b776e440d8b3f5e763e2b2cdd0>:0
   at cytonetwork.Program.BiodeepKEGGNetwork (Microsoft.VisualBasic.CommandLine.CommandLine args) [0x000c1] In &lt;2ebe3e57fb4d4cafb0d4cd22a0a764c2>:0
   at (wrapper managed-to-native) System.Reflection.MonoMethod:InternalInvoke (System.Reflection.MonoMethod,object,object[],System.Exception&amp;)
   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x00032] In &lt;902ab9e386384bec9c07fa19aa938869>:0
    --- End of inner exception stack trace ---
   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x00048] In &lt;902ab9e386384bec9c07fa19aa938869>:0
   at System.Reflection.MethodBase.Invoke (System.Object obj, System.Object[] parameters) [0x00000] In &lt;902ab9e386384bec9c07fa19aa938869>:0
   at Microsoft.VisualBasic.CommandLine.Reflection.EntryPoints.APIEntryPoint.__directInvoke (System.Object[] callParameters, System.Object target, System.Boolean Throw) [0x0000c] In &lt;fb45d3e2e23e49ecae88d0914baf5cb7>:0
    --- End of inner exception stack trace ---
 </remarks>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.Designer.allColorMapNames">
 <summary>
 <see cref="T:Microsoft.VisualBasic.Imaging.ColorMap"/> pattern names
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.Designer.MaterialPalette">
 <summary>
 20 Google material design colors
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.Designer.SplitColorList(System.String)">
 <summary>
 在这个函数里，需要保证颜色的顺序和表达式之中所输入的顺序一致
 </summary>
 <param name="expr"></param>
 <returns></returns>
 <remarks>
 这个函数不支持rgb表达式与颜色名称，html颜色表达式混合
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.Designer.GetColors(System.String)">
 <summary>
 a unify method for get color maps.
 
 (对于无效的键名称，默认是返回<see cref="F:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.DesignerTerms.Office2016"/>，请注意，
 如果是所有的.net的颜色的话，这里面还会包含有白色，所以还需要手工
 去除掉白色)
 </summary>
 <param name="exp$">
 <see cref="T:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.DesignerExpression"/>.
 (假若这里所输入的是一组颜色值，则必须是htmlcolor或者颜色名称，RGB表达式将不会被允许)
 </param>
 <returns></returns>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.Designer.colorRegistry">
 <summary>
 registry for external color palette
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.Designer.Register(System.String,System.Drawing.Color[])">
 <summary>
 register a custom color palette
 </summary>
 <param name="colorName"></param>
 <param name="colors"></param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.Designer.Register(Microsoft.VisualBasic.Imaging.Drawing2D.Colors.Designer.TryGetExternalColorPalette)">
 <summary>
 register an external custom color palette function
 </summary>
 <param name="external"></param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.Designer.getColorsInternal(System.String)">
 <summary>
 a unify method for get color maps
 </summary>
 <param name="term$"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.Designer.GetColors(System.String,System.Int32,System.Int32)">
 <summary>
 这个函数是获取得到一个连续的颜色谱
 </summary>
 <param name="term"></param>
 <param name="n">negative or zero value means no interoplation, 
 just returns the raw color list which is mapping by the 
 <paramref name="term"/>
 </param>
 <param name="alpha">the transparency alpha channel data</param>
 <returns></returns>
 <remarks>
 create color profile with <see cref="M:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.Designer.CubicSpline(System.Collections.Generic.IEnumerable{System.Drawing.Color},System.Int32,System.Int32,System.Boolean)"/>.
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.Designer.GetBrushes(System.String,System.Int32,System.Int32)">
 <summary>
 ``New <see cref="T:Microsoft.VisualBasic.Imaging.SolidBrush"/>(<see cref="M:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.Designer.GetColors(System.String,System.Int32,System.Int32)"/>)``
 </summary>
 <param name="term$"></param>
 <param name="n%"></param>
 <param name="alpha%"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.Designer.FromNames(System.String[],System.Int32)">
 <summary>
 相对于<see cref="M:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.Designer.GetColors(System.String)"/>函数而言，这个函数是返回非连续的颜色谱，假若数量不足，会重新使用开头的起始颜色连续填充
 </summary>
 <param name="colors$"></param>
 <param name="n%"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.Designer.FromSchema(System.String,System.Int32)">
 <summary>
 <see cref="M:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.Designer.FromSchema(System.String,System.Int32)"/>和<see cref="M:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.Designer.FromNames(System.String[],System.Int32)"/>适用于函数绘图之类需要区分数据系列的颜色谱的生成
 </summary>
 <param name="term$"></param>
 <param name="n%"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.Designer.Colors(System.Drawing.Color[],System.Int32,System.Int32)">
 <summary>
 **<see cref="M:Microsoft.VisualBasic.Imaging.ColorCube.GetColorSequence(System.Drawing.Color,System.Drawing.Color,System.Int32,System.Int32)"/>**
 
 Some useful color tables for images and tools to handle them.
 Several color scales useful for image plots: a pleasing rainbow 
 style color table patterned after that used in Matlab by Tim 
 Hoar and also some simple color interpolation schemes between 
 two or more colors. There is also a function that converts 
 between colors and a real valued vector.
 </summary>
 <param name="col">
 A list of colors (names or hex values) to interpolate.
 </param>
 <param name="n">
 Number of color levels. The setting n=64 is the 
 orignal definition.
 </param>
 <param name="alpha">
 The transparency of the color – 255 is opaque and 0 is transparent. 
 This is useful for overlays of color and still being able to view 
 the graphics that is covered.
 </param>
 <returns>
 A vector giving the colors in a hexadecimal format, two extra 
 hex digits are added for the alpha channel.
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.Designer.CubicSpline(System.Collections.Generic.IEnumerable{System.Drawing.Color},System.Int32,System.Int32,System.Boolean)">
 <summary>
 这个函数并不会计算alpha的值
 </summary>
 <param name="colors"></param>
 <param name="n">所期望的颜色的数量</param>
 <param name="interpolate">
 set the interpolate parameter to value TRUE if apply the function 
 for the scalar palette, otherwise keeps the default value FALSE
 for deal with the category color palette.
 </param>
 <returns></returns>
 <remarks>
 if the <paramref name="n"/> value less than the 
 collection size of the input <paramref name="colors"/>, 
 then top n colors will be takes from the input 
 color.
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.Designer.rangeConstraint(System.Single)">
 <summary>
 Limit <see cref="M:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.Designer.CubicSpline(System.Collections.Generic.IEnumerable{System.Drawing.Color},System.Int32,System.Int32,System.Boolean)"/> result in range [0, 255]
 </summary>
 <param name="x!"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.DesignerTerms">
 <summary>
 Color name terms
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.DesignerTerms.TermHelpInfo">
 <summary>
 主要是应用于命令行帮助的字符串信息
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.DesignerTerms.GoogleMaterialPalette">
 <summary>
 20种Android MD设计中使用的颜色
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.DesignerTerms.ConsoleColors">
 <summary>
 16种Windows的命令行配色
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.DesignerTerms.TSFShellColors">
 <summary>
 19中分类颜色
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.DesignerTerms.Rainbow">
 <summary>
 总共7种彩虹色
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.DesignerTerms.sciBASICCategory31">
 <summary>
 31种分类颜色
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.DesignerTerms.ClusterCategory10">
 <summary>
 总共10种分类颜色
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.DesignerExpression">
 <summary>
 ```vbnet
 lighter(term, percentage)
 darker(term, percentage)
 alpha(term, percentage) percentage = [0, 1]
 reverse(term)
 skip(term, n)
 take(term, n)
 ```
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.ColorMapLegend">
 <summary>
 a continues numeric scaler legend bar
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.ColorMapLegend.Draw(Microsoft.VisualBasic.Imaging.IGraphics@,System.Drawing.Rectangle)">
 <summary>
 
 </summary>
 <param name="g"></param>
 <param name="layout">
 the plot location and the rectangle region
 </param>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.Legends.ColorMapLegend(System.Drawing.Color[],System.String,System.String,System.String,System.String,System.Boolean,System.Drawing.Size,System.String,Microsoft.VisualBasic.Imaging.Font,Microsoft.VisualBasic.Imaging.Font,System.Single)">
 <summary>
 Draw color legend for the color sequnece.
 (通过这个函数只是生成了legend的图片，还需要自己将图片放置到图表上的合适的位置)
 </summary>
 <param name="designer"></param>
 <param name="title$">The legend title</param>
 <param name="min$"></param>
 <param name="max$"></param>
 <param name="bg$"></param>
 <param name="haveUnmapped"></param>
 <param name="lsize"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.Legends.ColorMapLegend(Microsoft.VisualBasic.Imaging.SolidBrush[],System.String,System.String,System.String,System.String,System.Boolean,System.Drawing.Size,System.String,Microsoft.VisualBasic.Imaging.Font,Microsoft.VisualBasic.Imaging.Font,System.Single)">
 <summary>
 竖直的颜色图例，输出的图例的大小默认为：``{800, 1024}``
 </summary>
 <param name="designer"></param>
 <param name="title$"></param>
 <param name="min$"></param>
 <param name="max$"></param>
 <param name="bg$"></param>
 <param name="haveUnmapped"></param>
 <param name="lsize"></param>
 <param name="titleFont"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.Legends.ColorMapLegend(Microsoft.VisualBasic.Imaging.IGraphics@,System.Drawing.Rectangle,Microsoft.VisualBasic.Imaging.SolidBrush[],System.Double[],Microsoft.VisualBasic.Imaging.Font,System.String,Microsoft.VisualBasic.Imaging.Font,Microsoft.VisualBasic.Imaging.Pen,System.String,System.Single,System.String,System.Single,System.Boolean,System.String,System.Single)">
 <summary>
 垂直的颜色谱的绘制：左边为颜色谱，右边为标尺，左边的颜色谱的上方为标题
 </summary>
 <param name="g"></param>
 <param name="layout">legend的大小和位置</param>
 <param name="unmapColor">
 当这个参数为空值的时候，将不会绘制未映射颜色示例
 </param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.Legends.ColorLegendHorizontal(Microsoft.VisualBasic.Imaging.SolidBrush[],System.Double[],System.Drawing.Size,System.String,System.String)">
 <summary>
 横向的颜色legend
 </summary>
 <param name="designer"></param>
 <param name="size"></param>
 <param name="padding$"></param>
 <param name="labelFontCSS$"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.OfficeAccent.srgbClr">
 <summary>
 颜色值
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.OfficeAccent.srgbClr.val">
 <summary>
 颜色值
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.OfficeAccent.OfficeColorThemes.Themes">
 <summary>
 All office color themes
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.OfficeAccent.OfficeColorThemes.GetAccentColors(System.String)">
 <summary>
 If found failure, default is reutrns the theme <see cref="P:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.OfficeAccent.OfficeColorThemes.Office2016"/>
 </summary>
 <param name="theme$"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.CategoryPalettes">
 <summary>
 color palette for category data.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.CategoryPalettes.material">
 <summary>
 Includes 20 typical colors that used in Google Android material design.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.CategoryPalettes.ConsoleColors">
 <summary>
 Includes 16 colors from Windows command terminal.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.CategoryPalettes.TSF">
 <summary>
 Includes 19 colors that defines in the TSFShell launcher on Android.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.CategoryPalettes.rainbow">
 <summary>
 Includes 7 rainbow colors.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.CategoryPalettes.sciBasicChart">
 <summary>
 Chartting colors in sciBASIC.NET framework.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.CategoryPalettes.sciBasicCategory31">
 <summary>
 Includes 31 colors that used for category data.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.CategoryPalettes.Clusters">
 <summary>
 Includes 10 colors that used for category data.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.CategoryPalettes.ColorBrewerSet2">
 <summary>
 ColorBrewer Qualitative schemes
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.CategoryPalettes.ColorBrewerAccent">
 <summary>
 ColorBrewer Qualitative schemes
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.CategoryPalettes.ColorBrewerSet1">
 <summary>
 ColorBrewer Qualitative schemes
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.CategoryPalettes.ColorBrewerSet3">
 <summary>
 ColorBrewer Qualitative schemes
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.CategoryPalettes.ColorBrewerDark2">
 <summary>
 ColorBrewer Qualitative schemes
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.CategoryPalettes.ColorBrewerPaired">
 <summary>
 ColorBrewer Qualitative schemes
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.CategoryPalettes.ColorBrewerPastel2">
 <summary>
 ColorBrewer Qualitative schemes
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.CategoryPalettes.ColorBrewerPastel1">
 <summary>
 ColorBrewer Qualitative schemes
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.CategoryPalettes.Office2016">
 <summary>
 Microsoft Office Color Accents: The default color schema that used in Office2016
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.CategoryPalettes.Office2010">
 <summary>
 Microsoft Office Color Accents: The default color schema that used in Office2010
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.CategoryPalettes.Slipstream">
 <summary>
 Microsoft Office Color Accents
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.CategoryPalettes.Marquee">
 <summary>
 Microsoft Office Color Accents
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.CategoryPalettes.Aspect">
 <summary>
 Microsoft Office Color Accents
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.CategoryPalettes.Paper">
 <summary>
 Microsoft Office Color Accents
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.ScalerPalette">
 <summary>
 color set for visualize linear scale data color mapping
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.ScalerPalette.Jet">
 <summary>
 <see cref="F:Microsoft.VisualBasic.Imaging.ColorMap.PatternJet"/>
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.ScalerPalette.Autumn">
 <summary>
 <see cref="F:Microsoft.VisualBasic.Imaging.ColorMap.PatternAutumn"/>
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.ScalerPalette.Cool">
 <summary>
 <see cref="F:Microsoft.VisualBasic.Imaging.ColorMap.PatternCool"/>
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.ScalerPalette.Gray">
 <summary>
 <see cref="F:Microsoft.VisualBasic.Imaging.ColorMap.PatternGray"/>
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.ScalerPalette.Hot">
 <summary>
 <see cref="F:Microsoft.VisualBasic.Imaging.ColorMap.PatternHot"/>
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.ScalerPalette.Spring">
 <summary>
 <see cref="F:Microsoft.VisualBasic.Imaging.ColorMap.PatternSpring"/>
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.ScalerPalette.Summer">
 <summary>
 <see cref="F:Microsoft.VisualBasic.Imaging.ColorMap.PatternSummer"/>
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.ScalerPalette.Winter">
 <summary>
 <see cref="F:Microsoft.VisualBasic.Imaging.ColorMap.PatternWinter"/>
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.Scaler.ColorHeightMap">
 <summary>
 Map a color to a single numeric value
 </summary>
 <remarks>
 Extract numeric value from a raster data
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.Scaler.ColorHeightMap.ScaleLevels(System.Int32)">
 <summary>
 scale the scalar color palette to a specific level.
 </summary>
 <param name="level"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.Scaler.ColorHeightMap.GetScale(System.Drawing.Color)">
 <summary>
 mapping color to level
 </summary>
 <param name="c"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.Scaler.ColorHeightMap.GetVector">
 <summary>
 use for html view in R# scripting
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.Scaler.ColorIndex">
 <summary>
 map colors and the numeric range
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.Scaler.ColorRange.GetMinDistance(System.Drawing.Color)">
 <summary>
 返回和最近的一个颜色点的距离值
 </summary>
 <param name="color"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.Scaler.CategoryColorProfile">
 <summary>
 mapping term to color, used for category group plot
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.Scaler.CategoryColorProfile.category">
 <summary>
 the raw term inputs
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.Scaler.CategoryColorProfile.categoryIndex">
 <summary>
 [0...N]
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.Scaler.CategoryColorProfile.size">
 <summary>
 get the size of the category collection
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.Scaler.CategoryColorProfile.#ctor(System.Collections.Generic.Dictionary{System.String,System.String},System.String)">
 <summary>
 
 </summary>
 <param name="category">[term => category label]</param>
 <param name="colorSchema">
 Should be the term name for create color set via <see cref="M:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.Designer.GetColors(System.String)"/>
 </param>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.Scaler.CategoryColorProfile.GetColor(Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedValue{System.Double})">
 <summary>
 get color by term name
 </summary>
 <param name="item">get color use this item name</param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.Scaler.ColorProfile">
 <summary>
 A color collection
 </summary>
 <remarks>
 includes sub class:
 
 1. <see cref="T:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.Scaler.ValueScaleColorProfile"/>: a color mapper for the value range;
 2. <see cref="T:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.Scaler.CategoryColorProfile"/>: a color mapper for the category terms
 </remarks>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.Scaler.ColorProfile.DefaultColor">
 <summary>
 default color value for missing value, example as: nothing, NaN, Inf, etc
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.Scaler.ColorProfile.#ctor(System.String)">
 <summary>
 Create profile with a pre-defined color set
 </summary>
 <param name="colorSchema"></param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.Scaler.ColorProfile.#ctor(System.Collections.Generic.IEnumerable{System.Drawing.Color})">
 <summary>
 Create profile with custom color set
 </summary>
 <param name="colors"></param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.Scaler.ColorProfile.ToString">
 <summary>
 view of the colors vector for mapping
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.Scaler.ValueScaleColorProfile">
 <summary>
 scale(color_schema_term_name), apply for the heatmap plot
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.Scaler.ValueScaleColorProfile.valueRange">
 <summary>
 data range of the real world sample value, example as temperature value for heatmap
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.Scaler.ValueScaleColorProfile.indexRange">
 <summary>
 data range for the color array
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.Scaler.ValueScaleColorProfile.logarithm">
 <summary>
 base value for the log function for scale of the input value.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.Scaler.ValueScaleColorProfile.ValueMinMax">
 <summary>
 get the [min,max] value range of the real world sample value input.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.Scaler.ValueScaleColorProfile.#ctor(System.Collections.Generic.IEnumerable{Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedValue{System.Double}},System.String,System.Int32,System.Double)">
 <summary>
 
 </summary>
 <param name="data">
 the real world sample value, example as temperature value for heatmap
 </param>
 <param name="colorSchema">the color map name, usually be the <see cref="T:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.ScalerPalette"/> enum string value.</param>
 <param name="level">color map depth levels</param>
 <param name="logarithm">
 base value for the log function for scale of the input value. zero or negative value mean no log function calls
 </param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.Scaler.ValueScaleColorProfile.GetColor(Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedValue{System.Double})">
 <summary>
 get color use the item value
 </summary>
 <param name="item"></param>
 <returns>this function scale the <paramref name="item"/> its <see cref="P:Microsoft.VisualBasic.ComponentModel.DataSourceModel.NamedValue`1.Value"/> to a color</returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.Viridis.magma">
 <summary>
 viridis(12, option = "A")
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.Viridis.inferno">
 <summary>
 viridis(12, option = "B")
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.Viridis.plasma">
 <summary>
 viridis(12, option = "C")
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.Viridis.viridis">
 <summary>
 viridis(12, option = "D")
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.Viridis.cividis">
 <summary>
 viridis(12, option = "E")
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.Viridis.mako">
 <summary>
 viridis(12, option = "G")
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.Viridis.rocket">
 <summary>
 viridis(12, option = "F")
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Colors.Viridis.turbo">
 <summary>
 viridis(12, option = "H")
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Extensions.GetTextAnchor(System.Drawing.Rectangle,System.Drawing.PointF)">
 <summary>
 分别计算出<paramref name="textLayout"/>的上下左右对<paramref name="anchor"/>的距离，取最小的距离的位置并返回
 </summary>
 <param name="textLayout">标签文本的大小和位置，生成一个<see cref="T:System.Drawing.Rectangle"/>布局对象</param>
 <param name="anchor">这个标签文本所属的对象的锚点</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Extensions.GetTextAnchor(System.Drawing.RectangleF,System.Drawing.PointF)">
 <summary>
 分别计算出<paramref name="textLayout"/>的上下左右对<paramref name="anchor"/>的距离，取最小的距离的位置并返回
 </summary>
 <param name="textLayout">标签文本的大小和位置，生成一个<see cref="T:System.Drawing.Rectangle"/>布局对象</param>
 <param name="anchor">这个标签文本所属的对象的锚点</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Extensions.Enlarge(System.Collections.Generic.IEnumerable{System.Drawing.PointF},System.Double)">
 <summary>
 将一个多边形放大指定的倍数<paramref name="scale"/>
 </summary>
 <param name="shape">矢量图形的点集合</param>
 <param name="scale#"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Extensions.Enlarge(System.Collections.Generic.IEnumerable{System.Drawing.PointF},System.Drawing.SizeF)">
 <summary>
 将一个多边形放大指定的倍数<paramref name="scale"/>
 </summary>
 <param name="shape">矢量图形的点集合</param>
 <param name="scale#"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Extensions.Enlarge(System.Collections.Generic.IEnumerable{System.Drawing.PointF},System.ValueTuple{System.Double,System.Double})">
 <summary>
 将一个多边形放大指定的倍数<paramref name="scale"/>
 </summary>
 <param name="shape">矢量图形的点集合</param>
 <param name="scale"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Extensions.Rotate(System.Collections.Generic.IEnumerable{System.Drawing.PointF},System.Double)">
 <summary>
 请注意，这个是围绕坐标轴远点进行的旋转，如果想要围绕指定点进行旋转，还需要进行平移操作
 </summary>
 <param name="shape"></param>
 <param name="alpha">angle in radius</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Extensions.Rotate(System.Collections.Generic.IEnumerable{System.Drawing.PointF},System.Drawing.PointF,System.Double)">
 <summary>
 The required alpha angle data should be in data unit of radians
 </summary>
 <param name="shape"></param>
 <param name="center"></param>
 <param name="alpha">the angle in radius, could be translate from angle via function <see cref="M:Microsoft.VisualBasic.Math.Trigonometric.ToRadians(System.Double)"/></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Extensions.MoveTo(System.Collections.Generic.IEnumerable{System.Drawing.PointF},System.Drawing.PointF,Microsoft.VisualBasic.Imaging.Drawing2D.Extensions.MoveTypes)">
 <summary>
 
 </summary>
 <param name="shape"></param>
 <param name="location"></param>
 <param name="type">By default, is move the shape its bounds box topleft to target place.</param>
 <returns></returns>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing2D.Extensions.MoveTypes.BoundsBoxTopLeft">
 <summary>
 Move the shape its bounds box topleft to target place
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Drawing2D.IPlot">
 <summary>
 An abstract function interface for make graphics plot
 </summary>
 <param name="g">GDI+设备</param>
 <param name="grct">绘图区域的大小</param>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Drawing2D.g">
 <summary>
 Data plots graphics engine common abstract. 
 </summary>
 <remarks>
 (在命令行中使用``graphic_driver=svg``来切换默认的图形引擎为SVG矢量图作图引擎)
 </remarks>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing2D.g.DefaultPadding">
 <summary>
 默认的页边距大小都是100个像素
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing2D.g.DefaultLargerPadding">
 <summary>
 与<see cref="F:Microsoft.VisualBasic.Imaging.Drawing2D.g.DefaultPadding"/>相比而言，这个padding的值在坐标轴Axis的label的绘制上空间更加大
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing2D.g.ZeroPadding">
 <summary>
 所有的页边距都是零
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.g.#cctor">
 <summary>
 在这个模块的构造函数之中，程序会自动根据命令行所设置的环境参数来设置默认的图形引擎
 
 ```
 /@set graphic_driver=svg|gdi
 ```
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.g.ActiveDriver">
 <summary>
 Get the result from commandline environment variable: ``graphic_driver``
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.g.DriverExtensionName">
 <summary>
 Get the image file extension name for current default image driver.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.g.__getDriver(Microsoft.VisualBasic.Imaging.Driver.Drivers)">
 <summary>
 这个函数不会返回<see cref="F:Microsoft.VisualBasic.Imaging.Driver.Drivers.Default"/>
 </summary>
 <param name="developerValue">程序开发人员所设计的驱动程序的值</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.g.SetDriver(Microsoft.VisualBasic.Imaging.Driver.Drivers)">
 <summary>
 在代码中手动配置默认的驱动程序
 </summary>
 <param name="driver"></param>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.g.GraphicsPlots(System.Drawing.Size@,Microsoft.VisualBasic.MIME.Html.CSS.Padding@,System.String,Microsoft.VisualBasic.Imaging.Drawing2D.IPlot,Microsoft.VisualBasic.Imaging.Driver.Drivers,System.Int32)">
 <summary>
 Data plots graphics engine. Default: <paramref name="size"/>:=(4300, 2000), <paramref name="padding"/>:=(100,100,100,100).
 (用户可以通过命令行设置环境变量``graphic_driver``来切换图形引擎)
 </summary>
 <param name="size"></param>
 <param name="padding">页边距</param>
 <param name="bg">颜色值或者图片资源文件的url或者文件路径</param>
 <param name="plotAPI"></param>
 <param name="driver">驱动程序是默认与当前的环境参数设置相关的</param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.g.FillBackground(Microsoft.VisualBasic.Imaging.IGraphics@,System.String,System.Drawing.Rectangle)">
 <summary>
 自动根据表达式的类型来进行纯色绘制或者图形纹理画刷绘制
 </summary>
 <param name="g"></param>
 <param name="bg$">
 1. 可能为颜色表达式
 2. 可能为图片的路径
 3. 可能为base64图片字符串
 </param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.g.MeasureSize(System.String,Microsoft.VisualBasic.Imaging.IGraphics,Microsoft.VisualBasic.Imaging.Font)">
 <summary>
 <see cref="M:Microsoft.VisualBasic.Imaging.IGraphics.MeasureString(System.String,Microsoft.VisualBasic.Imaging.Font)"/> extensions
 </summary>
 <param name="text$"></param>
 <param name="g"></param>
 <param name="font"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.g.MeasureSize(System.String,Microsoft.VisualBasic.Imaging.IGraphics,Microsoft.VisualBasic.Imaging.Font,System.ValueTuple{System.Double,System.Double})">
 <summary>
 <see cref="M:Microsoft.VisualBasic.Imaging.IGraphics.MeasureString(System.String,Microsoft.VisualBasic.Imaging.Font)"/> extensions
 </summary>
 <param name="text"></param>
 <param name="g"></param>
 <param name="font"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.g.GraphicsPlots(System.Action{Microsoft.VisualBasic.Imaging.IGraphics},System.Drawing.Size@,Microsoft.VisualBasic.MIME.Html.CSS.Padding@,System.String)">
 <summary>
 Data plots graphics engine.
 </summary>
 <param name="size"></param>
 <param name="bg"></param>
 <param name="plot"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Drawing2D.GraphicsRegion">
 <summary>
 绘图区域的参数
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing2D.GraphicsRegion.Size">
 <summary>
 整张画布的大小
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing2D.GraphicsRegion.Padding">
 <summary>
 画布的边留白
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.GraphicsRegion.Width">
 <summary>
 Get the width of the entire canvas <see cref="F:Microsoft.VisualBasic.Imaging.Drawing2D.GraphicsRegion.Size"/>
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.GraphicsRegion.Height">
 <summary>
 Get the height of the entire canvas <see cref="F:Microsoft.VisualBasic.Imaging.Drawing2D.GraphicsRegion.Size"/>
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.GraphicsRegion.EntireArea">
 <summary>
 整张画布的大小区域
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.GraphicsRegion.Bottom(Microsoft.VisualBasic.MIME.Html.CSS.CSSEnvirnment)">
 <summary>
 绘图区域的底部Y坐标值
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.GraphicsRegion.XRange(Microsoft.VisualBasic.MIME.Html.CSS.CSSEnvirnment)">
 <summary>
 ``[left, right]`` as <see cref="T:Microsoft.VisualBasic.ComponentModel.Ranges.Model.DoubleRange"/>
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.GraphicsRegion.YRange(Microsoft.VisualBasic.MIME.Html.CSS.CSSEnvirnment)">
 <summary>
 ``[top, bottom]`` as <see cref="T:Microsoft.VisualBasic.ComponentModel.Ranges.Model.DoubleRange"/>
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.GraphicsRegion.PlotRegion(Microsoft.VisualBasic.MIME.Html.CSS.CSSEnvirnment)">
 <summary>
 整张画布出去margin部分剩余的可供绘图的区域
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.HeatMap.HeatMapBrushes.defaultFill">
 <summary>
 background color options when deal with the irregular polygon
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.HeatMap.HeatMapBrushes.valueRange">
 <summary>
 manual controls of the heatmap value mapping range
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.HeatMap.HeatMapParameters.defaultFill">
 <summary>
 background color options when deal with the irregular polygon
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.HeatMap.HeatMapParameters.valueRange">
 <summary>
 manual controls of the heatmap value mapping range
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Drawing2D.HeatMap.HeatMapRaster`1">
 <summary>
 A helper class or produce heatmap raster matrix data
 </summary>
 <remarks>
 https://github.com/RainkLH/HeatMapSharp
 </remarks>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing2D.HeatMap.HeatMapRaster`1.gSize">
 <summary>
 gaussian kernel size
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing2D.HeatMap.HeatMapRaster`1.gSigma">
 <summary>
 gaussian kernel sigma
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing2D.HeatMap.HeatMapRaster`1.r">
 <summary>
 radius
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing2D.HeatMap.HeatMapRaster`1.m_heatMatrix">
 <summary>
 Two dimensional matrix corresponding to data list
 
 the heatmap cells data, transform color scale from
 this matrix data
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing2D.HeatMap.HeatMapRaster`1.m_kernelField">
 <summary>
 gaussian kernel
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.HeatMap.HeatMapRaster`1.Kernel">
 <summary>
 gaussian kernel
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.HeatMap.HeatMapRaster`1.HeatMatrix">
 <summary>
 Two dimensional matrix corresponding to data list
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.HeatMap.HeatMapRaster`1.#ctor(System.Int32,System.Double)">
 <summary>
 construction
 </summary>
 <param name="gSize">gaussian kernel size</param>
 <param name="gSigma">gaussian kernel sigma</param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.HeatMap.HeatMapRaster`1.SetDataInternal(`0[])">
 <summary>
 set imaging raster pixels data to generate heatmap matrix
 </summary>
 <param name="datas"></param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.HeatMap.HeatMapRaster`1.GetRasterPixels(System.Func{System.Int32,System.Int32,System.Double,`0})">
 <summary>
 
 </summary>
 <param name="activator">
 a delegate function for create the pixel spot data object
 </param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.HeatMap.HeatMapRaster`1.GetRasterPixels">
 <summary>
 populate out the default internal <see cref="T:Microsoft.VisualBasic.Imaging.Drawing2D.HeatMap.PixelData"/> model
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Drawing2D.HeatMap.hqx.HqxScaling">
 <summary>
 + wikipedia: https://en.wikipedia.org/wiki/Hqx
 + [Tamschi/hqxSharp](https://github.com/Tamschi/hqxSharp): hqxSharp is a C# port of hqx, a fast, high-quality magnification filter designed for pixel art.
 + [Arcnor/hqx-java](https://github.com/Arcnor/hqx-java): hqx-java is a Java port of hqx, a fast, high-quality magnification filter designed for pixel art.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.HeatMap.hqx.HqxScaling.diff(System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
 <summary>
 Compares two ARGB colors according to the provided Y, U, V and A thresholds. </summary>
 <param name="c1"> an ARGB color </param>
 <param name="c2"> a second ARGB color </param>
 <param name="trY"> the Y (luminance) threshold </param>
 <param name="trU"> the U (chrominance) threshold </param>
 <param name="trV"> the V (chrominance) threshold </param>
 <param name="trA"> the A (transparency) threshold </param>
 <returns> true if colors differ more than the thresholds permit, false otherwise </returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.HeatMap.hqx.Hqx_2x.hq2x_32_rb(System.UInt32[]@,System.UInt32[]@,System.Int32,System.Int32)">
 <summary>
 This is the extended Java port of the hq2x algorithm.
 <b>The destination image must be exactly twice as large in both dimensions as the source image</b>
 The Y, U, V, A parameters will be set as 48, 7, 6 and 0, respectively. Also, wrapping will be false.
 </summary>
 <param name="sp"> the source image data array in ARGB format </param>
 <param name="dp"> the destination image data array in ARGB format </param>
 <param name="Xres"> the horizontal resolution of the source image </param>
 <param name="Yres"> the vertical resolution of the source image
 </param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.HeatMap.hqx.Hqx_2x.hq2x_32_rb(System.UInt32[]@,System.UInt32[]@,System.Int32,System.Int32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.Boolean,System.Boolean)">
 <summary>
 This is the extended Java port of the hq2x algorithm.
 <b>The destination image must be exactly twice as large in both dimensions as the source image</b> </summary>
 <param name="sp"> the source image data array in ARGB format </param>
 <param name="dp"> the destination image data array in ARGB format </param>
 <param name="Xres"> the horizontal resolution of the source image </param>
 <param name="Yres"> the vertical resolution of the source image </param>
 <param name="trY"> the Y (luminance) threshold </param>
 <param name="trU"> the U (chrominance) threshold </param>
 <param name="trV"> the V (chrominance) threshold </param>
 <param name="trA"> the A (transparency) threshold </param>
 <param name="wrapX"> used for images that can be seamlessly repeated horizontally </param>
 <param name="wrapY"> used for images that can be seamlessly repeated vertically </param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.HeatMap.hqx.Hqx_3x.hq3x_32_rb(System.UInt32[],System.UInt32[],System.Int32,System.Int32)">
 <summary>
 This is the extended Java port of the hq3x algorithm.
 <b>The destination image must be exactly 3 times as large in both dimensions as the source image</b>
 The Y, U, V, A parameters will be set as 48, 7, 6 and 0, respectively. Also, wrapping will be false.
 </summary>
 <param name="sp"> the source image data array in ARGB format </param>
 <param name="dp"> the destination image data array in ARGB format </param>
 <param name="Xres"> the horizontal resolution of the source image </param>
 <param name="Yres"> the vertical resolution of the source image
 </param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.HeatMap.hqx.Hqx_3x.hq3x_32_rb(System.UInt32[],System.UInt32[],System.Int32,System.Int32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.Boolean,System.Boolean)">
 <summary>
 This is the extended Java port of the hq3x algorithm.
 <b>The destination image must be exactly 3 times as large in both dimensions as the source image</b> </summary>
 <param name="sp"> the source image data array in ARGB format </param>
 <param name="dp"> the destination image data array in ARGB format </param>
 <param name="Xres"> the horizontal resolution of the source image </param>
 <param name="Yres"> the vertical resolution of the source image </param>
 <param name="trY"> the Y (luminance) threshold </param>
 <param name="trU"> the U (chrominance) threshold </param>
 <param name="trV"> the V (chrominance) threshold </param>
 <param name="trA"> the A (transparency) threshold </param>
 <param name="wrapX"> used for images that can be seamlessly repeated horizontally </param>
 <param name="wrapY"> used for images that can be seamlessly repeated vertically </param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.HeatMap.hqx.Hqx_4x.hq4x_32_rb(System.UInt32[],System.UInt32[],System.Int32,System.Int32)">
 <summary>
 This is the extended Java port of the hq4x algorithm.
 <b>The destination image must be exactly 4 times as large in both dimensions as the source image</b>
 The Y, U, V, A parameters will be set as 48, 7, 6 and 0, respectively. Also, wrapping will be false.
 </summary>
 <param name="sp"> the source image data array in ARGB format </param>
 <param name="dp"> the destination image data array in ARGB format </param>
 <param name="Xres"> the horizontal resolution of the source image </param>
 <param name="Yres"> the vertical resolution of the source image
 </param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.HeatMap.hqx.Hqx_4x.case0(System.UInt32[],System.Int32,System.Int32,System.UInt32[])">
 <summary>
 This and the next caseXXX methods were used to reduce the code size of the main
 #hq4x_32_rb(int[], int[], int, int, int, int, int, int, boolean, boolean) method because of the Java 65K bytecode limit.
 Only the necessary methods were created, to leave the maximum code on the original one to avoid excessive calling.
 However, this is a very bad design (too much code in the same method)
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.HeatMap.hqx.Hqx_4x.hq4x_32_rb(System.UInt32[],System.UInt32[],System.Int32,System.Int32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.Boolean,System.Boolean)">
 <summary>
 This is the extended Java port of the hq4x algorithm.
 <b>The destination image must be exactly 4 times as large in both dimensions as the source image</b> </summary>
 <param name="sp"> the source image data array in ARGB format </param>
 <param name="dp"> the destination image data array in ARGB format </param>
 <param name="Xres"> the horizontal resolution of the source image </param>
 <param name="Yres"> the vertical resolution of the source image </param>
 <param name="trY"> the Y (luminance) threshold </param>
 <param name="trU"> the U (chrominance) threshold </param>
 <param name="trV"> the V (chrominance) threshold </param>
 <param name="trA"> the A (transparency) threshold </param>
 <param name="wrapX"> used for images that can be seamlessly repeated horizontally </param>
 <param name="wrapY"> used for images that can be seamlessly repeated vertically </param>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Drawing2D.HeatMap.hqx.Interpolation">
 <summary>
 Helper class to interpolate colors. Nothing to see here, move along...
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.HeatMap.hqx.Interpolation.MixColours(System.UInt32[])">
 <summary>
 This method can overflow between blue and red and from red 
 to nothing when the sum of all weightings is higher than 255.
 It only works for weightings with a sum that Is a power of 
 two, otherwise the blue value Is corrupted.
 </summary>
 <param name="weightingsAndColours">
 weighting0, weighting1[, ...], colour0, colour1[, ...]
 </param>
 <returns></returns>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing2D.HeatMap.hqx.RgbYuv.RGBtoYUV">
 <summary>
 this array is readonly to public
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.HeatMap.hqx.RgbYuv.getYuv(System.UInt32)">
 <summary>
 Returns the 24bit YUV equivalent of the provided 24bit RGB color.<b>Any alpha component is dropped</b>
 </summary>
 <param name="rgb"> a 24bit rgb color </param>
 <returns> the corresponding 24bit YUV color </returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.HeatMap.hqx.RgbYuv.hqxInit">
 <summary>
 Calculates the lookup table. <b>MUST</b> be called (only once) before doing anything else
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.HeatMap.hqx.RgbYuv.Release">
 <summary>
 Releases the reference to the lookup table.
 <para>The table has to be calculated again for the next lookup.</para>
 </summary>
 
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Drawing2D.HeatMap.PixelData">
 <summary>
 A pixel spot object associate [x,y] with intensity scale data
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.HeatMap.PixelData.#ctor(System.Int32,System.Int32)">
 <summary>
 spot data is zero
 </summary>
 <param name="x"></param>
 <param name="y"></param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.HeatMap.PixelRender.ScalePixels(Microsoft.VisualBasic.Imaging.Pixel[],Microsoft.VisualBasic.ComponentModel.Ranges.Model.DoubleRange)">
 <summary>
 scale raw data into <see cref="F:Microsoft.VisualBasic.Imaging.Drawing2D.HeatMap.PixelRender.indexRange"/> for get 
 corresponding color data.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.HeatMap.PixelRender.RenderRasterImage``1(System.Collections.Generic.IEnumerable{``0},System.Drawing.Size,System.Boolean,System.Double,System.Double,System.Boolean)">
 <summary>
 rendering pixels with no size scaling.
 </summary>
 <param name="pixels"></param>
 <param name="size"></param>
 <returns></returns>
 <remarks>
 do heatmap rendering based on the <see cref="T:Microsoft.VisualBasic.Imaging.Drawing2D.HeatMap.HeatMapRaster`1"/>
 </remarks>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Drawing2D.HeatMap.RasterMatrix">
 <summary>
 matrix helper for do heatmap rendering
 </summary>
 <remarks>
 raster object is based on the <see cref="T:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.NumericMatrix"/> or <see cref="T:Microsoft.VisualBasic.Math.LinearAlgebra.Matrix.SparseMatrix"/> data
 object with specific size.
 </remarks>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.HeatMap.RasterMatrix.DenseMatrix">
 <summary>
 is dense matrix?
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.HeatMap.RasterMatrix.Size">
 <summary>
 get the 2d canvas dimension size of current raster object
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.HeatMap.RasterMatrix.RasterMatrix">
 <summary>
 get a dense numeric matrix for represents current raster object
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.HeatMap.RasterMatrix.PopulateDenseRasterMatrix``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Int32)">
 <summary>
 cast the sparse raster data as dense matrx liked raster data
 </summary>
 <param name="datas"></param>
 <param name="w">the matrix width, ncols</param>
 <param name="h">the matrix height, nrows</param>
 <returns>the full scan <see cref="T:Microsoft.VisualBasic.Imaging.Drawing2D.HeatMap.PixelData"/> spot data, number of 
 the returns collection equals to <paramref name="w"/> * <paramref name="h"/>.
 </returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Drawing2D.HeatMap.RasterScaler">
 <summary>
 do image size scaling
 </summary>
 <remarks>
 A internal image data readonly matrix object
 </remarks>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.HeatMap.RasterScaler.size">
 <summary>
 the dimension size of the bitmap buffer data
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.HeatMap.RasterScaler.#ctor(Microsoft.VisualBasic.Imaging.Bitmap,System.Func{System.Drawing.Color,System.Single})">
 <summary>
 
 </summary>
 <param name="heatmap">
 a heatmap imaging result which is generated by the <see cref="T:Microsoft.VisualBasic.Imaging.Drawing2D.HeatMap.PixelRender"/>
 </param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.HeatMap.RasterScaler.ScaleTo(Microsoft.VisualBasic.Imaging.IGraphics,System.Drawing.Rectangle)">
 <summary>
 scale image size via rectangle drawing
 </summary>
 <param name="g"></param>
 <param name="region"></param>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.HeatMap.RasterScaler.GetRasterData(System.Boolean)">
 <summary>
 Get grayscale raster data
 </summary>
 <returns></returns>
 <remarks>
 default scale value of each <see cref="T:Microsoft.VisualBasic.Imaging.Drawing2D.HeatMap.PixelData"/> is the color brightness
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.HeatMap.RasterScaler.Scale(Microsoft.VisualBasic.Imaging.IGraphics,System.Drawing.Size,System.Drawing.Point)">
 <summary>
 scale image size via rectangle drawing
 </summary>
 <param name="g"></param>
 <param name="newSize"></param>
 <param name="offset"></param>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Drawing2D.HeatMap.ReinhardColorNormalization">
 <summary>
 The Reinhard Color Normalization algorithm, developed by Reinhard et al., is a classical method 
 for color transfer between images. Its core principles and implementation are as follows:
 
 ### 1 Fundamental Principle  
 
 The algorithm leverages the **LAB color space**, where the L (lightness), A (green-red), and B 
 (blue-yellow) channels are statistically uncorrelated. This independence allows for separate processing 
 of each channel. The core idea involves deriving a **linear transformation** based on statistical 
 analysis (mean and standard deviation) of the source and target images. By aligning the color 
 distributions of the source image to match those of the target image, effective color migration 
 is achieved .
 
 ### 2 Implementation Approach  
 
 In practical applications (e.g., MATLAB), the algorithm follows these steps:  
 
 1. **Color Space Conversion**: Convert both source and target images from RGB to LAB using functions like `rgb2lab` .  
 2. **Statistical Calculation**: Compute the mean (μ) and standard deviation (σ) for each LAB channel in both images.  
 3. **Linear Transformation**: For each channel, apply the transformation:  
 
 \[
 \text{output\_channel} = \left( \frac{\text{source\_channel} - \mu_{\text{source}}}{\sigma_{\text{source}}} \right) \times \sigma_{\text{target}} + \mu_{\text{target}}
 \]  
 
 This scales and shifts the source channel's distribution to match the target's statistics.  
 
 4. **Reconversion**: Convert the transformed LAB image back to RGB using `lab2rgb` to produce the final color-normalized result .  
 
 ### 3 Key Advantages  
 
 - **Channel Independence**: Processing LAB channels separately avoids cross-channel interference, enhancing accuracy .  
 - **Simplicity**: The linear transformation is computationally efficient and easy to implement.  
 - **Effectiveness**: Preserves structural details while adapting colors, making it suitable for 
                      applications like photo stylization and medical imaging.  

 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.CanvasScaler">
 <summary>
 the scaler of the canvas size and rectangle
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.CanvasScaler.AutoScaler(System.Drawing.RectangleF,Microsoft.VisualBasic.MIME.Html.CSS.CSSEnvirnment,Microsoft.VisualBasic.MIME.Html.CSS.Padding)">
 <summary>
 
 </summary>
 <param name="boundary"></param>
 <param name="frame"></param>
 <param name="padding"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.CanvasScaler.ScalePoints(System.Drawing.PointF[],System.Drawing.SizeF,Microsoft.VisualBasic.MIME.Html.CSS.Padding,System.Drawing.SizeF@,System.Drawing.PointF@)">
 <summary>
 
 </summary>
 <param name="polygon"></param>
 <param name="frameSize">the canvas drawing size</param>
 <param name="padding"></param>
 <param name="scaleFactor"></param>
 <param name="centraOffset"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.ConcaveHull.BallConcave">
 <summary>
 + http://www.tuicool.com/articles/iUvMjm
 + http://www.ian-ko.com/ET_GeoWizards/UserGuide/concaveHull.htm
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.ConcaveHull.DelaunayTriangulation">
 <summary>
 http://www.tuicool.com/articles/iUvMjm
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.ConcaveHull.DelaunayTriangulation.#ctor(System.Collections.Generic.IEnumerable{Microsoft.VisualBasic.Imaging.Drawing3D.Point3D},System.Int32)">
 <summary>
 
 </summary>
 <param name="vertex">a set of [x,y,z] 3d point</param>
 <param name="MaxTriangles">max number of the triangles</param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.ConcaveHull.DelaunayTriangulation.Triangulate(System.Int32)">
 <summary>
 <paramref name="nvert"/>值必须要小于<see cref="F:Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.ConcaveHull.DelaunayTriangulation.Vertex"/>的数量
 </summary>
 <param name="nvert"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.ConcaveHull.Extensions.ConcaveHull(System.Collections.Generic.IEnumerable{System.Drawing.PointF},System.Double,System.Boolean)">
 <summary>
 The Concave Hull of a Set of Points
 
 In geometry, the convex hull or convex envelope or convex closure of a shape is the 
 smallest convex set that contains it. The convex hull may be defined either as the 
 intersection of all convex sets containing a given subset of a Euclidean space, or 
 equivalently as the set of all convex combinations of points in the subset. For a 
 bounded subset of the plane, the convex hull may be visualized as the shape enclosed 
 by a rubber band stretched around the subset.

 Convex hulls of open sets are open, and convex hulls of compact sets are compact. Every 
 compact convex set is the convex hull of its extreme points. The convex hull operator 
 is an example of a closure operator, and every antimatroid can be represented by applying
 this closure operator to finite sets of points. The algorithmic problems of finding the 
 convex hull of a finite set of points in the plane or other low-dimensional Euclidean 
 spaces, and its dual problem of intersecting half-spaces, are fundamental problems of 
 computational geometry. They can be solved in time (log)(n\log n) for two or three 
 dimensional point sets, and in time matching the worst-case output complexity given by 
 the upper bound theorem in higher dimensions.

 As well as for finite point sets, convex hulls have also been studied for simple polygons, 
 Brownian motion, space curves, and epigraphs of functions. Convex hulls have wide 
 applications in mathematics, statistics, combinatorial optimization, economics, geometric 
 modeling, and ethology. Related structures include the orthogonal convex hull, convex 
 layers, Delaunay triangulation and Voronoi diagram, and convex skull.
 </summary>
 <param name="points"></param>
 <param name="r">the ball radius</param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.ConcaveHull.TriangleIndex">
 <summary>
 the 3d point index
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.ConcaveHull.Triangle.P0Index">
 <summary>
 A
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.ConcaveHull.Triangle.P1Index">
 <summary>
 B
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.ConcaveHull.Triangle.P2Index">
 <summary>
 C
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.ConvexHull.ConvexHull">
 <summary>
 In mathematics, the convex hull or convex envelope of a set X of points in the Euclidean plane 
 or in a Euclidean space (or, more generally, in an affine space over the reals) is the smallest 
 convex set that contains X. For instance, when X is a bounded subset of the plane, the convex 
 hull may be visualized as the shape enclosed by a rubber band stretched around X.
 (多边形的点的数量必须要至少3个点)
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.ConvexHull.ConvexHull.JarvisMatch(System.Collections.Generic.IEnumerable{System.Drawing.PointF})">
 <summary>
 点的数量必须要多于2个!
 </summary>
 <param name="points"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.ConvexHull.ConvexHull.GrahamScan(System.Collections.Generic.IEnumerable{System.Drawing.PointF})">
 <summary>
 点的数量必须要多于2个!
 </summary>
 <param name="points"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.HullPolygonDraw.DrawHullPolygon(Microsoft.VisualBasic.Imaging.IGraphics,System.Collections.Generic.IEnumerable{System.Drawing.PointF},System.Drawing.Color,System.Single,System.Int32,System.Boolean,System.Single,System.Boolean,System.Boolean)">
 <summary>
 这个函数仅仅是作图函数，如果图形中有些离群点会导致图形面积过大的话，
 可以在调用这个函数之前做kmeans聚类过滤掉这些离群点
 </summary>
 <param name="g"></param>
 <param name="polygon"></param>
 <param name="color"></param>
 <param name="strokeWidth!"></param>
 <param name="alpha"><see cref="P:System.Drawing.Color.A"/></param>
 <param name="shadow"></param>
 <param name="convexHullCurveDegree">
 the spline degree of the polygon edges, smaller than value 1
 means on spline interpolation 
 </param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.MarchingSquares.ASCIIPrinter.asciiPrintContours(Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.MarchingSquares.MarchingSquares,System.Double[][],System.Double[])">
 <summary>
 Mainly for debugging, this can be called to have ascii art contours
 printed for the data.
 </summary>
 <param name="data"> measured data to use for isoline generation. </param>
 <param name="levels"> thresholds to use as iso levels. </param>
 <returns> return a string of ascii art corresponding to Marching Squares
 generation if isolines. </returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.MarchingSquares.ASCIIPrinter.asciiContourPrint(Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.MarchingSquares.MarchingSquares,Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.MarchingSquares.IsoCell[][])">
 <summary>
 Mainly for debugging, print an ascii version of this contour.
 </summary>
 <param name="a"> array of contour neighbor values. </param>
 <returns> string roughly representing contour in 'a'. </returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.MarchingSquares.ContourLayer.GetContours(System.Collections.Generic.IEnumerable{Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.MarchingSquares.MeasureData},System.Double,System.Boolean,System.Double[])">
 <summary>
 
 </summary>
 <param name="sample"></param>
 <param name="epsilon"></param>
 <param name="interpolateFill"></param>
 <param name="levels">
 [0,1]之间的等级值，空值则使用默认等级列表
 </param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.MarchingSquares.ContourLayer.GetOutline(System.Int32[],System.Int32[],System.Int32)">
 <summary>
 Do contour tracing for measure outline
 </summary>
 <param name="x"></param>
 <param name="y"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.MarchingSquares.ContourLayer.GetOutline(System.Double[],System.Double[],System.Int32)">
 <summary>
 Do contour tracing for measure outline
 </summary>
 <param name="x"></param>
 <param name="y"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.MarchingSquares.ContourLayer.GetOutline(System.Single[],System.Single[],System.Int32)">
 <summary>
 Do contour tracing for measure outline
 </summary>
 <param name="x"></param>
 <param name="y"></param>
 <returns></returns>
 
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.MarchingSquares.ContourTracing">
 <summary>
 
 </summary>
 <remarks>
 https://raw.githubusercontent.com/STPR/contour_tracing/main/rust/src/lib.rs
 </remarks>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.MarchingSquares.ContourTracing.MN">
 <summary>
 Moore neighborhood
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.MarchingSquares.ContourTracing.O_VERTEX">
 <summary>
 Bottom left coordinates
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.MarchingSquares.ContourTracing.H_VERTEX">
 <summary>
 Bottom right coordinates
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.MarchingSquares.ContourTracing.O_VALUE">
 <summary>
 Value to add into the array of contours
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.MarchingSquares.ContourTracing.H_VALUE">
 <summary>
 (idem)
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.MarchingSquares.ContourTracing.BitsToPaths(System.SByte[][])">
 <summary>
 
 </summary>
 <param name="bits">
 在这里使用字节表示像素的情况：0表示空白，1表示有像素
 </param>
 <returns></returns>
 
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.MarchingSquares.GeneralPath">
 <summary>
 a collection of the polygon data
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.MarchingSquares.GeneralPath.level">
 <summary>
 the z-index liked heatmap level, used for color rendering
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.MarchingSquares.GeneralPath.Discard">
 <summary>
 clear current temp data
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.MarchingSquares.GeneralPath.FilterSmallPolygon(System.Double)">
 <summary>
 
 </summary>
 <param name="q">[0,1]</param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.MarchingSquares.IsoCell">
 <summary>
 IsoCell is used to describe properties of data cells, in particular,
 indicating whether neighbors are above or below a threshold value. Other
 methods also help the caller follow isolines from cell to cell in a
 counter-clockwise manner. That is useful when converting the isolines to
 GeneralPaths.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.MarchingSquares.IsoCell.flipped">
 <summary>
 Determine is this cell is one of tow ambiguous cases in Marching Squares
 and, if so, whether or not it must be "flipped" to the other case.
 </summary>
 <returns> Indication whether this cell is or isn't flipped. </returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.MarchingSquares.IsoCell.neighborInfo">
 <summary>
 Retrieve the neighbor info of this cell. Each of its neighbors is given a
 value of 1, 2, 4 or 8 depending on whether or not each is above or below
 a threshold. These values are the foundation of the Marching Squares
 algorithm.
 
 @return
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.MarchingSquares.IsoCell.left">
 <returns> Get interpolated crossing on left edge of cell. </returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.MarchingSquares.IsoCell.right">
 <returns> Get interpolated crossing on right edge of cell. </returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.MarchingSquares.IsoCell.top">
 <returns> Get interpolated crossing on top edge of cell. </returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.MarchingSquares.IsoCell.bottom">
 <returns> Get interpolated crossing on bottom edge of cell. </returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.MarchingSquares.IsoCell.normalizedPointCCW(Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.MarchingSquares.Side)">
 <summary>
 After Marching Squares determines what kind of crossings go through each
 cell, this method can be used to save linearly interpolated values that
 more closely follow data values. So rather than using cell crossing
 values of, e.g., (0.5, 0), plotting is better if the data indicated, say,
 (0.83, 0) should be used.
 </summary>
 <param name="cellSide"> which side crossing is wanted. </param>
 <returns> crossing based on data and normalized to [0, 1]. </returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.MarchingSquares.IsoCell.firstSideCCW(Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.MarchingSquares.Side)">
 <summary>
 Depending on this cell's neighbor info, which is an integer in [0, 15],
 this method determines the first side that would used in a counter-
 clockwise traversal of an isoline.
 </summary>
 <param name="prev"> previous side, used only for ambiguous cases of 5 and 10. </param>
 <returns> side to start with in a CCW traversal. </returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.MarchingSquares.IsoCell.secondSideCCW(Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.MarchingSquares.Side)">
 <summary>
 Depending on this cell's neighbor info, which is an integer in [0, 15],
 this method determines the second side of a cell that would used in a
 counter-clockwise traversal of an isoline.
 </summary>
 <param name="prev"> previous side, used only for ambiguous cases of 5 and 10. </param>
 <returns> side to finish with in a call during a CCW traversal. </returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.MarchingSquares.IsoCell.nextCellCCW(Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.MarchingSquares.Side)">
 <summary>
 Find the next cell to use in a CCW traversal of an isoline.
 </summary>
 <param name="prev"> previous side, used only for ambiguous cases of 5 and 10. </param>
 <returns> next cell to use in a CCW traversal. </returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.MarchingSquares.IsoCell.clearIso(Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.MarchingSquares.Side)">
 <summary>
 Clear neighbor info in this cell. When building up shapes, it is possible
 to have disjoint isoshapes and holes in them. An easy way to build up a
 new shape from neighborInfo is to build sub-paths for one isoline at a
 time. As the shape is built up, it is necessary to erase the line
 afterward so that subsequent searches for isolines will not loop
 infinitely.
 </summary>
 <param name="prev"> </param>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.MarchingSquares.MapMatrix">
 <summary>
 将稀疏矩阵数据转换为稠密矩阵数据
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.MarchingSquares.MapMatrix.data">
 <summary>
 插值后得到的稠密矩阵数据
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.MarchingSquares.MapMatrix.dots">
 <summary>
 实际的测量结果数据，一般为一个稀疏矩阵
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.MarchingSquares.MapMatrix.#ctor(System.Collections.Generic.IEnumerable{Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.MarchingSquares.MeasureData},System.Boolean)">
 <summary>
 
 </summary>
 <param name="raw">现实世界中的原始测量结果数据</param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.MarchingSquares.MapMatrix.GetPercentages(System.Double[])">
 <summary>
 
 </summary>
 <param name="levels">``[0,1]``</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.MarchingSquares.MapMatrix.GetMatrixInterpolation">
 <summary>
 返回一个稠密状态的结果矩阵
 </summary>
 <returns>
 以行扫描的方式返回结果
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.MarchingSquares.MapMatrix.interpolateData(System.Boolean)">
 <summary>
 数据插值
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.MarchingSquares.MapMatrix.interpolate(System.Int32,System.Int32,System.Boolean)">
 <summary>
 进行数据插值
 </summary>
 <param name="i"></param>
 <param name="j"></param>
 <param name="interpolateFill"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.MarchingSquares.MarchingSquares">
 <summary>
 Algorithm taken from: http://en.wikipedia.org/wiki/Marching_squares . See
 that web page for a thorough description and helpful illustrations. In short,
 however, Marching Squares takes a 2d array of numbers and generates isolines
 for specified values.
 
 <para>The data array generally contains measurements of a natural phenomenon, so
 that adjacent numbers have some relation to each other. For example, they
 might be terrain elevations, RF power from a transmitter, snow fall amounts,
 and so on.
 
 </para>
 <para>Given a threshold, a copy of the data is made where each value is changed
 to 0 or 1 depending if the measurement is below or above it. The algorithm
 described below is applied one time for each isoline wanted. Each isoline is
 converted to Java GeneralPath instances, which are Shapes supporting holes
 and disconnected regions.
 
 </para>
 <para>NOTE: data is first padded with a new row at top and another at bottom, as
 well as a new first and last column. The new rows and columns are set to one
 less than the smallest data value. This ensures that all isos will be closed
 polygons. All generated GeneralPaths can then be easily filled and drawn.
 
 </para>
 <para>Taken from the Wikipedia page:
 
 </para>
 <para>Basic Algorithm
 
 </para>
 <para>Here are the steps of the algorithm:
 
 </para>
 <para>Apply a threshold to the 2D field to make a binary image containing:
 
 </para>
 <para>1 where the data value is above the isovalue
 0 where the data value is below the isovalue
 
 </para>
 <para>Every 2x2 block of pixels in the binary image forms a contouring cell, so
 the whole image is represented by a grid of such cells (shown in green in the
 picture below). Note that this contouring grid is one cell smaller in each
 direction than the original 2D field.
 
 </para>
 <para>For each cell in the contouring grid:
 
 </para>
 <para>1. Compose the 4 bits at the corners of the cell to build a binary index:
 walk around the cell in a clockwise direction appending the bit to the index,
 using bitwise OR and left-shift, from most significant bit at the top left,
 to least significant bit at the bottom left. The resulting 4-bit index can
 have 16 possible values in the range 0-15
 
 </para>
 <para>2. Use the cell index to access a pre-built lookup table with 16 entries
 listing the edges needed to represent the cell (shown in the lower right part
 of the picture below).
 
 </para>
 <para>3. Apply linear interpolation between the original field data values to
 find the exact position of the contour line along the edges of the cell.
 </para>
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.MarchingSquares.MarchingSquares.epsilon">
 <summary>
 Coordinates within this distance of each other are considered identical.
 This affects whether new segments are or are not created in an iso
 shape GeneralPath, in particular whether or not to generate a call
 to lineTo().
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.MarchingSquares.MarchingSquares.mkIsos(System.Double[][],System.Double[])">
 <summary>
 Typically, mkIsos() is the only method in this class that programs will
 call.  The caller supplies a 2d array of doubles representing some
 set of measured data.  Additionally, a 1d array of values is passed
 whose contents are thresholds corresponding to desired islines.
 The method returns a 1d array of GeneralPaths representing those
 isolines.  The GeneralPaths may contain disjoint polygons as well as
 holes.
 
 <para>Sample call:
 <pre>
 MarchingSquares marchingSquares = new MarchingSquares();
 GenersalPath[] isolines = marchingSquares.mkIsos(data_mW, levels);
 </pre>
 and the isolines can then be filled or drawn as desired.
 
 </para>
 </summary>
 <param name="data"> measured data to use for isoline generation. </param>
 <param name="levels"> thresholds to use as iso levels. </param>
 <returns> return an array of iso GeneralPaths. Each array element
 corresponds to the same threshold in the 'levels' input array. </returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.MarchingSquares.MarchingSquares.makeContour(System.Double[][],System.Double)">
 <summary>
 Create neighbor info for a single threshold. Neighbor info indicates
 which of the 4 surrounding data values are above or below the threshold.
 </summary>
 <param name="data"> measured data to use for isoline generation. </param>
 <param name="level"> threshold to use as iso levels. </param>
 <returns> return an array of iso GeneralPaths. Each array element
 corresponds to the same threshold in the 'levels' input array. </returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.MarchingSquares.MarchingSquares.mkIso(Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.MarchingSquares.IsoCell[][],System.Double[][],System.Double)">
 <summary>
 Build up a Shape corresponding to the isoline, and erase isoline at same
 time. Erasing isoline is important because it is expected that this
 method will be called repeatedly until no more isolines exist for a given
 threshold.
 </summary>
 <param name="isoData"> info indicating which adjacent neighbors are above or
 below threshold. </param>
 <param name="data"> measured data. </param>
 <param name="threshold"> this isoline's threshold value. </param>
 <returns> GeneralPath, possibly with disjoint areas and holes,
 representing isolines.  Shape is guaranteed closed and can be filled. </returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.MarchingSquares.MarchingSquares.isoSubpath(Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.MarchingSquares.IsoCell[][],System.Int32,System.Int32,Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.MarchingSquares.GeneralPath)">
 <summary>
 A given iso level can be made up of multiple disconnected regions and
 each region can have multiple holes. Both regions and holes are captured
 as individual iso subpaths. An existing GeneralPath is passed to this
 method so that a new subpath, which is a collection of one moveTo and
 multiple lineTo calls, can be added to it.
 </summary>
 <param name="isoData"> info indicating which adjacent neighbors are above or
 below threshold. </param>
 <param name="r"> row in isoData to start new sub-path. </param>
 <param name="c"> column is isoData to start new sub-path. </param>
 <param name="iso"> existing GeneralPath to which sub-path will be added. </param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.MarchingSquares.MarchingSquares.padData(System.Double[][],System.Double[])">
 <summary>
 Surround data with values less than any in the data to guarantee Marching
 Squares will find complete polygons and not march off the edge of the
 data area.
 </summary>
 <param name="data"> 2d data array to be padded </param>
 <returns> array which is a copy of input padded with top/bottom rows and
 left/right columns of values 1 less than smallest value in array. </returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.MarchingSquares.MarchingSquares.ovalOfCassini(System.Double,System.Double,System.Double,System.Double)">
 <summary>
 If desired, points of the isos can be drawn using the smooth ovals of
 Cassini.
 </summary>
 <param name="x"> </param>
 <param name="y"> </param>
 <param name="a"> </param>
 <param name="b">
 @return </param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.MarchingSquares.MarchingSquares.interpolateCrossing(Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.MarchingSquares.IsoCell[][],System.Double[][],System.Int32,System.Int32,System.Double)">
 <summary>
 Once Marching Squares has determined the kinds of lines crossing a cell,
 this method uses linear interpolation to make the crossings more
 representative of the data.
 </summary>
 <param name="isoData"> array of values of 0-15 indicating contour type. </param>
 <param name="data"> original data needed for linear interpolation. </param>
 <param name="r"> current row index. </param>
 <param name="c"> current column index. </param>
 <param name="threshold"> threshold for this iso level. </param>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.MarchingSquares.MeasureData">
 <summary>
 测量数据
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.MarchingSquares.MeasureData.X">
 <summary>
 坐标X
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.MarchingSquares.MeasureData.Y">
 <summary>
 坐标Y
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.MarchingSquares.MeasureData.Z">
 <summary>
 高度
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.MarchingSquares.MeasureData.#ctor(System.Int32,System.Int32,System.Double)">
 <summary>
 初始化测量数据
 </summary>
 <param name="x">坐标x</param>
 <param name="y">坐标y</param>
 <param name="z">高度</param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.PolylineSimplify.ISimplifyUtility.Simplify(Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.PolylineSimplify.Point[],System.Double,System.Boolean)">
 <summary>
 Simplifies a list of points to a shorter list of points.
 </summary>
 <param name="points">Points original list of points</param>
 <param name="tolerance">Tolerance tolerance in the same measurement as the point coordinates</param>
 <param name="highestQuality">Enable highest quality for using Douglas-Peucker, 
 set false for Radial-Distance algorithm</param>
 <returns>Simplified list of points</returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.PolylineSimplify.SimplifyUtility">
 <summary>
 Simplification of a 2D-polyline.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.PolylineSimplify.SimplifyUtility.Simplify(Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.PolylineSimplify.Point[],System.Double,System.Boolean)">
 <summary>
 Simplifies a list of points to a shorter list of points.
 </summary>
 <param name="points">Points original list of points</param>
 <param name="tolerance">Tolerance tolerance in the same measurement as the point coordinates</param>
 <param name="highestQuality">Enable highest quality for using Douglas-Peucker, set false for Radial-Distance algorithm</param>
 <returns>Simplified list of points</returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.PolylineSimplify.SimplifyUtility.SimplifyArray(Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.PolylineSimplify.Point[],System.Double,System.Boolean)">
 <summary>
 Simplifies a list of points to a shorter list of points.
 </summary>
 <param name="points">Points original list of points</param>
 <param name="tolerance">Tolerance tolerance in the same measurement as the point coordinates</param>
 <param name="highestQuality">Enable highest quality for using Douglas-Peucker, set false for Radial-Distance algorithm</param>
 <returns>Simplified list of points</returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.PolylineSimplify.SimplifyUtility3D">
 <summary>
 Simplification of a 3D-polyline. 
 Use only the 3D version if your point contains altitude information, 
 if no altitude information is provided the 2D library gives a 20%
 performance gain.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.PolylineSimplify.SimplifyUtility3D.GetSquareDistance(Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.PolylineSimplify.Point,Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.PolylineSimplify.Point)">
 <summary>
 square distance between 2 points
 </summary>
 <param name="p1"></param>
 <param name="p2"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.PolylineSimplify.SimplifyUtility3D.Simplify(Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.PolylineSimplify.Point[],System.Double,System.Boolean)">
 <summary>
 Simplifies a list of points to a shorter list of points.
 </summary>
 <param name="points">Points original list of points</param>
 <param name="tolerance">Tolerance tolerance in the same measurement as the point coordinates</param>
 <param name="highestQuality">Enable highest quality for using Douglas-Peucker, set false for Radial-Distance algorithm</param>
 <returns>Simplified list of points</returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.PolylineSimplify.SimplifyUtility3D.SimplifyArray(Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.PolylineSimplify.Point[],System.Double,System.Boolean)">
 <summary>
 Simplifies a list of points to a shorter list of points.
 </summary>
 <param name="points">Points original list of points</param>
 <param name="tolerance">Tolerance tolerance in the same measurement as the point coordinates</param>
 <param name="highestQuality">Enable highest quality for using Douglas-Peucker, set false for Radial-Distance algorithm</param>
 <returns>Simplified list of points</returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.DelaunayVoronoi.Edge">
 <summary> The line segment connecting the two Sites is part of the Delaunay triangulation
 The line segment connecting the two Vertices is part of the Voronoi diagram </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.DelaunayVoronoi.Edge.CreateBisectingEdge(Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.DelaunayVoronoi.Site,Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.DelaunayVoronoi.Site)">
 <summary> This is the only way to create a new Edge </summary>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.DelaunayVoronoi.Voronoi">
 <summary>
 https://github.com/jfg8/csDelaunay
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.DelaunayVoronoi.Voronoi.PlotBounds">
 <summary>
 TODO generalize this so it doesn't have to be a rectangle;
 then we can make the fractal voronois-within-voronois
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.DelaunayVoronoi.Voronoi.Regions">
 <summary>
 [output] the generated region polygon data
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Math2D.DelaunayVoronoi.Voronoi.SiteCoords">
 <summary>
 the input points
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Drawing2D.PolarGraphics2D">
 <summary>
 以极坐标为主的作图系统模块
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.PolarGraphics2D.center">
 <summary>
 通过极坐标计算出二维直角坐标的圆心中心点
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.PolarGraphics2D.canvas">
 <summary>
 the graphics canvas module
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.PolarGraphics2D.MeasureString(System.String,Microsoft.VisualBasic.Imaging.Font)">
 <summary>
 Measures the specified string when drawn with the specified <see cref="T:Microsoft.VisualBasic.Imaging.Font"/>.
 </summary>
 <param name="text">String to measure.</param>
 <param name="font">System.Drawing.Font that defines the text format of the string.</param>
 <returns>This method returns a System.Drawing.SizeF structure that represents the size,
 in the units specified by the System.Drawing.Graphics.PageUnit property, of the
 string specified by the text parameter as drawn with the font parameter.
 </returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.PolarGraphics2D.DrawString(System.String,Microsoft.VisualBasic.Imaging.Font,Microsoft.VisualBasic.Imaging.Brush,Microsoft.VisualBasic.Imaging.Math2D.PolarPoint)">
 <summary>
 Draws the specified text string at the specified location with the specified
 <see cref="T:Microsoft.VisualBasic.Imaging.Brush"/> and <see cref="T:Microsoft.VisualBasic.Imaging.Font"/> objects.
 </summary>
 <param name="s">String to draw.</param>
 <param name="font">System.Drawing.Font that defines the text format of the string.</param>
 <param name="brush">System.Drawing.Brush that determines the color and texture of the drawn text.</param>
 <param name="point">System.Drawing.PointF structure that specifies the upper-left corner of the drawn
 text.</param>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.PolarGraphics2D.DrawLine(Microsoft.VisualBasic.Imaging.Pen,Microsoft.VisualBasic.Imaging.Math2D.PolarPoint,Microsoft.VisualBasic.Imaging.Math2D.PolarPoint)">
 <summary>
 Draws a line connecting two System.Drawing.PointF structures.
 </summary>
 <param name="pen"><see cref="T:Microsoft.VisualBasic.Imaging.Pen"/> that determines the color, width, and style of the line.</param>
 <param name="pt1"><see cref="T:Microsoft.VisualBasic.Imaging.Math2D.PolarPoint"/> structure that represents the first point to connect.</param>
 <param name="pt2"><see cref="T:Microsoft.VisualBasic.Imaging.Math2D.PolarPoint"/> structure that represents the second point to connect.</param>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.PolarGraphics2D.DrawImage(Microsoft.VisualBasic.Imaging.Image,Microsoft.VisualBasic.Imaging.Math2D.PolarPoint)">
 <summary>
 Draws the specified <see cref="T:Microsoft.VisualBasic.Imaging.Image"/>, using its original physical size, at
 the specified location.
 </summary>
 <param name="image"><see cref="T:Microsoft.VisualBasic.Imaging.Image"/> to draw.</param>
 <param name="point"><see cref="T:Microsoft.VisualBasic.Imaging.Math2D.PolarPoint"/> structure that represents the upper-left corner of the
 drawn image.</param>
 
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Drawing2D.PrinterDimension">
 <summary>
 the size definition of the printer, usually apply for the PDF output
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.PrinterDimension.SizeOf(System.String)">
 <summary>
 The size expression parser
 </summary>
 <param name="expr">
 1. [w,h]: 100,200
 2. term_names: A4 
 3. times(size/term_names): 5(A4) = 5*297,5*210 = 1485,1050
 4. portal(times(size))
 </param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Drawing2D.Path2D">
 <summary>
 通过模拟HTML之中的svg path的绘图操作来将html svg path转换为gdi+ path对象
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Path2D.CurveTo(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Boolean)">
 <summary>
 三次贝塞曲线
 </summary>
 <param name="x1#">第一控制点X</param>
 <param name="y1#">第一控制点Y</param>
 <param name="x2#">第二控制点X</param>
 <param name="y2#">第二控制点Y</param>
 <param name="endX#">曲线结束点X</param>
 <param name="endY#">曲线结束点Y</param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Path2D.EllipticalArc(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Boolean)">
 <summary>
 
 </summary>
 <param name="rX!">所在椭圆的半轴大小</param>
 <param name="rY!">所在椭圆的半轴大小</param>
 <param name="xrotation!">椭圆的X轴与水平方向顺时针方向夹角，可以想像成一个水平的椭圆绕中心点顺时针旋转XROTATION的角度。</param>
 <param name="flag1!">1表示大角度弧线，0为小角度弧线。</param>
 <param name="flag2!">确定从起点至终点的方向，1为顺时针，0为逆时针</param>
 <param name="x!">终点坐标</param>
 <param name="y!">终点坐标</param>
 <param name="relative"></param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Path2D.Rewind">
 <summary>
 重置
 </summary>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Path2D.CloseAllFigures">
 <summary>
 关闭所有打开的数字，在此路径，并开始一个新图形。 通过将行从其终结点连接到其起始点，则关闭每个打开的图形。
 </summary>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.RenderShape.DrawArrowHead(Microsoft.VisualBasic.Imaging.IGraphics,Microsoft.VisualBasic.Imaging.Pen,System.Drawing.PointF,System.Drawing.PointF)">
 <summary>
 在指定终点绘制箭头头部
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.RenderShape.RenderBoid(Microsoft.VisualBasic.Imaging.IGraphics,System.Single,System.Single,System.Single,System.Single,System.Drawing.Color,System.Single,System.Single)">
 <summary>
 Arrow drawing for the .net core console application
 </summary>
 <param name="maxL">max length of the force</param>
 <param name="w">
 the pen width
 </param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Shadow.#ctor(System.Single,System.Single,System.Single,System.Single)">
 <summary>
 
 </summary>
 <param name="distance">正实数</param>
 <param name="angle">[0, 360]</param>
 <param name="scaleX!"></param>
 <param name="scaleY!"></param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Shadow.DropdownShadows(Microsoft.VisualBasic.Imaging.IGraphics,System.Drawing.RectangleF,System.String,System.String,System.String)">
 <summary>
 Draw shadow of a specifc <paramref name="rectangle"/>
 </summary>
 <param name="g"></param>
 <param name="rectangle"></param>
 <param name="shadowColor$"></param>
 <param name="alphaLevels$"></param>
 <param name="gradientLevels$"></param>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Drawing2D.Shapes.Arrow">
 <summary>
 按照任意角度旋转的箭头对象
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.Shapes.Arrow.HeadLengthPercentage">
 <summary>
 箭头的头部占据整个长度的百分比
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.Shapes.Arrow.BodyHeightPercentage">
 <summary>
 箭头的主体部分占据整个高度的百分比
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Shapes.Arrow.#ctor(System.Drawing.Point,System.Drawing.Size,System.Drawing.Color)">
 <summary>
 
 </summary>
 <param name="Location">箭头头部的位置</param>
 <param name="Size">高度和宽度</param>
 <param name="Color">填充的颜色</param>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.Shapes.Arrow.Size">
 <summary>
 返回图形上面的绘图的大小，而非箭头本身的大小
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.Shapes.Arrow.Left">
 <summary>
 忽略了箭头的方向，本箭头对象存粹的在进行图形绘制的时候的左右的位置
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.Shapes.Arrow.Right">
 <summary>
 忽略了箭头的方向，本箭头对象存粹的在进行图形绘制的时候的左右的位置
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Shapes.Arrow.Draw(Microsoft.VisualBasic.Imaging.IGraphics@,System.Drawing.Point)">
 <summary>
  /|_____
 /       |
 \       |
  \|-----
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Shapes.Arrow.ArrowHead(System.Single,System.Single)">
 <summary>
 
 </summary>
 <param name="height!">箭头的底部的高度的1/2</param>
 <param name="length!">箭头顶部到底部的长度</param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Drawing2D.Shapes.Box">
 <summary>
 rectangle model
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Shapes.Box.#ctor(System.Drawing.Point,System.Drawing.Size,System.Drawing.Color)">
 <summary>
 
 </summary>
 <param name="Location"></param>
 <param name="Size"></param>
 <param name="Color">the fill color of the rectangle object</param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Shapes.Box.#ctor(System.Drawing.Rectangle,System.Drawing.Color)">
 <summary>
 Create new rectangle box with fill color
 </summary>
 <param name="rect"></param>
 <param name="color">the fill color</param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Shapes.Box.#ctor(System.Drawing.RectangleF,System.Drawing.Color)">
 <summary>
 Create new rectangle box with fill color
 </summary>
 <param name="rect"></param>
 <param name="color">the fill color</param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Shapes.Circle.#ctor(System.Drawing.PointF,System.Int32,System.Drawing.Color)">
 <summary>
 
 </summary>
 <param name="topLeft">左上角</param>
 <param name="d">圆的直径</param>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Shapes.Circle.Draw(Microsoft.VisualBasic.Imaging.IGraphics@,System.Drawing.PointF,System.Single,Microsoft.VisualBasic.Imaging.Brush,Microsoft.VisualBasic.MIME.Html.CSS.Stroke)">
 <summary>
 绘制圆
 </summary>
 <param name="g"></param>
 <param name="center"></param>
 <param name="radius"></param>
 <param name="br"></param>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Drawing2D.Shapes.Hexagon">
 <summary>
 六边形
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.Shapes.Line.Length">
 <summary>
 线段的长度
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.Shapes.Line.Alpha">
 <summary>
 返回线段和X轴的夹角，夹角值为弧度值
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Shapes.Line.#ctor(System.Drawing.PointF,System.Drawing.PointF,System.Drawing.Color,System.Int32)">
 <summary>
 
 </summary>
 <param name="a">在进行位移的时候，这两个点之间的相对位置不会发生改变</param>
 <param name="b"></param>
 <param name="c"></param>
 <param name="width"></param>
 <remarks></remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Shapes.Line.LengthVariationFromPointA(System.Double)">
 <summary>
 在A短点处发生长度变化, B点的位置不变
 </summary>
 <param name="d">大于零为长度延伸,小于零为线段的长度缩短</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Shapes.Line.ParallelShift(System.Double)">
 <summary>
 对这条线段进行平行位移
 </summary>
 <param name="d#">位移的距离</param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Drawing2D.Shapes.Pentacle">
 <summary>
 五角星
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Shapes.Pentacle.RotateTheta(System.Drawing.Point,System.Drawing.Point,System.Single)">
 <summary>
 旋转
 </summary>
 <param name="pt"></param>
 <param name="center"></param>
 <param name="theta"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Drawing2D.Shapes.RoundRect">
 <summary>
 绘制圆角矩形
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Shapes.RoundRect.Draw(Microsoft.VisualBasic.Imaging.IGraphics@,System.Drawing.PointF,System.Drawing.SizeF,System.Int32,Microsoft.VisualBasic.Imaging.Brush,Microsoft.VisualBasic.MIME.Html.CSS.Stroke)">
 <summary>
 
 </summary>
 <param name="g"></param>
 <param name="topLeft"></param>
 <param name="size"></param>
 <param name="radius"></param>
 <param name="br">
 If the brush value is not nothing, then this plot function
 will use this brush value fill the background
 </param>
 <param name="border"></param>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Drawing2D.Shapes.Shape">
 <summary>
 An abstract shape element with layout information data.
 </summary>
 <remarks>
 (矢量图形)
 </remarks>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.Shapes.Shape.Location">
 <summary>
 the location of the current shape element
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.Shapes.Shape.TooltipTag">
 <summary>
 the metadata string of current shape element
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.Shapes.Shape.DrawingRegion">
 <summary>
 create the layout rectangle value based on the shape <see cref="P:Microsoft.VisualBasic.Imaging.Drawing2D.Shapes.Shape.Location"/> and its shape <see cref="P:Microsoft.VisualBasic.Imaging.Drawing2D.Shapes.Shape.Size"/>.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.Shapes.Shape.EnableAutoLayout">
 <summary>
 默认是允许自动组织布局的
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Shapes.Shape.#ctor(System.Drawing.Point)">
 <summary>
 create new shape element with a given <see cref="P:Microsoft.VisualBasic.Imaging.Drawing2D.Shapes.Shape.Location"/> value
 </summary>
 <param name="initLoci"></param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Shapes.Shape.#ctor(System.Drawing.PointF)">
 <summary>
 create new shape element with a given <see cref="P:Microsoft.VisualBasic.Imaging.Drawing2D.Shapes.Shape.Location"/> value
 </summary>
 <param name="loc"></param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Shapes.Shape.Draw(Microsoft.VisualBasic.Imaging.IGraphics@,System.Drawing.Point)">
 <summary>
 
 </summary>
 <param name="OverridesLoci">假若需要进行绘制到的时候复写当前的元素的位置，则请使用这个参数</param>
 <returns>函数返回当前元素在绘制之后所占据的区域</returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.Shapes.Triangle.Size">
 <summary>
 get the possible shape size of the triangle shape object
 </summary>
 <returns>
 width is the delta of the vertex2 and vertex3 x location;
 height is the delta of the vertex1 with mean of vertex2 and vertex3 y location value.
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Shapes.Triangle.DrawAsRightTriangle(System.Int32,System.Int32)">
 <summary>
 直角三角形
 </summary>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Shapes.Triangle.Draw(Microsoft.VisualBasic.Imaging.IGraphics@,System.Drawing.Point,System.Drawing.Size,Microsoft.VisualBasic.Imaging.Brush,Microsoft.VisualBasic.MIME.Html.CSS.Stroke,System.Boolean)">
 <summary>
 
 </summary>
 <param name="g"></param>
 <param name="topLeft"></param>
 <param name="size"></param>
 <param name="br"></param>
 <param name="border"></param>
 <param name="reversed">默认是顶部向上，如果reverse为真的话，则顶部向下</param>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Drawing2D.Text.ASCIIArt.HelperMethods">
 <summary>
 Program that converts images to ASCII art images
 
 > https://github.com/juangallostra/Image2ASCII
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Text.ASCIIArt.HelperMethods.Convert2ASCII(Microsoft.VisualBasic.Imaging.Image,Microsoft.VisualBasic.Imaging.Drawing2D.Text.ASCIIArt.WeightedChar[])">
 <summary>
 Image input <paramref name="monoImage"/> should be processed by <see cref="M:Microsoft.VisualBasic.Imaging.BitmapImage.BitmapScale.Binarization(Microsoft.VisualBasic.Imaging.Bitmap@,Microsoft.VisualBasic.Imaging.BitmapImage.BitmapScale.BinarizationStyles)"/> or <see cref="M:Microsoft.VisualBasic.Imaging.BitmapImage.BitmapScale.Grayscale(Microsoft.VisualBasic.Imaging.BitmapImage.BitmapBuffer@,System.Single,System.Single,System.Single)"/>, without colors.
 </summary>
 <param name="monoImage"></param>
 <param name="characters"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Text.ASCIIArt.HelperMethods.DrawText(System.String,System.Drawing.Color,System.Drawing.Color,System.Drawing.SizeF,Microsoft.VisualBasic.Imaging.Font)">
 <summary>
 将字符转换为图像
 </summary>
 <param name="text$"></param>
 <param name="textColor"></param>
 <param name="backColor"></param>
 <param name="WidthAndHeight"></param>
 <param name="fontStyle"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Drawing2D.Text.ASCIIArt.WeightedChar">
 <summary>
 a pixel char
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.Text.ASCIIArt.WeightedChar.Character">
 <summary>
 a char that represent a pixel on the source bitmap
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.Text.ASCIIArt.WeightedChar.Weight">
 <summary>
 the gray scale value
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Drawing2D.Text.HTMLRender">
 <summary>
 进行简单的HTML片段的渲染
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Text.HTMLRender.MeasureSize(Microsoft.VisualBasic.Imaging.IGraphics,Microsoft.VisualBasic.MIME.Html.Render.TextString[])">
 <summary>
 估算出文本的绘制区域大小
 </summary>
 <param name="g"></param>
 <param name="html"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Text.HTMLRender.RenderHTML(Microsoft.VisualBasic.Imaging.IGraphics,Microsoft.VisualBasic.MIME.Html.Render.TextString[],System.Drawing.PointF)">
 <summary>
 
 </summary>
 <param name="g"></param>
 <param name="html"></param>
 <param name="topleft">程序会以这个位置为原点进行布局的计算操作</param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Text.Nudge.Adjustment.make_text_rectangle(Microsoft.VisualBasic.Imaging.d3js.Layout.Label,System.Double[],Microsoft.VisualBasic.Imaging.Drawing2D.Text.Nudge.GraphicsTextHandle)">
 <summary>
 function to create text rectangle from xy coordonnee and text to print.
 Added a coef to balance output for some reason
 </summary>
 <param name="marge"></param>
 <param name="ax"></param>
 <returns></returns>
 
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Drawing2D.Text.Nudge.CloudOfTextRectangle">
 <summary>
 class to represent an esemble of TextRectangle object. I.e in the
 pyplot context, a cloud Of text annotation To attached point. Goal Is To 
 arrange the cloud Of point In order To have the least conflicts between 
 ext (i.e Rectangles). 

 So we will define a method To Get And count the conflicts, an other To
 arrange the cloud Of text rectangle In all possible ways With the "error"
 Function (number Of conflicts) To minimize
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing2D.Text.Nudge.CloudOfTextRectangle.list_tr">
 <summary>
 a collection of the text labels
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing2D.Text.Nudge.CloudOfTextRectangle.conflicts">
 <summary>
 <see cref="F:Microsoft.VisualBasic.Imaging.Drawing2D.Text.Nudge.CloudOfTextRectangle.list_tr"/> element index which there 
 text rectangle is conflicts with each other
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Text.Nudge.CloudOfTextRectangle.get_conflicts">
 <summary>
 function that compute the conflicts associated to a cloud of
 text rectangles.
 output: list of tuple. tuple Or text rectangle's index involved
 in conflicts. So conflicts are modelised as pairs.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Text.Nudge.CloudOfTextRectangle.new_config_cloud(System.Int32,Microsoft.VisualBasic.Imaging.Drawing2D.Text.Nudge.States)">
 <summary>
 function to change the state of i-ème text rectangle in the
 cloud of text rectangle.
 </summary>
 <param name="index"></param>
 <param name="state"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Text.Nudge.CloudOfTextRectangle.treat_conflicts(System.Collections.Generic.List{Microsoft.VisualBasic.Imaging.Drawing2D.Text.Nudge.CloudOfTextRectangle},System.Int32,System.Boolean)">
 <summary>
 resolution of the conflicts is recursive. First, we try
 to resolve the first conflict of the cloud of text rectangle.

 first resolution's try gives two list : a list of cloud with
 new configuration (the textRectangle has a different state's
 configuration) and without the first conflict (i.e the confluct 
 resolved), and a list of cloud with new new configuration and new 
 conflict. The we recursely do this resolution on the two different
 kind of clouds we get. The stop criteria is no conflict, or if we 
 have previously explore all the conflict/configuration situation
 before.
 </summary>
 <param name="parent_nodes_conflicts">
 empty list. Needed for recursion.
 </param>
 <param name="cpt"></param>
 <returns>
 a tree of resolved conflicts in the form of
 recursively nested dictionary.
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Text.Nudge.CloudOfTextRectangle.arrange_text(System.Boolean,System.Boolean)">
 <summary>
 main Function To arrange texts Using treat_conflicts result	
 </summary>
 <param name="arrows"></param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.Text.Nudge.ConflictIndexTuple.i">
 <summary>
 [0] item 1
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.Text.Nudge.ConflictIndexTuple.j">
 <summary>
 [1] item 2
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing2D.Text.Nudge.GraphicsTextHandle.canvas">
 <summary>
 the internal plot region
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Drawing2D.Text.Nudge.PlateRectangle">
 <summary>
 class of the geometrical figure of the plate rectangle, i.e
 the sides Of the rectangle are collinear With the canonical 
 basis vectors (1,0) And (0,1).
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Text.Nudge.PlateRectangle.#ctor(System.Double[],System.Double,System.Double)">
 <summary>
 This is a "plate" rectangle
 </summary>
 <param name="bottomLeft">``x1`` for the coordinates of the bottom left point.</param>
 <param name="l">l for the length of the rectangle to get the bottom right point</param>
 <param name="h">h for the height of the rectangle</param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Text.Nudge.PlateRectangle.isEqual(Microsoft.VisualBasic.Imaging.Drawing2D.Text.Nudge.PlateRectangle)">
 <summary>
 return True if self rectangle equals passed argument rectangle
 </summary>
 <param name="r"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Text.Nudge.PlateRectangle.contains_point(System.Double[])">
 <summary>
 method that evaluates if self rectangle contains a point
 Or Not. 
 </summary>
 <param name="p"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Text.Nudge.PlateRectangle.contains_rectangle_top(Microsoft.VisualBasic.Imaging.Drawing2D.Text.Nudge.PlateRectangle)">
 <summary>
 method that evaluates if self rectangle contains at least
 one of another's rectangle tops or not. 
 </summary>
 <param name="r">object of class Rectangle</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Text.Nudge.PlateRectangle.covers_rectangle(Microsoft.VisualBasic.Imaging.Drawing2D.Text.Nudge.PlateRectangle)">
 <summary>
 method that evaluates if self rectangle covers another
 rectangle Or Not. Return true if self And rectangle doesn't contains
 each other one of theirs top.
 </summary>
 <param name="r">object of class Rectangle</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Text.Nudge.SimpleNudge.ReduceOverlap(System.Collections.Generic.List{Microsoft.VisualBasic.Imaging.d3js.Layout.Label},System.Int32,System.Single)">
 <summary>
 减少标签重叠的主优化方法
 </summary>
 <param name="labels">待优化的标签列表</param>
 <param name="maxIterations">最大迭代次数</param>
 <param name="minDistance">最小允许距离</param>
 <returns>优化后的标签列表</returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Text.Nudge.SimpleNudge.CheckOverlap(Microsoft.VisualBasic.Imaging.d3js.Layout.Label,Microsoft.VisualBasic.Imaging.d3js.Layout.Label)">
 <summary>
 检查两个标签是否重叠
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Text.Nudge.SimpleNudge.CalculateAdjustment(Microsoft.VisualBasic.Imaging.d3js.Layout.Label,Microsoft.VisualBasic.Imaging.d3js.Layout.Label,System.Single)">
 <summary>
 计算需要调整的方向和距离
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Text.Nudge.SimpleNudge.ApplyAdjustment(Microsoft.VisualBasic.Imaging.d3js.Layout.Label,System.Drawing.PointF)">
 <summary>
 应用位置调整到标签
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Drawing2D.Text.Nudge.TextRectangle">
 <summary>
 class of particular rectangle in the context of pyplot.
 For the need of our problematic which Is To avoid texts annotation
 overlayering.

 a TextRectngle Is just a rectangle With a state. A state Is a given 
 position compared To the point at wich the rectangle (i.e the text 
 in pyplot) Is attached.

 We consider 4 possible state. The first state Is the Default state
 which Is the text positionned at the top-right of the attached point.
 Second state the text Is at the top left, In the third state it's at the
 right bottom And at the fourth state it's at the left bottom.

 Given this, estimate the length Is important To avoid an important shift
 For the second And fourth states.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Text.Nudge.TextRectangle.change_state(Microsoft.VisualBasic.Imaging.Drawing2D.Text.Nudge.States)">
 <summary>
 通过这个函数尝试进行位置更新
 </summary>
 <param name="state"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Text.WordWrap.DrawTextCentraAlign(Microsoft.VisualBasic.Imaging.IGraphics,System.String,System.Drawing.PointF,Microsoft.VisualBasic.Imaging.Brush,Microsoft.VisualBasic.Imaging.Font)">
 <summary>
 
 </summary>
 <param name="g"></param>
 <param name="wrappedText">
 Label text that re-layout by <see cref="M:Microsoft.VisualBasic.Imaging.Drawing2D.Text.WordWrap.DoWordWrap(System.String,System.Int32,System.String)"/>.
 </param>
 <param name="location"></param>
 <param name="brush"></param>
 <param name="font"></param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing2D.Text.WordWrap.DoWordWrap(System.String,System.Int32,System.String)">
 <summary>
 
 </summary>
 <param name="str">目标字符串</param>
 <param name="width">一行文本所限定的字符个数</param>
 <param name="splitChars">在行末所插入的分隔符</param>
 <returns></returns>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing3D.Camera.viewDistance">
 <summary>
 the view distance from the user view to target object
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing3D.Camera.offset">
 <summary>
 Using for the project result 
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing3D.Camera.lightAngle">
 <summary>
 Light
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing3D.Camera.colorDifference">
 <summary>
 Light
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing3D.Camera.lightColor">
 <summary>
 Light, default using <see cref="P:System.Drawing.Color.White"/> as the light color
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing3D.Camera.ToString">
 <summary>
 debug view
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Drawing3D.DrawGraphics">
 <summary>
 3D plot for Gdidevice，由于是需要将图像显示到WinFom控件上面，所以在这里要求的是gdi+的图形驱动程序
 </summary>
 <param name="canvas">gdi+ handle</param>
 <param name="camera">3d camera</param>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Drawing3D.IPointCloud">
 <summary>
 A 3D spatial heatmap point, 3d point [x,y,z] combine with the color scaler(or heatmap) data
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Drawing3D.IsometricEngine">
 <summary>
 Isometric 3d graphics painter
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing3D.IsometricEngine.models">
 <summary>
 The 3D models
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing3D.IsometricEngine.TranslatePoint(Microsoft.VisualBasic.Imaging.Drawing3D.Point3D)">
 <summary>
 + X rides along the angle extended from the origin
 + Y rides perpendicular to this angle (in isometric view: PI - angle)
 + Z affects the y coordinate of the drawn point
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing3D.IsometricEngine.AddPath(Microsoft.VisualBasic.Imaging.Drawing3D.Models.Isometric.Path3D,System.Drawing.Color)">
 <summary>
 这个函数会同时对曲面进行光照处理
 </summary>
 <param name="path"></param>
 <param name="color"></param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing3D.IsometricEngine.Measure(System.Int32,System.Int32,System.Boolean)">
 <summary>
 The 3D projection and model matrix transformation.
 (在绘图前面需要调用这个方法进行图形合成)
 </summary>
 <param name="width"></param>
 <param name="height"></param>
 <param name="sort"></param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing3D.IsometricEngine.Draw(Microsoft.VisualBasic.Imaging.IGraphics@)">
 <summary>
 Draw the 3D graphics onto the canvas device object.(进行三维图形绘图操作)
 </summary>
 <param name="canvas"></param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing3D.IsometricEngine.IsPointInPoly(System.Collections.Generic.IList{Microsoft.VisualBasic.Imaging.Drawing3D.Point3D},System.Double,System.Double)">
 <summary>
 点对象是否处于多边形对象<paramref name="poly"/>之中
 </summary>
 <param name="poly"></param>
 <param name="x"></param>
 <param name="y"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing3D.IsometricEngine.IntersectionWith(Microsoft.VisualBasic.Imaging.Drawing3D.Point3D[],Microsoft.VisualBasic.Imaging.Drawing3D.Point3D[])">
 <summary>
 判断两个多边形是否具有相交的部分
 </summary>
 <param name="pointsA"></param>
 <param name="pointsB"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Drawing3D.Device.Light">
 <summary>
 <see cref="T:Microsoft.VisualBasic.Imaging.Drawing3D.Surface"/>的表面光照的计算
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing3D.Device.Light.Illumination(System.Collections.Generic.IEnumerable{Microsoft.VisualBasic.Imaging.Drawing3D.PainterAlgorithm.Polygon})">
 <summary>
 Makes the 3D graphic more natural.(旧的光照模型，不推荐使用)
 </summary>
 <param name="surfaces">
 Polygon buffer.(经过投影和排序之后得到的多边形的缓存对象)
 </param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing3D.Device.Light.Lighting(Microsoft.VisualBasic.Imaging.Drawing3D.Models.Isometric.Path3D,Microsoft.VisualBasic.Imaging.Drawing3D.Point3D,System.Drawing.Color,System.Double,System.Drawing.Color)">
 <summary>
 对模型之中的某一个表面进行光照处理
 </summary>
 <param name="path">这个对象是一个平面</param>
 <param name="color"></param>
 <param name="lightColor">光源的颜色，最常用的光源颜色为白色``<see cref="P:System.Drawing.Color.White"/>``</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing3D.Device.Light.Lighting(Microsoft.VisualBasic.Imaging.Drawing3D.Point3D[],Microsoft.VisualBasic.Imaging.Drawing3D.Point3D,System.Drawing.Color,System.Double,System.Drawing.Color)">
 <summary>
 
 </summary>
 <param name="vertices">构成模型之中的一个表面的顶点数据</param>
 <param name="lightAngle"></param>
 <param name="color"></param>
 <param name="colorDifference#"></param>
 <param name="lightColor"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Drawing3D.Math3D.DistanceFieldSampler.Vertex">
 <summary>
 Represents a point along a path.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing3D.Math3D.DistanceFieldSampler.Vertex.Pos">
 <summary>
 Position in 3D space of the vertex.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing3D.Math3D.DistanceFieldSampler.Vertex.Radius">
 <summary>
 Radius of the line segment starting at this vertex.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing3D.Math3D.DistanceFieldSampler.Vertex.StartPoint">
 <summary>
 If true, this vertex has no edge preceding it.
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Drawing3D.Math3D.DistanceFieldSampler.Edge">
 <summary>
 A pair of vertices that define a line segment.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing3D.Math3D.DistanceFieldSampler.Edge.First">
 <summary>
 Start vertex of the line segment.
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing3D.Math3D.DistanceFieldSampler.Edge.Second">
 <summary>
 End vertex of the line segment.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing3D.Math3D.DistanceFieldSampler.FindNearbyEdges(System.Collections.Generic.List{Microsoft.VisualBasic.Imaging.Drawing3D.Math3D.DistanceFieldSampler.Vertex},System.Single,Microsoft.VisualBasic.Imaging.Math2D.Vector2D,Microsoft.VisualBasic.Imaging.Math2D.Vector2D,System.Collections.Generic.List{Microsoft.VisualBasic.Imaging.Drawing3D.Math3D.DistanceFieldSampler.Edge})">
 <summary>
 Find a list of edgest from the given vertex list that will possibly intesect with the
 given rectangle, defined by it's vertical position (<paramref name="layerPos"/>), and
 minimum and maximum X and Z bounds (<paramref name="min"/> and <paramref name="max"/>).
 </summary>
 <param name="path">List of vertices to search through/</param>
 <param name="layerPos">Vertical position of the rectangle to find edges near to.</param>
 <param name="min">Minimum X and Z coordinates of the rectangle.</param>
 <param name="max">Maximum X and Z coordinates of the rectangle.</param>
 <param name="outEdges">List to append the results to.</param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing3D.Math3D.Matrix.TranslateBuffer(Microsoft.VisualBasic.Imaging.Drawing3D.Camera,Microsoft.VisualBasic.Imaging.Drawing3D.Math3D.Vector3D,System.Boolean)">
 <summary>
 投影
 </summary>
 <param name="v">经过转换之后的向量，例如旋转或者位移，在这个函数值中会利用摄像机进行投影</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing3D.Math3D.MaxPlainCameraView.CalculateOptimalCameraView(System.Collections.Generic.IEnumerable{Microsoft.VisualBasic.Imaging.Drawing3D.Point3D},System.Double)">
 <summary>
 计算最优摄像头视角来垂直俯瞰点云中的主导平面
 </summary>
 <param name="points">三维点云集合</param>
 <param name="distanceScale">摄像头距离缩放因子</param>
 <returns>摄像头位置坐标</returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing3D.Math3D.MaxPlainCameraView.CalculateCentroid(System.Collections.Generic.List{Microsoft.VisualBasic.Imaging.Drawing3D.Point3D})">
 <summary>
 计算点云质心
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing3D.Math3D.MaxPlainCameraView.CalculateCovarianceMatrix(System.Collections.Generic.List{Microsoft.VisualBasic.Imaging.Drawing3D.Point3D},Microsoft.VisualBasic.Imaging.Drawing3D.Point3D)">
 <summary>
 计算协方差矩阵
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing3D.Math3D.MaxPlainCameraView.CalculatePlaneNormalViaSVD(Microsoft.VisualBasic.Imaging.Drawing3D.Math3D.Matrix3x3)">
 <summary>
 通过SVD计算平面法向量
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing3D.Math3D.MaxPlainCameraView.CalculateCameraPosition(Microsoft.VisualBasic.Imaging.Drawing3D.Point3D,Microsoft.VisualBasic.Imaging.Drawing3D.Point3D,System.Collections.Generic.List{Microsoft.VisualBasic.Imaging.Drawing3D.Point3D},System.Double)">
 <summary>
 计算摄像头位置
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing3D.Math3D.PolyhedronMath.vertex_sign(System.Double[],System.Double[])">
 <summary>
 Sign of the vertex P with respect to O, as defined above.
 </summary>
 <param name="P"></param>
 <param name="O"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing3D.Math3D.PolyhedronMath.edge_sign(System.Double[],System.Double[],System.Double[])">
 <summary>
 Sign of the edge PQ with respect to O, as defined above.
 </summary>
 <param name="P"></param>
 <param name="Q"></param>
 <param name="O"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing3D.Math3D.PolyhedronMath.triangle_sign(System.Double[],System.Double[],System.Double[],System.Double[])">
 <summary>
 Sign of the triangle PQR with respect to O, as defined above.
 </summary>
 <param name="P"></param>
 <param name="Q"></param>
 <param name="R"></param>
 <param name="O"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing3D.Math3D.PolyhedronMath.triangle_chain(System.Double[],System.Double[],System.Double[],System.Double[])">
 <summary>
 Return the contribution of this triangle to the winding number.
 Raise ValueError If the face contains the origin.
 </summary>
 <param name="v1"></param>
 <param name="v2"></param>
 <param name="v3"></param>
 <param name="origin"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Drawing3D.Math3D.Polyhedron">
 <summary>
 ## Robust point-in-polyhedron test.

 Given an closed, oriented surface in R^3 described by a triangular mesh, the
 code below gives a robust algorithm for determining whether a given point is
 inside, on the boundary of, or outside, the surface.  The algorithm should give
 correct results even in degenerate cases, and applies to disconnected
 polyhedra, non simply-connected surfaces, and so on.  There are no requirements
 for the surface to be convex, simple, connected or simply-connected.

 More precisely, we give a method for computing the *winding number* of a closed
 oriented surface S around a point O that doesn't lie on S.  Roughly speaking,
 the winding number of the closed oriented surface S around a point O not on S
 is the number of times that the surface encloses that point; for a simple
 outward-oriented surface (like that of a convex polyhedron, for example), the
 winding number will be 1 for points inside the surface and 0 for points
 outside.

 For a precise definition of winding number, we can turn to algebraic topology:
 our oriented surface is presented as a collection of combinatorial data
 defining abstract vertices, edges and triangles, together with a mapping of
 those vertices to R^3.  The combinatorial data describe a simplicial complex C,
 and assuming that O doesn't lie on the surface, the mapping of the vertices to
 R^3 gives a continuous map from the geometric realization of C to R^3 - {O}.
 This in turn induces a map on second homology groups:

 H^2(C, Z) -> H^2(R^3 - {O}, Z)

 and by taking the usual right-handed orientation in R^3 we identify H^2(R^3 -
 {O}, Z) with Z.  The image of [S] under this map gives the winding number.  In
 particular, the well-definedness of the winding number does not depend on
 topological properties of the embedding: it doesn't matter if the surface is
 self-intersecting, or has degenerate triangles.  The only condition is that O
 does not lie on the surface S.
 </summary>
 <remarks>
 Algorithm
 ---------
 The algorithm is based around the usual method of ray-casting: we take a
 vertical line L through O and count the intersections of this line with the
 triangles of the surface, keeping track of orientations as we go.  Let's ignore
 corner cases for a moment and assume that:

 (1) O does not lie on the surface, and
 (2) for each triangle T (thought of as a closed subset of R^3) touched by
 our vertical line L, L meets the interior of T in exactly one point Q

 Then there are four possibilities for each such triangle T:

 1. T lies *above* O and is oriented *upwards* (*away* from O).
 2. T lies *above* O and is oriented *downwards* (*towards* O).
 3. T lies *below* O and is oriented *downwards* (*away* from O).
 4. T lies *below* O and is oriented *upwards* (*towards* O).

 Let's write N1, N2, N3 and N4 for the counts of triangles satisfying conditions
 1, 2, 3 and 4 respectively.  Since we have a closed surface, these numbers
 are not independent; they satisfy the relation:

 N1 + N4 == N2 + N3

 That is, the number of upward-facing triangles must match the number of
 downward-facing triangles.  The winding number w is then given by:

 w = N1 - N2 == N3 - N4

 In the code below, we simply compute 2*w = (N1 + N3) - (N2 + N4), so each
 triangle oriented away from O contributes 1 to 2w, while each triangle oriented
 towards O contributes -1.


 Making the algorithm robust
 ---------------------------
 Now we describe how to augment the basic algorithm described above to include:

 - correct treatment of corner cases (vertical triangles, cases where L meets an
 edge or vertex directly, etc.)

 - detection of the case where the point lies directly on the surface.

 It turns out that to make the algorithm robust, all we need to do is be careful
 and consistent about classifying vertices, edges and triangles.  We do this as
 follows:

 - Each vertex of the surface that's not equal to O is considered *positive* if
 its coordinates are lexicographically greater than O, and *negative*
 otherwise.

 - For an edge PQ of the surface that's not collinear with O, we first describe
 the classification in the case that P is negative and Q is positive, and
 then extend to arbitrary PQ.

 For P negative and Q positive, there are two cases:

 1. P and Q have distinct x coordinates.  In that case we classify the edge
 PQ by its intersection with the plane passing through O and parallel
 to the yz-plane: the edge is *positive* if the intersection point is
 positive, and *negative* otherwise.

 2. P and Q have the same x coordinate, in which case they must have
 distinct y coordinates.  (If the x and the y coordinates both match
 then PQ passes through O.)  We classify by the intersection of PQ
 with the line parallel to the y-axis through O.

 For P positive and Q negative, we classify as above but reverse the sign.
 For like-signed P and Q, the classification isn't used.

 Computationally, in case 1 above, the y-coordinate of the intersection
 point is:

 Py + (Qy - Py) * (Ox - Px) / (Qx - Px)

 and this is greater than Oy iff

 (Py - Oy) * (Qx - Ox) - (Px - Ox) * (Qy - Oy)

 is positive, so the sign of the edge is the sign of the above expression.
 Similarly, if this quantity is zero then we need to look at the z-coordinate
 of the intersection, and the sign of the edge is given by

 (Pz - Oz) * (Qx - Ox) - (Px - Ox) * (Qz - Oz)

 In case 2, both of the above quantities are zero, and the sign of the edge is
 the sign of

 (Pz - Oz) * (Qy - Oy) - (Py - Oy) * (Qz - Oz)

 Another way to look at this: if P, Q and O are not collinear then the
 matrix

 ( Px Qx Ox )
 ( Py Qy Ox )
 ( Pz Qz Ox )
 (  1  1  1 )

 has rank 3.  It follows that at least one of the three 3x3 minors

 | Px Qx Ox |  | Px Qx Ox |  | Py Qy Oy |
 | Py Qy Oy |  | Pz Qz Oz |  | Pz Qz Oz |
 |  1  1  1 |  |  1  1  1 |  |  1  1  1 |

 is nonzero.  We define the sign of PQ to be the *negative* of the sign of the
 first nonzero minor in that list.

 - Each triangle PQR of the surface that's not coplanar with O is considered
 *positive* if its normal points away from O, and *negative* if its normal
 points towards O.

 Computationally, the sign of the triangle PQR is the sign of the 4x4
 determinant

 | Px Qx Rx Ox |
 | Py Qy Ry Oy |
 | Pz Qz Rz Oz |
 |  1  1  1  1 |

 or equivalently of the 3x3 determinant

 | Px-Ox Qx-Ox Rx-Ox |
 | Py-Oy Qy-Oy Ry-Oy |
 | Pz-Oz Qz-Oz Rz-Oz |

 Now to compute the contribution of any given triangle to the total winding
 number:

 1. Classify the vertices of the triangle.  At the same time, we can check that
 none of the vertices is equal to O.  If all vertices have the same sign,
 then the winding number contribution is zero.

 2. Assuming that the vertices do not all have the same sign, two of the three
 edges connect two differently-signed vertices.  Classify both those edges
 (and simultaneously check that they don't pass through O).  If the edges
 have opposite classification, then the winding number contribution is zero.

 3. Now two of the edges have the same sign: classify the triangle itself.  If
 the triangle is positive it contributes 1/2 to the winding number total; if
 negative it contributes -1/2.  In practice we count contributions of 1 and
 -1, and halve the total at the end.

 Note that an edge between two like-signed vertices can never pass through O, so
 there's no need to check the third edge in step 2.  Similarly, a triangle whose
 edge-cycle is trivial can't contain O in its interior.

 To understand what's going on above, it's helpful to step into the world of
 homology again. The homology of R^3 - {O} can be identified with that of the
 two-sphere S^2 by deformation retract, and we can decompose the two-sphere as a
 CW complex consisting of six cells, as follows:

 * 0-cells B and F, where B = (-1, 0, 0) and F = (1, 0, 0)
 * 1-cells L and R, where
 L = {(cos t, sin t, 0) | -pi &lt;= t &lt;= 0 }
 R = {(cos t, sin t, 0) | 0 &lt;= t &lt;= pi }
 * 2-cells U and D, where U is the top half of the sphere (z >= 0)
 and D is the bottom half (z &lt;= 0), both oriented outwards.

 And the homology of the CW complex is now representable in terms of cellular
 homology:

 d               d
 Z[U] + Z[D] --> Z[L] + Z[R] --> Z[B] + Z[F]

 with boundary maps given by:

 d[U] = [L] + [R]; d[D] = -[L] - [R]
 d[R] = [B] - [F]; d[L] = [F] - [B]

 Now the original map C -> R^3 - {O} from the geometric realization of the
 simplicial complex is homotopic to a map C -> S^2 that sends:

 * each positive vertex to F and each negative vertex to B
 * each edge with boundary [F] - [B] to L if the edge is negative, and -R if the
 edge is positive
 * each edge with boundary [B] - [F] to R if the edge is positive, and -L if the
 edge is negative
 * all other edges to 0
 * each triangle whose boundary is [L] + [R] to either U or -D,
 depending on whether the triangle is positive or negative
 * each triangle whose boundary is -[L] - [R] to either D or -U,
 depending on whether the triangle is positive or negative
 * all other triangles to 0

 Mapping all of the triangles in the surface this way, and summing the results
 in second homology, we end up with (winding number)*([U] + [D]).
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing3D.Math3D.Polyhedron.#ctor(System.Int32[][],System.Double[][])">
 <summary>
 Initialize from list of triangles and vertex positions.
 </summary>
 <param name="triangles"></param>
 <param name="vertex_positions">
 A collection of 3d point coordinations
 </param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing3D.Math3D.Polyhedron.triangle_positions">
 <summary>
 Triples of vertex positions.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing3D.Math3D.Polyhedron.volume">
 <summary>
 Return the volume of this polyhedron.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing3D.Math3D.Polyhedron.winding_number(Microsoft.VisualBasic.Imaging.Drawing3D.Point3D)">
 <summary>
 Determine the winding number of *self* around the given point.
 </summary>
 <param name="point"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Drawing3D.Math3D.Projection">
 <summary>
 3D coordinate transformation tools.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing3D.Math3D.Projection.PointXY(Microsoft.VisualBasic.Imaging.Drawing3D.Point3D,System.Drawing.Size)">
 <summary>
 Gets the projection 2D point result from this readonly property
 </summary>
 <param name="rect"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing3D.Math3D.Projection.Center(System.Collections.Generic.IEnumerable{Microsoft.VisualBasic.Imaging.Drawing3D.Point3D})">
 <summary>
 获取得到目标三维多边形的中心点
 </summary>
 <param name="model"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing3D.Math3D.Projection.SpaceToGrid(Microsoft.VisualBasic.Imaging.Drawing3D.Point3D,System.Single)">
 <summary>
 Transform point 3D into point 2D
 </summary>
 <param name="pt3D"></param>
 <param name="xRotate"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing3D.Math3D.Projection.SpaceToGrid(Microsoft.VisualBasic.Imaging.Drawing3D.Point3D,System.Single,System.Drawing.Point)">
 <summary>
 Project of the 3D point to 2D point
 </summary>
 <param name="pt3D"></param>
 <param name="xRotate"></param>
 <param name="offset"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing3D.Math3D.Transformation.Centra(System.Collections.Generic.IEnumerable{Microsoft.VisualBasic.Imaging.Drawing3D.Surface})">
 <summary>
 Gets the centra location of the target model which is consist with a set of surface
 </summary>
 <param name="surfaces"></param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing3D.Math3D.Transformation.ORIGIN">
 <summary>
 三维坐标系的原点``(0, 0, 0)``
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing3D.Math3D.Transformation.RotateX(Microsoft.VisualBasic.Imaging.Drawing3D.Point3D,Microsoft.VisualBasic.Imaging.Drawing3D.Point3D,System.Double)">
 <summary>
 Rotate about origin on the X axis
 </summary>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing3D.Math3D.Transformation.RotateY(Microsoft.VisualBasic.Imaging.Drawing3D.Point3D,Microsoft.VisualBasic.Imaging.Drawing3D.Point3D,System.Double)">
 <summary>
 Rotate about origin on the Y axis
 </summary>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing3D.Math3D.Transformation.RotateZ(Microsoft.VisualBasic.Imaging.Drawing3D.Point3D,Microsoft.VisualBasic.Imaging.Drawing3D.Point3D,System.Double)">
 <summary>
 Rotate about origin on the Y axis
 </summary>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing3D.Math3D.Transformation.Translate(Microsoft.VisualBasic.Imaging.Drawing3D.Point3D,System.Double,System.Double,System.Double)">
 <summary>
 Translate a point from a given dx, dy, and dz
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing3D.Math3D.Transformation.Scale(Microsoft.VisualBasic.Imaging.Drawing3D.Point3D,Microsoft.VisualBasic.Imaging.Drawing3D.Point3D,System.Double,System.Double,System.Double)">
 <summary>
 Scale a point about a given origin
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing3D.Math3D.Transformation.Distance(Microsoft.VisualBasic.Imaging.Drawing3D.Point3D,Microsoft.VisualBasic.Imaging.Drawing3D.Point3D)">
 <summary>
 Distance between two points
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Drawing3D.Math3D.VectorMath">
 <summary>
 helper for unity function
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing3D.Math3D.Vector3D.PointXY(System.Drawing.Size)">
 <summary>
 函数返回来的点集合之中的元素顺序和向量之中的数值的顺序是一致的
 </summary>
 <param name="screen"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing3D.Math3D.Vector3D.RotateX(System.Single)">
 <summary>
 
 </summary>
 <param name="angle">Degree.(度，函数里面会自动转换为三角函数所需要的弧度的)</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing3D.Math3D.Vector3D.Project(System.Int32,System.Int32,System.Int32,System.Single,System.Drawing.PointF)">
 <summary>
 Project the 3D point to the 2D screen. By using the projection result, 
 just read the property <see cref="M:Microsoft.VisualBasic.Imaging.Drawing3D.Math3D.Vector3D.PointXY(System.Drawing.Size)"/>.
 (将3D投影为2D，所以只需要取结果之中的<see cref="F:Microsoft.VisualBasic.Imaging.Drawing3D.Math3D.Vector3D.X"/>和<see cref="F:Microsoft.VisualBasic.Imaging.Drawing3D.Math3D.Vector3D.Y"/>就行了)
 </summary>
 <param name="viewWidth"></param>
 <param name="viewHeight"></param>
 <param name="fov">256默认值</param>
 <param name="viewDistance"></param>
 <returns></returns>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing3D.Model2D.path">
 <summary>
 实际的模型数据
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing3D.Model2D.DrawPath">
 <summary>
 经过模型数据<see cref="F:Microsoft.VisualBasic.Imaging.Drawing3D.Model2D.path"/>转换之后所得到的绘图所使用的对象模型
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing3D.Models.Cube._faces">
 <summary>
 Create an array representing the 6 faces of a cube. Each face is composed 
 by indices to the vertex array above.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing3D.Models.Cube.#ctor(System.Int32,System.Drawing.Color[])">
 <summary>
 
 </summary>
 <param name="d%">正方形的边的长度</param>
 <param name="colors"></param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing3D.Models.Cube.GetEnumerator">
 <summary>
 
 </summary>
 <returns></returns>
 <remarks>
 ```
 0 - {0, 1, 2, 3} 0,1,2,3 = 0,1,2,3
 1 - {1, 5, 6, 2}   1,2   = 5,6
 2 - {5, 4, 7, 6}   1,2   = 4,7
 3 - {4, 0, 3, 7}
 4 - {0, 4, 5, 1}
 5 - {3, 2, 6, 7}
 ```
 </remarks>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Drawing3D.Models.Isometric.Path3D">
 <summary>
 a collection of the 3d point consist a graphics path
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing3D.Models.Isometric.Path3D.Points">
 <summary>
 the 3d point collection
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing3D.Models.Isometric.Path3D.Depth">
 <summary>
 z-depth value
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing3D.Models.Isometric.Path3D.Push(Microsoft.VisualBasic.Imaging.Drawing3D.Point3D)">
 <summary>
 add a new point into current path object
 </summary>
 <param name="point"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing3D.Models.Isometric.Path3D.Reverse">
 <summary>
 Returns a new path with the points in reverse order
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing3D.Models.Isometric.Path3D.CloserThan(Microsoft.VisualBasic.Imaging.Drawing3D.Models.Isometric.Path3D,Microsoft.VisualBasic.Imaging.Drawing3D.Point3D)">
 <summary>
 If pathB ("this") is closer from the observer than pathA, it must be drawn after.
 It is closer if one of its vertices and the observer are on the same side of the plane defined by pathA.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing3D.Models.Isometric.Path3D.CountCloserThan(Microsoft.VisualBasic.Imaging.Drawing3D.Models.Isometric.Path3D,Microsoft.VisualBasic.Imaging.Drawing3D.Point3D)">
 <summary>
 The plane containing <paramref name="pathA"/> is defined by the three points A, B, C
 </summary>
 <param name="pathA"></param>
 <param name="observer"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Drawing3D.Models.Isometric.Paths.Circle">
 <summary>
 Created by fabianterhorst on 01.04.17.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing3D.Models.Isometric.Paths.Circle.#ctor(Microsoft.VisualBasic.Imaging.Drawing3D.Point3D,System.Double,System.Int32)">
 <summary>
 构建三维空间之中的一个圆弧路径
 </summary>
 <param name="origin">相对坐标系原点</param>
 <param name="radius"></param>
 <param name="vertices">构成这个圆形的顶点的数量</param>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Drawing3D.Models.Isometric.Paths.Arc">
 <summary>
 圆弧
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing3D.Models.Isometric.Paths.Arc.Circle(Microsoft.VisualBasic.Imaging.Drawing3D.Point3D,System.Double,System.Double)">
 <summary>
 Create a <see cref="T:Microsoft.VisualBasic.Imaging.Drawing3D.Models.Isometric.Path3D"/> model that similar with <see cref="T:Microsoft.VisualBasic.Imaging.Drawing3D.Models.Isometric.Paths.Circle"/> model.
 </summary>
 <param name="origin"></param>
 <param name="radius#"></param>
 <param name="vertices#"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Drawing3D.Models.Isometric.Paths.Rectangle">
 <summary>
 Created by fabianterhorst on 01.04.17.
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Drawing3D.Models.Isometric.Paths.Star">
 <summary>
 Created by fabianterhorst on 01.04.17.
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Drawing3D.Models.Isometric.Shape3D">
 <summary>
 A collection of the path3D data.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing3D.Models.Isometric.Shape3D.OrderedPath3Ds">
 <summary>
 Sort the list of faces by distance then map the entries, returning
 only the path and not the added "further point" from earlier.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing3D.Models.Isometric.Shape3D.Extrude(Microsoft.VisualBasic.Imaging.Drawing3D.Models.Isometric.Shape3D,Microsoft.VisualBasic.Imaging.Drawing3D.Models.Isometric.Path3D,System.Double)">
 <summary>
 将一个面平移一段距离，最后和通过平移新的到的平面，构成一个三维物体
 </summary>
 <param name="shape"></param>
 <param name="path"></param>
 <param name="height"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Drawing3D.Models.Isometric.Shapes.Cylinder">
 <summary>
 Created by fabianterhorst on 01.04.17.
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Drawing3D.Models.Isometric.Shapes.Pie">
 <summary>
 a 3d pie piece
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing3D.Models.Isometric.Shapes.Knot.#ctor(Microsoft.VisualBasic.Imaging.Drawing3D.Point3D,System.Double)">
 <summary>
 
 </summary>
 <param name="origin">The shape model location</param>
 <param name="scale">The scale size</param>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Drawing3D.Models.Isometric.Shapes.Octahedron">
 <summary>
 Created by fabianterhorst on 02.04.17.
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Drawing3D.Models.Isometric.Shapes.Prism">
 <summary>
 Created by fabianterhorst on 01.04.17.
 (立方体)
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing3D.Models.Isometric.Shapes.Prism.#ctor(Microsoft.VisualBasic.Imaging.Drawing3D.Point3D)">
 <summary>
 构造一个x,y,z的边长分别为1的正方体
 </summary>
 <param name="origin"></param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing3D.Models.Isometric.Shapes.Prism.#ctor(Microsoft.VisualBasic.Imaging.Drawing3D.Point3D,System.Double,System.Double,System.Double)">
 <summary>
 
 </summary>
 <param name="origin">位置</param>
 <param name="dx">边长</param>
 <param name="dy">边长</param>
 <param name="dz">边长</param>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Drawing3D.Models.Isometric.Shapes.Pyramid">
 <summary>
 Created by fabianterhorst on 02.04.17.
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Drawing3D.Models.Isometric.Shapes.Stairs">
 <summary>
 Created by fabianterhorst on 02.04.17.
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Drawing3D.PainterAlgorithm">
 <summary>
 ``PAINTERS ALGORITHM`` provider
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing3D.PainterAlgorithm.SurfacePainter(Microsoft.VisualBasic.Imaging.IGraphics@,Microsoft.VisualBasic.Imaging.Drawing3D.Camera,System.Collections.Generic.IEnumerable{Microsoft.VisualBasic.Imaging.Drawing3D.Surface},System.Boolean,System.Boolean)">
 <summary>
 这个函数主要是应用于函数绘图的。请注意，这个并没有rotate，只会利用camera进行project
 </summary>
 <param name="canvas"></param>
 <param name="camera"></param>
 <param name="surfaces"></param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing3D.PainterAlgorithm.BufferPainting(Microsoft.VisualBasic.Imaging.IGraphics@,System.Collections.Generic.IEnumerable{Microsoft.VisualBasic.Imaging.Drawing3D.PainterAlgorithm.Polygon},System.Boolean)">
 <summary>
 应用于GDI+/SVG的兼容方法
 </summary>
 <param name="canvas"></param>
 <param name="buf"></param>
 <param name="drawPath"></param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing3D.PainterAlgorithm.PainterBuffer(Microsoft.VisualBasic.Imaging.Drawing3D.Camera,System.Collections.Generic.IEnumerable{Microsoft.VisualBasic.Imaging.Drawing3D.Surface},System.Boolean)">
 <summary>
 生成三维图形绘图的多边形缓存。请注意，这个并没有rotate，只会利用camera进行project
 </summary>
 <param name="camera"></param>
 <param name="surfaces"></param>
 <param name="illumination">是否需要对每一个表面进行光照处理？</param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Drawing3D.PainterAlgorithm.Polygon">
 <summary>
 The polygon buffer unit after the 3D to 2D projection and the z-order sorts.
 (经过投影和排序操作之后的多边形图形缓存单元)
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing3D.PainterAlgorithm.Polygon.points">
 <summary>
 The 3D projection result buffer
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing3D.PainterAlgorithm.Polygon.brush">
 <summary>
 Surface fill
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing3D.PainterAlgorithm.OrderProvider``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double})">
 <summary>
 ``PAINTERS ALGORITHM`` kernel.(调用这个排序函数应该是发生在三维投影操作之后)
 </summary>
 <typeparam name="T"></typeparam>
 <param name="source"></param>
 <param name="z">计算出z轴的平均数据</param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Drawing3D.Point3D">
 <summary>
 Defines the Point3D class that represents points in 3D space with <see cref="T:System.Single"/> precise.
 Developed by leonelmachava &lt;leonelmachava@gmail.com>
 http://codentronix.com

 Copyright (c) 2011 Leonel Machava
 </summary>
 
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Drawing3D.Point3D.Depth">
 <summary>
 The depth of a point in the isometric plane
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing3D.Point3D.#ctor(Microsoft.VisualBasic.Imaging.PointF3D)">
 <summary>
 Copy 3d point data from the 3d point interface model
 </summary>
 <param name="p">the 3d point interface value</param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing3D.Point3D.translate(Microsoft.VisualBasic.Imaging.Drawing3D.Point3D)">
 <summary>
 Does the same as Point3D.add but changes the vector itself instead of returning a new one </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing3D.Point3D.RotateX(System.Single)">
 <summary>
 
 </summary>
 <param name="angle">Degree.(度，函数里面会自动转换为三角函数所需要的弧度的)</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing3D.Point3D.Project(System.Int32,System.Int32,System.Int32,System.Single,System.Drawing.PointF)">
 <summary>
 Project the 3D point to the 2D screen. By using the projection result, 
 just read the property <see cref="M:Microsoft.VisualBasic.Imaging.Drawing3D.Math3D.Projection.PointXY(Microsoft.VisualBasic.Imaging.Drawing3D.Point3D,System.Drawing.Size)"/>.
 (将3D投影为2D，所以只需要取结果之中的<see cref="P:Microsoft.VisualBasic.Imaging.Drawing3D.Point3D.X"/>和<see cref="P:Microsoft.VisualBasic.Imaging.Drawing3D.Point3D.Y"/>就行了)
 </summary>
 <param name="viewWidth"></param>
 <param name="viewHeight"></param>
 <param name="fov">256默认值</param>
 <param name="viewDistance"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing3D.Point3D.Project(System.Single@,System.Single@,System.Single,System.Int32,System.Int32,System.Int32,System.Int32)">
 <summary>
 Project the 3D point to the 2D screen. 
 </summary>
 <param name="x!"></param>
 <param name="y!"></param>
 <param name="z!">Using for the painter algorithm.</param>
 <param name="viewWidth%"></param>
 <param name="viewHeight%"></param>
 <param name="fov%">球度，当这个参数值非常大的时候，则产生的3D图像为isometrix类型的对称等边图形</param>
 <param name="viewDistance%">View distance to the model from the view window.</param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Drawing3D.Point3D.op_Equality(Microsoft.VisualBasic.Imaging.Drawing3D.Point3D,System.Single)">
 <summary>
 所有的分量是否都等于目标值？使用这个操作符可以很方便的判断点是否为空值
 </summary>
 <param name="p"></param>
 <param name="n!"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Drawing3D.Surface">
 <summary>
 Object model that using for the 3D graphics.
 </summary>
 <remarks>
 (进行实际3D绘图操作的对象模型，这个对象实际上就是相当于Path3D??)
 </remarks>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing3D.Surface.vertices">
 <summary>
 Vertix in this list have the necessary element orders
 for construct a correct closed figure.
 (请注意，在这里面的点都是有先后顺序分别的)
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Drawing3D.Surface.brush">
 <summary>
 Drawing texture material of this surface.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Driver.ImageDriver.GraphicsPlot(Microsoft.VisualBasic.Imaging.Driver.DeviceDescription,Microsoft.VisualBasic.Imaging.Drawing2D.IPlot)">
 <summary>
 a unify method for create graphics plot
 </summary>
 <param name="desc">the graphics drawing context description</param>
 <param name="plot"></param>
 <returns></returns>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Driver.CSS.Types.Font">
 <summary>
 <see cref="T:Microsoft.VisualBasic.MIME.Html.CSS.CSSFont"/>
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Driver.CSS.Types.Stroke">
 <summary>
 <see cref="F:Microsoft.VisualBasic.Imaging.Driver.CSS.Types.Stroke"/>
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Driver.CSS.Types.Brush">
 <summary>
 <see cref="M:Microsoft.VisualBasic.VectorExtensions.Fill``1(``0[],``0,System.Int32)"/>
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Driver.CSS.Types.Size">
 <summary>
 <see cref="T:Microsoft.VisualBasic.MIME.Html.CSS.CSSsize"/>
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Driver.CSS.Types.Padding">
 <summary>
 <see cref="F:Microsoft.VisualBasic.Imaging.Driver.CSS.Types.Padding"/>
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Driver.CSS.Types.Integer">
 <summary>
 line width, box width, etc, almost the same as <see cref="F:Microsoft.VisualBasic.Imaging.Driver.CSS.Types.Size"/>
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Driver.CSS.Types.Float">
 <summary>
 Circle Radius(examples as node size in ``d3.js``)
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Driver.CSS.RuntimeInvoker">
 <summary>
 因为绘图的函数一般有很多的CSS样式参数用来调整图形上面的元素的样式，
 通过命令行传递这么多的参数不现实，故而在这里通过CSS文件加反射的形式
 来传递这些绘图参数，并且同时也保留对函数式编程的兼容性
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Driver.CSS.RuntimeInvoker.ParseFieldNames(System.Type)">
 <summary>
 Get all CSS field names
 </summary>
 <param name="type"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Driver.CSS.RuntimeInvoker.CSSTemplate(System.Reflection.MethodInfo)">
 <summary>
 Generate CSS template for the plot driver function.
 </summary>
 <param name="driver"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Driver.CSS.RuntimeInvoker.RunPlot(System.Delegate,Microsoft.VisualBasic.MIME.Html.Language.CSS.CSSFile,Microsoft.VisualBasic.Language.ArgumentReference[])">
 <summary>
 
 </summary>
 <param name="driver">绘图函数</param>
 <param name="CSS">
 定义了该函数之中的CSS元素的样式值，假若没有某一个可选参数的值，则使用默认参数值；
 或者参数值出现在了<paramref name="args"/>列表之中，则会被<paramref name="args"/>的值所覆盖
 </param>
 <param name="args">必须要包含有所有的必须参数，可选参数可以不包含在其中</param>
 <returns></returns>
 <remarks>
 因为考虑到手动输入参数可能会出现大小写不匹配的问题，故而在这里会首先尝试使用字典查找，
 没有找到键名的时候才会进行字符串大小写不敏感的字符串比较
 </remarks>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Driver.DeviceDescription.background">
 <summary>
 the default background fill color
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Driver.DeviceDescription.bgHtmlColor">
 <summary>
 the html color string value of <see cref="P:Microsoft.VisualBasic.Imaging.Driver.DeviceDescription.background"/>
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Driver.IElementCommentWriter.SetLastComment(System.String)">
 <summary>
 set comment text to the last graphics element
 </summary>
 <param name="comment"></param>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Driver.ImageSynthesis">
 <summary>
 Makes the ``DrawImage`` function compatible 
 with old gdi+ interface
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Driver.ImageSynthesis.DrawImage(Microsoft.VisualBasic.Imaging.IGraphics,Microsoft.VisualBasic.Imaging.Driver.GraphicsData,System.Drawing.Point)">
 <summary>
 Draws the specified System.Drawing.Image, using its original physical size, at
 the specified location.
 </summary>
 <param name="g"></param>
 <param name="image">System.Drawing.Image to draw.</param>
 <param name="point">System.Drawing.Point structure that represents the location of the upper-left
 corner of the drawn image.</param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Driver.ImageSynthesis.DrawImage(Microsoft.VisualBasic.Imaging.IGraphics,Microsoft.VisualBasic.Imaging.Driver.GraphicsData,System.Drawing.Rectangle)">
 <summary>
 Draws the specified System.Drawing.Image at the specified location and with the
 specified size.
 </summary>
 <param name="g"></param>
 <param name="image">System.Drawing.Image to draw.</param>
 <param name="rect">System.Drawing.Rectangle structure that specifies the location and size of the
 drawn image.</param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Driver.ImageSynthesis.DrawImage(Microsoft.VisualBasic.Imaging.IGraphics,Microsoft.VisualBasic.Imaging.Driver.GraphicsData,System.Drawing.PointF)">
 <summary>
 Draws the specified System.Drawing.Image, using its original physical size, at
 the specified location.
 </summary>
 <param name="g"></param>
 <param name="image">System.Drawing.Image to draw.</param>
 <param name="point">System.Drawing.PointF structure that represents the upper-left corner of the
 drawn image.</param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Driver.ImageSynthesis.DrawImage(Microsoft.VisualBasic.Imaging.IGraphics,Microsoft.VisualBasic.Imaging.Driver.GraphicsData,System.Drawing.RectangleF)">
 <summary>
 Draws the specified System.Drawing.Image at the specified location and with the
 specified size.
 </summary>
 <param name="g"></param>
 <param name="image">System.Drawing.Image to draw.</param>
 <param name="rect">System.Drawing.RectangleF structure that specifies the location and size of the
 drawn image.</param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Driver.ImageSynthesis.DrawImage(Microsoft.VisualBasic.Imaging.IGraphics,Microsoft.VisualBasic.Imaging.Driver.GraphicsData,System.Int32,System.Int32)">
 <summary>
 Draws the specified image, using its original physical size, at the location
 specified by a coordinate pair.
 </summary>
 <param name="g"></param>
 <param name="image">System.Drawing.Image to draw.</param>
 <param name="x">The x-coordinate of the upper-left corner of the drawn image.</param>
 <param name="y">The y-coordinate of the upper-left corner of the drawn image.</param>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Driver.InternalCanvas">
 <summary>
 可以借助这个画布对象创建多图层的绘图操作
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Driver.InternalCanvas.op_LessThanOrEqual(Microsoft.VisualBasic.Imaging.Driver.InternalCanvas,Microsoft.VisualBasic.Imaging.Drawing2D.IPlot)">
 <summary>
 canvas invoke this plot.
 </summary>
 <param name="g"></param>
 <param name="plot"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Driver.GraphicsData">
 <summary>
 gdi+ images: <see cref="T:Microsoft.VisualBasic.Imaging.Image"/>, <see cref="T:Microsoft.VisualBasic.Imaging.Bitmap"/> / SVG image: <see cref="T:Microsoft.VisualBasic.Imaging.SVG.XML.SvgDocument"/>
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Driver.GraphicsData.Layout">
 <summary>
 The image size
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Driver.GraphicsData.#ctor(System.Object,System.Drawing.Size,Microsoft.VisualBasic.MIME.Html.CSS.Padding)">
 <summary>
 This constructor of base type is only assign the size value
 </summary>
 <param name="img">其实这个参数在基类<see cref="T:Microsoft.VisualBasic.Imaging.Driver.GraphicsData"/>之中是无用的，只是为了统一接口而设置的</param>
 <param name="size"></param>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Driver.ImageData">
 <summary>
 Get image value from <see cref="P:Microsoft.VisualBasic.Imaging.Driver.ImageData.Image"/>
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Driver.ImageData.Image">
 <summary>
 GDI+ image
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Driver.ImageData.DefaultFormat">
 <summary>
 Default image save format for <see cref="T:Microsoft.VisualBasic.Imaging.Bitmap"/>
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Driver.ImageData.Save(System.String)">
 <summary>
 Save the image as png
 </summary>
 <param name="path"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Driver.ImageData.Dispose(System.Boolean)">
 <summary>
 当进行连续绘图操作的时候，如果不释放image的内存会导致内存泄漏？？？
 </summary>
 <param name="disposing"></param>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Driver.SVGData">
 <summary>
 SVG graphic data
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Driver.SVGData.XmlComment">
 <summary>
 The xml comment text when generates the svg document text
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.Driver.SVGData.title">
 <summary>
 title of current svg graphics plot document
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Driver.SVGData.#ctor(System.Object,System.Drawing.Size,Microsoft.VisualBasic.MIME.Html.CSS.Padding)">
 <summary>
 <paramref name="img"/> parameter is <see cref="T:Microsoft.VisualBasic.Imaging.SVG.GraphicsSVG"/>
 </summary>
 <param name="img"></param>
 <param name="size"></param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Driver.SVGData.GetDataURI">
 <summary>
 convert the svg document to base64 encoded data uri
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Driver.SVGData.GetSVGXml">
 <summary>
 get xml document text of current svg graphics plot
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Driver.SVGData.Save(System.String)">
 <summary>
 Save the image as svg file.
 </summary>
 <param name="path"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Extensions.AsGDIImage(Microsoft.VisualBasic.Imaging.Driver.GraphicsData)">
 <summary>
 假若目标图像是svg类型，则会被合成为gdi图像，如果是gdi图像，则会被直接转换
 </summary>
 <param name="img"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Filters.GaussBlur">
 <summary>
 
 </summary>
 <remarks>
 20220621, warning: not working as expected on LINUX platform 
 due to the reason of call un-managed code.
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Filters.GaussBlur.GaussBlur(Microsoft.VisualBasic.Imaging.Bitmap)">
 <summary>
 对一幅图片进行快速模糊处理，函数由 [小鱼儿] 提供
 </summary>
 <param name="imgValue">待处理的图像数据</param>
 <returns>经过模糊处理之后的图像</returns>
 <remarks></remarks>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Filters.GaussianSmooth.GaussianBlur">
 <summary>
 声明私有的高斯模糊卷积核函数
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Filters.GaussianSmooth.#ctor(System.Int32)">
 <summary>
 初始化高斯模糊卷积核
 </summary>
 <param name="k"></param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Filters.GaussianSmooth.Smooth(Microsoft.VisualBasic.Imaging.BitmapImage.BitmapBuffer)">
 <summary>
 对图像进行平滑处理（利用高斯平滑Gaussian Blur）
 </summary>
 <param name="bitmap">要处理的位图</param>
 <returns>返回平滑处理后的位图</returns>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Filters.ImageStrech.matrix">
 <summary>
 [x => [y => pixel]]
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.Filters.ImageStrech.dims">
 <summary>
 the original image size
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Filters.ImageStrech.Resize(System.Drawing.Size)">
 <summary>
 Resize and strech the current image matrix data
 </summary>
 <param name="newSize"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Filters.Matrix">
 <summary>
 the bitmap image gauss smooth helper
 
 https://zhuanlan.zhihu.com/p/73363439
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Filters.Matrix2DFiltersAlgorithm">
 <summary>
 https://zhuanlan.zhihu.com/p/73421455
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.Filters.TabulateClipScaler">
 <summary>
 processing of the grayscale/heatmap scale image
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Filters.TabulateClipScaler.GlobalTileScales(System.Collections.Generic.IEnumerable{Microsoft.VisualBasic.Imaging.BitmapImage.BitmapBuffer},System.Single,System.Single,System.Single)">
 <summary>
 A help function for better processing of the dzi image
 </summary>
 <param name="tiles"></param>
 <param name="wr"></param>
 <param name="wg"></param>
 <param name="wb"></param>
 <returns>
 grayscale image data set
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Filters.Thresholding.MedianFilter(Microsoft.VisualBasic.Imaging.BitmapImage.BitmapBuffer)">
 <summary>
 通过中值滤波去噪
 </summary>
 <param name="bitmap"> 位图 </param>
 <returns> 返回转换好的位图 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Filters.Thresholding.AverageFilter(Microsoft.VisualBasic.Imaging.BitmapImage.BitmapBuffer)">
 <summary>
 通过均值滤波去噪
 </summary>
 <param name="bitmap"> 位图 </param>
 <returns> 返回转换好的位图 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Filters.Thresholding.ostuFilter(Microsoft.VisualBasic.Imaging.BitmapImage.BitmapBuffer,System.Boolean,System.Double,System.Boolean,System.Boolean)">
 <summary>
 通过OSTU二值化
 </summary>
 <param name="bitmap"> 位图 </param>
 <returns> 返回转换好的位图 </returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Filters.Thresholding.ostuFilter(Microsoft.VisualBasic.Imaging.BitmapImage.BitmapBuffer,System.Int32,System.Boolean,System.Boolean)">
 <summary>
 通过OSTU二值化
 </summary>
 <param name="bitmap"> 位图 </param>
 <returns> 返回转换好的位图 </returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Filters.Thresholding.otsuThreshold(Microsoft.VisualBasic.Imaging.BitmapImage.BitmapBuffer,System.Boolean)">
 <summary>
 通过OSTU寻找二值化的最佳阈值
 </summary>
 <param name="bitmap"> 位图 </param>
 <returns> 返回阈值大小 </returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.Filters.Thresholding.otsuThreshold(Microsoft.VisualBasic.ComponentModel.Collection.Generic.BucketSet{System.UInt32},System.Boolean)">
 <summary>
 通过OSTU寻找二值化的最佳阈值
 </summary>
 <param name="bitmap"> 位图 </param>
 <returns> 返回阈值大小 </returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.PostScript.GraphicsPostScript">
 <summary>
 Graphics for create postscript 
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.PostScript.GraphicsPostScript.ReleaseHandle">
 <summary>
 do nothing at here
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.PostScript.GraphicsPostScript.GetContextInfo">
 <summary>
 get the current postscript canvas context information
 </summary>
 <returns>An object in clr type <see cref="T:Microsoft.VisualBasic.Imaging.PostScript.PostScriptBuilder"/>.</returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.PostScript.GraphicsPostScript.Flush">
 <summary>
 do nothing on flush
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.PostScript.PostScriptBuilder">
 <summary>
 A helper module for convert the postscript object as ASCII script text
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.PostScript.PostScriptBuilder.Add(Microsoft.VisualBasic.Imaging.PostScript.PSElement)">
 <summary>
 Add a painting shape element into the canvas
 </summary>
 <param name="paint"></param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.PostScript.PostScriptBuilder.Clear">
 <summary>
 Clear all painting elements from the internal buffer.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.PostScript.PostScriptBuilder.Resize(System.Drawing.Size)">
 <summary>
 resize the canvase and returns a new postscript builder model
 </summary>
 <param name="newSize"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.PostScript.PostScriptBuilder.MakePaint(Microsoft.VisualBasic.Imaging.IGraphics)">
 <summary>
 make painting
 </summary>
 <param name="g">
 should be png/svg/pdf graphics
 </param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.PostScript.PostScriptBuilder.ToString">
 <summary>
 Get ascii postscript text
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.PostScript.PSElement">
 <summary>
 abstract model of the painting elements
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.PostScript.PSElement.comment">
 <summary>
 comment text about this postscript element
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.PostScript.PSElement.ScaleTo(Microsoft.VisualBasic.Imaging.d3js.scale.LinearScale,Microsoft.VisualBasic.Imaging.d3js.scale.LinearScale)">
 <summary>
 scale the current element to new location
 </summary>
 <param name="scaleX"></param>
 <param name="scaleY"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.PostScript.PSElement`1">
 <summary>
 An postscript graphics element
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.PostScript.PsComment.text">
 <summary>
 this text data will be base64 data string if is <see cref="P:Microsoft.VisualBasic.Imaging.PostScript.PsComment.binary"/> metadata
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.PostScript.PsComment.Paint(Microsoft.VisualBasic.Imaging.IGraphics)">
 <summary>
 do nothing on comment node
 </summary>
 <param name="g"></param>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.PostScript.Elements.ImageData.image">
 <summary>
 image data is encoded as base64 data uri
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.PostScript.Elements.ImageData.size">
 <summary>
 the image dimension size
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.PostScript.Elements.ImageData.scale">
 <summary>
 the image drawing size
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.PostScript.Writer">
 <summary>
 file writer for the postscript file
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.PostScript.Writer.pen(Microsoft.VisualBasic.MIME.Html.CSS.Stroke)">
 <summary>
 A helper function for make conversion from the css stroke object to the gdi+ pen object
 </summary>
 <param name="stroke"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.PostScript.Writer.moveto(System.Single,System.Single)">
 <summary>
 moveto
 </summary>
 <param name="x!"></param>
 <param name="y!"></param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.PostScript.Writer.moveto(System.Drawing.PointF)">
 <summary>
 moveto
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.PostScript.Writer.text(System.String,System.Single,System.Single)">
 <summary>
 show text
 </summary>
 <param name="s"></param>
 <param name="x!"></param>
 <param name="y!"></param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.PostScript.Writer.arct(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
 <summary>
 arct
 </summary>
 <param name="x!"></param>
 <param name="y!"></param>
 <param name="width!"></param>
 <param name="height!"></param>
 <param name="startAngle!"></param>
 <param name="sweepAngle!"></param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.PostScript.Writer.stroke">
 <summary>
 stroke
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.PostScript.Writer.dash(System.Int32[])">
 <summary>
 setdash
 </summary>
 <param name="dash"></param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.PostScript.Writer.linewidth(System.Single)">
 <summary>
 setlinewidth
 </summary>
 <param name="width"></param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.PostScript.Writer.color(System.Single,System.Single,System.Single)">
 <summary>
 setrgbcolor
 </summary>
 <param name="r"></param>
 <param name="g"></param>
 <param name="b"></param>
 <remarks>
 the rgb color value parameter should be in value range of [0,1]
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.PostScript.Writer.color(System.Drawing.Color)">
 <summary>
 setrgbcolor
 </summary>
 <param name="color"></param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.PostScript.Writer.font(System.String,System.Single)">
 <summary>
 setfont
 </summary>
 <param name="name"></param>
 <param name="fontsize!"></param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.PostScript.Writer.note(System.String)">
 <summary>
 write comment text
 </summary>
 <param name="noteText">
 the comment text that may contains multiple data lines
 </param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.PostScript.Writer.comment(System.String)">
 <summary>
 write a line of comment text
 </summary>
 <param name="line"></param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.PostScript.Writer.showpage">
 <summary>
 [showpage] mark the end of current page
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.SVG.CSS.CSSStyles">
 <summary>
 在这个SVG对象之中所定义的CSS样式数据
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.SVG.CSS.Filter">
 <summary>
 图层滤镜
 </summary>
 <remarks>
 请注意：filter里面的元素是有执行顺序的
 </remarks>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.SVG.GeometryElement.tag">
 <summary>
 get the xml element tag name
 </summary>
 <returns>
 <see cref="P:Microsoft.VisualBasic.Imaging.SVG.XML.SvgElement.Tag"/>
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.SVG.MatrixTransform.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
 <summary>
 
 </summary>
 <param name="a">水平缩放因子</param>
 <param name="b">水平倾斜因子</param>
 <param name="c">垂直倾斜因子</param>
 <param name="d">垂直缩放因子</param>
 <param name="e">水平移动距离</param>
 <param name="f">垂直移动距离</param>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.SVG.GraphicsSVG">
 <summary>
 SVG graphics generator
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.SVG.GraphicsSVG.__svgData">
 <summary>
 SVG图型的数据结构以及渲染是树形的，但是利用程序代码进行SVG数据的生成却是线性的
 这样子会导致产生的SVG图形错位
 所以在这里需要使用多层结构来将线性的绘图操作模拟为SVG的树形结构
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.SVG.GraphicsSVG.LastSvgLayerElement">
 <summary>
 try to get the last created <see cref="T:Microsoft.VisualBasic.Imaging.SVG.XML.SvgElement"/> in this svg document data.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.SVG.GraphicsSVG.AddMetafileComment(System.Byte[])">
 <summary>
 add comment to svg xml document
 </summary>
 <param name="data"></param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.SVG.GraphicsSVG.ClearCanvas(System.Drawing.Color)">
 <summary>
 This function will clear entire svg document contents.
 </summary>
 <param name="color"></param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.SVG.GraphicsSVG.DrawPath(Microsoft.VisualBasic.Imaging.Pen,Microsoft.VisualBasic.Imaging.GraphicsPath)">
 <summary>
 
 </summary>
 <param name="pen"></param>
 <param name="path"></param>
 <remarks>
 20220421  因为在svg没有设置默认底色的情况下，fill默认是黑色的，这个就会导致
 path绘制的结果是黑色的多边形，所以在这个函数没有办法传递底色的情况下，自动添加
 transparent填充底色来解决这个填充色为黑色默认值的问题
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.SVG.GraphicsSVG.Save(System.IO.Stream,Microsoft.VisualBasic.Imaging.ImageFormats)">
 <summary>
 save svg to a given file
 </summary>
 <param name="stream"></param>
 <param name="format"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.SVG.Renderer">
 <summary>
 Rendering svg vector image to gdi+ pixel image.
 </summary>
 <remarks>
 (将SVG图像渲染为gdi+图像<see cref="T:Microsoft.VisualBasic.Imaging.Image"/>)
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.SVG.Renderer.DrawImage(Microsoft.VisualBasic.Imaging.Driver.SVGData)">
 <summary>
 Rendering the SVG document as bitmap image.
 </summary>
 <param name="svg"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.SVG.SVGDataLayers">
 <summary>
 使用<see cref="T:Microsoft.VisualBasic.Imaging.SVG.XML.SvgGroup"/>图层的方式构建出一个完整的SVG模型
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.SVG.SVGDataLayers.svg">
 <summary>
 the svg xml document data
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.SVG.SVGDataLayers.filters">
 <summary>
 <see cref="P:Microsoft.VisualBasic.MIME.Html.XmlMeta.Node.id"/>为字典的键名
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.SVG.SVGDataLayers.Clear">
 <summary>
 reset
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.SVG.SVGDataLayers.ApplyFilter(System.Int32,System.String)">
 <summary>
 Apply of the graphics filter to a specific layer
 </summary>
 <param name="zindex">图层的编号</param>
 <param name="filter">filter的id编号</param>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.SVG.SVGDataLayers.ApplyFilter(System.String,System.String)">
 <summary>
 通过元素选择器来设置滤镜，函数返回所有<paramref name="selector"/>查找成功的图层的编号
 </summary>
 <param name="selector"></param>
 <param name="filter"></param>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.SVG.SVGWriter">
 <summary>
 Write the data in <see cref="T:Microsoft.VisualBasic.Imaging.SVG.GraphicsSVG"/> as a xml file.
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.SVG.SVGWriter.SVG(Microsoft.VisualBasic.Imaging.SVG.GraphicsSVG,System.String,System.String)">
 <summary>
 Get the current svg model data from current graphics engine.
 </summary>
 <param name="g"></param>
 <param name="size$">默认是使用<see cref="T:Microsoft.VisualBasic.Imaging.SVG.GraphicsSVG"/>对象的内部大小</param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.SVG.SVGWriter.WriteSVG(Microsoft.VisualBasic.Imaging.SVG.GraphicsSVG,System.String,System.String,System.String,System.String,System.String)">
 <summary>
 将画布<see cref="T:Microsoft.VisualBasic.Imaging.SVG.GraphicsSVG"/>之中的内容写入SVG文件
 </summary>
 <param name="g"></param>
 <param name="path$">``*.svg``保存的SVG文件的路径</param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.SVG.XML.SvgCircle">
 <summary>
 The &lt;circle> SVG element is an SVG basic shape, used to draw circles based on a center point and a radius.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.SVG.XML.SvgCircle.CX">
 <summary>
 The x-axis coordinate of the center of the circle. Value type: &lt;length>|&lt;percentage>; 
 Default value: 0; Animatable: yes
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.SVG.XML.SvgCircle.CY">
 <summary>
 The y-axis coordinate of the center of the circle. Value type: &lt;length>|&lt;percentage>; 
 Default value: 0; Animatable: yes
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.SVG.XML.SvgCircle.R">
 <summary>
 The radius of the circle. A value lower or equal to zero disables rendering of the circle.
 Value type: &lt;length>|&lt;percentage> ; Default value: 0; Animatable: yes
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.SVG.XML.SvgEllipse">
 <summary>
 An &lt;ellipse> is a more general form of the &lt;circle> element, where you 
 can scale the x and y radius (commonly referred to as the semimajor and 
 semiminor axes in maths) of the circle separately.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.SVG.XML.SvgEllipse.CX">
 <summary>
 The x position of the center of the ellipse.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.SVG.XML.SvgEllipse.CY">
 <summary>
 The y position of the center of the ellipse.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.SVG.XML.SvgEllipse.RX">
 <summary>
 The x radius of the ellipse.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.SVG.XML.SvgEllipse.RY">
 <summary>
 The y radius of the ellipse.
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.SVG.XML.SvgImage">
 <summary>
 The &lt;image> SVG element includes images inside SVG documents. It can display raster image files or other SVG files.

 The only image formats SVG software must support are JPEG, PNG, And other SVG files. Animated GIF behavior Is undefined.

 SVG files displayed With &lt;image> are treated As an image: external resources aren't loaded, :visited styles aren't
 applied, and they cannot be interactive. To include dynamic SVG elements, try &lt;use> with an external URL. To include 
 SVG files and run scripts inside them, try &lt;object> inside of &lt;foreignObject>.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.SVG.XML.SvgImage.HRef">
 <summary>
 the image data, usually be a base64 encoded uri string value.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.SVG.XML.SvgImage.Create(System.Xml.XmlElement)">
 <summary>
 create a new empty image node
 </summary>
 <param name="parent"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.SVG.XML.SvgLine">
 <summary>
 The &lt;line> element takes the positions of two points as 
 parameters and draws a straight line between them.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.SVG.XML.SvgLine.X1">
 <summary>
 The x position of point 1.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.SVG.XML.SvgLine.Y1">
 <summary>
 The y position of point 1.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.SVG.XML.SvgLine.X2">
 <summary>
 The x position of point 2.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.SVG.XML.SvgLine.Y2">
 <summary>
 The y position of point 2.
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.SVG.XML.SvgPath">
 <summary>
 A &lt;path> is the most general shape that can be used in SVG. Using a path element, 
 you can draw rectangles (with or without rounded corners), circles, ellipses, 
 polylines, and polygons. Basically any of the other types of shapes, bezier curves, 
 quadratic curves, and many more.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.SVG.XML.SvgPath.D">
 <summary>
 A list of points and other information about how to draw the path. 
 </summary>
 <remarks>
 下面的命令可用于路径数据：
 
 M = moveto
 L = lineto
 H = horizontal lineto
 V = vertical lineto
 C = curveto
 S = smooth curveto
 Q = quadratic Belzier curve
 T = smooth quadratic Belzier curveto
 A = elliptical Arc
 Z = closepath
 
 注释：以上所有命令均允许小写字母。大写表示绝对定位，小写表示相对定位。
 </remarks>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.SVG.XML.SvgPolygon">
 <summary>
 A &lt;polygon> is similar to a &lt;polyline>, in that it is composed of straight
 line segments connecting a list of points. For polygons though, the path 
 automatically connects the last point with the first, creating a closed shape.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.SVG.XML.SvgPolygon.Points">
 <summary>
 A list of points, each number separated by a space, comma, EOL, or a line
 feed character with additional whitespace permitted. Each point must contain 
 two numbers: an x coordinate and a y coordinate. So, the list (0,0), (1,1), 
 and (2,2) could be written as 0, 0 1, 1 2, 2. The drawing then closes the 
 path, so a final straight line would be drawn from (2,2) to (0,0).
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.SVG.XML.SvgPolyLine">
 <summary>
 A &lt;polyline> is a group of connected straight lines. Since the 
 list of points can get quite long, all the points are included in 
 one attribute
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.SVG.XML.SvgPolyLine.Points">
 <summary>
 A list of points. Each number must be separated by a space, comma, EOL,
 or a line feed character with additional whitespace permitted. Each point 
 must contain two numbers: an x coordinate and a y coordinate. So, the 
 list (0,0), (1,1), and (2,2) could be written as 0, 0 1, 1 2, 2.
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.SVG.XML.SvgRect">
 <summary>
 The &lt;rect> element draws a rectangle on the screen. There are six basic attributes
 that control the position and shape of the rectangles on screen. The one on the right
 has its rx and ry parameters set, giving it rounded corners. If they're not set, they 
 default to 0.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.SVG.XML.SvgRect.X">
 <summary>
 The x position of the top left corner of the rectangle.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.SVG.XML.SvgRect.Y">
 <summary>
 The y position of the top left corner of the rectangle.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.SVG.XML.SvgRect.Width">
 <summary>
 The width of the rectangle.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.SVG.XML.SvgRect.Height">
 <summary>
 The height of the rectangle.
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.SVG.XML.SvgBasicShape">
 <summary>
 ## Basic shapes
 
 There are several basic shapes used for most SVG drawing. The purpose of these shapes 
 is fairly obvious from their names. Some of the parameters that determine their position 
 and size are given, but an element reference would probably contain more accurate and 
 complete descriptions along with other properties that won't be covered in here. 
 However, since they're used in most SVG documents, it's necessary to give them some 
 sort of introduction.

 To insert a shape, you create an element in the document. Different elements correspond 
 to different shapes And take different parameters to describe the size And position of 
 those shapes. Some are slightly redundant in that they can be created by other shapes, 
 but they're all there for your convenience and to keep your SVG documents as short and 
 as readable as possible. 
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.SVG.XML.SvgText">
 <summary>
 The SVG &lt;text> element draws a graphics element consisting of text. It's possible 
 to apply a gradient, pattern, clipping path, mask, or filter to &lt;text>, like any 
 other SVG graphics element.

 If text Is included In SVG Not inside Of a &lt;text> element, it Is Not rendered. 
 This Is different than being hidden by Default, As setting the display Property won't 
 show the text.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.SVG.XML.SvgText.X">
 <summary>
 The x coordinate of the starting point of the text baseline. Value type: &lt;length>|&lt;percentage> ; Default value: 0; Animatable: yes
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.SVG.XML.SvgText.Y">
 <summary>
 The y coordinate of the starting point of the text baseline. Value type: &lt;length>|&lt;percentage> ; Default value: 0; Animatable: yes
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.SVG.XML.SvgText.DX">
 <summary>
 Shifts the text position horizontally from a previous text element. Value type: &lt;length>|&lt;percentage> ; Default value: none; Animatable: yes
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.SVG.XML.SvgText.DY">
 <summary>
 Shifts the text position vertically from a previous text element. Value type: &lt;length>|&lt;percentage> ; Default value: none; Animatable: yes
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.SVG.XML.SvgText.TextLength">
 <summary>
 A width that the text should be scaled to fit. Value type: &lt;length>|&lt;percentage> ; Default value: none; Animatable: yes
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.SVG.XML.SvgContainer">
 <summary>
 SVG之中的画布对象
 </summary>
 <remarks>
 理论上应该是<see cref="T:Microsoft.VisualBasic.Imaging.SVG.XML.SvgGroup"/> &lt;g>对象容器
 </remarks>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.SVG.XML.SvgContainer.lastElement">
 <summary>
 try to get the last created <see cref="T:Microsoft.VisualBasic.Imaging.SVG.XML.SvgElement"/> in this svg document data.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.SVG.XML.SvgContainer.GetElements">
 <summary>
 get all child elements from current xml <see cref="F:Microsoft.VisualBasic.Imaging.SVG.XML.SvgElement.Element"/> node
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.SVG.XML.SvgDocument">
 <summary>
 SVG: Scalable Vector Graphics
 
 Scalable Vector Graphics (SVG) is an XML-based markup language for describing 
 two-dimensional based vector graphics.
 </summary>
 <remarks>
 As such, it's a text-based, open Web standard for describing images that can 
 be rendered cleanly at any size and are designed specifically to work well with 
 other web standards including CSS, DOM, JavaScript, and SMIL. SVG is, 
 essentially, to graphics what HTML is to text.

 SVG images And their related behaviors are defined In XML text files, which means
 they can be searched, indexed, scripted, And compressed. Additionally, this means 
 they can be created And edited With any text editor Or With drawing software.

 Compared to classic bitmapped image formats such as JPEG Or PNG, SVG-format vector 
 images can be rendered at any size without loss of quality And can be easily 
 localized by updating the text within them, without the need of a graphical editor
 to do so. With proper libraries, SVG files can even be localized on-the-fly.

 SVG has been developed by the World Wide Web Consortium (W3C) since 1999.
 </remarks>
</member>
<member name="F:Microsoft.VisualBasic.Imaging.SVG.XML.SvgDocument._document">
 <summary>
 the xml document model of the current svg document object
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.SVG.XML.SvgDocument.defs">
 <summary>
 
 </summary>
 <returns>
 this property ensure that always has the value.
 </returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.SVG.XML.SvgDocument.ViewSize">
 <summary>
 get the canvas view size of the current svg document.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.SVG.XML.SvgDocument.Size(System.Drawing.Size)">
 <summary>
 set svg canvas size and viewbox size
 </summary>
 <param name="sz">set the viewbox size only</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.SVG.XML.SvgDocument.Parse(System.String,System.Boolean)">
 <summary>
 Parse the given xml document text as svg doucment model
 </summary>
 <param name="xml"></param>
 <returns>
 this function will returns nothing if this parser function is not 
 in strict mode and also the given <paramref name="xml"/> text is 
 empty.
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.SVG.XML.SvgDocument.SaveAsXml(System.String,System.Text.Encoding)">
 <summary>
 Save this svg document object into the file system.
 </summary>
 <param name="Path"></param>
 <param name="encoding"></param>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.SVG.XML.SvgDocument.GetSVGXml">
 <summary>
 get xml document string of current svg object
 </summary>
 <returns></returns>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.SVG.XML.SvgDocument.SaveAsXml(System.String,Microsoft.VisualBasic.Text.Encodings)">
 <summary>
 Save this svg document object into the file system.
 </summary>
 <param name="Path"></param>
 <param name="encoding"></param>
 <returns></returns>
 
</member>
<member name="T:Microsoft.VisualBasic.Imaging.SVG.XML.SvgGroup">
 <summary>
 The &lt;g> SVG element is a container used to group other SVG elements.

 Transformations applied To the &lt;g> element are performed On its child elements, 
 And its attributes are inherited by its children. It can also group multiple 
 elements To be referenced later With the &lt;use> element.
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.SVG.XML.SvgMarker">
 <summary>
 The &lt;marker> element defines a graphic used for drawing arrowheads or
 polymarkers on a given &lt;path>, &lt;line>, &lt;polyline> or &lt;polygon>
 element.

 Markers can be attached To shapes Using the marker-start, marker-mid, And 
 marker-End properties.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.SVG.XML.SvgMarker.RefX">
 <summary>
 This attribute defines the x coordinate for the reference point of the marker. 
 Value type: left|center|right|&lt;coordinate> ; Default value: 0; Animatable: yes
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.SVG.XML.SvgMarker.RefY">
 <summary>
 This attribute defines the y coordinate for the reference point of the marker. 
 Value type: top|center|bottom|&lt;coordinate> ; Default value: 0; Animatable: yes
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.SVG.XML.SvgMarker.Width">
 <summary>
 This attribute defines the width of the marker viewport. Value type: &lt;length> ; 
 Default value: 3; Animatable: yes
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.SVG.XML.SvgMarker.Height">
 <summary>
 This attribute defines the height of the marker viewport. Value type: &lt;length> ; 
 Default value: 3; Animatable: yes
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.SVG.XML.SvgMarker.ViewBox">
 <summary>
 This attribute defines the bound of the SVG viewport for the current SVG fragment. 
 Value type: &lt;list-of-numbers> ; Default value: none; Animatable: yes
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.SVG.XML.SvgSymbol">
 <summary>
 The &lt;symbol> element is used to define graphical template 
 objects which can be instantiated by a &lt;use> element.
 
 The use Of &lt;symbol> elements For graphics that are used multiple 
 times In the same document adds Structure And semantics. Documents 
 that are rich In Structure may be rendered graphically, As speech,
 Or As Braille, And thus promote accessibility.
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.SVG.XML.Enums.SvgEnum">
 <summary>
 a string constant value
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.SVG.XML.Enums.SvgEnum.GetHashCode">
 <summary>
 the hashcode is related to the constant string value
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.SVG.XML.SvgElement">
 <summary>
 The basically SVG XML document node, it can be tweaks on the style by using CSS
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.SVG.XML.SvgElement.Id">
 <summary>
 html element node id liked identifer 
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.SVG.XML.SvgElement.Stroke">
 <summary>
 the stroke color, value of this property should be html color code
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.SVG.XML.SvgElement.StrokeDashArray">
 <summary>
 The stroke-dasharray attribute is a presentation attribute defining the pattern of 
 dashes and gaps used to paint the outline of the shape;
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.SVG.XML.SvgElement.Style">
 <summary>
 current element node css style
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.SVG.XML.SvgElement.AriaLabel">
 <summary>
 The `aria-label` attribute is part of the Accessible Rich Internet Applications (ARIA) specification,
 which is designed to make web content and web applications more accessible to people with disabilities.
 Here's an overview of the `aria-label` attribute:<br />
 
 **Purpose:**
 - The `aria-label` attribute is used to provide a text label for an element that is not otherwise 
   labeled through text content or other attributes like `aria-labelledby`.
 - It is particularly useful for elements that do not have a visible text label, such as icons,
   buttons, or other interactive elements.<br />
   
 **Usage:**
 - The value of the `aria-label` attribute is a string that contains the text label for the element.
 - This text label is intended to be read by assistive technologies like screen readers, which can 
   announce the label to users who cannot see the screen.<br />
   
 **Example:**
 
 ```html
 &lt;button aria-label="Close">×&lt;!-- This is an icon representing a close action -->&lt;/button>
 ```
 
 In this example, a screen reader would announce "Close" when the user navigates to the button, even 
 though the visible content of the button is just an "×" symbol.<br />
 
 **Benefits:**
 - Improves accessibility by providing a clear description of the element's purpose or content.
 - Allows developers to create more semantic and accessible user interfaces without relying on off-screen 
   text or other less semantic methods.<br />
   
 **Considerations:**
 - The `aria-label` should be concise and descriptive.
 - It should not duplicate text that is already provided in the visible content of the element.
 - Avoid using `aria-label` for elements that already have a text label visible on the screen, as this
   can cause redundancy for screen reader users.<br />
   
 **Compatibility:**
 - The `aria-label` attribute is supported by most modern web browsers and assistive technologies.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.SVG.XML.SvgElement.Attribute(System.String)">
 <summary>
 get/set of the xml attribute value of current svg element.
 </summary>
 <param name="name"></param>
 <returns>The value of the specified attribute. An empty string is returned if a matching
 attribute is not found or if the attribute does not have a specified or default
 value.</returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.SVG.XML.SvgElement.Tag">
 <summary>
 get the xml tag name of current svg element
 </summary>
 <returns>
 the tag name string in lower case
 </returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.SVG.XML.SvgElement.Create(System.Xml.XmlElement)">
 <summary>
 create svg element based on the given <see cref="P:System.Xml.XmlElement.Name"/>
 </summary>
 <param name="e"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.SVG.XML.SvgMetadata">
 <summary>
 the svg RDF metadata node
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.SVG.XML.SvgUse">
 <summary>
 The &lt;use> element takes nodes from within the SVG document, and 
 duplicates them somewhere else. The effect is the same as if the 
 nodes were deeply cloned into a non-exposed DOM, then pasted where
 the use element is, much like cloned template elements.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.SVG.XML.SvgUse.href">
 <summary>
 The URL to an element/fragment that needs to be duplicated. 
 See Usage notes for details on common pitfalls.
 Value type: &lt;URL> ; Default value: none; Animatable: yes
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.SVG.XML.SvgUse.xlink_href">
 <summary>
 An &lt;IRI> reference to an element/fragment that needs to be 
 duplicated. If both href and xlink:href are present, the value
 given by href is used.
 Value type: &lt;IRI> ; Default value: none; Animatable: yes
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.SVG.XML.SvgUse.x">
 <summary>
 The x coordinate of an additional final offset transformation
 applied to the &lt;use> element.
 Value type: &lt;coordinate> ; Default value: 0; Animatable: yes
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.SVG.XML.SvgUse.y">
 <summary>
 The y coordinate of an additional final offset transformation
 applied to the &lt;use> element.
 Value type: &lt;coordinate> ; Default value: 0; Animatable: yes
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.SVG.XML.SvgUse.width">
 <summary>
 The width of the use element.
 Value type: &lt;length> ; Default value: 0; Animatable: yes
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Imaging.SVG.XML.SvgUse.height">
 <summary>
 The height of the use element.
 Value type: &lt;length> ; Default value: 0; Animatable: yes
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.SVG.PathHelper.Command">
 <summary>
 the base command for build a svg path
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.SVG.PathHelper.Interpreter">
 <summary>
 the svg path <see cref="T:Microsoft.VisualBasic.Imaging.SVG.PathHelper.Command"/> interpreter
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.SVG.PathHelper.Interpreter.ParsePathCommands(System.String)">
 <summary>
 parse the svg path string as the path creator commands
 </summary>
 <param name="d"></param>
 <returns>
 the first command element is always a move point command
 </returns>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.SVG.PathHelper.ModelBuilder">
 <summary>
 gdi+ object to svg model convertor
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.SVG.PathHelper.ModelBuilder.SVGPathData(Microsoft.VisualBasic.Imaging.GraphicsPath)">
 <summary>
 Translate the gdi+ graphic path object to the svg path data
 </summary>
 <returns></returns>
 <remarks>
 下面的命令可用于路径数据：
 
 + ``M`` = moveto(``M X,Y``)
 + ``L`` = lineto(``L X,Y``)
 + ``H`` = horizontal lineto(``H X``)
 + ``V`` = vertical lineto(``V Y``)
 + ``C`` = curveto(``C X1,Y1,X2,Y2,ENDX,ENDY``)
 + ``S`` = smooth curveto(``S X2,Y2,ENDX,ENDY``)
 + ``Q`` = quadratic Belzier curve(``Q X,Y,ENDX,ENDY``)
 + ``T`` = smooth quadratic Belzier curveto(``T ENDX,ENDY``)
 + ``A`` = elliptical Arc(``A RX,RY,XROTATION,FLAG1,FLAG2,X,Y``)
 + ``Z`` = closepath()
 
 注释：以上所有命令均允许小写字母。大写表示绝对定位，小写表示相对定位。
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.SVG.PathHelper.ModelBuilder.ParseSVGPathData(Microsoft.VisualBasic.Imaging.SVG.XML.SvgPath)">
 <summary>
 解析SVG之中的path数据，并转换为等价的gdi+的path对象
 </summary>
 <param name="path"></param>
 <returns></returns>
 <remarks>
 ```vbnet
 ' M0 0 L15 0 L8 15 L0 0 Z
 
 Move(0, 0)
 LineTo(15, 0)
 LineTo(8, 15)
 LineTo(0, 0)
 Close()
 ```
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.SVG.PathHelper.ModelBuilder.Call(Microsoft.VisualBasic.Imaging.Drawing2D.Path2D,System.Char,Microsoft.VisualBasic.Language.List{System.Double},Microsoft.VisualBasic.Imaging.SVG.XML.SvgPath)">
 <summary>
 Invoke gdi+ path build action
 </summary>
 <param name="g"></param>
 <param name="action"></param>
 <param name="parameters"></param>
 <param name="path"></param>
</member>
<member name="T:Microsoft.VisualBasic.Imaging.TextureResourceLoader">
 <summary>
 Default texture brush provider
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.TextureResourceLoader.LoadTextureResource(Microsoft.VisualBasic.Imaging.Image,System.Drawing.Size,System.Int32,System.Int32)">
 <summary>
 按照指定的资源图片和参数进行纹理资源的剪裁处理
 </summary>
 <param name="res"></param>
 <param name="Size"></param>
 <param name="IntervalWidth">纹理模块之间在水平上的间隔宽度</param>
 <param name="IntervalHeight">纹理模块之间在竖直方向上的间隔宽度</param>
 <returns></returns>
 <remarks></remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.Imaging.TextureResourceLoader.AdjustColor(Microsoft.VisualBasic.Imaging.Image,System.Drawing.Color)">
 <summary>
 adjust of the image color of the texture image
 </summary>
 <param name="Image"></param>
 <param name="Color"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Imaging.TextureResourceLoader.LoadInternalDefaultResource">
 <summary>
 Load default internal texture image resource
 </summary>
 <returns></returns>
</member>
</members>
</doc>
